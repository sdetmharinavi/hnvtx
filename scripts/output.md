<!-- path: postcss.config.mjs -->
```mjs
const config = {
  plugins: ["@tailwindcss/postcss"],
};

export default config;

```

<!-- path: stores/authStore.ts -->
```typescript
// stores/authStore.ts
import { create } from "zustand";
import { devtools, persist } from "zustand/middleware";
import { User } from "@supabase/supabase-js";

export type AuthState = "loading" | "authenticated" | "unauthenticated";

interface AuthStore {
  // Auth State
  user: User | null;
  authState: AuthState;

  // Actions
  setUser: (user: User | null) => void;
  setAuthState: (state: AuthState) => void;
  logout: () => void;

  // Async action wrapper to handle loading states
  executeWithLoading: <T>(action: () => Promise<T>) => Promise<T>;

  // Getters
  isLoading: () => boolean;
  isAuthenticated: () => boolean;
  getUserId: () => string | null;
}

export const useAuthStore = create<AuthStore>()(
  persist(
    devtools(
      (set, get) => ({
        // Initial State
        user: null,
        authState: "loading",

        // Actions
        setUser: (user) => {
          // Only update if the user has actually changed
          const currentUser = get().user;
          if (user?.id !== currentUser?.id) {
            set({
              user,
              authState: user ? "authenticated" : "unauthenticated",
            });
          }
        },

        setAuthState: (newAuthState) => {
          // Only update if the state has actually changed
          if (get().authState !== newAuthState) {
            set({ authState: newAuthState });
          }
        },

        logout: () => {
          set({
            user: null,
            authState: "unauthenticated",
          });
        },

        // Fixed async action wrapper
        executeWithLoading: async <T>(action: () => Promise<T>): Promise<T> => {
          const currentState = get().authState;
          const currentUser = get().user;

          // Only set loading if not already in a loading state
          if (currentState !== "loading") {
            set({ authState: "loading" });
          }

          try {
            const result = await action();
            
            // Get the latest state after action completes
            const { authState: latestState, user: latestUser } = get();
            
            // Only update state if still in loading state and we have a definitive state
            if (latestState === "loading") {
              // If user exists, we're authenticated, otherwise unauthenticated
              const newState = latestUser ? "authenticated" : "unauthenticated";
              if (newState !== currentState) {
                set({ authState: newState });
              }
            }

            return result;
          } catch (error) {
            // On error, reset to appropriate state based on current user
            const { user } = get();
            const newState = user ? "authenticated" : "unauthenticated";
            if (newState !== currentState) {
              set({ authState: newState });
            }
            throw error;
          }
        },

        // Getters
        isLoading: () => {
          return get().authState === "loading";
        },

        isAuthenticated: () => {
          const { user, authState } = get();
          return user !== null && authState === "authenticated";
        },

        getUserId: () => {
          const { user } = get();
          return user?.id || null;
        },
      }),
      {
        name: "AuthenticationStore",
      }
    ),
    {
      name: "auth-store",
      partialize: (state) => ({
        user: state.user,
        authState: state.authState,
      }),
    }
  )
);

```

<!-- path: stores/useUploadConfigStore.ts -->
```typescript
// src/stores/useUploadConfigStore.ts

import { create } from "zustand";
import { devtools, persist } from "zustand/middleware";
import { TableNames } from "@/config/helper-types";
import { Tables } from "@/types/supabase-types";

export interface UploadColumnMapping<T extends TableNames> {
  excelHeader: string;
  dbKey: keyof Tables<T> & string;
  transform?: (value: unknown) => unknown;
}

export interface UploadConfig<T extends TableNames> {
  tableName: T;
  columnMapping: UploadColumnMapping<T>[];
  uploadType: "insert" | "upsert";
  conflictColumn?: keyof Tables<T> & string;
  isUploadEnabled: boolean;
}

interface UploadConfigState {
  configs: Record<string, UploadConfig<TableNames>>;
  setUploadConfig: <T extends TableNames>(pageKey: string, config: UploadConfig<T>) => void;
  getUploadConfig: (pageKey: string) => UploadConfig<TableNames> | undefined;
  clearUploadConfig: (pageKey: string) => void;
}

export const useUploadConfigStore = create<UploadConfigState>()(
  persist( // `persist` should be the outer wrapper
    devtools( // `devtools` should be the inner wrapper
      (set, get) => ({
        // The store's state is a dictionary of configurations.
        configs: {},

        setUploadConfig: (pageKey, config) => {
          if (config?.uploadType === "upsert" && !config.conflictColumn) {
            console.error(`UploadConfig Error...`);
          }
          set((state) => ({
            configs: {
              ...state.configs,
              [pageKey]: config,
            },
          }));
        },

        getUploadConfig: (pageKey) => {
          return get().configs[pageKey];
        },

        clearUploadConfig: (pageKey) => {
          set((state) => {
            const newConfigs = { ...state.configs };
            delete newConfigs[pageKey];
            return { configs: newConfigs };
          });
        },
      }),
      // The options object for devtools
      {
        name: "UploadConfigStore",
      }
    ),
    // The options object for persist
    {
      name: "upload-config-storage", // Use a different key for localStorage
    }
  )
);
```

<!-- path: stores/themeStore.ts -->
```typescript
import { create } from "zustand";

export type Theme = "light" | "dark" | "system";

interface ThemeState {
  theme: Theme;
  setTheme: (theme: Theme) => void;
  hydrated: boolean;
  setHydrated: (hydrated: boolean) => void;
}

export const useThemeStore = create<ThemeState>()((set, get) => ({
  // NEVER access localStorage in initial state - always use default
  theme: "system", // Default value, no localStorage access
  hydrated: false,

  setTheme: (newTheme: Theme) => {
    set({ theme: newTheme });
    // Only access localStorage in actions (client-side)
    if (typeof window !== "undefined") {
      try {
        localStorage.setItem("theme-storage", newTheme);
      } catch (error) {
        console.warn("Failed to save theme:", error);
      }
    }
  },

  setHydrated: (hydrated: boolean) => set({ hydrated }),
}));

// Client-side hydration function
export const hydrateThemeStore = () => {
  if (typeof window === "undefined") return;

  try {
    const storedTheme = localStorage.getItem("theme-storage");
    if (storedTheme && ["light", "dark", "system"].includes(storedTheme)) {
      useThemeStore.setState({
        theme: storedTheme as Theme,
        hydrated: true,
      });
    } else {
      useThemeStore.setState({ hydrated: true });
    }
  } catch (error) {
    console.warn("Failed to load theme:", error);
    useThemeStore.setState({ hydrated: true });
  }
};
```

<!-- path: providers/QueryProvider.tsx -->
```typescript
// providers/QueryProvider.tsx
'use client'

import { QueryClient, QueryClientProvider } from '@tanstack/react-query'
import { ReactQueryDevtools } from '@tanstack/react-query-devtools'
import { useState } from 'react'

export function QueryProvider({ children }: { children: React.ReactNode }) {
  const [queryClient] = useState(() => new QueryClient({
    defaultOptions: {
      queries: {
        staleTime: 5 * 60 * 1000, // 5 minutes
        gcTime: 10 * 60 * 1000, // 10 minutes
        retry: (failureCount, error: Error) => {
          if ('status' in error && typeof error.status === 'number' && error.status >= 400 && error.status < 500) {
            return false
          }
          return failureCount < 3
        },
        refetchOnWindowFocus: false,
      },
      mutations: {
        retry: 1,
      },
    },
  }))

  return (
    <QueryClientProvider client={queryClient}>
      {children}
      <ReactQueryDevtools initialIsOpen={false} />
    </QueryClientProvider>
  )
}


```

<!-- path: providers/ToastProvider.tsx -->
```typescript
// components/providers/ToastProvider.tsx
'use client';

import { Toaster } from 'sonner';
import { useThemeStore } from '@/stores/themeStore';

export function ToastProvider({ children }: { children: React.ReactNode }) {
  const { theme } = useThemeStore();

  return (
    <>
      {children}
      <Toaster
        theme={theme === 'system' ? 'system' : theme}
        className="toaster group"
        toastOptions={{
          classNames: {
            toast:
              'group toast group-[.toaster]:bg-white group-[.toaster]:text-gray-950 group-[.toaster]:border-gray-200 group-[.toaster]:shadow-lg dark:group-[.toaster]:bg-gray-950 dark:group-[.toaster]:text-gray-50 dark:group-[.toaster]:border-gray-800',
            description: 'group-[.toast]:text-gray-500 dark:group-[.toast]:text-gray-400',
            actionButton:
              'group-[.toast]:bg-gray-900 group-[.toast]:text-gray-50 dark:group-[.toast]:bg-gray-50 dark:group-[.toast]:text-gray-900',
            cancelButton:
              'group-[.toast]:bg-gray-100 group-[.toast]:text-gray-500 dark:group-[.toast]:bg-gray-800 dark:group-[.toast]:text-gray-400',
          },
        }}
        richColors
        closeButton
        position="top-right"
      />
    </>
  );
}
```

<!-- path: providers/ThemeProvider.tsx -->
```typescript
"use client";

import { useEffect } from "react";
import { useThemeStore, hydrateThemeStore, Theme } from "@/stores/themeStore";

export default function ThemeProvider({
  children,
}: {
  children: React.ReactNode;
}) {
  const { theme, hydrated } = useThemeStore();

  // Hydrate theme from localStorage on mount
  useEffect(() => {
    // Add class to disable transitions during initial load
    document.documentElement.classList.add("no-transition");

    hydrateThemeStore();

    // Re-enable transitions after a short delay
    setTimeout(() => {
      document.documentElement.classList.remove("no-transition");
    }, 50);
  }, []);

  // Apply theme when hydrated or theme changes
  useEffect(() => {
    if (!hydrated) return;

    const applyTheme = (theme: Theme) => {
      const isDark =
        theme === "dark" ||
        (theme === "system" &&
          window.matchMedia("(prefers-color-scheme: dark)").matches);

      if (isDark) {
        document.documentElement.classList.add("dark");
      } else {
        document.documentElement.classList.remove("dark");
      }
    };

    applyTheme(theme);

    // Listen for system theme changes
    if (theme === "system") {
      const mediaQuery = window.matchMedia("(prefers-color-scheme: dark)");
      const handleChange = () => applyTheme("system");

      mediaQuery.addEventListener("change", handleChange);
      return () => mediaQuery.removeEventListener("change", handleChange);
    }
  }, [theme, hydrated]);

  return <>{children}</>;
}
```

<!-- path: data/migrations/05_auditing/03_triggers_attach_all.sql -->
```sql
-- Path: migrations/05_auditing/03_triggers_attach_all.sql
-- Description: Dynamically attaches the log_data_changes trigger to all relevant tables.
-- This script is idempotent and can be re-run safely.

DO $$
DECLARE
    table_rec RECORD;
    trigger_name TEXT;
BEGIN
    -- Loop through all user tables in the 'public' schema
    FOR table_rec IN
        SELECT t.table_name
        FROM information_schema.tables t
        WHERE t.table_schema = 'public'
          AND t.table_type = 'BASE TABLE'
          -- Exclude the log table itself to prevent infinite loops
          AND t.table_name <> 'user_activity_logs'
          -- Only attach to tables that have an 'id' column, which is our standard for auditable records
          AND EXISTS (
              SELECT 1
              FROM information_schema.columns c
              WHERE c.table_schema = t.table_schema
                AND c.table_name = t.table_name
                AND c.column_name = 'id'
          )
    LOOP
        trigger_name := table_rec.table_name || '_log_trigger';

        -- Drop the trigger if it already exists to ensure it's up-to-date
        EXECUTE format('DROP TRIGGER IF EXISTS %I ON public.%I;', trigger_name, table_rec.table_name);

        -- Create the new trigger
        EXECUTE format('CREATE TRIGGER %I ' ||
                       'AFTER INSERT OR UPDATE OR DELETE ON public.%I ' ||
                       'FOR EACH ROW EXECUTE FUNCTION public.log_data_changes();',
                       trigger_name,
                       table_rec.table_name);

        RAISE NOTICE 'Created/Refreshed audit trigger on table: public.%', table_rec.table_name;
    END LOOP;
END;
$$;
```

<!-- path: data/migrations/05_auditing/01_table_user_activity_logs.sql -->
```sql
-- Path: migrations/05_auditing/01_table_user_activity_logs.sql
-- Description: Defines the table for storing all user activity and data change logs.

CREATE TABLE IF NOT EXISTS public.user_activity_logs (
    id BIGSERIAL PRIMARY KEY,
    user_id UUID REFERENCES auth.users(id) ON DELETE SET NULL,
    user_role TEXT,
    action_type TEXT NOT NULL,
    table_name TEXT,
    record_id TEXT,
    old_data JSONB,
    new_data JSONB,
    details TEXT,
    created_at TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP
);

-- Add indexes for better query performance on the logs table
CREATE INDEX IF NOT EXISTS idx_user_activity_logs_user_id ON public.user_activity_logs(user_id);
CREATE INDEX IF NOT EXISTS idx_user_activity_logs_action_type ON public.user_activity_logs(action_type);
CREATE INDEX IF NOT EXISTS idx_user_activity_logs_table_name ON public.user_activity_logs(table_name);
```

<!-- path: data/migrations/05_auditing/02_functions.sql -->
```sql
-- Path: migrations/05_auditing/02_functions.sql
-- Description: Core functions for the auditing system.

-- Function 1: log_user_activity()
-- This is the generic logging function that inserts a record into the audit table.
-- It can be called directly for custom actions or by the trigger function for data changes.
CREATE OR REPLACE FUNCTION public.log_user_activity(
    p_action_type TEXT,
    p_table_name TEXT DEFAULT NULL,
    p_record_id TEXT DEFAULT NULL,
    p_old_data JSONB DEFAULT NULL,
    p_new_data JSONB DEFAULT NULL,
    p_details TEXT DEFAULT NULL
)
RETURNS VOID
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = ''
AS $$
BEGIN
    INSERT INTO public.user_activity_logs (
        user_id,
        user_role,
        action_type,
        table_name,
        record_id,
        old_data,
        new_data,
        details
    )
    VALUES (
        auth.uid(),
        public.get_my_role(),
        p_action_type,
        p_table_name,
        p_record_id,
        p_old_data,
        p_new_data,
        p_details
    );
END;
$$;


-- Function 2: log_data_changes()
-- This is the TRIGGER function that will be attached to tables.
-- It captures INSERT, UPDATE, DELETE events and calls log_user_activity() with the correct data.
CREATE OR REPLACE FUNCTION public.log_data_changes()
RETURNS TRIGGER
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = ''
AS $$
DECLARE
    v_record_id TEXT;
BEGIN
    IF (TG_OP = 'INSERT') THEN
        v_record_id := NEW.id::TEXT;
        PERFORM public.log_user_activity(
            'INSERT',
            TG_TABLE_NAME,
            v_record_id,
            NULL,
            row_to_json(NEW)::jsonb
        );
        RETURN NEW;
    ELSIF (TG_OP = 'UPDATE') THEN
        v_record_id := NEW.id::TEXT;
        PERFORM public.log_user_activity(
            'UPDATE',
            TG_TABLE_NAME,
            v_record_id,
            row_to_json(OLD)::jsonb,
            row_to_json(NEW)::jsonb
        );
        RETURN NEW;
    ELSIF (TG_OP = 'DELETE') THEN
        v_record_id := OLD.id::TEXT;
        PERFORM public.log_user_activity(
            'DELETE',
            TG_TABLE_NAME,
            v_record_id,
            row_to_json(OLD)::jsonb,
            NULL
        );
        RETURN OLD;
    END IF;
    -- This line is unreachable in an AFTER trigger but is good practice.
    RETURN NULL;
END;
$$;
```

<!-- path: data/migrations/05_auditing/04_rls_and_grants.sql -->
```sql
-- Path: migrations/05_auditing/04_rls_and_grants.sql
-- Description: Secures the user_activity_logs table, allowing access only to admins.

-- Enable Row Level Security on the log table
ALTER TABLE public.user_activity_logs ENABLE ROW LEVEL SECURITY;

-- Grant table-level permissions to the 'admin' role
GRANT ALL ON public.user_activity_logs TO admin;

-- Drop existing policies for idempotency
DROP POLICY IF EXISTS "Allow full access to admins" ON public.user_activity_logs;

-- Create a single policy granting full access (SELECT, INSERT, UPDATE, DELETE)
-- only to users who are super_admins or have the 'admin' role.
CREATE POLICY "Allow full access to admins"
ON public.user_activity_logs
FOR ALL
TO admin
USING (is_super_admin() OR get_my_role() = 'admin')
WITH CHECK (is_super_admin() OR get_my_role() = 'admin');
```

<!-- path: data/migrations/03_network_systems/02_views.sql -->
```sql
-- Path: migrations/03_network_systems/02_views.sql
-- Description: Defines denormalized views for the Network Systems module.

-- View for a complete picture of a system and its specific details.
CREATE OR REPLACE VIEW public.v_systems_complete WITH (security_invoker = true) AS
SELECT
  s.*,
  n.name AS node_name,
  n.latitude,
  n.longitude,
  lt_system.name AS system_type_name,
  lt_system.code AS system_type_code,
  lt_system.category AS system_category,
  ma.name AS system_maintenance_terminal_name,
  rbs.ring_id,
  ring_area.name AS ring_logical_area_name,
  ss.gne AS sdh_gne,
  ss.make AS sdh_make,
  vs.vm_id AS vmux_vm_id,
  count(*) OVER() AS total_count,
  sum(CASE WHEN s.status THEN 1 ELSE 0 END) OVER() AS active_count,
  sum(CASE WHEN NOT s.status THEN 1 ELSE 0 END) OVER() AS inactive_count
FROM public.systems s
  JOIN public.nodes n ON s.node_id = n.id
  JOIN public.lookup_types lt_system ON s.system_type_id = lt_system.id
  LEFT JOIN public.maintenance_areas ma ON s.maintenance_terminal_id = ma.id
  LEFT JOIN public.ring_based_systems rbs ON s.id = rbs.system_id
  LEFT JOIN public.maintenance_areas ring_area ON rbs.maintenance_area_id = ring_area.id
  LEFT JOIN public.sdh_systems ss ON s.id = ss.system_id
  LEFT JOIN public.vmux_systems vs ON s.id = vs.system_id;


-- View for a complete picture of a system connection and its specific details.
CREATE OR REPLACE VIEW public.v_system_connections_complete WITH (security_invoker = true) AS
SELECT
  sc.id, sc.system_id, s.system_name, lt_system.name AS system_type_name,
  s_sn.system_name AS sn_name, na.name AS sn_node_name, sc.sn_ip, sc.sn_interface,
  s_en.system_name AS en_name, nb.name AS en_node_name, sc.en_ip, sc.en_interface,
  lt_media.name AS media_type_name, sc.bandwidth_mbps, cs.system_name AS connected_system_name,
  lt_cs_type.name AS connected_system_type_name, sc.vlan, sc.commissioned_on,
  sc.remark, sc.status, sc.created_at, sc.updated_at,
  -- SFP-based details
  sfpc.sfp_port, lt_sfp.name as sfp_type_name, sfpc.sfp_capacity,
  sfpc.sfp_serial_no, sfpc.fiber_in, sfpc.fiber_out, sfpc.customer_name, sfpc.bandwidth_allocated_mbps,
  -- SDH details
  scs.stm_no AS sdh_stm_no, scs.carrier AS sdh_carrier, scs.a_slot AS sdh_a_slot,
  scs.a_customer AS sdh_a_customer, scs.b_slot AS sdh_b_slot, scs.b_customer AS sdh_b_customer,
  -- VMUX details
  vcs.subscriber AS vmux_subscriber, vcs.c_code AS vmux_c_code, vcs.channel AS vmux_channel, vcs.tk AS vmux_tk,
  count(*) OVER() AS total_count,
  sum(CASE WHEN sc.status THEN 1 ELSE 0 END) OVER() AS active_count,
  sum(CASE WHEN NOT sc.status THEN 1 ELSE 0 END) OVER() AS inactive_count
FROM public.system_connections sc
  JOIN public.systems s ON sc.system_id = s.id
  JOIN public.lookup_types lt_system ON s.system_type_id = lt_system.id
  LEFT JOIN public.systems s_sn ON sc.sn_id = s_sn.id
  LEFT JOIN public.nodes na ON s_sn.node_id = na.id
  LEFT JOIN public.systems s_en ON sc.en_id = s_en.id
  LEFT JOIN public.nodes nb ON s_en.node_id = nb.id
  LEFT JOIN public.systems cs ON sc.connected_system_id = cs.id
  LEFT JOIN public.lookup_types lt_cs_type ON cs.system_type_id = lt_cs_type.id
  LEFT JOIN public.lookup_types lt_media ON sc.media_type_id = lt_media.id
  LEFT JOIN public.sfp_based_connections sfpc ON sc.id = sfpc.system_connection_id
  LEFT JOIN public.lookup_types lt_sfp ON sfpc.sfp_type_id = lt_sfp.id
  LEFT JOIN public.sdh_connections scs ON sc.id = scs.system_connection_id
  LEFT JOIN public.vmux_connections vcs ON sc.id = vcs.system_connection_id;


-- View for OFC Connections, now including system details from this module.
CREATE OR REPLACE VIEW public.v_ofc_connections_complete WITH (security_invoker = true) AS
SELECT
  oc.id::uuid,
  oc.ofc_id::uuid,
  oc.fiber_no_sn::integer,
  oc.fiber_no_en::integer,
  oc.otdr_distance_sn_km::numeric(10,3),
  oc.sn_dom::date,
  oc.sn_power_dbm::numeric(10,3),
  oc.system_id::uuid,
  oc.otdr_distance_en_km::numeric(10,3),
  oc.en_dom::date,
  oc.en_power_dbm::numeric(10,3),
  oc.route_loss_db::numeric(10,3),
  oc.logical_path_id::uuid,
  oc.fiber_role::text,
  oc.path_segment_order::integer,
  oc.source_port::text,
  oc.destination_port::text,
  oc.connection_category::text,
  oc.connection_type::text,
  oc.remark::text,
  oc.status::boolean,
  oc.created_at::timestamptz,
  oc.updated_at::timestamptz,
  ofc.route_name AS ofc_route_name,
  ma.name AS maintenance_area_name,
  ofc.sn_id::uuid,
  ofc.en_id::uuid,
  ofc_type.name AS ofc_type_name,
  na.name AS sn_name,
  s.system_name AS system_name,
  nb.name AS en_name,
  count(*) OVER()::integer AS total_count,
  sum(CASE WHEN oc.status THEN 1 ELSE 0 END) OVER()::integer AS active_count,
  sum(CASE WHEN NOT oc.status THEN 1 ELSE 0 END) OVER()::integer AS inactive_count
FROM public.ofc_connections oc
  JOIN public.ofc_cables ofc ON oc.ofc_id = ofc.id
  JOIN public.lookup_types ofc_type ON ofc.ofc_type_id = ofc_type.id
  LEFT JOIN public.nodes na ON ofc.sn_id = na.id
  LEFT JOIN public.nodes nb ON ofc.en_id = nb.id
  LEFT JOIN public.systems s ON oc.system_id = s.id
  LEFT JOIN public.maintenance_areas ma ON ofc.maintenance_terminal_id = ma.id;
```

<!-- path: data/migrations/03_network_systems/03_indexes.sql -->
```sql
-- Path: migrations/03_network_systems/03_indexes.sql
-- Description: Creates B-tree and GIN (FTS) indexes for the Network Systems module.

-- =================================================================
-- Section 1: Standard B-Tree Indexes
-- =================================================================

-- Indexes for the generic systems table
CREATE INDEX IF NOT EXISTS idx_systems_node_id ON public.systems (node_id);

-- Indexes for the new consolidated tables
CREATE INDEX IF NOT EXISTS idx_ring_based_systems_ring_area ON public.ring_based_systems (ring_id, maintenance_area_id);
CREATE INDEX IF NOT EXISTS idx_sfp_based_connections_customer ON public.sfp_based_connections (customer_name);

-- Indexes for other system-specific tables
CREATE INDEX IF NOT EXISTS idx_sdh_systems_make ON public.sdh_systems (make);

-- =================================================================
-- Section 2: Full-Text Search (FTS) GIN Indexes
-- =================================================================

CREATE INDEX IF NOT EXISTS idx_systems_remark_fts ON public.systems USING gin(to_tsvector('english', remark));
CREATE INDEX IF NOT EXISTS idx_system_connections_remark_fts ON public.system_connections USING gin(to_tsvector('english', remark));
CREATE INDEX IF NOT EXISTS idx_management_ports_remark_fts ON public.management_ports USING gin(to_tsvector('english', remark));
```

<!-- path: data/migrations/03_network_systems/04_triggers.sql -->
```sql
-- Path: migrations/03_network_systems/04_triggers.sql
-- Description: Attaches 'updated_at' triggers to all tables in the Network Systems module.

CREATE OR REPLACE TRIGGER trigger_systems_updated_at BEFORE UPDATE ON public.systems FOR EACH ROW EXECUTE FUNCTION public.update_updated_at_column();
CREATE OR REPLACE TRIGGER trigger_system_connections_updated_at BEFORE UPDATE ON public.system_connections FOR EACH ROW EXECUTE FUNCTION public.update_updated_at_column();
CREATE OR REPLACE TRIGGER trigger_management_ports_updated_at BEFORE UPDATE ON public.management_ports FOR EACH ROW EXECUTE FUNCTION public.update_updated_at_column();
CREATE OR REPLACE TRIGGER trigger_ring_based_systems_updated_at BEFORE UPDATE ON public.ring_based_systems FOR EACH ROW EXECUTE FUNCTION public.update_updated_at_column();
CREATE OR REPLACE TRIGGER trigger_sfp_based_connections_updated_at BEFORE UPDATE ON public.sfp_based_connections FOR EACH ROW EXECUTE FUNCTION public.update_updated_at_column();
CREATE OR REPLACE TRIGGER trigger_sdh_systems_updated_at BEFORE UPDATE ON public.sdh_systems FOR EACH ROW EXECUTE FUNCTION public.update_updated_at_column();
CREATE OR REPLACE TRIGGER trigger_sdh_connections_updated_at BEFORE UPDATE ON public.sdh_connections FOR EACH ROW EXECUTE FUNCTION public.update_updated_at_column();
CREATE OR REPLACE TRIGGER trigger_sdh_node_associations_updated_at BEFORE UPDATE ON public.sdh_node_associations FOR EACH ROW EXECUTE FUNCTION public.update_updated_at_column();
CREATE OR REPLACE TRIGGER trigger_vmux_systems_updated_at BEFORE UPDATE ON public.vmux_systems FOR EACH ROW EXECUTE FUNCTION public.update_updated_at_column();
CREATE OR REPLACE TRIGGER trigger_vmux_connections_updated_at BEFORE UPDATE ON public.vmux_connections FOR EACH ROW EXECUTE FUNCTION public.update_updated_at_column();
```

<!-- path: data/migrations/03_network_systems/01_tables_systems.sql -->
```sql
-- Path: migrations/03_network_systems/01_tables_systems.sql
-- Description: Defines tables for generic and specific network systems.

-- 1. Generic Systems Table (e.g., CPAN, MAAN, SDH, VMUX)
CREATE TABLE IF NOT EXISTS public.systems (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  system_type_id UUID REFERENCES public.lookup_types (id) NOT NULL,
  node_id UUID REFERENCES public.nodes (id) NOT NULL,
  system_name TEXT,
  ip_address INET,
  maintenance_terminal_id UUID REFERENCES public.maintenance_areas (id),
  commissioned_on DATE,
  s_no TEXT,
  remark TEXT,
  status BOOLEAN DEFAULT true,
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- 2. Generic System Connections Table
CREATE TABLE IF NOT EXISTS public.system_connections (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  system_id UUID REFERENCES public.systems (id) NOT NULL,
  sn_id UUID REFERENCES public.systems (id),
  en_id UUID REFERENCES public.systems (id),
  connected_system_id UUID REFERENCES public.systems (id),
  sn_ip INET,
  sn_interface TEXT,
  en_ip INET,
  en_interface TEXT,
  media_type_id UUID REFERENCES public.lookup_types (id),
  bandwidth_mbps INTEGER,
  vlan TEXT,
  commissioned_on DATE,
  remark TEXT,
  status BOOLEAN DEFAULT true,
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- 3. Management Network Ports Table
CREATE TABLE IF NOT EXISTS public.management_ports (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  port_no TEXT NOT NULL,
  name TEXT,
  node_id UUID REFERENCES public.nodes (id),
  system_id UUID REFERENCES public.systems (id),
  commissioned_on DATE,
  remark TEXT,
  status BOOLEAN DEFAULT true,
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- 4. Consolidated Table for Ring-Based System Details (replaces cpan_systems, maan_systems)
CREATE TABLE IF NOT EXISTS public.ring_based_systems (
  system_id UUID PRIMARY KEY REFERENCES public.systems (id) ON DELETE CASCADE,
  ring_id UUID REFERENCES public.rings (id),
  maintenance_area_id UUID REFERENCES public.maintenance_areas (id)
);

-- 5. Consolidated Table for SFP-Based Connection Details (replaces cpan_connections, maan_connections)
CREATE TABLE IF NOT EXISTS public.sfp_based_connections (
  system_connection_id UUID PRIMARY KEY REFERENCES public.system_connections (id) ON DELETE CASCADE,
  sfp_port TEXT,
  sfp_type_id UUID REFERENCES public.lookup_types (id),
  sfp_capacity TEXT,
  sfp_serial_no TEXT,
  fiber_in INTEGER,
  fiber_out INTEGER,
  customer_name TEXT,
  bandwidth_allocated_mbps INTEGER
);

-- 6. Dedicated Table for SDH System Specific Details
CREATE TABLE IF NOT EXISTS public.sdh_systems (
  system_id UUID PRIMARY KEY REFERENCES public.systems (id) ON DELETE CASCADE,
  gne TEXT,
  make TEXT
);

-- 7. Dedicated Table for SDH Connection Specific Details
CREATE TABLE IF NOT EXISTS public.sdh_connections (
  system_connection_id UUID PRIMARY KEY REFERENCES public.system_connections (id) ON DELETE CASCADE,
  stm_no TEXT,
  carrier TEXT,
  a_slot TEXT,
  a_customer TEXT,
  b_slot TEXT,
  b_customer TEXT
);

-- 8. SDH Node Associations Table
CREATE TABLE IF NOT EXISTS public.sdh_node_associations (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  sdh_system_id UUID REFERENCES public.sdh_systems (system_id) NOT NULL,
  node_id UUID REFERENCES public.nodes (id) NOT NULL,
  node_position CHAR(1) CHECK (node_position IN ('A', 'B', 'C', 'D', 'E', 'F', 'G', 'H')),
  node_ip INET,
  CONSTRAINT uq_sdh_system_position UNIQUE (sdh_system_id, node_position)
);

-- 9. Dedicated Table for VMUX System Specific Details
CREATE TABLE IF NOT EXISTS public.vmux_systems (
  system_id UUID PRIMARY KEY REFERENCES public.systems (id) ON DELETE CASCADE,
  vm_id TEXT
);

-- 10. Dedicated Table for VMUX Connection Specific Details
CREATE TABLE IF NOT EXISTS public.vmux_connections (
  system_connection_id UUID PRIMARY KEY REFERENCES public.system_connections (id) ON DELETE CASCADE,
  subscriber TEXT,
  c_code TEXT,
  channel TEXT,
  tk TEXT
);
```

<!-- path: data/migrations/03_network_systems/05_rls_and_grants.sql -->
```sql
-- Path: migrations/03_network_systems/05_rls_and_grants.sql
-- Description: Defines all RLS policies and Grants for the Network Systems module.

-- =================================================================
-- PART 1: GENERIC GRANTS AND RLS SETUP FOR ALL SYSTEM TABLES
-- =================================================================
DO $$
DECLARE
  tbl TEXT;
BEGIN
  -- List all tables related to network systems
  FOREACH tbl IN ARRAY ARRAY[
    'systems', 'system_connections', 'management_ports',
    'ring_based_systems', 'sfp_based_connections',
    'sdh_systems', 'sdh_connections', 'sdh_node_associations',
    'vmux_systems', 'vmux_connections'
  ]
  LOOP
    -- Enable RLS and set table-level grants for all relevant roles
    EXECUTE format('ALTER TABLE public.%I ENABLE ROW LEVEL SECURITY;', tbl);
    EXECUTE format('GRANT SELECT, INSERT, UPDATE, DELETE ON public.%I TO admin;', tbl);
    EXECUTE format('GRANT SELECT ON public.%I TO viewer;', tbl);
    EXECUTE format('GRANT SELECT, INSERT, UPDATE, DELETE ON public.%I TO cpan_admin;', tbl);
    EXECUTE format('GRANT SELECT, INSERT, UPDATE, DELETE ON public.%I TO maan_admin;', tbl);
    EXECUTE format('GRANT SELECT, INSERT, UPDATE, DELETE ON public.%I TO sdh_admin;', tbl);
    EXECUTE format('GRANT SELECT, INSERT, UPDATE, DELETE ON public.%I TO vmux_admin;', tbl);
    EXECUTE format('GRANT SELECT, INSERT, UPDATE, DELETE ON public.%I TO mng_admin;', tbl);
  END LOOP;
END;
$$;


-- =================================================================
-- PART 2: COMPLEX POLICIES FOR GENERIC TABLES (systems, system_connections)
-- =================================================================

-- Policies for the 'systems' table
DO $$
BEGIN
  -- Clean up old policies for idempotency
  DROP POLICY IF EXISTS "Allow full access based on system type" ON public.systems;
  DROP POLICY IF EXISTS "Allow viewer read-access" ON public.systems;
  DROP POLICY IF EXISTS "Allow admin full access" ON public.systems;

  -- Viewer can see all systems
  CREATE POLICY "Allow viewer read-access" ON public.systems FOR SELECT TO viewer USING (true);
  -- Admin/Super-Admin can do anything
  CREATE POLICY "Allow admin full access" ON public.systems FOR ALL TO admin USING (is_super_admin() OR get_my_role() = 'admin') WITH CHECK (is_super_admin() OR get_my_role() = 'admin');

  -- System-specific admins can access rows matching their designated system type
  CREATE POLICY "Allow full access based on system type" ON public.systems
  FOR ALL TO cpan_admin, maan_admin, sdh_admin, vmux_admin, mng_admin
  USING (
    EXISTS (
        SELECT 1 FROM public.lookup_types lt
        WHERE lt.id = systems.system_type_id AND lt.category = 'SYSTEM' AND (
            (public.get_my_role() = 'cpan_admin' AND lt.name = 'CPAN') OR
            (public.get_my_role() = 'maan_admin' AND lt.name = 'MAAN') OR
            (public.get_my_role() = 'sdh_admin' AND lt.name = 'SDH') OR
            (public.get_my_role() = 'vmux_admin' AND lt.name = 'VMUX') OR
            (public.get_my_role() = 'mng_admin' AND lt.name = 'MNGPAN')
        )
    )
  )
  WITH CHECK (
    EXISTS (
        SELECT 1 FROM public.lookup_types lt
        WHERE lt.id = systems.system_type_id AND lt.category = 'SYSTEM' AND (
            (public.get_my_role() = 'cpan_admin' AND lt.name = 'CPAN') OR
            (public.get_my_role() = 'maan_admin' AND lt.name = 'MAAN') OR
            (public.get_my_role() = 'sdh_admin' AND lt.name = 'SDH') OR
            (public.get_my_role() = 'vmux_admin' AND lt.name = 'VMUX') OR
            (public.get_my_role() = 'mng_admin' AND lt.name = 'MNGPAN')
        )
    )
  );
END;
$$;


-- Policies for the 'system_connections' table
DO $$
BEGIN
  DROP POLICY IF EXISTS "Allow full access based on parent system type" ON public.system_connections;
  DROP POLICY IF EXISTS "Allow viewer read-access" ON public.system_connections;
  DROP POLICY IF EXISTS "Allow admin full access" ON public.system_connections;

  CREATE POLICY "Allow viewer read-access" ON public.system_connections FOR SELECT TO viewer USING (true);
  CREATE POLICY "Allow admin full access" ON public.system_connections FOR ALL TO admin USING (is_super_admin() OR get_my_role() = 'admin') WITH CHECK (is_super_admin() OR get_my_role() = 'admin');

  -- System-specific admins can access connections whose parent system matches their type.
  CREATE POLICY "Allow full access based on parent system type" ON public.system_connections
  FOR ALL TO cpan_admin, maan_admin, sdh_admin, vmux_admin, mng_admin
  USING (
    EXISTS (
      SELECT 1 FROM public.systems s
      JOIN public.lookup_types lt ON s.system_type_id = lt.id
      WHERE s.id = system_connections.system_id AND lt.category = 'SYSTEM' AND (
        (public.get_my_role() = 'cpan_admin' AND lt.name = 'CPAN') OR
        (public.get_my_role() = 'maan_admin' AND lt.name = 'MAAN') OR
        (public.get_my_role() = 'sdh_admin' AND lt.name = 'SDH') OR
        (public.get_my_role() = 'vmux_admin' AND lt.name = 'VMUX') OR
        (public.get_my_role() = 'mng_admin' AND lt.name = 'MNGPAN')
      )
    )
  )
  WITH CHECK ( -- Re-use the same logic for INSERTs and UPDATEs
    EXISTS (
      SELECT 1 FROM public.systems s
      JOIN public.lookup_types lt ON s.system_type_id = lt.id
      WHERE s.id = system_connections.system_id AND lt.category = 'SYSTEM' AND (
        (public.get_my_role() = 'cpan_admin' AND lt.name = 'CPAN') OR
        (public.get_my_role() = 'maan_admin' AND lt.name = 'MAAN') OR
        (public.get_my_role() = 'sdh_admin' AND lt.name = 'SDH') OR
        (public.get_my_role() = 'vmux_admin' AND lt.name = 'VMUX') OR
        (public.get_my_role() = 'mng_admin' AND lt.name = 'MNGPAN')
      )
    )
  );
END;
$$;


-- =================================================================
-- PART 3: AUTOMATED POLICIES FOR SYSTEM-SPECIFIC SUB-TABLES
-- =================================================================
DO $$
DECLARE
    -- Maps tables to their specific admin roles
    mappings TEXT[][] := ARRAY[
        ['ring_based_systems', 'cpan_admin'], ['ring_based_systems', 'maan_admin'],
        ['sfp_based_connections', 'cpan_admin'], ['sfp_based_connections', 'maan_admin'],
        ['sdh_systems', 'sdh_admin'], ['sdh_connections', 'sdh_admin'],
        ['sdh_node_associations', 'sdh_admin'], ['vmux_systems', 'vmux_admin'],
        ['vmux_connections', 'vmux_admin']
    ];
    tbl TEXT;
    specific_role TEXT;
    i INT;
BEGIN
    FOR i IN 1..array_length(mappings, 1) LOOP
        tbl := mappings[i][1];
        specific_role := mappings[i][2];

        -- Clean up old policies for idempotency
        EXECUTE format('DROP POLICY IF EXISTS "Allow viewer read-access" ON public.%I;', tbl);
        EXECUTE format('DROP POLICY IF EXISTS "Allow admin full access" ON public.%I;', tbl);
        EXECUTE format('DROP POLICY IF EXISTS "Allow %s full access" ON public.%I;', specific_role, tbl);

        -- Viewer can read
        EXECUTE format('CREATE POLICY "Allow viewer read-access" ON public.%I FOR SELECT TO viewer USING (true);', tbl);
        -- Admin/Super-Admin can do everything
        EXECUTE format('CREATE POLICY "Allow admin full access" ON public.%I FOR ALL TO admin USING (is_super_admin() OR get_my_role() = ''admin'') WITH CHECK (is_super_admin() OR get_my_role() = ''admin'');', tbl);
        -- The specific system admin can do everything
        EXECUTE format($p$
            CREATE POLICY "Allow %s full access" ON public.%I
            FOR ALL TO %I
            USING (public.get_my_role() = %L)
            WITH CHECK (public.get_my_role() = %L);
        $p$, specific_role, tbl, specific_role, specific_role, specific_role);

        RAISE NOTICE 'Applied specific policies for role % on table %', specific_role, tbl;
    END LOOP;
END;
$$;

-- =================================================================
-- Section 4: View-Level Grants
-- =================================================================
DO $$
BEGIN
  GRANT SELECT ON public.v_systems_complete TO admin, viewer, cpan_admin, maan_admin, sdh_admin, vmux_admin, mng_admin;
  GRANT SELECT ON public.v_system_connections_complete TO admin, viewer, cpan_admin, maan_admin, sdh_admin, vmux_admin, mng_admin;
  -- v_ofc_connections_complete is also defined here and needs grants
  GRANT SELECT ON public.v_ofc_connections_complete TO admin, viewer, cpan_admin, maan_admin, sdh_admin, vmux_admin, mng_admin;

  RAISE NOTICE 'Applied SELECT grants on network system views.';
END;
$$;
```

<!-- path: data/migrations/06_utilities/05_dashboard_functions.sql -->
```sql
-- Path: migrations/06_utilities/04_dashboard_functions.sql
-- Description: Contains functions for dashboard aggregations and a complete set of explicit pagination functions for all major views.

-- =================================================================
-- Section 1: Dashboard and Aggregation Functions
-- =================================================================

CREATE OR REPLACE FUNCTION public.get_dashboard_overview()
RETURNS JSONB LANGUAGE plpgsql SECURITY INVOKER SET search_path = public AS $$
DECLARE result jsonb;
BEGIN
    SELECT jsonb_build_object(
        'system_status_counts', (SELECT jsonb_object_agg(CASE WHEN status THEN 'Active' ELSE 'Inactive' END, count) FROM (SELECT status, COUNT(*) as count FROM public.systems GROUP BY status) as s),
        'node_status_counts', (SELECT jsonb_object_agg(CASE WHEN status THEN 'Active' ELSE 'Inactive' END, count) FROM (SELECT status, COUNT(*) as count FROM public.nodes GROUP BY status) as n),
        'path_operational_status', (SELECT jsonb_object_agg(lt.name, p.count) FROM (SELECT operational_status_id, COUNT(*) as count FROM public.logical_fiber_paths WHERE operational_status_id IS NOT NULL GROUP BY operational_status_id) as p JOIN lookup_types lt ON p.operational_status_id = lt.id),
        'cable_utilization_summary', (SELECT jsonb_build_object('average_utilization_percent', ROUND(AVG(utilization_percent)::numeric, 2), 'high_utilization_count', COUNT(*) FILTER (WHERE utilization_percent > 80), 'total_cables', COUNT(*)) FROM public.v_cable_utilization),
        'user_activity_last_30_days', (SELECT jsonb_agg(jsonb_build_object('date', day::date, 'count', COALESCE(activity_count, 0)) ORDER BY day) FROM generate_series(CURRENT_DATE - interval '29 days', CURRENT_DATE, '1 day') as s(day) LEFT JOIN (SELECT created_at::date as activity_date, COUNT(*) as activity_count FROM public.user_activity_logs WHERE created_at >= CURRENT_DATE - interval '29 days' GROUP BY activity_date) as activity ON s.day = activity.activity_date),
        'systems_per_maintenance_area', (SELECT jsonb_object_agg(ma.name, s.system_count) FROM (SELECT maintenance_terminal_id, COUNT(id) as system_count FROM public.systems WHERE maintenance_terminal_id IS NOT NULL GROUP BY maintenance_terminal_id) as s JOIN public.maintenance_areas ma ON s.maintenance_terminal_id = ma.id)
    ) INTO result;
    RETURN result;
END; $$;
GRANT EXECUTE ON FUNCTION public.get_dashboard_overview() TO authenticated;

CREATE OR REPLACE FUNCTION public.get_entity_counts(p_entity_name TEXT, p_filters JSONB DEFAULT '{}')
RETURNS TABLE (total_count BIGINT, active_count BIGINT, inactive_count BIGINT)
LANGUAGE plpgsql SECURITY DEFINER SET search_path = public AS $$
DECLARE sql_query TEXT; sql_where TEXT := 'WHERE 1=1'; filter_key TEXT; filter_value JSONB;
BEGIN
    IF p_filters IS NOT NULL AND jsonb_typeof(p_filters) = 'object' AND p_filters != '{}'::jsonb THEN
        FOR filter_key, filter_value IN SELECT * FROM jsonb_each(p_filters) LOOP
            sql_where := sql_where || format(' AND %I = %L', filter_key, trim(both '"' from filter_value::text));
        END LOOP;
    END IF;
    sql_query := format('SELECT count(*), count(*) FILTER (WHERE status = true), count(*) FILTER (WHERE status = false) FROM %I %s', p_entity_name, sql_where);
    RETURN QUERY EXECUTE sql_query;
END; $$;
GRANT EXECUTE ON FUNCTION public.get_entity_counts(TEXT, JSONB) TO authenticated;


```

<!-- path: data/migrations/06_utilities/01_generic_functions.sql -->
```sql
-- Path: migrations/06_utilities/01_generic_functions.sql
-- Description: A collection of generic, reusable utility functions for querying, pagination, and data manipulation.

-- =================================================================
-- Section 1: Generic Query & Data Operation Functions [CORRECTED]
-- =================================================================

-- Function: execute_sql
-- Executes a read-only SQL query and returns the result as JSON.
DROP FUNCTION IF EXISTS public.execute_sql(TEXT);
CREATE OR REPLACE FUNCTION public.execute_sql(sql_query TEXT)
RETURNS JSON
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public, pg_temp
AS $$
DECLARE
  cleaned_query TEXT;
  result_json JSON;
BEGIN
  cleaned_query := lower(trim(sql_query));
  IF cleaned_query LIKE 'insert %' OR cleaned_query LIKE 'update %' OR cleaned_query LIKE 'delete %' OR
     cleaned_query LIKE 'truncate %' OR cleaned_query LIKE 'drop %' OR cleaned_query LIKE 'create %' OR
     cleaned_query LIKE 'alter %' OR cleaned_query LIKE 'grant %' OR cleaned_query LIKE 'revoke %' OR
     cleaned_query LIKE 'set %'
  THEN
    RAISE EXCEPTION 'Only read-only statements (SELECT, WITH, CALL) are allowed.';
  END IF;
  EXECUTE 'SELECT json_agg(t) FROM (' || sql_query || ') t' INTO result_json;
  RETURN json_build_object('result', COALESCE(result_json, '[]'::json));
EXCEPTION WHEN OTHERS THEN
  RETURN json_build_object('error', SQLERRM);
END;
$$;
GRANT EXECUTE ON FUNCTION public.execute_sql(TEXT) TO authenticated;


-- Function: aggregate_query
-- Performs dynamic aggregations (COUNT, SUM, AVG, etc.) on a table.
CREATE OR REPLACE FUNCTION public.aggregate_query(
    table_name TEXT,
    aggregation_options JSONB,
    filters JSONB DEFAULT '{}'::jsonb,
    order_by JSONB DEFAULT '[]'::jsonb
)
RETURNS TABLE(result JSONB)
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public, pg_temp
AS $$
DECLARE
  query_text TEXT;
  select_clause TEXT := '';
  where_clause TEXT := '';
  group_clause TEXT := '';
  order_clause TEXT := '';
  agg_parts TEXT[] := ARRAY[]::TEXT[];
BEGIN
  -- Build aggregation parts (COUNT, SUM, AVG, etc.)
  -- ... (this part of the function remains unchanged)
  IF (aggregation_options->>'count')::boolean THEN agg_parts := array_append(agg_parts, 'COUNT(*) as count');
  ELSIF aggregation_options->'count' IS NOT NULL THEN agg_parts := array_append(agg_parts, format('COUNT(%I) as count', aggregation_options->>'count')); END IF;
  IF aggregation_options->'sum' IS NOT NULL THEN SELECT array_cat(agg_parts, array_agg(format('SUM(%I) as sum_%s', value, value))) INTO agg_parts FROM jsonb_array_elements_text(aggregation_options->'sum') AS value; END IF;
  IF aggregation_options->'avg' IS NOT NULL THEN SELECT array_cat(agg_parts, array_agg(format('AVG(%I) as avg_%s', value, value))) INTO agg_parts FROM jsonb_array_elements_text(aggregation_options->'avg') AS value; END IF;
  IF aggregation_options->'min' IS NOT NULL THEN SELECT array_cat(agg_parts, array_agg(format('MIN(%I) as min_%s', value, value))) INTO agg_parts FROM jsonb_array_elements_text(aggregation_options->'min') AS value; END IF;
  IF aggregation_options->'max' IS NOT NULL THEN SELECT array_cat(agg_parts, array_agg(format('MAX(%I) as max_%s', value, value))) INTO agg_parts FROM jsonb_array_elements_text(aggregation_options->'max') AS value; END IF;

  -- Build GROUP BY
  -- ... (this part of the function remains unchanged)
  IF aggregation_options->'groupBy' IS NOT NULL THEN
    SELECT string_agg(format('%I', value), ', ') INTO group_clause FROM jsonb_array_elements_text(aggregation_options->'groupBy') AS value;
    SELECT string_agg(format('%I', value), ', ') INTO select_clause FROM jsonb_array_elements_text(aggregation_options->'groupBy') AS value;
    group_clause := 'GROUP BY ' || group_clause;
  END IF;

  IF select_clause != '' AND array_length(agg_parts, 1) > 0 THEN select_clause := select_clause || ', ' || array_to_string(agg_parts, ', ');
  ELSIF array_length(agg_parts, 1) > 0 THEN select_clause := array_to_string(agg_parts, ', ');
  ELSE select_clause := '*'; END IF;

  -- START OF FIX --
  -- Build WHERE clause by calling the robust helper function.
  -- We pass an empty string '' as the alias.
  where_clause := public.build_where_clause(filters, '');
  
  -- The helper function returns a string with a leading ' AND ...', so we strip it if it exists.
  -- We also add the 'WHERE' keyword.
  IF where_clause != '' THEN
    where_clause := 'WHERE ' || substr(where_clause, 6); -- substr(..., 6) removes the leading ' AND '
  END IF;
  -- END OF FIX --

  -- Build ORDER BY
  -- ... (this part of the function remains unchanged)
  IF jsonb_typeof(order_by) = 'array' AND jsonb_array_length(order_by) > 0 THEN
    SELECT string_agg(format('%I %s', item->>'column', CASE WHEN (item->>'ascending')::boolean THEN 'ASC' ELSE 'DESC' END), ', ') INTO order_clause FROM jsonb_array_elements(order_by) AS item;
    IF order_clause IS NOT NULL THEN order_clause := 'ORDER BY ' || order_clause; END IF;
  END IF;

  query_text := format('SELECT %s FROM %I %s %s %s', select_clause, table_name, where_clause, group_clause, order_clause);
  RETURN QUERY EXECUTE format('SELECT row_to_json(t)::jsonb FROM (%s) t', query_text);
END;
$$;
GRANT EXECUTE ON FUNCTION public.aggregate_query(TEXT, JSONB, JSONB, JSONB) TO authenticated;


-- Function: get_unique_values
-- Gets distinct values from a specified column, with optional filtering.
CREATE OR REPLACE FUNCTION public.get_unique_values(
    p_table_name TEXT,
    p_column_name TEXT,
    p_filters JSONB DEFAULT '{}'::jsonb,
    p_order_by JSONB DEFAULT '[]'::jsonb,
    p_limit_count INTEGER DEFAULT NULL
)
RETURNS TABLE(value JSONB)
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public, pg_temp
AS $$
DECLARE
  query_text TEXT;
  where_clause TEXT := '';
  order_clause TEXT := '';
  limit_clause TEXT := '';
BEGIN
    IF jsonb_typeof(p_filters) = 'object' AND p_filters != '{}'::jsonb THEN
        SELECT string_agg(format('%I = %L', key, p_filters->>key), ' AND ')
        INTO where_clause FROM jsonb_object_keys(p_filters) key;
        IF where_clause IS NOT NULL THEN where_clause := 'WHERE ' || where_clause; END IF;
    END IF;
    IF jsonb_typeof(p_order_by) = 'array' AND jsonb_array_length(p_order_by) > 0 THEN
        SELECT string_agg(
            format('%I %s', item->>'column', CASE WHEN (item->>'ascending')::boolean THEN 'ASC' ELSE 'DESC' END), ', '
        ) INTO order_clause FROM jsonb_array_elements(p_order_by) AS item;
        IF order_clause IS NOT NULL THEN order_clause := 'ORDER BY ' || order_clause; END IF;
    END IF;
    IF p_limit_count IS NOT NULL THEN
        limit_clause := format('LIMIT %s', p_limit_count);
    END IF;
    query_text := format('SELECT DISTINCT %I as value FROM %I %s %s %s', p_column_name, p_table_name, where_clause, order_clause, limit_clause);
    RETURN QUERY EXECUTE format('SELECT to_jsonb(t.value) FROM (%s) t', query_text);
END;
$$;
GRANT EXECUTE ON FUNCTION public.get_unique_values(TEXT, TEXT, JSONB, JSONB, INTEGER) TO authenticated;


-- Function: bulk_update
-- Performs bulk updates on a table from a JSONB array of updates.
CREATE OR REPLACE FUNCTION public.bulk_update(
    p_table_name TEXT,
    p_updates JSONB
)
RETURNS JSONB
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
DECLARE
  update_item JSONB;
  set_clause TEXT;
  query_text TEXT;
  updated_count INTEGER := 0;
  current_updated_count INTEGER;
BEGIN
  FOR update_item IN SELECT * FROM jsonb_array_elements(p_updates) LOOP
    SELECT string_agg(format('%I = %L', key, value), ', ')
    INTO set_clause
    FROM jsonb_each_text(update_item->'data');

    IF set_clause IS NOT NULL THEN
      query_text := format('UPDATE public.%I SET %s, updated_at = NOW() WHERE id = %L',
        p_table_name, set_clause, update_item->>'id');
      EXECUTE query_text;
      GET DIAGNOSTICS current_updated_count = ROW_COUNT;
      updated_count := updated_count + current_updated_count;
    END IF;
  END LOOP;
  RETURN jsonb_build_object('updated_count', updated_count);
END;
$$;
GRANT EXECUTE ON FUNCTION public.bulk_update(TEXT, JSONB) TO authenticated;


-- =================================================================
-- Section 2: Lookup and Enumeration Functions
-- =================================================================

-- Securely get the ID of a lookup type by its category and name.
CREATE OR REPLACE FUNCTION public.get_lookup_type_id(p_category TEXT, p_name TEXT)
RETURNS UUID
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
DECLARE
  v_type_id UUID;
BEGIN
  SELECT id INTO v_type_id FROM public.lookup_types
  WHERE category = p_category AND name = p_name AND status = true;
  IF v_type_id IS NULL THEN
    RAISE EXCEPTION 'Lookup type not found for category=% and name=%', p_category, p_name;
  END IF;
  RETURN v_type_id;
END;
$$;
GRANT EXECUTE ON FUNCTION public.get_lookup_type_id(TEXT, TEXT) TO authenticated;


-- Add a new lookup type entry.
CREATE OR REPLACE FUNCTION public.add_lookup_type(
  p_category TEXT, p_name TEXT, p_code TEXT DEFAULT NULL,
  p_description TEXT DEFAULT NULL, p_sort_order INTEGER DEFAULT 0
)
RETURNS UUID
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
DECLARE
  v_type_id UUID;
BEGIN
  INSERT INTO public.lookup_types (category, name, code, description, sort_order)
  VALUES (p_category, p_name, p_code, p_description, p_sort_order)
  RETURNING id INTO v_type_id;
  RETURN v_type_id;
END;
$$;
GRANT EXECUTE ON FUNCTION public.add_lookup_type(TEXT, TEXT, TEXT, TEXT, INTEGER) TO authenticated;


-- Get all active lookup types for a given category.
CREATE OR REPLACE FUNCTION public.get_lookup_types_by_category(p_category TEXT)
RETURNS TABLE (id UUID, name TEXT, code TEXT, description TEXT, sort_order INTEGER)
LANGUAGE sql
STABLE
SECURITY INVOKER
AS $$
  SELECT lt.id, lt.name, lt.code, lt.description, lt.sort_order
  FROM public.lookup_types lt
  WHERE lt.category = p_category AND lt.status = true
  ORDER BY lt.sort_order, lt.name;
$$;
GRANT EXECUTE ON FUNCTION public.get_lookup_types_by_category(TEXT) TO authenticated;

-- Generic function to get total, active, and inactive counts for any table/view.
CREATE OR REPLACE FUNCTION public.get_entity_counts(
    p_entity_name TEXT,
    p_filters JSONB DEFAULT '{}'
)
RETURNS TABLE (total_count BIGINT, active_count BIGINT, inactive_count BIGINT)
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
DECLARE
    sql_query TEXT;
    sql_where TEXT := 'WHERE 1=1';
    filter_key TEXT;
    filter_value JSONB;
BEGIN
    IF p_filters IS NOT NULL AND jsonb_typeof(p_filters) = 'object' AND p_filters != '{}'::jsonb THEN
        FOR filter_key, filter_value IN SELECT * FROM jsonb_each(p_filters)
        LOOP
            sql_where := sql_where || format(' AND %I = %L', filter_key, trim(both '"' from filter_value::text));
        END LOOP;
    END IF;

    sql_query := format(
        'SELECT count(*), count(*) FILTER (WHERE status = true), count(*) FILTER (WHERE status = false) FROM %I %s',
        p_entity_name, sql_where
    );
    RETURN QUERY EXECUTE sql_query;
END;
$$;
GRANT EXECUTE ON FUNCTION public.get_entity_counts(TEXT, JSONB) TO authenticated;
```

<!-- path: data/migrations/06_utilities/04_no_pagination_specialized_function.sql -->
```sql
-- =================================================================
-- Section 3: Specialized Utility Functions (No Pagination)
-- =================================================================

CREATE OR REPLACE FUNCTION public.get_system_path_details(p_path_id UUID)
RETURNS SETOF public.v_system_ring_paths_detailed LANGUAGE plpgsql SECURITY DEFINER SET search_path = public AS $$
BEGIN
    IF NOT EXISTS (SELECT 1 FROM public.logical_fiber_paths lfp WHERE lfp.id = p_path_id AND EXISTS (SELECT 1 FROM public.systems s WHERE s.id = lfp.source_system_id)) THEN
        RETURN;
    END IF;
    RETURN QUERY SELECT * FROM public.v_system_ring_paths_detailed WHERE logical_path_id = p_path_id ORDER BY path_order ASC;
END; $$;
GRANT EXECUTE ON FUNCTION public.get_system_path_details(UUID) TO authenticated;

CREATE OR REPLACE FUNCTION public.get_continuous_available_fibers(p_path_id UUID)
RETURNS TABLE(fiber_no INT) LANGUAGE plpgsql SECURITY DEFINER SET search_path = public AS $$
DECLARE path_cable_count INT;
BEGIN
    SELECT COUNT(DISTINCT seg.ofc_cable_id) INTO path_cable_count FROM public.logical_path_segments seg WHERE seg.logical_path_id = p_path_id AND seg.ofc_cable_id IS NOT NULL;
    IF COALESCE(path_cable_count, 0) = 0 THEN RETURN; END IF;
    RETURN QUERY SELECT conn.fiber_no_sn::INT FROM public.ofc_connections conn JOIN public.logical_path_segments seg ON conn.ofc_id = seg.ofc_cable_id
    WHERE seg.logical_path_id = p_path_id AND conn.logical_path_id IS NULL AND conn.status = TRUE
    GROUP BY conn.fiber_no_sn HAVING COUNT(conn.ofc_id) = path_cable_count;
END; $$;
GRANT EXECUTE ON FUNCTION public.get_continuous_available_fibers(UUID) TO authenticated;
```

<!-- path: data/migrations/06_utilities/02_paged_functions.sql -->
```sql
-- =================================================================
-- Section 2: Generic Pagination Functions
-- =================================================================
-- These functions build dynamic SQL. They are constructed to be secure
-- using format() with %I for identifiers and %L for literals.

-- Helper function to build the WHERE clause dynamically
-- [CORRECTED] to check for column existence before adding a filter.
-- CLEANUP: Drop all possible ambiguous versions of build_where_clause to ensure a clean slate.
DROP FUNCTION IF EXISTS public.build_where_clause(jsonb);
DROP FUNCTION IF EXISTS public.build_where_clause(jsonb, text);
DROP FUNCTION IF EXISTS public.build_where_clause(jsonb, text, text);

-- =================================================================
-- Section 1: Helper Functions (in 'public' schema)
-- =================================================================

-- Helper function to check if a column exists in a given table/view
CREATE OR REPLACE FUNCTION public.column_exists(p_schema_name TEXT, p_table_name TEXT, p_column_name TEXT)
RETURNS BOOLEAN LANGUAGE plpgsql STABLE AS $$
BEGIN
    RETURN EXISTS (
        SELECT 1
        FROM information_schema.columns
        WHERE table_schema = p_schema_name
          AND table_name = p_table_name
          AND column_name = p_column_name
    );
END;
$$;

-- -- Back-compat wrappers for existing callers

-- -- 2-arg wrapper: delegates to 3-arg with default alias 'v'
-- CREATE OR REPLACE FUNCTION public.build_where_clause(p_filters JSONB, p_view_name TEXT)
-- RETURNS TEXT LANGUAGE plpgsql STABLE AS $$
-- BEGIN
--   RETURN public.build_where_clause(p_filters, p_view_name, 'v');
-- END;
-- $$;

-- -- 1-arg wrapper: delegates to 3-arg without a view name (no column-existence check)
-- -- We pass empty view/alias; the 3-arg function should tolerate empty view_name by skipping column checks.
-- CREATE OR REPLACE FUNCTION public.build_where_clause(p_filters JSONB)
-- RETURNS TEXT LANGUAGE plpgsql STABLE AS $$
-- DECLARE
--   where_clause TEXT := '';
--   filter_key TEXT;
--   filter_value JSONB;
-- BEGIN
--   IF p_filters IS NOT NULL AND jsonb_typeof(p_filters) = 'object' AND p_filters != '{}'::jsonb THEN
--     FOR filter_key, filter_value IN SELECT key, value FROM jsonb_each(p_filters) LOOP
--       IF filter_value IS NULL OR filter_value = '""'::jsonb THEN CONTINUE; END IF;
--       IF filter_key = 'or' OR filter_key = '$or' THEN
--         where_clause := where_clause || format(' AND (%s)', filter_value->>0);
--       ELSE
--         IF jsonb_typeof(filter_value) = 'array' THEN
--           where_clause := where_clause || format(
--             ' AND %I IN (SELECT value::text FROM jsonb_array_elements_text(%L))',
--             filter_key, filter_value
--           );
--         ELSE
--           IF right(filter_key, 3) = '_id' OR jsonb_typeof(filter_value) = 'boolean' THEN
--             where_clause := where_clause || format(' AND %I::text = %L', filter_key, filter_value->>0);
--           ELSE
--             where_clause := where_clause || format(' AND %I::text ILIKE %L', filter_key, '%' || (filter_value->>0) || '%');
--           END IF;
--         END IF;
--       END IF;
--     END LOOP;
--   END IF;
--   RETURN where_clause;
-- END;
-- $$;

-- Helper function to build the WHERE clause dynamically
CREATE OR REPLACE FUNCTION public.build_where_clause(p_filters JSONB, p_view_name TEXT, p_alias TEXT DEFAULT 'v')
RETURNS TEXT LANGUAGE plpgsql STABLE AS $$
DECLARE
  where_clause TEXT := ''; filter_key TEXT; filter_value JSONB; alias_prefix TEXT;
BEGIN
    alias_prefix := CASE WHEN p_alias IS NOT NULL AND p_alias != '' THEN format('%I.', p_alias) ELSE '' END;
    IF p_filters IS NOT NULL AND jsonb_typeof(p_filters) = 'object' AND p_filters != '{}'::jsonb THEN
        FOR filter_key, filter_value IN SELECT key, value FROM jsonb_each(p_filters) LOOP
            IF filter_value IS NULL OR filter_value = '""'::jsonb THEN CONTINUE; END IF;
            IF filter_key = 'or' OR filter_key = '$or' THEN
                where_clause := where_clause || format(' AND (%s)', filter_value->>0);
                CONTINUE;
            END IF;
            -- Use our helper to only add filters for columns that actually exist
            IF public.column_exists('public', p_view_name, filter_key) THEN
                IF jsonb_typeof(filter_value) = 'array' THEN
                    where_clause := where_clause || format(' AND %s%I IN (SELECT value::text FROM jsonb_array_elements_text(%L))', alias_prefix, filter_key, filter_value);
                ELSE
                    IF right(filter_key, 3) = '_id' OR jsonb_typeof(filter_value) = 'boolean' THEN
                        where_clause := where_clause || format(' AND %s%I::text = %L', alias_prefix, filter_key, filter_value->>0);
                    ELSE
                        where_clause := where_clause || format(' AND %s%I::text ILIKE %L', alias_prefix, filter_key, '%' || (filter_value->>0) || '%');
                    END IF;
                END IF;
            END IF;
        END LOOP;
    END IF;
    RETURN where_clause;
END;
$$;

-- =================================================================
-- Section 2: Generic Pagination Function
-- =================================================================
CREATE OR REPLACE FUNCTION public.get_paged_data(
    p_view_name TEXT, p_limit INT, p_offset INT, p_order_by TEXT DEFAULT 'id',
    p_order_dir TEXT DEFAULT 'asc', p_filters JSONB DEFAULT '{}'
)
RETURNS JSONB LANGUAGE plpgsql SECURITY DEFINER SET search_path = public AS $$
DECLARE
    data_query TEXT; count_query TEXT; where_clause TEXT; order_by_column TEXT;
    result_data JSONB; total_records BIGINT; active_records BIGINT := 0; inactive_records BIGINT := 0;
    status_column_exists BOOLEAN;
BEGIN
    status_column_exists := public.column_exists('public', p_view_name, 'status');
    where_clause := public.build_where_clause(p_filters, p_view_name);
    IF public.column_exists('public', p_view_name, p_order_by) THEN
        order_by_column := p_order_by;
    ELSE
        IF public.column_exists('public', p_view_name, 'id') THEN
            order_by_column := 'id';
        ELSE
            SELECT column_name INTO order_by_column FROM information_schema.columns
            WHERE table_schema = 'public' AND table_name = p_view_name
            ORDER BY ordinal_position LIMIT 1;
        END IF;
    END IF;
    data_query := format(
        'SELECT jsonb_agg(v) FROM (SELECT * FROM public.%I v WHERE 1=1 %s ORDER BY v.%I %s LIMIT %L OFFSET %L) v',
        p_view_name, where_clause, order_by_column, p_order_dir, p_limit, p_offset
    );
    IF status_column_exists THEN
        count_query := format(
            'SELECT count(*), count(*) FILTER (WHERE v.status = true), count(*) FILTER (WHERE v.status = false)
             FROM public.%I v WHERE 1=1 %s', p_view_name, where_clause
        );
        EXECUTE count_query INTO total_records, active_records, inactive_records;
    ELSE
        count_query := format('SELECT count(*) FROM public.%I v WHERE 1=1 %s', p_view_name, where_clause);
        EXECUTE count_query INTO total_records;
    END IF;
    EXECUTE data_query INTO result_data;
    RETURN jsonb_build_object(
        'data', COALESCE(result_data, '[]'::jsonb), 'total_count', COALESCE(total_records, 0),
        'active_count', COALESCE(active_records, 0), 'inactive_count', COALESCE(inactive_records, 0)
    );
END;
$$;
GRANT EXECUTE ON FUNCTION public.get_paged_data(TEXT, INT, INT, TEXT, TEXT, JSONB) TO authenticated;


-- Paged function for v_nodes_complete
CREATE OR REPLACE FUNCTION public.get_paged_nodes_complete(p_limit INT, p_offset INT, p_order_by TEXT DEFAULT 'name', p_order_dir TEXT DEFAULT 'asc', p_filters JSONB DEFAULT '{}')
RETURNS TABLE(id UUID, name TEXT, created_at TIMESTAMPTZ, latitude NUMERIC, longitude NUMERIC, maintenance_area_name TEXT, node_type_name TEXT, remark TEXT, status BOOLEAN, updated_at TIMESTAMPTZ, total_count BIGINT, active_count BIGINT, inactive_count BIGINT)
LANGUAGE plpgsql SECURITY DEFINER SET search_path = public AS $$
BEGIN
    RETURN QUERY EXECUTE format(
    'SELECT v.id, v.name, v.created_at, v.latitude, v.longitude, v.maintenance_area_name, v.node_type_name, v.remark, v.status, v.updated_at,
      count(*) OVER() AS total_count, sum(CASE WHEN v.status THEN 1 ELSE 0 END) OVER() AS active_count, sum(CASE WHEN NOT v.status THEN 1 ELSE 0 END) OVER() AS inactive_count
    FROM public.v_nodes_complete v WHERE 1=1 %s ORDER BY v.%I %s LIMIT %L OFFSET %L',
    public.build_where_clause(p_filters), p_order_by, p_order_dir, p_limit, p_offset);
END; $$;
GRANT EXECUTE ON FUNCTION public.get_paged_nodes_complete(INT, INT, TEXT, TEXT, JSONB) TO authenticated;

-- Paged function for v_ofc_cables_complete
CREATE OR REPLACE FUNCTION public.get_paged_ofc_cables_complete(p_limit INT, p_offset INT, p_order_by TEXT DEFAULT 'route_name', p_order_dir TEXT DEFAULT 'asc', p_filters JSONB DEFAULT '{}')
RETURNS TABLE(id UUID, route_name TEXT, sn_name TEXT, en_name TEXT, capacity INT, ofc_type_name TEXT, ofc_owner_name TEXT, current_rkm NUMERIC, maintenance_area_name TEXT, commissioned_on DATE, status BOOLEAN, remark TEXT, updated_at TIMESTAMPTZ, total_count BIGINT, active_count BIGINT, inactive_count BIGINT)
LANGUAGE plpgsql SECURITY DEFINER SET search_path = public AS $$
BEGIN
    RETURN QUERY EXECUTE format(
    'SELECT v.id, v.route_name, v.sn_name, v.en_name, v.capacity, v.ofc_type_name, v.ofc_owner_name, v.current_rkm, v.maintenance_area_name, v.commissioned_on, v.status, v.remark, v.updated_at,
           count(*) OVER() AS total_count, sum(CASE WHEN v.status THEN 1 ELSE 0 END) OVER() AS active_count, sum(CASE WHEN NOT v.status THEN 1 ELSE 0 END) OVER() AS inactive_count
    FROM public.v_ofc_cables_complete v WHERE 1=1 %s ORDER BY v.%I %s LIMIT %L OFFSET %L',
    public.build_where_clause(p_filters), p_order_by, p_order_dir, p_limit, p_offset);
END; $$;
GRANT EXECUTE ON FUNCTION public.get_paged_ofc_cables_complete(INT, INT, TEXT, TEXT, JSONB) TO authenticated;

-- Paged function for v_rings_with_count
CREATE OR REPLACE FUNCTION public.get_paged_rings_with_count(p_limit INT, p_offset INT, p_order_by TEXT DEFAULT 'name', p_order_dir TEXT DEFAULT 'asc', p_filters JSONB DEFAULT '{}')
RETURNS TABLE(id UUID, name TEXT, ring_type_name TEXT, maintenance_area_name TEXT, total_nodes INT, status BOOLEAN, total_count BIGINT, active_count BIGINT, inactive_count BIGINT)
LANGUAGE plpgsql SECURITY DEFINER SET search_path = public AS $$
BEGIN
    RETURN QUERY EXECUTE format(
    'SELECT v.id, v.name, v.ring_type_name, v.maintenance_area_name, v.total_nodes, v.status,
           count(*) OVER() AS total_count, sum(CASE WHEN v.status THEN 1 ELSE 0 END) OVER() AS active_count, sum(CASE WHEN NOT v.status THEN 1 ELSE 0 END) OVER() AS inactive_count
    FROM public.v_rings_with_count v WHERE 1=1 %s ORDER BY v.%I %s LIMIT %L OFFSET %L',
    public.build_where_clause(p_filters), p_order_by, p_order_dir, p_limit, p_offset);
END; $$;
GRANT EXECUTE ON FUNCTION public.get_paged_rings_with_count(INT, INT, TEXT, TEXT, JSONB) TO authenticated;

-- Paged function for v_ofc_connections_complete
CREATE OR REPLACE FUNCTION public.get_paged_ofc_connections_complete(p_limit INT, p_offset INT, p_order_by TEXT DEFAULT 'fiber_no_sn', p_order_dir TEXT DEFAULT 'asc', p_filters JSONB DEFAULT '{}')
RETURNS TABLE(id UUID, ofc_route_name TEXT, fiber_no_sn INT, sn_name TEXT, system_name TEXT, en_name TEXT, fiber_role TEXT, status BOOLEAN, total_count BIGINT, active_count BIGINT, inactive_count BIGINT)
LANGUAGE plpgsql SECURITY DEFINER SET search_path = public AS $$
BEGIN
    RETURN QUERY EXECUTE format(
    'SELECT v.id, v.ofc_route_name, v.fiber_no_sn, v.sn_name, v.system_name, v.en_name, v.fiber_role, v.status,
           count(*) OVER() AS total_count, sum(CASE WHEN v.status THEN 1 ELSE 0 END) OVER() AS active_count, sum(CASE WHEN NOT v.status THEN 1 ELSE 0 END) OVER() AS inactive_count
    FROM public.v_ofc_connections_complete v WHERE 1=1 %s ORDER BY v.%I %s LIMIT %L OFFSET %L',
    public.build_where_clause(p_filters), p_order_by, p_order_dir, p_limit, p_offset);
END; $$;
GRANT EXECUTE ON FUNCTION public.get_paged_ofc_connections_complete(INT, INT, TEXT, TEXT, JSONB) TO authenticated;

-- Paged function for v_systems_complete
CREATE OR REPLACE FUNCTION public.get_paged_systems_complete(p_limit INT, p_offset INT, p_order_by TEXT DEFAULT 'system_name', p_order_dir TEXT DEFAULT 'asc', p_filters JSONB DEFAULT '{}')
RETURNS TABLE(id UUID, system_name TEXT, system_type_name TEXT, node_name TEXT, ip_address INET, status BOOLEAN, remark TEXT, total_count BIGINT, active_count BIGINT, inactive_count BIGINT)
LANGUAGE plpgsql SECURITY DEFINER SET search_path = public AS $$
BEGIN
    RETURN QUERY EXECUTE format(
    'SELECT v.id, v.system_name, v.system_type_name, v.node_name, v.ip_address, v.status, v.remark,
           count(*) OVER() AS total_count, sum(CASE WHEN v.status THEN 1 ELSE 0 END) OVER() AS active_count, sum(CASE WHEN NOT v.status THEN 1 ELSE 0 END) OVER() AS inactive_count
    FROM public.v_systems_complete v WHERE 1=1 %s ORDER BY v.%I %s LIMIT %L OFFSET %L',
    public.build_where_clause(p_filters), p_order_by, p_order_dir, p_limit, p_offset);
END; $$;
GRANT EXECUTE ON FUNCTION public.get_paged_systems_complete(INT, INT, TEXT, TEXT, JSONB) TO authenticated;

-- Paged function for v_system_connections_complete
CREATE OR REPLACE FUNCTION public.get_paged_system_connections_complete(p_limit INT, p_offset INT, p_order_by TEXT DEFAULT 'system_name', p_order_dir TEXT DEFAULT 'asc', p_filters JSONB DEFAULT '{}')
RETURNS TABLE(id UUID, system_name TEXT, system_type_name TEXT, media_type_name TEXT, sn_name TEXT, sn_node_name TEXT, en_name TEXT, en_node_name TEXT, connected_system_name TEXT, status BOOLEAN, total_count BIGINT, active_count BIGINT, inactive_count BIGINT)
LANGUAGE plpgsql SECURITY DEFINER SET search_path = public AS $$
BEGIN
    RETURN QUERY EXECUTE format(
    'SELECT v.id, v.system_name, v.system_type_name, v.media_type_name, v.sn_name, v.sn_node_name, v.en_name, v.en_node_name, v.connected_system_name, v.status,
           count(*) OVER() AS total_count, sum(CASE WHEN v.status THEN 1 ELSE 0 END) OVER() AS active_count, sum(CASE WHEN NOT v.status THEN 1 ELSE 0 END) OVER() AS inactive_count
    FROM public.v_system_connections_complete v WHERE 1=1 %s ORDER BY v.%I %s LIMIT %L OFFSET %L',
    public.build_where_clause(p_filters), p_order_by, p_order_dir, p_limit, p_offset);
END; $$;
GRANT EXECUTE ON FUNCTION public.get_paged_system_connections_complete(INT, INT, TEXT, TEXT, JSONB) TO authenticated;

-- Paged function for v_lookup_types_with_count
CREATE OR REPLACE FUNCTION public.get_paged_lookup_types_with_count(p_limit INT, p_offset INT, p_order_by TEXT DEFAULT 'name', p_order_dir TEXT DEFAULT 'asc', p_filters JSONB DEFAULT '{}')
RETURNS TABLE(id UUID, category TEXT, name TEXT, code TEXT, description TEXT, sort_order INT, status BOOLEAN, total_count BIGINT, active_count BIGINT, inactive_count BIGINT)
LANGUAGE plpgsql SECURITY DEFINER SET search_path = public AS $$
BEGIN
    RETURN QUERY EXECUTE format(
    'SELECT v.id, v.category, v.name, v.code, v.description, v.sort_order, v.status,
           count(*) OVER() AS total_count, sum(CASE WHEN v.status THEN 1 ELSE 0 END) OVER() AS active_count, sum(CASE WHEN NOT v.status THEN 1 ELSE 0 END) OVER() AS inactive_count
    FROM public.v_lookup_types_with_count v WHERE 1=1 %s ORDER BY v.%I %s LIMIT %L OFFSET %L',
    public.build_where_clause(p_filters), p_order_by, p_order_dir, p_limit, p_offset);
END; $$;
GRANT EXECUTE ON FUNCTION public.get_paged_lookup_types_with_count(INT, INT, TEXT, TEXT, JSONB) TO authenticated;

-- Paged function for v_maintenance_areas_with_count
CREATE OR REPLACE FUNCTION public.get_paged_maintenance_areas_with_count(p_limit INT, p_offset INT, p_order_by TEXT DEFAULT 'name', p_order_dir TEXT DEFAULT 'asc', p_filters JSONB DEFAULT '{}')
RETURNS TABLE(id UUID, name TEXT, code TEXT, maintenance_area_type_name TEXT, contact_person TEXT, contact_number TEXT, status BOOLEAN, total_count BIGINT, active_count BIGINT, inactive_count BIGINT)
LANGUAGE plpgsql SECURITY DEFINER SET search_path = public AS $$
BEGIN
    RETURN QUERY EXECUTE format(
    'SELECT v.id, v.name, v.code, v.maintenance_area_type_name, v.contact_person, v.contact_number, v.status,
           count(*) OVER() AS total_count, sum(CASE WHEN v.status THEN 1 ELSE 0 END) OVER() AS active_count, sum(CASE WHEN NOT v.status THEN 1 ELSE 0 END) OVER() AS inactive_count
    FROM public.v_maintenance_areas_with_count v WHERE 1=1 %s ORDER BY v.%I %s LIMIT %L OFFSET %L',
    public.build_where_clause(p_filters), p_order_by, p_order_dir, p_limit, p_offset);
END; $$;
GRANT EXECUTE ON FUNCTION public.get_paged_maintenance_areas_with_count(INT, INT, TEXT, TEXT, JSONB) TO authenticated;

-- Paged function for v_employee_designations_with_count
CREATE OR REPLACE FUNCTION public.get_paged_employee_designations_with_count(p_limit INT, p_offset INT, p_order_by TEXT DEFAULT 'name', p_order_dir TEXT DEFAULT 'asc', p_filters JSONB DEFAULT '{}')
RETURNS TABLE(id UUID, name TEXT, parent_id UUID, status BOOLEAN, total_count BIGINT, active_count BIGINT, inactive_count BIGINT)
LANGUAGE plpgsql SECURITY DEFINER SET search_path = public AS $$
BEGIN
    RETURN QUERY EXECUTE format(
    'SELECT v.id, v.name, v.parent_id, v.status,
           count(*) OVER() AS total_count, sum(CASE WHEN v.status THEN 1 ELSE 0 END) OVER() AS active_count, sum(CASE WHEN NOT v.status THEN 1 ELSE 0 END) OVER() AS inactive_count
    FROM public.v_employee_designations_with_count v WHERE 1=1 %s ORDER BY v.%I %s LIMIT %L OFFSET %L',
    public.build_where_clause(p_filters), p_order_by, p_order_dir, p_limit, p_offset);
END; $$;
GRANT EXECUTE ON FUNCTION public.get_paged_employee_designations_with_count(INT, INT, TEXT, TEXT, JSONB) TO authenticated;

-- Paged function for v_employees_with_count
CREATE OR REPLACE FUNCTION public.get_paged_employees_with_count(p_limit INT, p_offset INT, p_order_by TEXT DEFAULT 'employee_name', p_order_dir TEXT DEFAULT 'asc', p_filters JSONB DEFAULT '{}')
RETURNS TABLE(id UUID, employee_name TEXT, employee_pers_no TEXT, employee_designation_name TEXT, employee_contact TEXT, status BOOLEAN, total_count BIGINT, active_count BIGINT, inactive_count BIGINT)
LANGUAGE plpgsql SECURITY DEFINER SET search_path = public AS $$
BEGIN
    RETURN QUERY EXECUTE format(
    'SELECT v.id, v.employee_name, v.employee_pers_no, v.employee_designation_name, v.employee_contact, v.status,
           count(*) OVER() AS total_count, sum(CASE WHEN v.status THEN 1 ELSE 0 END) OVER() AS active_count, sum(CASE WHEN NOT v.status THEN 1 ELSE 0 END) OVER() AS inactive_count
    FROM public.v_employees_with_count v WHERE 1=1 %s ORDER BY v.%I %s LIMIT %L OFFSET %L',
    public.build_where_clause(p_filters), p_order_by, p_order_dir, p_limit, p_offset);
END; $$;
GRANT EXECUTE ON FUNCTION public.get_paged_employees_with_count(INT, INT, TEXT, TEXT, JSONB) TO authenticated;

```

<!-- path: data/migrations/06_utilities/03_ofc_route_functions.sql -->
```sql
-- =================================================================
-- Section 4: OFC and Splicing Specific Utility Functions
-- =================================================================

-- Provision a working and protection fiber pair on a logical path.
CREATE OR REPLACE FUNCTION public.provision_ring_path(
    p_system_id UUID, p_path_name TEXT, p_working_fiber_no INT,
    p_protection_fiber_no INT, p_physical_path_id UUID
)
RETURNS TABLE(working_path_id UUID, protection_path_id UUID)
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
DECLARE
    v_working_path_id UUID;
    v_protection_path_id UUID;
    v_active_status_id UUID;
BEGIN
    SELECT id INTO v_active_status_id FROM public.lookup_types WHERE category = 'OFC_PATH_STATUSES' AND name = 'active' LIMIT 1;
    IF v_active_status_id IS NULL THEN RAISE EXCEPTION 'Operational status "active" not found.'; END IF;

    INSERT INTO public.logical_fiber_paths (path_name, source_system_id, path_role, operational_status_id)
    VALUES (p_path_name || ' (Working)', p_system_id, 'working', v_active_status_id) RETURNING id INTO v_working_path_id;

    INSERT INTO public.logical_fiber_paths (path_name, source_system_id, path_role, working_path_id, operational_status_id)
    VALUES (p_path_name || ' (Protection)', p_system_id, 'protection', v_working_path_id, v_active_status_id) RETURNING id INTO v_protection_path_id;

    UPDATE public.ofc_connections SET logical_path_id = v_working_path_id, fiber_role = 'working'
    WHERE fiber_no_sn = p_working_fiber_no AND ofc_id IN (
        SELECT lps.ofc_cable_id FROM logical_path_segments lps WHERE lps.logical_path_id = p_physical_path_id
    );

    UPDATE public.ofc_connections SET logical_path_id = v_protection_path_id, fiber_role = 'protection'
    WHERE fiber_no_sn = p_protection_fiber_no AND ofc_id IN (
        SELECT lps.ofc_cable_id FROM logical_path_segments lps WHERE lps.logical_path_id = p_physical_path_id
    );

    RETURN QUERY SELECT v_working_path_id, v_protection_path_id;
END;
$$;
GRANT EXECUTE ON FUNCTION public.provision_ring_path(UUID, TEXT, INT, INT, UUID) TO authenticated;


-- Automatically create 1-to-1 "straight" splices for available fibers between two cables.
CREATE OR REPLACE FUNCTION public.auto_splice_straight(p_jc_id UUID, p_cable1_id UUID, p_cable2_id UUID)
RETURNS JSONB
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
DECLARE
    cable1_capacity INT; cable2_capacity INT; i INT; splice_count INT := 0;
    available_fibers_c1 INT[]; available_fibers_c2 INT[];
BEGIN
    SELECT capacity INTO cable1_capacity FROM public.ofc_cables WHERE id = p_cable1_id;
    SELECT capacity INTO cable2_capacity FROM public.ofc_cables WHERE id = p_cable2_id;
    IF cable1_capacity IS NULL OR cable2_capacity IS NULL THEN RAISE EXCEPTION 'One or both cables not found.'; END IF;

    SELECT array_agg(s.i) INTO available_fibers_c1 FROM generate_series(1, cable1_capacity) s(i)
    WHERE NOT EXISTS (SELECT 1 FROM public.fiber_splices fs WHERE fs.jc_id = p_jc_id AND ((fs.incoming_cable_id = p_cable1_id AND fs.incoming_fiber_no = s.i) OR (fs.outgoing_cable_id = p_cable1_id AND fs.outgoing_fiber_no = s.i)));
    SELECT array_agg(s.i) INTO available_fibers_c2 FROM generate_series(1, cable2_capacity) s(i)
    WHERE NOT EXISTS (SELECT 1 FROM public.fiber_splices fs WHERE fs.jc_id = p_jc_id AND ((fs.incoming_cable_id = p_cable2_id AND fs.incoming_fiber_no = s.i) OR (fs.outgoing_cable_id = p_cable2_id AND fs.outgoing_fiber_no = s.i)));

    FOR i IN 1..LEAST(cardinality(available_fibers_c1), cardinality(available_fibers_c2)) LOOP
        INSERT INTO public.fiber_splices (jc_id, incoming_cable_id, incoming_fiber_no, outgoing_cable_id, outgoing_fiber_no, splice_type)
        VALUES (p_jc_id, p_cable1_id, available_fibers_c1[i], p_cable2_id, available_fibers_c2[i], 'pass_through');
        splice_count := splice_count + 1;
    END LOOP;
    RETURN jsonb_build_object('status', 'success', 'splices_created', splice_count);
END;
$$;
GRANT EXECUTE ON FUNCTION public.auto_splice_straight(UUID, UUID, UUID) TO authenticated;


-- RPC function to handle creating, deleting, and updating splices.
CREATE OR REPLACE FUNCTION public.manage_splice(
    p_action TEXT, p_jc_id UUID, p_splice_id UUID DEFAULT NULL, p_incoming_cable_id UUID DEFAULT NULL,
    p_incoming_fiber_no INT DEFAULT NULL, p_outgoing_cable_id UUID DEFAULT NULL, p_outgoing_fiber_no INT DEFAULT NULL,
    p_splice_type TEXT DEFAULT 'pass_through', p_otdr_length_km NUMERIC DEFAULT NULL
)
RETURNS RECORD
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
DECLARE
    result RECORD;
BEGIN
    IF p_action = 'create' THEN
        INSERT INTO public.fiber_splices (jc_id, incoming_cable_id, incoming_fiber_no, outgoing_cable_id, outgoing_fiber_no, splice_type, otdr_length_km)
        VALUES (p_jc_id, p_incoming_cable_id, p_incoming_fiber_no, p_outgoing_cable_id, p_outgoing_fiber_no, p_splice_type, p_otdr_length_km)
        RETURNING id, 'created' INTO result;
    ELSIF p_action = 'delete' THEN
        DELETE FROM public.fiber_splices WHERE id = p_splice_id AND jc_id = p_jc_id RETURNING id, 'deleted' INTO result;
        IF NOT FOUND THEN RAISE EXCEPTION 'Splice not found.'; END IF;
    ELSIF p_action = 'update_otdr' THEN
        UPDATE public.fiber_splices SET otdr_length_km = p_otdr_length_km, updated_at = now()
        WHERE id = p_splice_id AND jc_id = p_jc_id RETURNING id, 'updated' INTO result;
        IF NOT FOUND THEN RAISE EXCEPTION 'Splice not found.'; END IF;
    ELSE
        RAISE EXCEPTION 'Invalid action specified.';
    END IF;
    RETURN result;
END;
$$;
GRANT EXECUTE ON FUNCTION public.manage_splice(TEXT, UUID, UUID, UUID, INT, UUID, INT, TEXT, NUMERIC) TO authenticated;


-- Get a list of all OFC cables present at a specific Junction Closure.
CREATE OR REPLACE FUNCTION public.get_cables_at_jc(p_jc_id UUID)
RETURNS TABLE (id UUID, route_name TEXT, capacity INT)
LANGUAGE sql
STABLE
SECURITY DEFINER
SET search_path = public
AS $$
    WITH jc_node_info AS (
        SELECT n.id as node_id FROM public.junction_closures jc
        JOIN public.nodes n ON jc.latitude = n.latitude AND jc.longitude = n.longitude
        WHERE jc.id = p_jc_id
    )
    SELECT c.id, c.route_name, c.capacity
    FROM public.ofc_cables c
    WHERE c.sn_id = (SELECT node_id FROM jc_node_info) OR c.en_id = (SELECT node_id FROM jc_node_info);
$$;
GRANT EXECUTE ON FUNCTION public.get_cables_at_jc(UUID) TO authenticated;


-- Get a list of all splices with their JC details.
CREATE OR REPLACE FUNCTION public.get_all_splices()
RETURNS TABLE (
    splice_id UUID, jc_id UUID, jc_name TEXT, jc_position_km NUMERIC,
    incoming_cable_id UUID, incoming_fiber_no INT, outgoing_cable_id UUID,
    outgoing_fiber_no INT, otdr_length_km NUMERIC, loss_db NUMERIC
)
LANGUAGE sql
STABLE
SECURITY DEFINER
SET search_path = public
AS $$
    SELECT s.id, s.jc_id, jc.name, jc.position_km, s.incoming_cable_id,
           s.incoming_fiber_no, s.outgoing_cable_id, s.outgoing_fiber_no,
           s.otdr_length_km, s.loss_db
    FROM public.fiber_splices s
    JOIN public.junction_closures jc ON s.jc_id = jc.id;
$$;
GRANT EXECUTE ON FUNCTION public.get_all_splices() TO authenticated;


-- Trace a fiber's path from a starting point through splices.
CREATE OR REPLACE FUNCTION public.trace_fiber_path(p_start_cable_id UUID, p_start_fiber_no INT)
RETURNS TABLE (
    segment_order BIGINT, path_type TEXT, element_id UUID,
    element_name TEXT, details TEXT, fiber_no INT,
    distance_km NUMERIC, loss_db NUMERIC
)
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
BEGIN
    RETURN QUERY
    WITH RECURSIVE path_traversal AS (
        SELECT 1::BIGINT AS segment_order, p_start_cable_id AS current_cable_id, p_start_fiber_no AS current_fiber_no, 0::NUMERIC AS last_position_km
        UNION ALL
        SELECT p.segment_order + 1, s.outgoing_cable_id, s.outgoing_fiber_no, jc.position_km
        FROM path_traversal p
        JOIN public.fiber_splices s ON p.current_cable_id = s.incoming_cable_id AND p.current_fiber_no = s.incoming_fiber_no
        JOIN public.junction_closures jc ON s.jc_id = jc.id
        WHERE s.outgoing_cable_id IS NOT NULL AND p.segment_order < 50 -- Safety break
    )
    SELECT
        ROW_NUMBER() OVER (ORDER BY pt.segment_order, z.type_order) AS final_segment_order,
        z.path_type, z.element_id, z.element_name, z.details, z.fiber_no, z.distance_km, z.loss_db
    FROM path_traversal pt
    CROSS JOIN LATERAL (
        SELECT 1 AS type_order, 'CABLE'::TEXT, pt.current_cable_id, c.route_name, (sn.name || '  ' || en.name)::TEXT, pt.current_fiber_no,
               ABS(COALESCE((SELECT jc_next.position_km FROM junction_closures jc_next JOIN fiber_splices s_next ON jc_next.id = s_next.jc_id WHERE s_next.incoming_cable_id = pt.current_cable_id AND s_next.incoming_fiber_no = pt.current_fiber_no LIMIT 1), c.current_rkm) - pt.last_position_km) AS distance_km,
               NULL::NUMERIC
        FROM public.ofc_cables c JOIN public.nodes sn ON c.sn_id = sn.id JOIN public.nodes en ON c.en_id = en.id WHERE c.id = pt.current_cable_id
        UNION ALL
        SELECT 2 AS type_order, 'JC'::TEXT, s.jc_id, jc.name, 'Splice'::TEXT, s.outgoing_fiber_no, NULL::NUMERIC, s.loss_db
        FROM public.fiber_splices s JOIN public.junction_closures jc ON s.jc_id = jc.id
        WHERE s.incoming_cable_id = pt.current_cable_id AND s.incoming_fiber_no = pt.current_fiber_no
    ) AS z
    WHERE z.element_id IS NOT NULL ORDER BY final_segment_order;
END;
$$;
GRANT EXECUTE ON FUNCTION public.trace_fiber_path(UUID, INT) TO authenticated;


```

<!-- path: data/migrations/99_finalization/01_cross_module_constraints.sql -->
```sql
-- Path: migrations/99_finalization/01_cross_module_constraints.sql
-- Description: Adds all cross-module foreign key constraints after all tables have been created.
-- This script is essential for maintaining referential integrity between different domains.

-- =================================================================
-- Constraint Set 1: Linking Core Infrastructure to Network Systems
-- =================================================================

-- Add the foreign key from ofc_connections (Module 02) to systems (Module 03).
-- This links a physical fiber connection to the network equipment it terminates on.
ALTER TABLE public.ofc_connections
ADD CONSTRAINT fk_ofc_connections_system
FOREIGN KEY (system_id)
REFERENCES public.systems(id)
ON DELETE SET NULL;


-- =================================================================
-- Constraint Set 2: Linking Core Infrastructure to Advanced OFC
-- =================================================================

-- Add the foreign key from ofc_connections (Module 02) to logical_fiber_paths (Module 04).
-- This assigns a physical fiber to a logical end-to-end path.
ALTER TABLE public.ofc_connections
ADD CONSTRAINT fk_ofc_connections_logical_path
FOREIGN KEY (logical_path_id)
REFERENCES public.logical_fiber_paths(id)
ON DELETE SET NULL;


-- =================================================================
-- Constraint Set 3: Linking Network Systems to Advanced OFC
-- =================================================================

-- Add foreign keys from logical_fiber_paths (Module 04) to systems (Module 03).
-- This defines the start and end systems for a logical path.
ALTER TABLE public.logical_fiber_paths
ADD CONSTRAINT fk_lfp_source_system
FOREIGN KEY (source_system_id)
REFERENCES public.systems(id)
ON DELETE SET NULL;

ALTER TABLE public.logical_fiber_paths
ADD CONSTRAINT fk_lfp_destination_system
FOREIGN KEY (destination_system_id)
REFERENCES public.systems(id)
ON DELETE SET NULL;
```

<!-- path: data/migrations/00_setup/01_roles.sql -->
```sql
-- Path: migrations/00_setup/01_roles.sql
-- Description: Creates all custom database roles. Must be run first.

-- Create roles only if they don't exist
DO $$
BEGIN
    IF NOT EXISTS (SELECT FROM pg_roles WHERE rolname = 'admin') THEN
        CREATE ROLE admin NOINHERIT;
    END IF;

    IF NOT EXISTS (SELECT FROM pg_roles WHERE rolname = 'cpan_admin') THEN
        CREATE ROLE cpan_admin NOINHERIT;
    END IF;

    IF NOT EXISTS (SELECT FROM pg_roles WHERE rolname = 'maan_admin') THEN
        CREATE ROLE maan_admin NOINHERIT;
    END IF;

    IF NOT EXISTS (SELECT FROM pg_roles WHERE rolname = 'sdh_admin') THEN
        CREATE ROLE sdh_admin NOINHERIT;
    END IF;

    IF NOT EXISTS (SELECT FROM pg_roles WHERE rolname = 'vmux_admin') THEN
        CREATE ROLE vmux_admin NOINHERIT;
    END IF;

    IF NOT EXISTS (SELECT FROM pg_roles WHERE rolname = 'mng_admin') THEN
        CREATE ROLE mng_admin NOINHERIT;
    END IF;

    IF NOT EXISTS (SELECT FROM pg_roles WHERE rolname = 'viewer') THEN
        CREATE ROLE viewer NOINHERIT;
    END IF;
END
$$;

-- Safely grant membership to the 'authenticated' role for all custom roles.
-- This allows any logged-in user to assume one of these roles via JWT claims.
DO $$
DECLARE
    r TEXT;
BEGIN
    FOR r IN
        SELECT unnest(ARRAY['admin','cpan_admin','maan_admin','sdh_admin','vmux_admin','mng_admin','viewer'])
    LOOP
        IF NOT EXISTS (
            SELECT 1
            FROM pg_auth_members m
            JOIN pg_roles r1 ON r1.oid = m.roleid
            JOIN pg_roles r2 ON r2.oid = m.member
            WHERE r1.rolname = r
              AND r2.rolname = 'authenticated'
        ) THEN
            EXECUTE format('GRANT %I TO authenticated', r);
        END IF;
    END LOOP;
END
$$;
```

<!-- path: data/migrations/00_setup/02_function_stubs.sql -->
```sql
-- Path: migrations/00_setup/02_function_stubs.sql
-- Description: Creates dummy "stub" versions of functions that may be optionally defined later.
-- This prevents dependency errors if certain modules (like Auditing) are not deployed.

-- Stub for the user activity logging function.
-- The real version is in the 05_auditing module.
CREATE OR REPLACE FUNCTION public.log_user_activity(
    p_action_type TEXT,
    p_table_name TEXT DEFAULT NULL,
    p_record_id TEXT DEFAULT NULL,
    p_old_data JSONB DEFAULT NULL,
    p_new_data JSONB DEFAULT NULL,
    p_details TEXT DEFAULT NULL
)
RETURNS VOID
LANGUAGE plpgsql
AS $$
BEGIN
    -- This is a stub function. It does nothing.
    -- If the 05_auditing module is deployed, it will replace this function
    -- with the real implementation.
    RETURN;
END;
$$;
```

<!-- path: data/migrations/01_user_management/02_views.sql -->
```sql
-- Path: migrations/01_user_management/02_views.sql
-- Description: Defines views for the User Management module.

-- Extended view combining auth.users and public.user_profiles
CREATE OR REPLACE VIEW v_user_profiles_extended WITH (security_invoker = true) AS
SELECT
    u.id,
    u.email::text AS email,
    u.last_sign_in_at,
    u.created_at,
    u.is_super_admin,
    (u.email_confirmed_at IS NOT NULL) AS is_email_verified,
    p.first_name::text AS first_name,
    p.last_name::text AS last_name,
    p.avatar_url::text AS avatar_url,
    p.phone_number::text AS phone_number,
    p.date_of_birth,
    p.address,
    p.preferences,
    p.role::text AS role,
    p.designation::text AS designation,
    p.updated_at,
    p.status::text AS status,
    u.email_confirmed_at,
    u.phone_confirmed_at,
    (u.phone_confirmed_at IS NOT NULL) AS is_phone_verified,
    u.updated_at AS auth_updated_at,
    u.raw_user_meta_data,
    u.raw_app_meta_data,
    CONCAT(p.first_name::text, ' ', p.last_name::text) AS full_name,
    CASE
        WHEN p.status::text = 'active' AND u.email_confirmed_at IS NOT NULL THEN 'active_verified'
        WHEN p.status::text = 'active' AND u.email_confirmed_at IS NULL THEN 'active_unverified'
        WHEN p.status::text = 'inactive' THEN 'inactive'
        WHEN p.status::text = 'suspended' THEN 'suspended'
        ELSE 'unknown'
    END::text AS computed_status,
    EXTRACT(DAYS FROM (NOW() - u.created_at))::INTEGER AS account_age_days,
    CASE
        WHEN u.last_sign_in_at > NOW() - INTERVAL '1 day' THEN 'today'
        WHEN u.last_sign_in_at > NOW() - INTERVAL '7 days' THEN 'this_week'
        WHEN u.last_sign_in_at > NOW() - INTERVAL '30 days' THEN 'this_month'
        WHEN u.last_sign_in_at > NOW() - INTERVAL '90 days' THEN 'last_3_months'
        ELSE 'older'
    END::text AS last_activity_period
FROM auth.users u
JOIN public.user_profiles p ON u.id = p.id;
```

<!-- path: data/migrations/01_user_management/06_rls_and_grants.sql -->
```sql
-- Path: migrations/01_user_management/06_rls_and_grants.sql
-- Description: All RLS policies and Grants for the User Management module.

-- =================================================================
-- Section 1: Grants
-- =================================================================

-- Grants for utility functions
GRANT EXECUTE ON FUNCTION public.is_super_admin() TO authenticated;
GRANT EXECUTE ON FUNCTION public.get_my_role() TO authenticated;
GRANT EXECUTE ON FUNCTION public.get_my_user_details() TO authenticated;

-- Grants for admin functions
GRANT EXECUTE ON FUNCTION public.admin_get_all_users(text, text, text, timestamptz, timestamptz, integer, integer) TO authenticated;
GRANT EXECUTE ON FUNCTION public.admin_get_all_users_extended(text, text, text, text, timestamptz, timestamptz, integer, integer) TO authenticated;
GRANT EXECUTE ON FUNCTION public.admin_get_user_by_id(uuid) TO authenticated;
GRANT EXECUTE ON FUNCTION public.admin_update_user_profile(uuid, text, text, text, text, date, jsonb, jsonb, text, text, text) TO authenticated;
GRANT EXECUTE ON FUNCTION public.admin_bulk_update_status(uuid[], text) TO authenticated;
GRANT EXECUTE ON FUNCTION public.admin_bulk_update_role(uuid[], text) TO authenticated;
GRANT EXECUTE ON FUNCTION public.admin_bulk_delete_users(uuid[]) TO authenticated;

-- Grant Table Permissions
GRANT SELECT, INSERT, UPDATE, DELETE ON public.user_profiles TO admin;
GRANT SELECT ON public.user_profiles TO viewer;


-- =================================================================
-- Section 2: RLS Policies for user_profiles
-- =================================================================

-- Enable RLS on the table
ALTER TABLE public.user_profiles ENABLE ROW LEVEL SECURITY;

-- Drop existing policies for idempotency
DROP POLICY IF EXISTS "Super admins have full access to user_profiles" ON public.user_profiles;
DROP POLICY IF EXISTS "Users can view their own profile" ON public.user_profiles;
DROP POLICY IF EXISTS "Users can update their own profile" ON public.user_profiles;
DROP POLICY IF EXISTS "Users can insert their own profile" ON public.user_profiles;
DROP POLICY IF EXISTS "Users can delete their own profile" ON public.user_profiles;

-- Allow super admins full access to all rows
CREATE POLICY "Super admins have full access to user_profiles"
ON public.user_profiles
FOR ALL
USING (public.is_super_admin())
WITH CHECK (public.is_super_admin());

-- Allow users to read their own profile
CREATE POLICY "Users can view their own profile"
ON public.user_profiles
FOR SELECT
USING ((select auth.uid()) = id);

-- Allow users to update their own profile
CREATE POLICY "Users can update their own profile"
ON public.user_profiles
FOR UPDATE
USING ((select auth.uid()) = id)
WITH CHECK ((select auth.uid()) = id);

-- Allow users to insert their own profile
CREATE POLICY "Users can insert their own profile"
ON public.user_profiles
FOR INSERT
WITH CHECK ((select auth.uid()) = id);

-- Allow users to delete their own profile
CREATE POLICY "Users can delete their own profile"
ON public.user_profiles
FOR DELETE
USING ((select auth.uid()) = id);
```

<!-- path: data/migrations/01_user_management/05_triggers.sql -->
```sql
-- Path: migrations/01_user_management/05_triggers.sql
-- Description: Attaches triggers for the User Management module.

-- CREATE TRIGGER for new auth users to create a public profile
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_trigger WHERE tgname = 'on_auth_user_created') THEN
        CREATE TRIGGER on_auth_user_created
        AFTER INSERT ON auth.users
        FOR EACH ROW EXECUTE FUNCTION public.create_public_profile_for_new_user();
    END IF;
END $$;

-- CREATE TRIGGER for updating the 'updated_at' timestamp on profile updates
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_trigger WHERE tgname = 'update_user_profile_updated_at') THEN
        CREATE TRIGGER update_user_profile_updated_at
        BEFORE UPDATE ON public.user_profiles
        FOR EACH ROW EXECUTE FUNCTION public.update_user_profile_timestamp();
    END IF;
END $$;

-- CREATE TRIGGER for role sync to auth.users on profile UPDATE
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_trigger WHERE tgname = 'sync_user_role_trigger') THEN
        CREATE TRIGGER sync_user_role_trigger
        AFTER UPDATE ON public.user_profiles
        FOR EACH ROW
        WHEN (NEW.role IS DISTINCT FROM OLD.role)
        EXECUTE FUNCTION sync_user_role_to_auth();
    END IF;
END $$;

-- CREATE TRIGGER for role sync to auth.users on profile INSERT
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_trigger WHERE tgname = 'sync_user_role_insert_trigger') THEN
        CREATE TRIGGER sync_user_role_insert_trigger
        AFTER INSERT ON public.user_profiles
        FOR EACH ROW EXECUTE FUNCTION sync_user_role_to_auth();
    END IF;
END $$;
```

<!-- path: data/migrations/01_user_management/04_indexes.sql -->
```sql
-- Path: migrations/01_user_management/04_indexes.sql
-- Description: Indexes for user_profiles to improve performance.

-- Index for filtering users by their role
CREATE INDEX IF NOT EXISTS idx_user_profiles_role ON public.user_profiles (role);

-- Index for filtering users by their status (e.g., active, inactive)
CREATE INDEX IF NOT EXISTS idx_user_profiles_status ON public.user_profiles (status);

-- Composite index for efficient searching and sorting by user's full name
CREATE INDEX IF NOT EXISTS idx_user_profiles_last_name_first_name ON public.user_profiles (last_name, first_name);

-- Index on the creation timestamp to speed up date range filters
CREATE INDEX IF NOT EXISTS idx_user_profiles_created_at ON public.user_profiles (created_at);
```

<!-- path: data/migrations/01_user_management/01_tables_user_profiles.sql -->
```sql
-- Path: migrations/01_user_management/01_tables_user_profiles.sql
-- Description: Defines the user_profiles table, which extends auth.users.

CREATE TABLE IF NOT EXISTS public.user_profiles (
  id UUID NOT NULL PRIMARY KEY REFERENCES auth.users (id) ON DELETE CASCADE,
  first_name TEXT NOT NULL CHECK (first_name <> ''),
  last_name TEXT NOT NULL CHECK (last_name <> ''),
  avatar_url TEXT,
  phone_number TEXT CHECK (
    phone_number IS NULL
    OR phone_number ~ '^\+?[1-9]\d{1,14}$'
  ),
  date_of_birth DATE CHECK (
    date_of_birth IS NULL
    OR (
      date_of_birth > '1900-01-01'
      AND date_of_birth < CURRENT_DATE
    )
  ),
  role TEXT DEFAULT 'viewer' CHECK (
    role IN (
      'admin',
      'viewer',
      'cpan_admin',
      'maan_admin',
      'sdh_admin',
      'vmux_admin',
      'mng_admin'
    )
  ),
  designation TEXT,
  address JSONB DEFAULT '{}'::jsonb,
  preferences JSONB DEFAULT '{}'::jsonb,
  status TEXT DEFAULT 'inactive' CHECK (status IN ('active', 'inactive', 'suspended')),
  created_at TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP,
  updated_at TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP
);
```

<!-- path: data/migrations/01_user_management/03_functions.sql -->
```sql
-- Path: migrations/01_user_management/03_functions.sql
-- Description: All functions for the User Management module.

-- =================================================================
-- Section 1: Utility Functions
-- =================================================================

-- SUPER ADMIN CHECK FUNCTION
CREATE OR REPLACE FUNCTION public.is_super_admin()
RETURNS boolean
LANGUAGE sql
SECURITY DEFINER
SET search_path = ''
STABLE
AS $$
SELECT EXISTS (
    SELECT 1
    FROM auth.users
    WHERE id = auth.uid()
      AND is_super_admin = true
  );
$$;

-- GET MY ROLE FUNCTION
CREATE OR REPLACE FUNCTION public.get_my_role()
RETURNS text
LANGUAGE sql
STABLE
SECURITY DEFINER
SET search_path = ''
AS $$
SELECT role
FROM auth.users
WHERE id = auth.uid();
$$;

-- USER DETAILS FUNCTION
CREATE OR REPLACE FUNCTION public.get_my_user_details()
RETURNS TABLE (
    id uuid,
    email text,
    last_sign_in_at timestamptz,
    created_at timestamptz,
    is_super_admin boolean,
    is_email_verified boolean,
    first_name text,
    last_name text,
    avatar_url text,
    phone_number text,
    date_of_birth date,
    address jsonb,
    preferences jsonb,
    role text,
    designation text,
    updated_at timestamptz
)
LANGUAGE sql
SECURITY DEFINER
SET search_path = ''
AS $$
SELECT
    u.id,
    u.email,
    u.last_sign_in_at,
    u.created_at,
    u.is_super_admin,
    (u.email_confirmed_at IS NOT NULL) AS is_email_verified,
    p.first_name,
    p.last_name,
    p.avatar_url,
    p.phone_number,
    p.date_of_birth,
    p.address,
    p.preferences,
    p.role,
    p.designation,
    p.updated_at
FROM auth.users AS u
LEFT JOIN public.user_profiles AS p ON u.id = p.id
WHERE u.id = auth.uid();
$$;


-- =================================================================
-- Section 2: Admin RPC Functions
-- =================================================================

-- Function to get all users (admin only)
CREATE OR REPLACE FUNCTION public.admin_get_all_users (
    search_query TEXT DEFAULT NULL,
    filter_role TEXT DEFAULT NULL,
    filter_status TEXT DEFAULT NULL,
    date_from TIMESTAMPTZ DEFAULT NULL,
    date_to TIMESTAMPTZ DEFAULT NULL,
    page_offset INTEGER DEFAULT 0,
    page_limit INTEGER DEFAULT 50
) RETURNS TABLE (
    id uuid,
    email text,
    first_name text,
    last_name text,
    avatar_url text,
    phone_number text,
    date_of_birth date,
    address jsonb,
    preferences jsonb,
    role text,
    designation text,
    status text,
    is_email_verified boolean,
    last_sign_in_at timestamptz,
    created_at timestamptz,
    updated_at timestamptz,
    total_count bigint
) LANGUAGE plpgsql SECURITY DEFINER
SET search_path = ''
AS $$
DECLARE
    total_records bigint;
BEGIN
    IF NOT public.is_super_admin() THEN
        RAISE EXCEPTION 'Access denied. Super admin privileges required.';
    END IF;

    SELECT COUNT(*) INTO total_records
    FROM public.user_profiles p
    WHERE (search_query IS NULL OR p.first_name ILIKE '%' || search_query || '%' OR p.last_name ILIKE '%' || search_query || '%')
    AND (filter_role IS NULL OR filter_role = 'all' OR p.role = filter_role)
    AND (filter_status IS NULL OR filter_status = 'all' OR p.status = filter_status)
    AND (date_from IS NULL OR p.created_at >= date_from)
    AND (date_to IS NULL OR p.created_at <= date_to);

    RETURN QUERY
    SELECT
        p.id,
        CAST(u.email AS text) as email,
        p.first_name,
        p.last_name,
        p.avatar_url,
        p.phone_number,
        p.date_of_birth,
        p.address,
        p.preferences,
        p.role,
        p.designation,
        p.status,
        (u.email_confirmed_at IS NOT NULL) as is_email_verified,
        u.last_sign_in_at,
        p.created_at,
        p.updated_at,
        total_records
    FROM public.user_profiles p
    LEFT JOIN auth.users u ON p.id = u.id
    WHERE (search_query IS NULL OR p.first_name ILIKE '%' || search_query || '%' OR p.last_name ILIKE '%' || search_query || '%')
    AND (filter_role IS NULL OR filter_role = 'all' OR p.role = filter_role)
    AND (filter_status IS NULL OR filter_status = 'all' OR p.status = filter_status)
    AND (date_from IS NULL OR p.created_at >= date_from)
    AND (date_to IS NULL OR p.created_at <= date_to)
    ORDER BY p.created_at DESC
    OFFSET page_offset
    LIMIT page_limit;
END;
$$;

-- Enhanced admin function that leverages the view structure
CREATE OR REPLACE FUNCTION public.admin_get_all_users_extended(
    search_query TEXT DEFAULT NULL,
    filter_role TEXT DEFAULT NULL,
    filter_status TEXT DEFAULT NULL,
    filter_activity TEXT DEFAULT NULL,
    date_from TIMESTAMPTZ DEFAULT NULL,
    date_to TIMESTAMPTZ DEFAULT NULL,
    page_offset INTEGER DEFAULT 0,
    page_limit INTEGER DEFAULT 50
) RETURNS TABLE (
    id uuid, email text, last_sign_in_at timestamptz, created_at timestamptz, is_super_admin boolean, is_email_verified boolean,
    first_name text, last_name text, avatar_url text, phone_number text, date_of_birth date, address jsonb, preferences jsonb,
    role text, designation text, updated_at timestamptz, status text, full_name text, computed_status text, account_age_days integer,
    last_activity_period text, total_count bigint, active_count bigint, inactive_count bigint
)
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public, auth
AS $$
DECLARE
    -- Declare variables to hold all three counts
    v_total_records bigint;
    v_active_count bigint;
    v_inactive_count bigint;
BEGIN
    -- Check if user is super admin
    IF NOT public.is_super_admin() THEN
        RAISE EXCEPTION 'Access denied. Super admin privileges required.';
    END IF;

    -- FIX: Calculate all three counts in a single, efficient query
    SELECT
        COUNT(*),
        COUNT(*) FILTER (WHERE v.status = 'active'),
        COUNT(*) FILTER (WHERE v.status = 'inactive') -- You can add more statuses if needed
    INTO
        v_total_records,
        v_active_count,
        v_inactive_count
    FROM v_user_profiles_extended v
    WHERE
        (search_query IS NULL OR v.full_name ILIKE '%' || search_query || '%' OR v.email ILIKE '%' || search_query || '%')
    AND (filter_role IS NULL OR filter_role = 'all' OR v.role = filter_role)
    AND (filter_status IS NULL OR filter_status = 'all' OR v.status = filter_status)
    AND (filter_activity IS NULL OR filter_activity = 'all' OR v.last_activity_period = filter_activity)
    AND (date_from IS NULL OR v.created_at >= date_from)
    AND (date_to IS NULL OR v.created_at <= date_to);

    -- Return paginated results using the calculated counts
    RETURN QUERY
    SELECT
        v.id, v.email, v.last_sign_in_at, v.created_at, v.is_super_admin, v.is_email_verified,
        v.first_name, v.last_name, v.avatar_url, v.phone_number, v.date_of_birth, v.address,
        v.preferences, v.role, v.designation, v.updated_at, v.status, v.full_name,
        v.computed_status, v.account_age_days, v.last_activity_period,
        -- FIX: Use the variables calculated above instead of trying to select from the view
        v_total_records,
        v_active_count,
        v_inactive_count
    FROM public.v_user_profiles_extended v
    WHERE
        (search_query IS NULL OR v.full_name ILIKE '%' || search_query || '%' OR v.email ILIKE '%' || search_query || '%')
    AND (filter_role IS NULL OR filter_role = 'all' OR v.role = filter_role)
    AND (filter_status IS NULL OR filter_status = 'all' OR v.status = filter_status)
    AND (filter_activity IS NULL OR filter_activity = 'all' OR v.last_activity_period = filter_activity)
    AND (date_from IS NULL OR v.created_at >= date_from)
    AND (date_to IS NULL OR v.created_at <= date_to)
    ORDER BY v.created_at DESC
    OFFSET page_offset
    LIMIT page_limit;
END;
$$;


-- Function to get a single user by ID (admin only)
CREATE OR REPLACE FUNCTION public.admin_get_user_by_id ( user_id uuid )
RETURNS TABLE (
    id uuid, email text, first_name text, last_name text, avatar_url text, phone_number text, date_of_birth date, address jsonb,
    preferences jsonb, role text, designation text, status text, is_email_verified boolean, last_sign_in_at timestamptz,
    created_at timestamptz, updated_at timestamptz
) LANGUAGE plpgsql SECURITY DEFINER SET search_path = '' AS $$
BEGIN
    IF NOT (public.is_super_admin() OR auth.uid() = user_id) THEN
        RAISE EXCEPTION 'Access denied. Insufficient privileges.';
    END IF;
    RETURN QUERY
    SELECT p.id, CAST(u.email AS text) as email, p.first_name, p.last_name, p.avatar_url, p.phone_number, p.date_of_birth, p.address,
           p.preferences, p.role, p.designation, p.status, (u.email_confirmed_at IS NOT NULL) as is_email_verified, u.last_sign_in_at,
           p.created_at, p.updated_at
    FROM public.user_profiles p
    LEFT JOIN auth.users u ON p.id = u.id
    WHERE p.id = user_id;
END;
$$;

-- Function to update user profile (admin only)
CREATE OR REPLACE FUNCTION public.admin_update_user_profile (
    user_id uuid, update_first_name text DEFAULT NULL, update_last_name text DEFAULT NULL, update_avatar_url text DEFAULT NULL,
    update_phone_number text DEFAULT NULL, update_date_of_birth date DEFAULT NULL, update_address jsonb DEFAULT NULL,
    update_preferences jsonb DEFAULT NULL, update_role text DEFAULT NULL, update_designation text DEFAULT NULL, update_status text DEFAULT NULL
) RETURNS boolean LANGUAGE plpgsql SECURITY DEFINER SET search_path = '' AS $$
BEGIN
    IF NOT (public.is_super_admin() OR auth.uid() = user_id) THEN
        RAISE EXCEPTION 'Access denied. Insufficient privileges.';
    END IF;
    UPDATE public.user_profiles
    SET first_name = COALESCE(update_first_name, first_name),
        last_name = COALESCE(update_last_name, last_name),
        avatar_url = CASE WHEN update_avatar_url = '' THEN NULL ELSE COALESCE(update_avatar_url, avatar_url) END,
        phone_number = CASE WHEN update_phone_number = '' THEN NULL ELSE COALESCE(update_phone_number, phone_number) END,
        date_of_birth = COALESCE(update_date_of_birth, date_of_birth),
        address = COALESCE(update_address, address),
        preferences = COALESCE(update_preferences, preferences),
        role = COALESCE(update_role, role),
        designation = COALESCE(update_designation, designation),
        status = COALESCE(update_status, status),
        updated_at = NOW()
    WHERE id = user_id;
    RETURN FOUND;
END;
$$;

-- Function to bulk update user status (admin only)
CREATE OR REPLACE FUNCTION public.admin_bulk_update_status ( user_ids uuid[], new_status text )
RETURNS boolean LANGUAGE plpgsql SECURITY DEFINER SET search_path = '' AS $$
BEGIN
    IF NOT public.is_super_admin() THEN RAISE EXCEPTION 'Access denied. Super admin privileges required.'; END IF;
    IF new_status NOT IN ('active', 'inactive', 'suspended') THEN RAISE EXCEPTION 'Invalid status. Must be active, inactive, or suspended.'; END IF;
    UPDATE public.user_profiles SET status = new_status, updated_at = NOW() WHERE id = ANY(user_ids);
    PERFORM public.log_user_activity('BULK_UPDATE_STATUS', 'user_profiles', NULL, jsonb_build_object('user_ids', user_ids), jsonb_build_object('new_status', new_status), 'Bulk status update performed by admin');
    RETURN FOUND;
END;
$$;

-- Function to bulk update user role (admin only)
CREATE OR REPLACE FUNCTION public.admin_bulk_update_role ( user_ids uuid[], new_role text )
RETURNS boolean LANGUAGE plpgsql SECURITY DEFINER SET search_path = '' AS $$
BEGIN
    IF NOT public.is_super_admin() THEN RAISE EXCEPTION 'Access denied. Super admin privileges required.'; END IF;
    IF new_role NOT IN ('admin', 'viewer', 'cpan_admin', 'maan_admin', 'sdh_admin', 'vmux_admin', 'mng_admin') THEN RAISE EXCEPTION 'Invalid role.'; END IF;
    UPDATE public.user_profiles SET role = new_role, updated_at = NOW() WHERE id = ANY(user_ids);
    PERFORM public.log_user_activity('BULK_UPDATE_ROLE', 'user_profiles', NULL, jsonb_build_object('user_ids', user_ids), jsonb_build_object('new_role', new_role), 'Bulk role update performed by admin');
    RETURN FOUND;
END;
$$;

-- Function to bulk delete users (admin only)
CREATE OR REPLACE FUNCTION public.admin_bulk_delete_users ( user_ids uuid[] )
RETURNS boolean LANGUAGE plpgsql SECURITY DEFINER SET search_path = '' AS $$
BEGIN
    IF NOT public.is_super_admin() THEN RAISE EXCEPTION 'Access denied. Super admin privileges required.'; END IF;
    PERFORM public.log_user_activity('BULK_DELETE', 'user_profiles', NULL, jsonb_build_object('user_ids', user_ids), NULL, 'Bulk user deletion performed by admin');
    DELETE FROM public.user_profiles WHERE id = ANY(user_ids);
    RETURN FOUND;
END;
$$;


-- =================================================================
-- Section 3: Trigger Functions
-- =================================================================

-- TRIGGER FUNCTION for updating timestamps
CREATE OR REPLACE FUNCTION public.update_user_profile_timestamp()
RETURNS TRIGGER LANGUAGE plpgsql SET search_path = '' AS $$
BEGIN
    NEW.updated_at = NOW();
    RETURN NEW;
END;
$$;

-- Function that will sync the role to auth.users
CREATE OR REPLACE FUNCTION public.sync_user_role_to_auth()
RETURNS TRIGGER LANGUAGE plpgsql SECURITY DEFINER SET search_path = '' AS $$
BEGIN
    IF (TG_OP = 'INSERT' OR (TG_OP = 'UPDATE' AND NEW.role IS DISTINCT FROM OLD.role)) AND NEW.role IS NOT NULL THEN
        UPDATE auth.users SET role = NEW.role WHERE id = NEW.id;
    END IF;
    RETURN NEW;
END;
$$;

-- USER CREATION FUNCTION
CREATE OR REPLACE FUNCTION public.create_public_profile_for_new_user()
RETURNS TRIGGER LANGUAGE plpgsql SECURITY DEFINER SET search_path = '' AS $$
BEGIN
    IF NOT EXISTS (SELECT 1 FROM public.user_profiles WHERE id = NEW.id) THEN
        INSERT INTO public.user_profiles (id, first_name, last_name, avatar_url, phone_number, date_of_birth, address, preferences, status)
        VALUES (
            NEW.id,
            COALESCE(NEW.raw_user_meta_data->>'first_name', NEW.raw_user_meta_data->>'name', (SELECT initcap(word) FROM regexp_split_to_table(split_part(NEW.email, '@', 1), '[^a-zA-Z]+') AS word WHERE word ~ '^[a-zA-Z]+' LIMIT 1), 'Placeholder'),
            COALESCE(NEW.raw_user_meta_data->>'last_name', SPLIT_PART(NEW.raw_user_meta_data->>'name', ' ', 2), 'User'),
            NEW.raw_user_meta_data->>'avatar_url',
            NEW.raw_user_meta_data->>'phone_number',
            CASE WHEN NEW.raw_user_meta_data->>'date_of_birth' ~ '^\d{4}-\d{2}-\d{2}$' THEN (NEW.raw_user_meta_data->>'date_of_birth')::date ELSE NULL END,
            COALESCE(NEW.raw_user_meta_data->'address', '{}'::jsonb),
            COALESCE(NEW.raw_user_meta_data->'preferences', '{}'::jsonb),
            'active'
        );
    END IF;
    RETURN NEW;
END;
$$;
```

<!-- path: data/migrations/02_core_infrastructure/06_rls_and_grants.sql -->
```sql
-- Path: migrations/02_core_infrastructure/06_rls_and_grants.sql
-- Description: Applies a baseline set of RLS policies and grants to core tables.

DO $$
DECLARE
  tbl TEXT;
  admin_role TEXT := 'admin';
  viewer_role TEXT := 'viewer';
BEGIN
  -- This list includes all tables in this module that follow the simple admin/viewer security model.
  FOREACH tbl IN ARRAY ARRAY[
    'lookup_types', 'maintenance_areas', 'rings',
    'employee_designations', 'employees', 'nodes',
    'ofc_cables', 'ofc_connections',
    'folders', 'files'
  ]
  LOOP
    -- Step 1: Enable Row-Level Security
    EXECUTE format('ALTER TABLE public.%I ENABLE ROW LEVEL SECURITY;', tbl);

    -- Step 2: Set Table-Level Grants
    EXECUTE format('GRANT SELECT, INSERT, UPDATE, DELETE ON public.%I TO %I;', tbl, admin_role);
    EXECUTE format('GRANT SELECT ON public.%I TO %I;', tbl, viewer_role);

    -- Step 3: Create Row-Level Security Policies (idempotent)
    EXECUTE format('DROP POLICY IF EXISTS "policy_admin_all_%s" ON public.%I;', tbl, tbl);
    EXECUTE format('DROP POLICY IF EXISTS "policy_viewer_select_%s" ON public.%I;', tbl, tbl);

    -- Admin Policy: Full access for the 'admin' role or a super_admin user.
    EXECUTE format($p$
      CREATE POLICY "policy_admin_all_%s" ON public.%I
      FOR ALL TO %I
      USING (is_super_admin() OR public.get_my_role() = %L)
      WITH CHECK (is_super_admin() OR public.get_my_role() = %L);
    $p$, tbl, tbl, admin_role, admin_role, admin_role);

    -- Viewer Policy: Read-only access for the 'viewer' role.
    EXECUTE format($p$
      CREATE POLICY "policy_viewer_select_%s" ON public.%I
      FOR SELECT TO %I
      USING (public.get_my_role() = %L);
    $p$, tbl, tbl, viewer_role, viewer_role);

    RAISE NOTICE 'Applied baseline admin/viewer RLS policies to %', tbl;
  END LOOP;
END;
$$;


-- =================================================================
-- Section 2: SELECT Grants and Policies for Specific Admin Roles
-- =================================================================

-- START OF FIX --
-- This entire section is now wrapped in DO blocks to allow for procedural logic.
DO $$
BEGIN
  -- First, grant the basic ability to SELECT from these tables to the specific roles.
  -- These GRANTs are now executed dynamically.
  EXECUTE 'GRANT SELECT ON public.nodes TO cpan_admin, maan_admin, sdh_admin, vmux_admin, mng_admin;';
  EXECUTE 'GRANT SELECT ON public.maintenance_areas TO cpan_admin, maan_admin, sdh_admin, vmux_admin, mng_admin;';
  EXECUTE 'GRANT SELECT ON public.lookup_types TO cpan_admin, maan_admin, sdh_admin, vmux_admin, mng_admin;';
  EXECUTE 'GRANT SELECT ON public.ofc_cables TO cpan_admin, maan_admin, sdh_admin, vmux_admin, mng_admin;';
  EXECUTE 'GRANT SELECT ON public.ofc_connections TO cpan_admin, maan_admin, sdh_admin, vmux_admin, mng_admin;';

  RAISE NOTICE 'Granted SELECT on core tables to specific admin roles.';
END;
$$;
-- END OF FIX --


DO $$
DECLARE
  tbl TEXT;
BEGIN
  -- Second, add a policy that allows these roles to see the data.
  FOREACH tbl IN ARRAY ARRAY['nodes', 'maintenance_areas', 'lookup_types', 'ofc_cables', 'ofc_connections']
  LOOP
    EXECUTE format('DROP POLICY IF EXISTS "policy_system_admins_select_%s" ON public.%I;', tbl, tbl);

    EXECUTE format($p$
      CREATE POLICY "policy_system_admins_select_%s" ON public.%I
      FOR SELECT TO cpan_admin, maan_admin, sdh_admin, vmux_admin, mng_admin
      USING (
        get_my_role() IN ('cpan_admin', 'maan_admin', 'sdh_admin', 'vmux_admin', 'mng_admin')
      );
    $p$, tbl, tbl);

    RAISE NOTICE 'Applied system-admin SELECT RLS policy to %', tbl;
  END LOOP;
END;
$$;

-- =================================================================
-- Section 3: View-Level Grants [NEW AND CRITICAL FIX]
-- =================================================================
-- Grants SELECT permission on the views defined in this module to the relevant roles.
-- This is separate from RLS on the underlying tables. A user needs both.

DO $$
BEGIN
  GRANT SELECT ON public.v_lookup_types_with_count TO admin, viewer;
  GRANT SELECT ON public.v_maintenance_areas_with_count TO admin, viewer;
  GRANT SELECT ON public.v_employee_designations_with_count TO admin, viewer;
  GRANT SELECT ON public.v_employees_with_count TO admin, viewer;
  GRANT SELECT ON public.v_rings_with_count TO admin, viewer;
  GRANT SELECT ON public.v_nodes_complete TO admin, viewer;
  GRANT SELECT ON public.v_ofc_cables_complete TO admin, viewer;

  RAISE NOTICE 'Applied SELECT grants on core infrastructure views.';
END;
$$;
```

<!-- path: data/migrations/02_core_infrastructure/03_views.sql -->
```sql
-- Path: migrations/02_core_infrastructure/03_views.sql
-- Description: Defines denormalized views for the Core Infrastructure module.

-- View for lookup_types with aggregate counts
CREATE OR REPLACE VIEW public.v_lookup_types_with_count WITH (security_invoker = true) AS
SELECT
  lt.*,
  count(*) OVER() AS total_count,
  sum(CASE WHEN lt.status = true THEN 1 ELSE 0 END) OVER() AS active_count,
  sum(CASE WHEN lt.status = false THEN 1 ELSE 0 END) OVER() AS inactive_count
FROM public.lookup_types lt;

-- View for maintenance_areas with joined data and aggregate counts
CREATE OR REPLACE VIEW public.v_maintenance_areas_with_count WITH (security_invoker = true) AS
SELECT
  ma.*,
  lt_ma.name AS maintenance_area_type_name,
  lt_ma.code AS maintenance_area_type_code,
  lt_ma.category AS maintenance_area_type_category,
  lt_ma.sort_order AS maintenance_area_type_sort_order,
  lt_ma.is_system_default AS maintenance_area_type_is_system_default,
  lt_ma.status AS maintenance_area_type_status,
  lt_ma.created_at AS maintenance_area_type_created_at,
  lt_ma.updated_at AS maintenance_area_type_updated_at,
  count(*) OVER() AS total_count,
  sum(CASE WHEN ma.status = true THEN 1 ELSE 0 END) OVER() AS active_count,
  sum(CASE WHEN ma.status = false THEN 1 ELSE 0 END) OVER() AS inactive_count
FROM public.maintenance_areas ma
LEFT JOIN public.lookup_types lt_ma ON ma.area_type_id = lt_ma.id;

-- View for employee_designations with aggregate counts
CREATE OR REPLACE VIEW public.v_employee_designations_with_count WITH (security_invoker = true) AS
SELECT
  ed.*,
  count(*) OVER() AS total_count,
  sum(CASE WHEN ed.status = true THEN 1 ELSE 0 END) OVER() AS active_count,
  sum(CASE WHEN ed.status = false THEN 1 ELSE 0 END) OVER() AS inactive_count
FROM public.employee_designations ed;

-- View for employees with joined data and aggregate counts
CREATE OR REPLACE VIEW public.v_employees_with_count WITH (security_invoker = true) AS
SELECT
  e.*,
  ed.name AS employee_designation_name,
  count(*) OVER() AS total_count,
  sum(CASE WHEN e.status = true THEN 1 ELSE 0 END) OVER() AS active_count,
  sum(CASE WHEN e.status = false THEN 1 ELSE 0 END) OVER() AS inactive_count
FROM public.employees e
LEFT JOIN public.employee_designations ed ON e.employee_designation_id = ed.id;

-- View for rings with joined data and aggregate counts
CREATE OR REPLACE VIEW public.v_rings_with_count WITH (security_invoker = true) AS
SELECT
  r.*,
  lt_ring.name AS ring_type_name,
  lt_ring.code AS ring_type_code,
  lt_ring.category AS ring_type_category,
  lt_ring.sort_order AS ring_type_sort_order,
  lt_ring.is_system_default AS ring_type_is_system_default,
  lt_ring.status AS ring_type_status,
  lt_ring.created_at AS ring_type_created_at,
  lt_ring.updated_at AS ring_type_updated_at,
  ma.name AS maintenance_area_name,
  ma.code AS maintenance_area_code,
  ma.email AS maintenance_area_email,
  ma.contact_person AS maintenance_area_contact_person,
  ma.contact_number AS maintenance_area_contact_number,
  ma.latitude AS maintenance_area_latitude,
  ma.longitude AS maintenance_area_longitude,
  ma.area_type_id AS maintenance_area_area_type_id,
  ma.parent_id AS maintenance_area_parent_id,
  ma.status AS maintenance_area_status,
  ma.created_at AS maintenance_area_created_at,
  ma.updated_at AS maintenance_area_updated_at,
  count(*) OVER() AS total_count,
  sum(CASE WHEN r.status = true THEN 1 ELSE 0 END) OVER() AS active_count,
  sum(CASE WHEN r.status = false THEN 1 ELSE 0 END) OVER() AS inactive_count
FROM public.rings r
LEFT JOIN public.lookup_types lt_ring ON r.ring_type_id = lt_ring.id
LEFT JOIN public.maintenance_areas ma ON r.maintenance_terminal_id = ma.id;

-- View for nodes with joined data and aggregate counts
CREATE OR REPLACE VIEW public.v_nodes_complete WITH (security_invoker = true) AS
SELECT
  n.*,
  lt_node.name AS node_type_name,
  lt_node.code AS node_type_code,
  ma.name AS maintenance_area_name,
  ma.code AS maintenance_area_code,
  lt_ma.name AS maintenance_area_type_name,
  count(*) OVER() AS total_count,
  sum(CASE WHEN n.status = true THEN 1 ELSE 0 END) OVER() AS active_count,
  sum(CASE WHEN n.status = false THEN 1 ELSE 0 END) OVER() AS inactive_count
FROM public.nodes n
LEFT JOIN public.lookup_types lt_node ON n.node_type_id = lt_node.id
LEFT JOIN public.maintenance_areas ma ON n.maintenance_terminal_id = ma.id
LEFT JOIN public.lookup_types lt_ma ON ma.area_type_id = lt_ma.id;

-- View for ofc_cables with joined data and aggregate counts
CREATE OR REPLACE VIEW public.v_ofc_cables_complete WITH (security_invoker = true) AS
SELECT
  ofc.id,
  ofc.route_name,
  ofc.sn_id,
  ofc.en_id,
  sn.name AS sn_name,
  en.name AS en_name,
  ofc.capacity,
  ofc.ofc_type_id,
  lt_ofc.name AS ofc_type_name,
  lt_ofc.code AS ofc_type_code,
  ofc.ofc_owner_id,
  lt_ofc_owner.name AS ofc_owner_name,
  lt_ofc_owner.code AS ofc_owner_code,
  ofc.asset_no,
  ofc.transnet_id,
  ofc.transnet_rkm,
  ofc.current_rkm,
  ofc.maintenance_terminal_id,
  ma.name AS maintenance_area_name,
  ma.code AS maintenance_area_code,
  ofc.commissioned_on,
  ofc.status,
  ofc.remark,
  ofc.created_at,
  ofc.updated_at,
  count(*) OVER() AS total_count,
  sum(CASE WHEN ofc.status = true THEN 1 ELSE 0 END) OVER() AS active_count,
  sum(CASE WHEN ofc.status = false THEN 1 ELSE 0 END) OVER() AS inactive_count
FROM public.ofc_cables ofc
LEFT JOIN public.nodes sn ON ofc.sn_id = sn.id
LEFT JOIN public.nodes en ON ofc.en_id = en.id
LEFT JOIN public.lookup_types lt_ofc ON ofc.ofc_type_id = lt_ofc.id
LEFT JOIN public.lookup_types lt_ofc_owner ON ofc.ofc_owner_id = lt_ofc_owner.id
LEFT JOIN public.maintenance_areas ma ON ofc.maintenance_terminal_id = ma.id;
```

<!-- path: data/migrations/02_core_infrastructure/02_functions.sql -->
```sql
-- Path: migrations/02_core_infrastructure/02_functions.sql
-- Description: Contains helper and trigger functions for core tables.

-- Generic function to update the 'updated_at' column on any table.
CREATE OR REPLACE FUNCTION public.update_updated_at_column()
RETURNS TRIGGER
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public, pg_catalog
AS $$
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
$$;

-- Trigger function to update sn_dom (start node date of measurement) if OTDR distance changes significantly.
CREATE OR REPLACE FUNCTION public.update_sn_dom_on_otdr_change()
RETURNS TRIGGER
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public, pg_catalog
AS $$
BEGIN
  IF NEW.otdr_distance_sn_km IS DISTINCT FROM OLD.otdr_distance_sn_km THEN
    IF NEW.sn_dom IS NULL OR abs(coalesce(NEW.otdr_distance_sn_km, 0) - coalesce(OLD.otdr_distance_sn_km, 0)) > 0.05 THEN
      NEW.sn_dom := CURRENT_DATE;
    END IF;
  END IF;
  RETURN NEW;
END;
$$;

-- Trigger function to update en_dom (end node date of measurement) if OTDR distance changes significantly.
CREATE OR REPLACE FUNCTION public.update_en_dom_on_otdr_change()
RETURNS TRIGGER
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public, pg_catalog
AS $$
BEGIN
  IF NEW.otdr_distance_en_km IS DISTINCT FROM OLD.otdr_distance_en_km THEN
    IF NEW.en_dom IS NULL OR abs(coalesce(NEW.otdr_distance_en_km, 0) - coalesce(OLD.otdr_distance_en_km, 0)) > 0.05 THEN
      NEW.en_dom := CURRENT_DATE;
    END IF;
  END IF;
  RETURN NEW;
END;
$$;
```

<!-- path: data/migrations/02_core_infrastructure/05_triggers.sql -->
```sql
-- Path: migrations/02_core_infrastructure/05_triggers.sql
-- Description: Attaches all triggers for the Core Infrastructure module.

-- Apply the generic 'update_updated_at_column' trigger to all relevant tables.
CREATE OR REPLACE TRIGGER trigger_lookup_types_updated_at BEFORE UPDATE ON public.lookup_types FOR EACH ROW EXECUTE FUNCTION public.update_updated_at_column();
CREATE OR REPLACE TRIGGER trigger_maintenance_areas_updated_at BEFORE UPDATE ON public.maintenance_areas FOR EACH ROW EXECUTE FUNCTION public.update_updated_at_column();
CREATE OR REPLACE TRIGGER trigger_rings_updated_at BEFORE UPDATE ON public.rings FOR EACH ROW EXECUTE FUNCTION public.update_updated_at_column();
CREATE OR REPLACE TRIGGER trigger_employee_designations_updated_at BEFORE UPDATE ON public.employee_designations FOR EACH ROW EXECUTE FUNCTION public.update_updated_at_column();
CREATE OR REPLACE TRIGGER trigger_employees_updated_at BEFORE UPDATE ON public.employees FOR EACH ROW EXECUTE FUNCTION public.update_updated_at_column();
CREATE OR REPLACE TRIGGER trigger_nodes_updated_at BEFORE UPDATE ON public.nodes FOR EACH ROW EXECUTE FUNCTION public.update_updated_at_column();
CREATE OR REPLACE TRIGGER trigger_ofc_cables_updated_at BEFORE UPDATE ON public.ofc_cables FOR EACH ROW EXECUTE FUNCTION public.update_updated_at_column();
CREATE OR REPLACE TRIGGER trigger_ofc_connections_updated_at BEFORE UPDATE ON public.ofc_connections FOR EACH ROW EXECUTE FUNCTION public.update_updated_at_column();

-- Apply the specific DOM update triggers to the ofc_connections table.
CREATE OR REPLACE TRIGGER trigger_update_sn_dom_on_otdr_change BEFORE UPDATE ON public.ofc_connections FOR EACH ROW EXECUTE FUNCTION public.update_sn_dom_on_otdr_change();
CREATE OR REPLACE TRIGGER trigger_update_en_dom_on_otdr_change BEFORE UPDATE ON public.ofc_connections FOR EACH ROW EXECUTE FUNCTION public.update_en_dom_on_otdr_change();
```

<!-- path: data/migrations/02_core_infrastructure/04_indexes.sql -->
```sql
-- Path: migrations/02_core_infrastructure/04_indexes.sql
-- Description: Creates all B-tree and GIN (FTS) indexes for the Core module.

-- =================================================================
-- Section 1: Standard B-Tree Indexes
-- =================================================================

-- Indexes for lookup_types
CREATE INDEX IF NOT EXISTS idx_lookup_types_category ON public.lookup_types (category);
CREATE INDEX IF NOT EXISTS idx_lookup_types_name ON public.lookup_types (name);

-- Indexes for maintenance_areas
CREATE INDEX IF NOT EXISTS idx_maintenance_areas_parent_id ON public.maintenance_areas (parent_id);

-- Indexes for employee_designations
CREATE INDEX IF NOT EXISTS idx_employee_designations_parent_id ON public.employee_designations (parent_id);

-- Indexes for employees
CREATE INDEX IF NOT EXISTS idx_employees_employee_designation_id ON public.employees (employee_designation_id);
CREATE INDEX IF NOT EXISTS idx_employees_maintenance_terminal_id ON public.employees (maintenance_terminal_id);

-- Indexes for nodes
CREATE INDEX IF NOT EXISTS idx_nodes_type_id ON public.nodes (node_type_id);
CREATE INDEX IF NOT EXISTS idx_nodes_maintenance_area ON public.nodes (maintenance_terminal_id);
CREATE INDEX IF NOT EXISTS idx_nodes_coordinates ON public.nodes (latitude, longitude);
CREATE INDEX IF NOT EXISTS idx_nodes_status ON public.nodes (status);

-- Indexes for ofc_connections
CREATE INDEX IF NOT EXISTS idx_ofc_connections_ofc_id ON public.ofc_connections (ofc_id);
CREATE INDEX IF NOT EXISTS idx_ofc_connections_system_id ON public.ofc_connections (system_id);
CREATE INDEX IF NOT EXISTS idx_ofc_connections_logical_path_id ON public.ofc_connections (logical_path_id);

-- Indexes for files/folders
CREATE INDEX IF NOT EXISTS idx_folders_user_id ON public.folders USING btree (user_id);
CREATE INDEX IF NOT EXISTS idx_files_user_id ON public.files USING btree (user_id);
CREATE INDEX IF NOT EXISTS idx_files_folder_id ON public.files USING btree (folder_id);

-- =================================================================
-- Section 2: Full-Text Search (FTS) GIN Indexes
-- =================================================================

CREATE INDEX IF NOT EXISTS idx_employees_remark_fts ON public.employees USING gin(to_tsvector('english', remark));
CREATE INDEX IF NOT EXISTS idx_nodes_remark_fts ON public.nodes USING gin(to_tsvector('english', remark));
CREATE INDEX IF NOT EXISTS idx_ofc_cables_remark_fts ON public.ofc_cables USING gin(to_tsvector('english', remark));
CREATE INDEX IF NOT EXISTS idx_ofc_connections_remark_fts ON public.ofc_connections USING gin(to_tsvector('english', remark));
```

<!-- path: data/migrations/02_core_infrastructure/01_tables_core.sql -->
```sql
-- Path: migrations/02_core_infrastructure/01_tables_core.sql
-- Description: Defines all core infrastructure and master data tables.

-- Centralized Lookup Types Table
CREATE TABLE IF NOT EXISTS public.lookup_types (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  category TEXT NOT NULL,
  name TEXT NOT NULL,
  code TEXT,
  description TEXT,
  sort_order INTEGER DEFAULT 0,
  is_system_default BOOLEAN DEFAULT false,
  status BOOLEAN DEFAULT true,
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW(),
  CONSTRAINT uq_lookup_types_category_name UNIQUE (category, name),
  CONSTRAINT uq_lookup_types_category_code UNIQUE (category, code)
);

-- Maintenance Areas/Terminals Master Table
CREATE TABLE IF NOT EXISTS public.maintenance_areas (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  name TEXT NOT NULL,
  code TEXT UNIQUE,
  area_type_id UUID REFERENCES public.lookup_types (id),
  parent_id UUID REFERENCES public.maintenance_areas (id),
  contact_person TEXT,
  contact_number TEXT,
  email TEXT,
  latitude DECIMAL(10, 8),
  longitude DECIMAL(11, 8),
  address TEXT,
  status BOOLEAN DEFAULT true,
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Employee Designation Table
CREATE TABLE IF NOT EXISTS public.employee_designations (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  name TEXT NOT NULL UNIQUE,
  parent_id UUID REFERENCES public.employee_designations(id) ON DELETE SET NULL,
  status BOOLEAN DEFAULT true,
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Employee Master Table
CREATE TABLE IF NOT EXISTS public.employees (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  employee_name TEXT NOT NULL,
  employee_pers_no TEXT UNIQUE,
  employee_contact TEXT,
  employee_email TEXT,
  employee_dob DATE,
  employee_doj DATE,
  employee_designation_id UUID REFERENCES public.employee_designations (id),
  employee_addr TEXT,
  maintenance_terminal_id UUID REFERENCES public.maintenance_areas (id),
  remark TEXT,
  status BOOLEAN DEFAULT true,
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Ring Master Table
CREATE TABLE IF NOT EXISTS public.rings (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  name TEXT NOT NULL,
  ring_type_id UUID REFERENCES public.lookup_types (id),
  description TEXT,
  maintenance_terminal_id UUID REFERENCES public.maintenance_areas (id),
  total_nodes INTEGER DEFAULT 0,
  status BOOLEAN DEFAULT true,
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Node List (Physical Locations/Sites)
CREATE TABLE IF NOT EXISTS public.nodes (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  name TEXT NOT NULL,
  node_type_id UUID REFERENCES public.lookup_types (id),
  latitude DECIMAL(10, 8),
  longitude DECIMAL(11, 8),
  maintenance_terminal_id UUID REFERENCES public.maintenance_areas (id),
  remark TEXT,
  status BOOLEAN DEFAULT true,
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified OFC (Optical Fiber Cable) Table
CREATE TABLE IF NOT EXISTS public.ofc_cables (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  route_name TEXT NOT NULL,
  sn_id UUID REFERENCES public.nodes (id) NOT NULL,
  en_id UUID REFERENCES public.nodes (id) NOT NULL,
  ofc_type_id UUID REFERENCES public.lookup_types (id) NOT NULL,
  capacity INTEGER NOT NULL,
  ofc_owner_id UUID REFERENCES public.lookup_types (id) NOT NULL,
  current_rkm DECIMAL(10, 3),
  transnet_id TEXT,
  transnet_rkm DECIMAL(10, 3),
  asset_no TEXT,
  maintenance_terminal_id UUID REFERENCES public.maintenance_areas (id),
  commissioned_on DATE,
  remark TEXT,
  status BOOLEAN DEFAULT true,
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- OFC Connection Details (Fiber connections between nodes)
CREATE TABLE IF NOT EXISTS public.ofc_connections (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  ofc_id UUID REFERENCES public.ofc_cables (id) NOT NULL,
  fiber_no_sn INTEGER NOT NULL,
  fiber_no_en INTEGER NOT NULL,
  otdr_distance_sn_km DECIMAL(10, 3),
  sn_dom DATE,
  sn_power_dbm DECIMAL(10, 3),
  system_id UUID, -- NOTE: FK constraint to systems table is added in 99_finalization
  otdr_distance_en_km DECIMAL(10, 3),
  en_dom DATE,
  en_power_dbm DECIMAL(10, 3),
  route_loss_db DECIMAL(10, 3),
  logical_path_id UUID, -- NOTE: FK constraint to logical_fiber_paths is added in 99_finalization
  fiber_role TEXT CHECK (fiber_role IN ('working', 'protection')),
  path_segment_order INTEGER DEFAULT 1,
  source_port TEXT,
  destination_port TEXT,
  connection_category TEXT NOT NULL DEFAULT 'OFC_JOINT_TYPES',
  connection_type TEXT NOT NULL DEFAULT 'straight',
  CONSTRAINT fk_connection_type FOREIGN KEY (connection_category, connection_type)
    REFERENCES public.lookup_types(category, name),
  remark TEXT,
  status BOOLEAN DEFAULT true,
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Folders table for file management
CREATE TABLE IF NOT EXISTS public.folders (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID NOT NULL REFERENCES auth.users (id),
  name TEXT NOT NULL,
  created_at TIMESTAMPTZ DEFAULT NOW()
);

-- Files table for file management
CREATE TABLE IF NOT EXISTS public.files (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID NOT NULL REFERENCES auth.users (id),
  folder_id UUID REFERENCES public.folders (id),
  file_name TEXT NOT NULL,
  file_type TEXT NOT NULL,
  file_size TEXT NOT NULL,
  file_route TEXT NOT NULL,
  file_url TEXT NOT NULL,
  uploaded_at TIMESTAMPTZ DEFAULT NOW()
);
```

<!-- path: data/migrations/04_advanced_ofc/02_views.sql -->
```sql
-- Path: migrations/04_advanced_ofc/02_views.sql
-- Description: Defines views for analyzing OFC paths and utilization.

-- View showing complete information for a junction closure.
CREATE OR REPLACE VIEW public.v_junction_closures_complete WITH (security_invoker = true) AS
SELECT
  jc.id,
  jc.node_id,
  jc.ofc_cable_id,
  jc.position_km,
  n.name,
  n.latitude,
  n.longitude
FROM public.junction_closures jc
JOIN public.nodes n ON jc.node_id = n.id;

CREATE OR REPLACE VIEW public.v_cable_segments_at_jc WITH (security_invoker = true) AS
-- Normalize START endpoint: expose jc_id as the node_id of the matched junction_closure
SELECT
  cs.id,
  cs.original_cable_id,
  cs.segment_order,
  cs.fiber_count,
  cs.start_node_id,
  cs.end_node_id,
  cs.start_node_type,
  cs.end_node_type,
  cs.created_at,
  cs.updated_at,
  jcs.node_id AS jc_id,
  'start'::text AS jc_position
FROM public.cable_segments cs
JOIN public.junction_closures jcs
  ON cs.start_node_type = 'jc'
 AND (
       jcs.id = cs.start_node_id  -- proper schema
    OR jcs.node_id = cs.start_node_id -- legacy data stored node_id in start_node_id
     )
UNION ALL
-- Normalize END endpoint: expose jc_id as the node_id of the matched junction_closure
SELECT
  cs.id,
  cs.original_cable_id,
  cs.segment_order,
  cs.fiber_count,
  cs.start_node_id,
  cs.end_node_id,
  cs.start_node_type,
  cs.end_node_type,
  cs.created_at,
  cs.updated_at,
  jce.node_id AS jc_id,
  'end'::text AS jc_position
FROM public.cable_segments cs
JOIN public.junction_closures jce
  ON cs.end_node_type = 'jc'
 AND (
       jce.id = cs.end_node_id    -- proper schema
    OR jce.node_id = cs.end_node_id -- legacy data stored node_id in end_node_id
     );


-- View showing end-to-end logical path summaries.
CREATE OR REPLACE VIEW public.v_end_to_end_paths WITH (security_invoker = true) AS
SELECT
  lfp.id AS path_id,
  lfp.path_name,
  lfp.source_system_id,
  lfp.destination_system_id,
  lfp.total_distance_km,
  lfp.total_loss_db,
  lt_status.name AS operational_status,
  COUNT(lps.id) AS segment_count,
  STRING_AGG(DISTINCT oc.route_name, ' -> ' ORDER BY oc.route_name) AS route_names
FROM public.logical_fiber_paths lfp
LEFT JOIN public.lookup_types lt_status ON lfp.operational_status_id = lt_status.id
LEFT JOIN public.logical_path_segments lps ON lfp.id = lps.logical_path_id
LEFT JOIN public.ofc_cables oc ON lps.ofc_cable_id = oc.id
GROUP BY
  lfp.id,
  lt_status.name;


-- View showing detailed segments for a given logical path.
CREATE OR REPLACE VIEW public.v_system_ring_paths_detailed WITH (security_invoker = true) AS
SELECT
  srp.id,
  srp.logical_path_id,
  lp.path_name,
  lp.source_system_id,
  srp.ofc_cable_id,
  srp.path_order,
  oc.route_name,
  oc.sn_id AS start_node_id,
  sn.name AS start_node_name,
  oc.en_id AS end_node_id,
  en.name AS end_node_name,
  srp.created_at
FROM public.logical_path_segments srp
JOIN public.logical_fiber_paths lp ON srp.logical_path_id = lp.id
JOIN public.ofc_cables oc ON srp.ofc_cable_id = oc.id
LEFT JOIN public.nodes sn ON oc.sn_id = sn.id
LEFT JOIN public.nodes en ON oc.en_id = en.id
ORDER BY
  srp.logical_path_id,
  srp.path_order;


-- View for calculating fiber utilization per cable.
CREATE OR REPLACE VIEW public.v_cable_utilization WITH (security_invoker = true) AS
SELECT
  oc.id AS cable_id,
  oc.route_name,
  oc.capacity,
  COUNT(lfp.id) FILTER (WHERE lt_status.name = 'active' AND conn.fiber_role = 'working') AS used_fibers,
  (oc.capacity - COUNT(conn.id)) AS available_fibers,
  ROUND(
    (COUNT(lfp.id) FILTER (WHERE lt_status.name = 'active' AND conn.fiber_role = 'working')::DECIMAL / NULLIF(oc.capacity, 0)) * 100, 2
  ) AS utilization_percent
FROM public.ofc_cables oc
LEFT JOIN public.ofc_connections conn ON oc.id = conn.ofc_id
LEFT JOIN public.logical_fiber_paths lfp ON conn.logical_path_id = lfp.id
LEFT JOIN public.lookup_types lt_status ON lfp.operational_status_id = lt_status.id
GROUP BY
  oc.id, oc.route_name, oc.capacity;
```

<!-- path: data/migrations/04_advanced_ofc/03_indexes.sql -->
```sql
-- Path: migrations/04_advanced_ofc/03_indexes.sql
-- Description: Creates indexes for the Advanced OFC module tables.

CREATE INDEX IF NOT EXISTS idx_fiber_joints_node_id ON public.fiber_joints (node_id);
CREATE INDEX IF NOT EXISTS idx_logical_fiber_paths_source_system_id ON public.logical_fiber_paths (source_system_id);
CREATE INDEX IF NOT EXISTS idx_logical_path_segments_path_id ON public.logical_path_segments(logical_path_id);
```

<!-- path: data/migrations/04_advanced_ofc/04_triggers.sql -->
```sql
-- Path: migrations/04_advanced_ofc/04_triggers.sql
-- Description: Attaches 'updated_at' triggers and cable segmentation triggers for the Advanced OFC module.



CREATE OR REPLACE TRIGGER trigger_joint_chambers_updated_at BEFORE UPDATE ON public.joint_chambers FOR EACH ROW EXECUTE FUNCTION public.update_updated_at_column();
CREATE OR REPLACE TRIGGER trigger_fiber_joints_updated_at BEFORE UPDATE ON public.fiber_joints FOR EACH ROW EXECUTE FUNCTION public.update_updated_at_column();
CREATE OR REPLACE TRIGGER trigger_logical_fiber_paths_updated_at BEFORE UPDATE ON public.logical_fiber_paths FOR EACH ROW EXECUTE FUNCTION public.update_updated_at_column();
CREATE OR REPLACE TRIGGER trigger_logical_path_segments_updated_at BEFORE UPDATE ON public.logical_path_segments FOR EACH ROW EXECUTE FUNCTION public.update_updated_at_column();
CREATE OR REPLACE TRIGGER trigger_fiber_splices_updated_at BEFORE UPDATE ON public.fiber_splices FOR EACH ROW EXECUTE FUNCTION public.update_updated_at_column();
```

<!-- path: data/migrations/04_advanced_ofc/01_tables_advanced_ofc.sql -->
```sql
-- Path: migrations/04_advanced_ofc/01_tables_advanced_ofc.sql
-- Description: Defines tables for advanced OFC path and splice management.

-- Represents a physical junction closure (splice box) along an OFC route.
CREATE TABLE IF NOT EXISTS public.junction_closures (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  node_id UUID NOT NULL REFERENCES public.nodes(id) ON DELETE CASCADE,
  ofc_cable_id UUID NOT NULL REFERENCES public.ofc_cables(id) ON DELETE CASCADE,
  position_km NUMERIC(10,3),
  created_at TIMESTAMPTZ DEFAULT now(),
  updated_at TIMESTAMPTZ DEFAULT now()
);
COMMENT ON TABLE public.junction_closures IS 'Physical junction closures (splice boxes) along OFC routes.';
COMMENT ON COLUMN public.junction_closures.ofc_cable_id IS 'The primary OFC cable this JC is physically located on.';
COMMENT ON COLUMN public.junction_closures.position_km IS 'The distance in kilometers from the start node of the ofc_cable.';

-- Cable segments created when JCs are added to cables
CREATE TABLE IF NOT EXISTS public.cable_segments (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  original_cable_id UUID NOT NULL REFERENCES public.ofc_cables(id) ON DELETE CASCADE,
  segment_order INTEGER NOT NULL,
  start_node_id UUID NOT NULL,
  end_node_id UUID NOT NULL,
  start_node_type TEXT NOT NULL CHECK (start_node_type IN ('node', 'jc')),
  end_node_type TEXT NOT NULL CHECK (end_node_type IN ('node', 'jc')),
  distance_km DECIMAL(10,3) NOT NULL,
  fiber_count INTEGER NOT NULL,
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW(),
  UNIQUE (original_cable_id, segment_order)
);
COMMENT ON TABLE public.cable_segments IS 'Cable segments created when junction closures are added to cables.';
COMMENT ON COLUMN public.cable_segments.start_node_type IS 'Whether the start point is a node or junction closure.';
COMMENT ON COLUMN public.cable_segments.end_node_type IS 'Whether the end point is a node or junction closure.';

-- Represents the logical end-to-end path for a service or connection.
CREATE TABLE IF NOT EXISTS public.logical_fiber_paths (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  path_name TEXT,
  working_path_id UUID REFERENCES public.logical_fiber_paths(id) ON DELETE SET NULL,
  path_role TEXT NOT NULL DEFAULT 'working' CHECK (path_role IN ('working', 'protection')),
  path_type_id UUID REFERENCES public.lookup_types(id) ON DELETE SET NULL,
  source_system_id UUID, -- NOTE: FK added in 99_finalization
  destination_system_id UUID, -- NOTE: FK added in 99_finalization
  operational_status_id UUID REFERENCES public.lookup_types(id) ON DELETE SET NULL,
  source_port TEXT,
  destination_port TEXT,
  total_distance_km DECIMAL(10, 3),
  total_loss_db DECIMAL(10, 3),
  service_type TEXT,
  bandwidth_gbps INTEGER,
  wavelength_nm INTEGER,
  commissioned_date DATE,
  remark TEXT,
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Tracks every single fiber connection (splice) inside a Junction Closure.
CREATE TABLE IF NOT EXISTS public.fiber_splices (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    jc_id UUID NOT NULL REFERENCES public.junction_closures(id) ON DELETE CASCADE,
    incoming_cable_id UUID NOT NULL REFERENCES public.ofc_cables(id) ON DELETE CASCADE,
    incoming_fiber_no INT NOT NULL,
    outgoing_cable_id UUID REFERENCES public.ofc_cables(id) ON DELETE CASCADE,
    outgoing_fiber_no INT,
    splice_type TEXT NOT NULL DEFAULT 'pass_through' CHECK (splice_type IN ('pass_through', 'branch', 'termination')),
    status TEXT NOT NULL DEFAULT 'active' CHECK (status IN ('active', 'faulty', 'reserved')),
    logical_path_id UUID REFERENCES public.logical_fiber_paths(id) ON DELETE SET NULL,
    loss_db NUMERIC(5, 2),
    otdr_length_km NUMERIC(10, 3),
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ,
    CONSTRAINT unique_incoming_fiber_in_jc UNIQUE (jc_id, incoming_cable_id, incoming_fiber_no),
    CONSTRAINT unique_outgoing_fiber_in_jc UNIQUE (jc_id, outgoing_cable_id, outgoing_fiber_no),
    CONSTRAINT check_no_self_splice CHECK (incoming_cable_id <> outgoing_cable_id OR incoming_fiber_no <> outgoing_fiber_no)
);
COMMENT ON TABLE public.fiber_splices IS 'Tracks individual fiber connections (splices) within a junction closure.';
COMMENT ON COLUMN public.fiber_splices.splice_type IS 'Type of splice: pass_through, branch, or termination (if outgoing is NULL).';
COMMENT ON COLUMN public.fiber_splices.otdr_length_km IS 'The measured OTDR distance in kilometers for the incoming fiber arriving at this splice.';

-- -- Represents abstract fiber joints not tied to a specific cable's distance.
-- CREATE TABLE IF NOT EXISTS public.fiber_joints (
--   id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
--   joint_name TEXT NOT NULL,
--   joint_category TEXT NOT NULL DEFAULT 'OFC_JOINT_TYPES',
--   joint_type TEXT NOT NULL DEFAULT 'straight',
--   CONSTRAINT fk_joint_type FOREIGN KEY (joint_category, joint_type) REFERENCES public.lookup_types(category, name),
--   location_description TEXT,
--   latitude DECIMAL(10, 8),
--   longitude DECIMAL(11, 8),
--   node_id UUID REFERENCES public.nodes (id),
--   maintenance_area_id UUID REFERENCES public.maintenance_areas (id),
--   installed_date DATE,
--   remark TEXT,
--   status BOOLEAN DEFAULT true,
--   created_at TIMESTAMPTZ DEFAULT NOW(),
--   updated_at TIMESTAMPTZ DEFAULT NOW()
-- );



-- -- Links a logical path to its physical segments (cables or joints).
-- CREATE TABLE IF NOT EXISTS public.logical_path_segments (
--   id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
--   logical_path_id UUID NOT NULL REFERENCES public.logical_fiber_paths(id) ON DELETE CASCADE,
--   ofc_cable_id UUID REFERENCES public.ofc_cables(id),
--   fiber_joint_id UUID REFERENCES public.fiber_joints(id),
--   path_order INT NOT NULL,
--   created_at TIMESTAMPTZ DEFAULT NOW(),
--   CHECK ((ofc_cable_id IS NOT NULL AND fiber_joint_id IS NULL) OR (ofc_cable_id IS NULL AND fiber_joint_id IS NOT NULL)),
--   UNIQUE (logical_path_id, path_order)
-- );


```

<!-- path: data/migrations/04_advanced_ofc/06_functions.sql -->
```sql
-- Path: migrations/04_advanced_ofc/06_functions.sql
-- Description: Database functions for cable segmentation and fiber path management

-- Function to add a junction closure
CREATE OR REPLACE FUNCTION public.add_junction_closure(
  p_ofc_cable_id UUID,         -- the fiber cable this JC belongs to
  p_position_km DECIMAL(10,3), -- the position along the cable
  p_node_id UUID               -- existing node ID to reference (not create new node)
)
RETURNS TABLE (                -- what the function will return
  id UUID,
  node_id UUID,
  ofc_cable_id UUID,
  position_km DECIMAL(10,3),
  created_at TIMESTAMPTZ
)
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public, pg_catalog
AS $$
DECLARE
  v_jc_id UUID;
BEGIN
  -- Validate that the node exists
  IF NOT EXISTS (SELECT 1 FROM nodes WHERE nodes.id = p_node_id) THEN
    RAISE EXCEPTION 'Node with ID % does not exist', p_node_id;
  END IF;

  -- Validate that the cable exists
  IF NOT EXISTS (SELECT 1 FROM ofc_cables WHERE ofc_cables.id = p_ofc_cable_id) THEN
    RAISE EXCEPTION 'Cable with ID % does not exist', p_ofc_cable_id;
  END IF;

  -- Create the junction closure record (references existing node)
  INSERT INTO junction_closures (
    node_id,
    ofc_cable_id,
    position_km,
    created_at
  ) VALUES (
    p_node_id,
    p_ofc_cable_id,
    p_position_km,
    NOW()
  )
  RETURNING junction_closures.id INTO v_jc_id;

  -- Return the created junction closure
  RETURN QUERY
  SELECT
    created_jc.id,
    created_jc.node_id,
    created_jc.ofc_cable_id,
    created_jc.position_km,
    created_jc.created_at
  FROM junction_closures created_jc
  WHERE created_jc.id = v_jc_id;
END;
$$;

-- Function to create cable segments when a JC is added
CREATE OR REPLACE FUNCTION public.create_cable_segments_on_jc_add(
  p_jc_id UUID,
  p_ofc_cable_id UUID
)
RETURNS TABLE (
  segment_id UUID,
  segment_order INTEGER,
  start_node_id UUID,
  end_node_id UUID,
  distance_km DECIMAL(10,3),
  fiber_count INTEGER
)
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public, pg_catalog
AS $$
DECLARE
  v_jc_record RECORD;
  v_cable_record RECORD;
  v_existing_segments INTEGER;
  v_segment_order INTEGER := 1;
  v_start_distance DECIMAL(10,3) := 0;
  v_end_distance DECIMAL(10,3);
  v_jc_count INTEGER;
BEGIN
  -- Debug logging
  RAISE NOTICE 'Creating cable segments for JC: % on cable: %', p_jc_id, p_ofc_cable_id;

  -- Get JC information
  SELECT jc_info.* INTO v_jc_record
  FROM junction_closures jc_info
  WHERE jc_info.id = p_jc_id;

  -- Get cable information
  SELECT oc.* INTO v_cable_record
  FROM ofc_cables oc
  WHERE oc.id = p_ofc_cable_id;

  IF NOT FOUND THEN
    RAISE EXCEPTION 'JC or cable not found. JC: %, Cable: %', p_jc_id, p_ofc_cable_id;
  END IF;

  RAISE NOTICE 'Found JC: % at position %, Cable: % from % to %',
    v_jc_record.id, v_jc_record.position_km,
    v_cable_record.id, v_cable_record.sn_id, v_cable_record.en_id;

  -- Check if segments already exist for this cable
  SELECT COUNT(*) INTO v_existing_segments
  FROM cable_segments cs
  WHERE cs.original_cable_id = p_ofc_cable_id;

  -- If segments exist, we need to handle this differently
  -- For now, let's allow adding more JCs but we need to rebuild segments
  IF v_existing_segments > 0 THEN
    -- Delete existing segments and recreate them
    DELETE FROM cable_segments WHERE original_cable_id = p_ofc_cable_id;
    RAISE NOTICE 'Deleted % existing segments, recreating all segments', v_existing_segments;
  END IF;

  RAISE NOTICE 'Creating segments for cable with % JCs', v_existing_segments;

  -- Get all junction closures for this cable, ordered by position
  -- Also include the cable start and end nodes
  CREATE TEMP TABLE temp_jc_positions AS
  SELECT
    'start'::TEXT as node_type,
    v_cable_record.sn_id as node_id,
    0::DECIMAL(10,3) as position_km
  UNION ALL
  SELECT
    'jc'::TEXT as node_type,
    cable_jc.node_id as node_id,  -- Fixed: use node_id instead of id
    cable_jc.position_km
  FROM junction_closures cable_jc
  WHERE cable_jc.ofc_cable_id = p_ofc_cable_id
  UNION ALL
  SELECT
    'end'::TEXT as node_type,
    v_cable_record.en_id as node_id,
    v_cable_record.current_rkm as position_km;

  -- Debug: Check what nodes we have
  RAISE NOTICE 'Nodes for cable %: %',
    p_ofc_cable_id,
    (SELECT string_agg(node_type || ':' || node_id::text || '@' || position_km::text, ', ' ORDER BY position_km)
     FROM temp_jc_positions);

  -- Create segments between consecutive nodes
  INSERT INTO cable_segments (
    original_cable_id,
    segment_order,
    start_node_id,
    end_node_id,
    start_node_type,
    end_node_type,
    distance_km,
    fiber_count,
    created_at
  )
  SELECT
    p_ofc_cable_id,
    ROW_NUMBER() OVER (ORDER BY t.position_km),
    prev_node.node_id,
    t.node_id,
    CASE prev_node.node_type
      WHEN 'start' THEN 'node'
      WHEN 'jc' THEN 'jc'
      ELSE 'node'
    END,
    CASE t.node_type
      WHEN 'end' THEN 'node'
      WHEN 'jc' THEN 'jc'
      ELSE 'node'
    END,
    t.position_km - prev_node.position_km,
    v_cable_record.capacity,
    NOW()
  FROM temp_jc_positions t
  JOIN LATERAL (
    SELECT t2.node_id, t2.node_type, t2.position_km
    FROM temp_jc_positions t2
    WHERE t2.position_km < t.position_km
    ORDER BY t2.position_km DESC
    LIMIT 1
  ) prev_node ON true
  WHERE t.node_type != 'start';

  -- Clean up temp table
  DROP TABLE temp_jc_positions;

  -- Return the created segments
  RETURN QUERY
  SELECT
    cs.id,
    cs.segment_order,
    cs.start_node_id,
    cs.end_node_id,
    cs.distance_km,
    cs.fiber_count
  FROM cable_segments cs
  WHERE cs.original_cable_id = p_ofc_cable_id
  ORDER BY cs.segment_order;

  -- Log the number of segments created
  GET DIAGNOSTICS v_segment_order = ROW_COUNT;
  RAISE NOTICE 'Created % segments for cable %', v_segment_order, p_ofc_cable_id;
END;
$$;

-- Function to create initial fiber connections for a cable segment
CREATE OR REPLACE FUNCTION public.create_initial_fiber_connections(
  p_segment_id UUID
)
RETURNS INTEGER
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public, pg_catalog
AS $$
DECLARE
  v_segment_record RECORD;
  v_fiber_count INTEGER;
  v_connection_count INTEGER := 0;
  v_fiber_no INTEGER;
BEGIN
  -- Get segment information
  SELECT cs.* INTO v_segment_record
  FROM cable_segments cs
  WHERE cs.id = p_segment_id;

  IF NOT FOUND THEN
    RAISE EXCEPTION 'Segment not found';
  END IF;

  v_fiber_count := v_segment_record.fiber_count;

  -- Create fiber connections for each fiber in the segment
  FOR v_fiber_no IN 1..v_fiber_count LOOP
    INSERT INTO ofc_connections (
      ofc_id,
      fiber_no_sn,
      fiber_no_en,
      connection_category,
      connection_type,
      created_at
    ) VALUES (
      v_segment_record.original_cable_id,
      v_fiber_no,
      v_fiber_no,
      'OFC_JOINT_TYPES',
      'straight',
      NOW()
    );

    v_connection_count := v_connection_count + 1;
  END LOOP;

  RETURN v_connection_count;
END;
$$;

-- Function to update fiber connections when splicing occurs
CREATE OR REPLACE FUNCTION public.update_fiber_connections_on_splice(
  p_jc_id UUID,
  p_incoming_segment_id UUID,
  p_outgoing_segment_id UUID,
  p_splice_config JSONB
)
RETURNS INTEGER
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public, pg_catalog
AS $$
DECLARE
  v_splice_record JSONB;
  v_updated_count INTEGER := 0;
BEGIN
  -- Process each splice in the configuration
  FOR v_splice_record IN
    SELECT jsonb_array_elements(p_splice_config)
  LOOP
    -- Update the fiber connections based on splice configuration
    UPDATE ofc_connections
    SET
      fiber_no_en = (v_splice_record->>'outgoing_fiber_no')::INTEGER,
      connection_type = COALESCE(v_splice_record->>'splice_type', 'straight'),
      updated_at = NOW()
    WHERE
      ofc_connections.ofc_id = (SELECT cs.original_cable_id FROM cable_segments cs WHERE cs.id = p_incoming_segment_id)
      AND ofc_connections.fiber_no_sn = (v_splice_record->>'incoming_fiber_no')::INTEGER;

    v_updated_count := v_updated_count + 1;
  END LOOP;

  RETURN v_updated_count;
END;
$$;

-- Function to get fiber path from start to end node
CREATE OR REPLACE FUNCTION public.get_fiber_path(
  p_start_node_id UUID,
  p_end_node_id UUID,
  p_fiber_number INTEGER
)
RETURNS TABLE (
  segment_id UUID,
  segment_order INTEGER,
  start_node_id UUID,
  end_node_id UUID,
  fiber_no_sn INTEGER,
  fiber_no_en INTEGER,
  connection_type TEXT,
  distance_km DECIMAL(10,3)
)
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public, pg_catalog
AS $$
BEGIN
  RETURN QUERY
  WITH RECURSIVE fiber_path AS (
    -- Start with segments connected to the start node
    SELECT
      cs.id as segment_id,
      cs.segment_order,
      cs.start_node_id,
      cs.end_node_id,
      oc.fiber_no_sn,
      oc.fiber_no_en,
      oc.connection_type,
      cs.distance_km,
      1 as path_level
    FROM cable_segments cs
    JOIN ofc_connections oc ON oc.ofc_id = cs.original_cable_id
    WHERE cs.start_node_id = p_start_node_id
      AND oc.fiber_no_sn = p_fiber_number

    UNION ALL

    -- Recursively find next segments through JCs
    SELECT
      cs2.id as segment_id,
      cs2.segment_order,
      cs2.start_node_id,
      cs2.end_node_id,
      oc2.fiber_no_sn,
      oc2.fiber_no_en,
      oc2.connection_type,
      cs2.distance_km,
      fp.path_level + 1
    FROM fiber_path fp
    JOIN cable_segments cs ON cs.id = fp.segment_id
    JOIN junction_closures fiber_jc ON fiber_jc.node_id = cs.end_node_id  -- Fixed: use node_id instead of id
    JOIN cable_segments cs2 ON cs2.start_node_id = fiber_jc.node_id
    JOIN ofc_connections oc2 ON oc2.ofc_id = cs2.original_cable_id
    WHERE cs.end_node_id = fiber_jc.node_id  -- Fixed: use node_id instead of id
      AND oc2.fiber_no_sn = fp.fiber_no_en
      AND fp.path_level < 10 -- Prevent infinite recursion
  )
  SELECT
    fp.segment_id,
    fp.segment_order,
    fp.start_node_id,
    fp.end_node_id,
    fp.fiber_no_sn,
    fp.fiber_no_en,
    fp.connection_type,
    fp.distance_km
  FROM fiber_path fp
  WHERE fp.end_node_id = p_end_node_id
  ORDER BY fp.path_level;
END;
$$;

-- Function to apply straight joint splicing
CREATE OR REPLACE FUNCTION public.apply_straight_joint_splicing(
  p_jc_id UUID,
  p_incoming_segment_id UUID,
  p_outgoing_segment_id UUID
)
RETURNS INTEGER
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public, pg_catalog
AS $$
DECLARE
  v_incoming_segment RECORD;
  v_outgoing_segment RECORD;
  v_fiber_count INTEGER;
  v_updated_count INTEGER := 0;
  v_fiber_no INTEGER;
BEGIN
  -- Get segment information
  SELECT cs.* INTO v_incoming_segment
  FROM cable_segments cs
  WHERE cs.id = p_incoming_segment_id;

  SELECT cs.* INTO v_outgoing_segment
  FROM cable_segments cs
  WHERE cs.id = p_outgoing_segment_id;

  IF NOT FOUND THEN
    RAISE EXCEPTION 'Segments not found';
  END IF;

  -- Ensure both segments belong to the same cable
  IF v_incoming_segment.original_cable_id != v_outgoing_segment.original_cable_id THEN
    RAISE EXCEPTION 'Segments must belong to the same cable';
  END IF;

  v_fiber_count := v_incoming_segment.fiber_count;

  -- For straight joint, fiber numbers remain the same
  FOR v_fiber_no IN 1..v_fiber_count LOOP
    -- Update or create fiber splice
    INSERT INTO fiber_splices (
      jc_id,
      incoming_cable_id,
      incoming_fiber_no,
      outgoing_cable_id,
      outgoing_fiber_no,
      splice_type,
      status,
      created_at
    ) VALUES (
      p_jc_id,
      v_incoming_segment.original_cable_id,
      v_fiber_no,
      v_outgoing_segment.original_cable_id,
      v_fiber_no,
      'pass_through',
      'active',
      NOW()
    )
    ON CONFLICT (jc_id, incoming_cable_id, incoming_fiber_no)
    DO UPDATE SET
      outgoing_fiber_no = EXCLUDED.outgoing_fiber_no,
      splice_type = EXCLUDED.splice_type,
      status = EXCLUDED.status,
      updated_at = NOW();

    v_updated_count := v_updated_count + 1;
  END LOOP;

  -- Update OFC connections to reflect straight splicing
  UPDATE ofc_connections
  SET
    connection_type = 'straight',
    updated_at = NOW()
  WHERE ofc_connections.ofc_id = v_incoming_segment.original_cable_id
    AND ofc_connections.fiber_no_sn <= v_fiber_count;

  RETURN v_updated_count;
END;
$$;

-- Function to apply cross joint splicing
CREATE OR REPLACE FUNCTION public.apply_cross_joint_splicing(
  p_jc_id UUID,
  p_incoming_segment_id UUID,
  p_outgoing_segment_id UUID,
  p_fiber_mapping JSONB
)
RETURNS INTEGER
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public, pg_catalog
AS $$
DECLARE
  v_mapping_record JSONB;
  v_incoming_segment RECORD;
  v_outgoing_segment RECORD;
  v_updated_count INTEGER := 0;
BEGIN
  -- Get segment information
  SELECT cs.* INTO v_incoming_segment
  FROM cable_segments cs
  WHERE cs.id = p_incoming_segment_id;

  SELECT cs.* INTO v_outgoing_segment
  FROM cable_segments cs
  WHERE cs.id = p_outgoing_segment_id;

  IF NOT FOUND THEN
    RAISE EXCEPTION 'Segments not found';
  END IF;

  -- Process each fiber mapping
  FOR v_mapping_record IN
    SELECT jsonb_array_elements(p_fiber_mapping)
  LOOP
    -- Create or update fiber splice
    INSERT INTO fiber_splices (
      jc_id,
      incoming_cable_id,
      incoming_fiber_no,
      outgoing_cable_id,
      outgoing_fiber_no,
      splice_type,
      status,
      created_at
    ) VALUES (
      p_jc_id,
      v_incoming_segment.original_cable_id,
      (v_mapping_record->>'incoming_fiber_no')::INTEGER,
      v_outgoing_segment.original_cable_id,
      (v_mapping_record->>'outgoing_fiber_no')::INTEGER,
      'branch',
      'active',
      NOW()
    )
    ON CONFLICT (jc_id, incoming_cable_id, incoming_fiber_no)
    DO UPDATE SET
      outgoing_fiber_no = EXCLUDED.outgoing_fiber_no,
      splice_type = EXCLUDED.splice_type,
      status = EXCLUDED.status,
      updated_at = NOW();

    v_updated_count := v_updated_count + 1;
  END LOOP;

  -- Update OFC connections to reflect cross splicing
  UPDATE ofc_connections
  SET
    connection_type = 'cross',
    fiber_no_en = CASE
      WHEN ofc_connections.fiber_no_sn = (p_fiber_mapping->0->>'incoming_fiber_no')::INTEGER
      THEN (p_fiber_mapping->0->>'outgoing_fiber_no')::INTEGER
      ELSE ofc_connections.fiber_no_en
    END,
    updated_at = NOW()
  WHERE ofc_connections.ofc_id = v_incoming_segment.original_cable_id;

  RETURN v_updated_count;
END;
$$;

-- Triggers
-- Trigger function to recreate cable segments when a JC is deleted
CREATE OR REPLACE FUNCTION public.trigger_recreate_cable_segments_on_jc_delete()
RETURNS TRIGGER
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public, pg_catalog
AS $$
DECLARE
  v_cable_record RECORD;
  v_existing_segments INTEGER;
  v_jc_id UUID;
  v_cable_id UUID;
BEGIN
  -- Extract values to avoid column ambiguity
  v_jc_id := OLD.id;
  v_cable_id := OLD.ofc_cable_id;

  -- Log the deletion
  RAISE NOTICE 'JC deleted: % from cable: %. Recreating cable segments.',
    v_jc_id, v_cable_id;

  -- Get cable information
  SELECT oc.* INTO v_cable_record
  FROM ofc_cables oc
  WHERE oc.id = v_cable_id;

  IF NOT FOUND THEN
    RAISE NOTICE 'Cable % not found, nothing to recreate', v_cable_id;
    RETURN OLD;
  END IF;

  -- Check if there are any remaining JCs on this cable
  SELECT COUNT(*) INTO v_existing_segments
  FROM junction_closures jc
  WHERE jc.ofc_cable_id = v_cable_id;

  -- If no JCs remain, delete all segments (cable becomes one segment from start to end)
  IF v_existing_segments = 0 THEN
    DELETE FROM cable_segments WHERE original_cable_id = v_cable_id;
    RAISE NOTICE 'No JCs remaining on cable %, deleted all segments', v_cable_id;
    RETURN OLD;
  END IF;

  -- If JCs remain, delete existing segments and recreate them
  DELETE FROM cable_segments WHERE original_cable_id = v_cable_id;
  RAISE NOTICE 'Deleted % existing segments, recreating segments for remaining % JCs',
    v_existing_segments, v_existing_segments;

  -- Get cable information and remaining JCs
  CREATE TEMP TABLE temp_remaining_jcs AS
  SELECT
    'start'::TEXT as node_type,
    v_cable_record.sn_id as node_id,
    0::DECIMAL(10,3) as position_km
  UNION ALL
  SELECT
    'jc'::TEXT as node_type,
    remaining_jc.node_id as node_id,  -- Fixed: use node_id instead of id
    remaining_jc.position_km
  FROM junction_closures remaining_jc
  WHERE remaining_jc.ofc_cable_id = v_cable_id
  UNION ALL
  SELECT
    'end'::TEXT as node_type,
    v_cable_record.en_id as node_id,
    v_cable_record.current_rkm as position_km;

  -- Create segments between consecutive nodes
  INSERT INTO cable_segments (
    original_cable_id,
    segment_order,
    start_node_id,
    end_node_id,
    start_node_type,
    end_node_type,
    distance_km,
    fiber_count,
    created_at
  )
  SELECT
    v_cable_id,
    ROW_NUMBER() OVER (ORDER BY t.position_km),
    prev_node.node_id,
    t.node_id,
    CASE prev_node.node_type
      WHEN 'start' THEN 'node'
      WHEN 'jc' THEN 'jc'
      ELSE 'node'
    END,
    CASE t.node_type
      WHEN 'end' THEN 'node'
      WHEN 'jc' THEN 'jc'
      ELSE 'node'
    END,
    t.position_km - prev_node.position_km,
    v_cable_record.capacity,
    NOW()
  FROM temp_remaining_jcs t
  JOIN LATERAL (
    SELECT t2.node_id, t2.node_type, t2.position_km
    FROM temp_remaining_jcs t2
    WHERE t2.position_km < t.position_km
    ORDER BY t2.position_km DESC
    LIMIT 1
  ) prev_node ON true
  WHERE t.node_type != 'start';

  -- Clean up temp table
  DROP TABLE temp_remaining_jcs;

  -- Log completion
  RAISE NOTICE 'Successfully recreated cable segments for cable % after JC deletion', v_cable_id;

  RETURN OLD;
END;
$$;

CREATE OR REPLACE FUNCTION public.trigger_create_cable_segments_on_jc()
RETURNS TRIGGER
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public, pg_catalog
AS $$
DECLARE
  v_jc_id UUID;
  v_cable_id UUID;
BEGIN
  -- Only create segments for new junction closures (INSERT), not updates
  IF TG_OP = 'INSERT' THEN
    -- Extract values to avoid column ambiguity
    v_jc_id := NEW.id;
    v_cable_id := NEW.ofc_cable_id;

    -- Call the function to create cable segments
    PERFORM public.create_cable_segments_on_jc_add(v_jc_id, v_cable_id);

    -- Log the operation
    RAISE NOTICE 'Automatically created cable segments for new JC: % on cable: %',
      v_jc_id, v_cable_id;
  END IF;

  RETURN NEW;
END;
$$;

-- Attach triggers
CREATE OR REPLACE TRIGGER trigger_junction_closures_updated_at
  BEFORE UPDATE ON public.junction_closures
  FOR EACH ROW
  EXECUTE FUNCTION public.update_updated_at_column();

-- Auto-create cable segments when a new JC is added
CREATE OR REPLACE TRIGGER trigger_junction_closures_create_segments
  AFTER INSERT ON public.junction_closures
  FOR EACH ROW
  EXECUTE FUNCTION public.trigger_create_cable_segments_on_jc();

-- Auto-recreate cable segments when a JC is deleted
CREATE OR REPLACE TRIGGER trigger_junction_closures_delete_segments
  AFTER DELETE ON public.junction_closures
  FOR EACH ROW
  EXECUTE FUNCTION public.trigger_recreate_cable_segments_on_jc_delete();
```

<!-- path: data/migrations/04_advanced_ofc/05_rls_and_grants.sql -->
```sql
-- Path: migrations/04_advanced_ofc/05_rls_and_grants.sql
-- Description: RLS policies and Grants for the Advanced OFC (Route Manager) module.

-- =================================================================
-- Step 1: Grant Table-Level Permissions to Roles
-- =================================================================

-- Admin gets full control over all tables.
GRANT ALL ON public.junction_closures TO admin;
GRANT ALL ON public.cable_segments TO admin;
GRANT ALL ON public.fiber_splices TO admin;
GRANT ALL ON public.fiber_joints TO admin;
GRANT ALL ON public.logical_fiber_paths TO admin;
GRANT ALL ON public.logical_path_segments TO admin;


-- Viewer gets read-only access to all tables and views.
GRANT SELECT ON public.junction_closures TO viewer;
GRANT SELECT ON public.cable_segments TO viewer;
GRANT SELECT ON public.fiber_splices TO viewer;
GRANT SELECT ON public.fiber_joints TO viewer;
GRANT SELECT ON public.logical_fiber_paths TO viewer;
GRANT SELECT ON public.logical_path_segments TO viewer;

-- View grants for this module's features
GRANT SELECT ON public.v_junction_closures_complete TO viewer, admin;
GRANT SELECT ON public.v_system_ring_paths_detailed TO viewer, admin;
GRANT SELECT ON public.v_cable_utilization TO viewer, admin;
GRANT SELECT ON public.v_end_to_end_paths TO viewer, admin;
GRANT SELECT ON public.v_cable_segments_at_node TO viewer, admin, authenticated;

-- Grant select on dependent tables from other modules for views to work
GRANT SELECT ON public.ofc_cables TO viewer, authenticated;
GRANT SELECT ON public.nodes TO viewer;
GRANT SELECT ON public.junction_closures TO authenticated;
GRANT SELECT ON public.v_cable_segments_at_node TO viewer, authenticated;
GRANT SELECT ON public.cable_segments TO authenticated;


-- =================================================================
-- Step 2: Apply RLS Policies to Tables
-- =================================================================
-- Note: A simplified admin/viewer policy is applied here.
-- More complex, row-specific logic would be added if, for example,
-- a 'maan_admin' could only see JCs in their maintenance area.

DO $$
DECLARE
  tbl TEXT;
BEGIN
  FOREACH tbl IN ARRAY ARRAY[
    'junction_closures', 'cable_segments', 'fiber_splices', 'fiber_joints',
    'logical_fiber_paths', 'logical_path_segments'
  ]
  LOOP
    -- Enable RLS
    EXECUTE format('ALTER TABLE public.%I ENABLE ROW LEVEL SECURITY;', tbl);

    -- Drop old policies
    EXECUTE format('DROP POLICY IF EXISTS "policy_admin_all_%s" ON public.%I;', tbl, tbl);
    EXECUTE format('DROP POLICY IF EXISTS "policy_viewer_select_%s" ON public.%I;', tbl, tbl);

    -- Admin Policy
    EXECUTE format($p$
      CREATE POLICY "policy_admin_all_%s" ON public.%I FOR ALL TO admin
      USING (is_super_admin() OR get_my_role() = 'admin')
      WITH CHECK (is_super_admin() OR get_my_role() = 'admin');
    $p$, tbl, tbl);

    -- Viewer Policy
    EXECUTE format($p$
      CREATE POLICY "policy_viewer_select_%s" ON public.%I FOR SELECT TO viewer
      USING (get_my_role() = 'viewer' OR is_super_admin() OR get_my_role() = 'admin');
    $p$, tbl, tbl);

  END LOOP;
END;
$$;

-- Additional policy: allow authenticated clients to read cable_segments (required for view with security_invoker)
DROP POLICY IF EXISTS policy_authenticated_select_cable_segments ON public.cable_segments;
CREATE POLICY policy_authenticated_select_cable_segments ON public.cable_segments
FOR SELECT
TO authenticated
USING (true);

-- Additional policy: allow authenticated clients to read junction_closures (required for view join)
DROP POLICY IF EXISTS policy_authenticated_select_junction_closures ON public.junction_closures;
CREATE POLICY policy_authenticated_select_junction_closures ON public.junction_closures
FOR SELECT
TO authenticated
USING (true);

-- =================================================================
-- Step 3: Grant EXECUTE on RPC Functions
-- =================================================================
-- This allows any logged-in user to CALL the function.
-- Security inside the function and RLS on tables will enforce permissions.

GRANT EXECUTE ON FUNCTION public.manage_splice(p_action TEXT, p_jc_id UUID, p_splice_id UUID, p_incoming_cable_id UUID, p_incoming_fiber_no INT, p_outgoing_cable_id UUID, p_outgoing_fiber_no INT, p_splice_type TEXT) TO authenticated;

-- =================================================================
-- Section 4: View-Level Grants
-- =================================================================
DO $$
BEGIN
  GRANT SELECT ON public.v_end_to_end_paths TO admin, viewer;
  GRANT SELECT ON public.v_system_ring_paths_detailed TO admin, viewer;
  GRANT SELECT ON public.v_cable_utilization TO admin, viewer;

  RAISE NOTICE 'Applied SELECT grants on advanced OFC views.';
END;
$$;
```

<!-- path: next.config.ts -->
```typescript
import type { NextConfig } from "next";

const nextConfig: NextConfig = {
  /* config options here */
  images: {
    qualities: [25, 50, 75, 90, 100],
    remotePatterns: [
      {
        protocol: 'https',
        hostname: 'lh3.googleusercontent.com',
      },
      {
        protocol: 'https',
        hostname: 'example.com',
      },
      {
        protocol: 'https',
        hostname: 'gravatar.com',
      },
      {
        protocol: 'https',
        hostname: 'res.cloudinary.com',
      },
      {
        protocol: 'https',
        hostname: 'images.unsplash.com',
      },
      {
        protocol: 'https',
        hostname: 'cdn.pixabay.com',
      },
    ],
  },
  turbopack: {
    root: __dirname, // explicitly set project root
  },
};

export default nextConfig;

```

<!-- path: schemas/advanced.ts -->
```typescript
import z from "zod";

// helpers are not needed for this schema anymore, but might be for others.
import { requiredStringToNumber, emptyStringToNumber } from './helpers';

export const logicalFiberPathSchema = z.object({
    id: z.uuid().optional(),
    path_name: z.string().min(1, "Path name is required."),
    path_type_id: z.uuid({ message: "Path type is required." }).nullable(),
    source_system_id: z.uuid(),
    destination_system_id: z.uuid().optional().nullable(),
    source_port: z.string().optional().nullable(),
    destination_port: z.string().optional().nullable(),
    operational_status_id: z.uuid({ message: "Operational status is required." }).nullable(),
    total_distance_km: z.number().optional().nullable(),
    remark: z.string().optional().nullable(),
  });

// THE DEFINITIVE FIX: Schema for Junction Closures
export const junctionClosureSchema = z.object({
  id: z.uuid().optional(),
  name: z.string().min(1, "JC name is required."),
  jc_type_id: z.string().uuid("Please select a valid JC type.").nullable(),
  
  // Inline preprocessing to ensure correct type inference for react-hook-form
  capacity: z.preprocess(
    (val) => (val === "" || val === null || val === undefined ? undefined : Number(val)),
    z.number("Capacity is required.").int().positive("Capacity must be a positive integer.")
  ),
  latitude: z.preprocess(
    (val) => (val === "" || val === null ? null : Number(val)),
    z.number().min(-90, "Invalid latitude.").max(90, "Invalid latitude.").nullable().optional()
  ),
  longitude: z.preprocess(
    (val) => (val === "" || val === null ? null : Number(val)),
    z.number().min(-180, "Invalid longitude.").max(180, "Invalid longitude.").nullable().optional()
  ),
  position_km: z.preprocess(
    (val) => (val === "" || val === null || val === undefined ? undefined : Number(val)),
    z.number("Position on route is required.").min(0, "Position must be a positive number.")
  ),
  
  // REMOVED: ofc_cable_id is contextual data, not form data.
  // It will be added back in the submit handler.

  created_at: z.coerce.date().optional(),
  updated_at: z.coerce.date().optional(),
});

// ... (fiberSpliceSchema remains the same)
export const fiberSpliceSchema = z.object({
    id: z.uuid().optional(),
    jc_id: z.string().uuid("Junction Closure is required."),
    incoming_cable_id: z.string().uuid("Incoming cable is required."),
    incoming_fiber_no: z.number().int().positive("Incoming fiber number is required."),
    outgoing_cable_id: z.string().uuid("Outgoing cable is required.").optional().nullable(),
    outgoing_fiber_no: z.number().int().positive("Outgoing fiber number is required.").optional().nullable(),
    splice_type: z.enum(['pass_through', 'branch', 'termination']).default('pass_through'),
    status: z.enum(['active', 'faulty', 'reserved']).default('active'),
    logical_path_id: z.string().uuid().optional().nullable(),
    loss_db: emptyStringToNumber.pipe(z.number().min(0)).nullable(),
    otdr_length_km: emptyStringToNumber.pipe(z.number().min(0)).nullable(),
    created_at: z.coerce.date().optional(),
    updated_at: z.coerce.date().optional(),
  }).refine(data => {
      if (data.splice_type !== 'termination') {
          return data.outgoing_cable_id && data.outgoing_fiber_no;
      }
      return true;
  }, {
      message: "Outgoing cable and fiber number are required for non-termination splices.",
      path: ["outgoing_cable_id"],
  });
```

<!-- path: schemas/helpers.ts -->
```typescript
import z from "zod";

export const ipv4Regex =
  /^((25[0-5]|(2[0-4]|1\d|[1-9]|)\d)\.){3}(25[0-5]|(2[0-4]|1\d|[1-9]|)\d)$/;
export const ipValidation = z
  .string()
  .regex(ipv4Regex, { message: "Invalid IPv4 address format." });

// 2. Create a preprocessor for OPTIONAL numbers.
export const emptyStringToNumber = z.preprocess(
  (val) => (val === "" || val === null ? null : Number(val)),
  z.number().optional().nullable()
);

// 3. Create a preprocessor for REQUIRED numbers.
export const requiredStringToNumber = z.preprocess((val) => {
  if (val === "" || val === null || val === undefined) return undefined;
  return Number(val); // ensure cast
}, z.number({ error: (issue) => (issue.input === undefined ? "This field is required" : "Not a number") }));

// A reusable schema for optional IP addresses that can be an empty string
export const optionalIpValidation = z.union([
  z.string().regex(ipv4Regex, { message: "Invalid IPv4 address format." }),
  z.string().length(0), // Allows empty string
])
.optional()
.nullable()
.transform(val => val === "" ? null : val); // Transform empty string to null for the database

//  Create a preprocessor for optional dates
export const optionalDate = z.preprocess(
  (val) => {
    if (val === "" || val === null || val === undefined) return undefined;
    return new Date(val as string);
  },
  z.date().optional().nullable()
);


export const requiredDate = z.preprocess(
  (val) => {
    if (val === "" || val === null || val === undefined) return undefined;
    return new Date(val as string);
  },
  z.date({
    error: (iss) => iss.input === undefined ? "This field is required" : "Not a valid date"
  })
);

export const optionalDateString = z.iso.datetime().nullable().optional();
```

<!-- path: schemas/system-specific.ts -->
```typescript
// =================================================================
// SYSTEM-SPECIFIC TABLES
// =================================================================

import z from "zod";

export const cpanSystemSchema = z.object({
  system_id: z.uuid(),
  ring_no: z.string().optional().nullable(),
  area: z.string().optional().nullable(),
});

export const maanSystemSchema = z.object({
  system_id: z.uuid(),
  ring_no: z.string().optional().nullable(),
  area: z.string().optional().nullable(),
});

export const sdhSystemSchema = z.object({
  system_id: z.uuid(),
  gne: z.string().optional().nullable(),
  make: z.string().optional().nullable(),
});

export const vmuxSystemSchema = z.object({
  system_id: z.uuid(),
  vm_id: z.string().optional().nullable(),
});

export const cpanConnectionSchema = z.object({
  system_connection_id: z.uuid(),
  sfp_port: z.string().optional().nullable(),
  sfp_type_id: z.uuid().optional().nullable(),
  sfp_capacity: z.string().optional().nullable(),
  sfp_serial_no: z.string().optional().nullable(),
  fiber_in: z.number().int().optional().nullable(),
  fiber_out: z.number().int().optional().nullable(),
  customer_name: z.string().optional().nullable(),
  bandwidth_allocated_mbps: z.number().int().optional().nullable(),
});

export const maanConnectionSchema = cpanConnectionSchema.extend({});

export const sdhConnectionSchema = z.object({
  system_connection_id: z.uuid(),
  stm_no: z.string().optional().nullable(),
  carrier: z.string().optional().nullable(),
  a_slot: z.string().optional().nullable(),
  a_customer: z.string().optional().nullable(),
  b_slot: z.string().optional().nullable(),
  b_customer: z.string().optional().nullable(),
});

export const vmuxConnectionSchema = z.object({
  system_connection_id: z.uuid(),
  subscriber: z.string().optional().nullable(),
  c_code: z.string().optional().nullable(),
  channel: z.string().optional().nullable(),
  tk: z.string().optional().nullable(),
});
```

<!-- path: schemas/masters.ts -->
```typescript
// =================================================================
// MASTER TABLES (Using the corrected helpers)
// =================================================================

import z from "zod";

export const lookupTypeSchema = z.object({
  id: z.uuid().optional(),
  category: z.string().min(1, { message: "Category is required." }),
  name: z.string().min(1, { message: "Name is required." }),
  code: z.string().optional().nullable(),
  description: z.string().optional().nullable(),
  sort_order: z.number().int().default(0).optional(),
  is_system_default: z.boolean().default(false).optional(),
  status: z.boolean().default(true).optional(),
  created_at: z.coerce.date().optional(),
  updated_at: z.coerce.date().optional(),
});

export const maintenanceAreaSchema = z.object({
  id: z.uuid().optional(),
  name: z.string().min(1, { message: "Area name is required." }),
  code: z.string().optional().nullable(),
  area_type_id: z.uuid().optional().nullable(),
  parent_id: z.uuid().optional().nullable(),
  contact_person: z.string().optional().nullable(),
  contact_number: z.string().optional().nullable(),
  email: z
    .email({ message: "Invalid email address." })
    .optional()
    .or(z.literal("")),
  latitude: z.number().optional().nullable(),
  longitude: z.number().optional().nullable(),
  address: z.string().optional().nullable(),
  status: z.boolean().default(true).optional(),
  created_at: z.coerce.date().optional(),
  updated_at: z.coerce.date().optional(),
});

export const employeeDesignationSchema = z.object({
  id: z.uuid().optional(),
  name: z.string().min(1, { message: "Designation name is required." }),
  parent_id: z.uuid().optional().nullable(),
  status: z.boolean().default(true).optional(),
  created_at: z.coerce.date().optional(),
  updated_at: z.coerce.date().optional(),
});

export const employeeSchema = z.object({
  id: z.uuid().optional(),
  employee_name: z.string().min(1, { message: "Employee name is required." }),
  employee_pers_no: z.string().optional().nullable(),
  employee_contact: z.string().optional().nullable(),
  employee_email: z.email({ message: "Invalid email address." })
    .optional()
    .or(z.literal("")),
  // dob/doj should not be future dates
  employee_dob: z.coerce
    .date<Date>()
    .optional()
    .nullable()
    .refine((date) => !date || date < new Date(), {
      message: "Date of birth cannot be in the future.",
    }),
  employee_doj: z.coerce
    .date<Date>()
    .optional()
    .nullable()
    .refine((date) => !date || date < new Date(), {
      message: "Date of joining cannot be in the future.",
    }),
  employee_designation_id: z.string().uuid().optional().nullable(),
  employee_addr: z.string().optional().nullable(),
  maintenance_terminal_id: z.string().uuid().optional().nullable(),
  remark: z.string().optional().nullable(),
  status: z.boolean().default(true).optional(),
  created_at: z.coerce.date().optional(),
  updated_at: z.coerce.date().optional(),
});

```

<!-- path: schemas/core.ts -->
```typescript
// =================================================================
// CORE INFRASTRUCTURE
// =================================================================

import z from 'zod';
import {
  emptyStringToNumber,
  ipValidation,
  optionalDate,
  optionalDateString,
  requiredStringToNumber,
} from '@/schemas/helpers';

export const ringSchema = z.object({
  id: z.uuid().optional(),
  name: z.string().min(1, { message: 'Ring name is required.' }),
  ring_type_id: z.uuid().optional().nullable(),
  description: z.string().optional().nullable(),
  maintenance_terminal_id: z.uuid().optional().nullable(),
  total_nodes: z.number().int().default(0).optional(),
  status: z.boolean().default(true).optional(),
  created_at: optionalDate,
  updated_at: optionalDate,
});

export const nodeSchema = z.object({
  id: z.uuid().optional(),
  name: z.string().min(1, { message: 'Node name is required.' }),
  node_type_id: z.uuid().optional().nullable(),
  latitude: requiredStringToNumber,
  longitude: requiredStringToNumber,
  maintenance_terminal_id: z.uuid().optional().nullable(),
  remark: z.string().optional().nullable(),
  status: z.boolean().default(true).optional(),
  created_at: optionalDate,
  updated_at: optionalDate,
});

export const ofcCableSchema = z
  .object({
    id: z.uuid().optional(),
    route_name: z.string().min(1, { message: 'Route name is required.' }),
    sn_id: z.uuid({ message: 'Starting node is required.' }),
    en_id: z.uuid({ message: 'Ending node is required.' }),
    ofc_type_id: z.uuid({ message: 'OFC type is required.' }),
    // capacity must be a positive integer
    capacity: requiredStringToNumber.pipe(
      z
        .number()
        .int({ message: 'Capacity must be an integer.' })
        .refine((val) => val > 0, {
          message: 'Capacity must be a positive integer.',
        })
    ),
    // current_rkm must be a positive number
    current_rkm: emptyStringToNumber.pipe(
      z.number().refine((val) => val >= 0, {
        message: 'Current RKM must be a positive number.',
      })
    ),
    transnet_id: z.string().optional().nullable(),
    // transnet_rkm must be a positive number
    transnet_rkm: emptyStringToNumber.pipe(
      z.number().refine((val) => val >= 0, {
        message: 'Transnet RKM must be a positive number.',
      })
    ),
    asset_no: z.string().optional().nullable(),
    maintenance_terminal_id: z.uuid().optional().nullable(),
    commissioned_on: optionalDate,
    remark: z.string().optional().nullable(),
    status: z.boolean().default(true).optional(),
    created_at: optionalDate,
    updated_at: optionalDate,
    total_count: z.number().int().optional().nullable(),
  })
  .superRefine((data, ctx) => {
    const a = data.sn_id;
    const b = data.en_id;
    // Run this check only when both IDs are present
    if (!a || !b) return;
    if (a === b) {
      ctx.addIssue({
        code: 'custom',
        message: 'Ending node must be different from starting node.',
        path: ['en_id'],
      });
    }
  });

export const systemSchema = z.object({
  commissioned_on: optionalDateString,
  created_at: optionalDateString,
  id: z.string().optional(),
  ip_address: z.unknown().nullable().optional(),
  maintenance_terminal_id: z.string().nullable().optional(),
  node_id: z.string(),
  remark: z.string().nullable().optional(),
  s_no: z.string().nullable().optional(),
  status: z.boolean().nullable().optional(),
  system_name: z.string().nullable().optional(),
  system_type_id: z.string(),
  updated_at: optionalDateString,
});

export const ofcConnectionSchema = z.object({
  id: z.uuid().optional(),
  ofc_id: z.uuid({ message: "OFC Cable is required." }),
  logical_path_id: z.uuid().optional().nullable(),
  system_id: z.uuid().optional().nullable(),

  fiber_role: z.string().optional().nullable(),

  fiber_no_sn: z.number().int({ message: "Start Node Fiber No. is required." }),
  fiber_no_en: z.number().int({ message: "End Node Fiber No. is required." }),

  path_segment_order: z.number().int().optional().nullable(),
  connection_category: z.string({ message: "Connection Category is required." }),
  connection_type: z.string({ message: "Connection Type is required." }),

  source_port: z.string().optional().nullable(),
  destination_port: z.string().optional().nullable(),

  sn_dom: optionalDate,
  otdr_distance_sn_km: emptyStringToNumber,
  sn_power_dbm: emptyStringToNumber,

  en_dom: optionalDate,
  otdr_distance_en_km: emptyStringToNumber,
  en_power_dbm: emptyStringToNumber,

  route_loss_db: emptyStringToNumber,
  status: z.boolean().optional().nullable(),
  remark: z.string().optional().nullable(),

  created_at: optionalDate,
  updated_at: optionalDate,
});


export const systemConnectionSchema = z.object({
  id: z.uuid().optional(),
  system_id: z.uuid({ message: 'System is required.' }),
  node_a_id: z.uuid().optional().nullable(),
  node_b_id: z.uuid().optional().nullable(),
  connected_system_id: z.uuid().optional().nullable(),
  ea_ip: ipValidation.optional().or(z.literal('')),
  ea_interface: z.string().optional().nullable(),
  eb_ip: ipValidation.optional().or(z.literal('')),
  eb_interface: z.string().optional().nullable(),
  media_type_id: z.uuid().optional().nullable(),
  bandwidth_mbps: z.number().int().optional().nullable(),
  vlan: z.string().optional().nullable(),
  commissioned_on: optionalDate,
  remark: z.string().optional().nullable(),
  status: z.boolean().default(true).optional(),
  created_at: optionalDate,
  updated_at: optionalDate,
});

export const managementPortSchema = z.object({
  id: z.uuid().optional(),
  port_no: z.string().min(1, { message: 'Port number is required.' }),
  name: z.string().optional().nullable(),
  node_id: z.uuid().optional().nullable(),
  system_id: z.uuid().optional().nullable(),
  commissioned_on: optionalDate,
  remark: z.string().optional().nullable(),
  status: z.boolean().default(true).optional(),
  created_at: optionalDate,
  updated_at: optionalDate,
});

export const sdhNodeAssociationSchema = z.object({
  id: z.uuid().optional(),
  sdh_system_id: z.string().uuid({ message: 'SDH System is required.' }),
  node_id: z.string().uuid({ message: 'Node is required.' }),
  node_position: z
    .enum(['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H'])
    .optional()
    .nullable(),
  node_ip: ipValidation.optional().or(z.literal('')),
});

```

<!-- path: schemas/zod-schemas.ts -->
```typescript
// Auto-generated Zod schemas from flattened-types.ts

import { z } from "zod";

import { UserRole } from "@/types/user-roles";

// ============= TABLE SCHEMAS =============

export const authAudit_log_entriesRowSchema = z.object({
  created_at: z.iso.datetime().nullable(),
  id: z.uuid(),
  instance_id: z.uuid().nullable(),
  ip_address: z.string().min(5, "Address must be at least 5 characters").max(500),
  payload: z.any().nullable(),
});

export const authAudit_log_entriesInsertSchema = z.object({
  created_at: z.iso.datetime().nullable().optional(),
  id: z.uuid(),
  instance_id: z.uuid().nullable().optional(),
  ip_address: z.string().min(5, "Address must be at least 5 characters").max(500).optional(),
  payload: z.any().nullable().optional(),
});

export const authAudit_log_entriesUpdateSchema = z.object({
  created_at: z.iso.datetime().nullable().optional(),
  id: z.uuid().optional(),
  instance_id: z.uuid().nullable().optional(),
  ip_address: z.string().min(5, "Address must be at least 5 characters").max(500).optional(),
  payload: z.any().nullable().optional(),
});

export const authFlow_stateRowSchema = z.object({
  auth_code: z.string(),
  auth_code_issued_at: z.iso.datetime().nullable(),
  authentication_method: z.string(),
  code_challenge: z.string(),
  code_challenge_method: z.string(),
  created_at: z.iso.datetime().nullable(),
  id: z.uuid(),
  provider_access_token: z.jwt().nullable(),
  provider_refresh_token: z.jwt().nullable(),
  provider_type: z.string(),
  updated_at: z.iso.datetime().nullable(),
  user_id: z.uuid().nullable(),
});

export const authFlow_stateInsertSchema = z.object({
  auth_code: z.string(),
  auth_code_issued_at: z.iso.datetime().nullable().optional(),
  authentication_method: z.string(),
  code_challenge: z.string(),
  code_challenge_method: z.string(),
  created_at: z.iso.datetime().nullable().optional(),
  id: z.uuid(),
  provider_access_token: z.jwt().nullable().optional(),
  provider_refresh_token: z.jwt().nullable().optional(),
  provider_type: z.string(),
  updated_at: z.iso.datetime().nullable().optional(),
  user_id: z.uuid().nullable().optional(),
});

export const authFlow_stateUpdateSchema = z.object({
  auth_code: z.string().optional(),
  auth_code_issued_at: z.iso.datetime().nullable().optional(),
  authentication_method: z.string().optional(),
  code_challenge: z.string().optional(),
  code_challenge_method: z.string().optional(),
  created_at: z.iso.datetime().nullable().optional(),
  id: z.uuid().optional(),
  provider_access_token: z.jwt().nullable().optional(),
  provider_refresh_token: z.jwt().nullable().optional(),
  provider_type: z.string().optional(),
  updated_at: z.iso.datetime().nullable().optional(),
  user_id: z.uuid().nullable().optional(),
});

export const authIdentitiesRowSchema = z.object({
  created_at: z.iso.datetime().nullable(),
  email: z.email().nullable(),
  id: z.uuid(),
  identity_data: z.any(),
  last_sign_in_at: z.iso.datetime().nullable(),
  provider: z.string(),
  provider_id: z.uuid(),
  updated_at: z.iso.datetime().nullable(),
  user_id: z.uuid(),
});

export const authIdentitiesInsertSchema = z.object({
  created_at: z.iso.datetime().nullable().optional(),
  email: z.email().nullable().optional(),
  id: z.uuid().optional(),
  identity_data: z.any(),
  last_sign_in_at: z.iso.datetime().nullable().optional(),
  provider: z.string(),
  provider_id: z.uuid(),
  updated_at: z.iso.datetime().nullable().optional(),
  user_id: z.uuid(),
});

export const authIdentitiesUpdateSchema = z.object({
  created_at: z.iso.datetime().nullable().optional(),
  email: z.email().nullable().optional(),
  id: z.uuid().optional(),
  identity_data: z.any().optional(),
  last_sign_in_at: z.iso.datetime().nullable().optional(),
  provider: z.string().optional(),
  provider_id: z.uuid().optional(),
  updated_at: z.iso.datetime().nullable().optional(),
  user_id: z.uuid().optional(),
});

export const authInstancesRowSchema = z.object({
  created_at: z.iso.datetime().nullable(),
  id: z.uuid(),
  raw_base_config: z.string().nullable(),
  updated_at: z.iso.datetime().nullable(),
  uuid: z.uuid().nullable(),
});

export const authInstancesInsertSchema = z.object({
  created_at: z.iso.datetime().nullable().optional(),
  id: z.uuid(),
  raw_base_config: z.string().nullable().optional(),
  updated_at: z.iso.datetime().nullable().optional(),
  uuid: z.uuid().nullable().optional(),
});

export const authInstancesUpdateSchema = z.object({
  created_at: z.iso.datetime().nullable().optional(),
  id: z.uuid().optional(),
  raw_base_config: z.string().nullable().optional(),
  updated_at: z.iso.datetime().nullable().optional(),
  uuid: z.uuid().nullable().optional(),
});

export const authMfa_amr_claimsRowSchema = z.object({
  authentication_method: z.string(),
  created_at: z.iso.datetime(),
  id: z.uuid(),
  session_id: z.uuid(),
  updated_at: z.iso.datetime(),
});

export const authMfa_amr_claimsInsertSchema = z.object({
  authentication_method: z.string(),
  created_at: z.iso.datetime(),
  id: z.uuid(),
  session_id: z.uuid(),
  updated_at: z.iso.datetime(),
});

export const authMfa_amr_claimsUpdateSchema = z.object({
  authentication_method: z.string().optional(),
  created_at: z.iso.datetime().optional(),
  id: z.uuid().optional(),
  session_id: z.uuid().optional(),
  updated_at: z.iso.datetime().optional(),
});

export const authMfa_challengesRowSchema = z.object({
  created_at: z.iso.datetime(),
  factor_id: z.uuid(),
  id: z.uuid(),
  ip_address: z.string(),
  otp_code: z.string().nullable(),
  verified_at: z.iso.datetime().nullable(),
  web_authn_session_data: z.any().nullable(),
});

export const authMfa_challengesInsertSchema = z.object({
  created_at: z.iso.datetime(),
  factor_id: z.uuid(),
  id: z.uuid(),
  ip_address: z.string(),
  otp_code: z.string().nullable().optional(),
  verified_at: z.iso.datetime().nullable().optional(),
  web_authn_session_data: z.any().nullable().optional(),
});

export const authMfa_challengesUpdateSchema = z.object({
  created_at: z.iso.datetime().optional(),
  factor_id: z.uuid().optional(),
  id: z.uuid().optional(),
  ip_address: z.string().optional(),
  otp_code: z.string().nullable().optional(),
  verified_at: z.iso.datetime().nullable().optional(),
  web_authn_session_data: z.any().nullable().optional(),
});

export const authMfa_factorsRowSchema = z.object({
  created_at: z.iso.datetime(),
  factor_type: z.string(),
  friendly_name: z.string().min(1, "Name cannot be empty").max(255, "Name is too long").nullable(),
  id: z.uuid(),
  last_challenged_at: z.iso.datetime().nullable(),
  phone: z.string().regex(/^[+]?[1-9]?[0-9]{7,15}$/, "Invalid phone number").nullable(),
  secret: z.string().nullable(),
  status: z.string(),
  updated_at: z.iso.datetime(),
  user_id: z.uuid(),
  web_authn_aaguid: z.string().nullable(),
  web_authn_credential: z.any().nullable(),
});

export const authMfa_factorsInsertSchema = z.object({
  created_at: z.iso.datetime(),
  factor_type: z.string(),
  friendly_name: z.string().min(1, "Name cannot be empty").max(255, "Name is too long").nullable().optional(),
  id: z.uuid(),
  last_challenged_at: z.iso.datetime().nullable().optional(),
  phone: z.string().regex(/^[+]?[1-9]?[0-9]{7,15}$/, "Invalid phone number").nullable().optional(),
  secret: z.string().nullable().optional(),
  status: z.string(),
  updated_at: z.iso.datetime(),
  user_id: z.uuid(),
  web_authn_aaguid: z.string().nullable().optional(),
  web_authn_credential: z.any().nullable().optional(),
});

export const authMfa_factorsUpdateSchema = z.object({
  created_at: z.iso.datetime().optional(),
  factor_type: z.string().optional(),
  friendly_name: z.string().min(1, "Name cannot be empty").max(255, "Name is too long").nullable().optional(),
  id: z.uuid().optional(),
  last_challenged_at: z.iso.datetime().nullable().optional(),
  phone: z.string().regex(/^[+]?[1-9]?[0-9]{7,15}$/, "Invalid phone number").nullable().optional(),
  secret: z.string().nullable().optional(),
  status: z.string().optional(),
  updated_at: z.iso.datetime().optional(),
  user_id: z.uuid().optional(),
  web_authn_aaguid: z.string().nullable().optional(),
  web_authn_credential: z.any().nullable().optional(),
});

export const authOauth_clientsRowSchema = z.object({
  client_id: z.uuid(),
  client_name: z.string().min(1, "Name cannot be empty").max(255, "Name is too long").nullable(),
  client_secret_hash: z.string(),
  client_uri: z.string().nullable(),
  created_at: z.iso.datetime(),
  deleted_at: z.iso.datetime().nullable(),
  grant_types: z.string(),
  id: z.uuid(),
  logo_uri: z.string().nullable(),
  redirect_uris: z.string(),
  registration_type: z.string(),
  updated_at: z.iso.datetime(),
});

export const authOauth_clientsInsertSchema = z.object({
  client_id: z.uuid(),
  client_name: z.string().min(1, "Name cannot be empty").max(255, "Name is too long").nullable().optional(),
  client_secret_hash: z.string(),
  client_uri: z.string().nullable().optional(),
  created_at: z.iso.datetime().optional(),
  deleted_at: z.iso.datetime().nullable().optional(),
  grant_types: z.string(),
  id: z.uuid(),
  logo_uri: z.string().nullable().optional(),
  redirect_uris: z.string(),
  registration_type: z.string(),
  updated_at: z.iso.datetime().optional(),
});

export const authOauth_clientsUpdateSchema = z.object({
  client_id: z.uuid().optional(),
  client_name: z.string().min(1, "Name cannot be empty").max(255, "Name is too long").nullable().optional(),
  client_secret_hash: z.string().optional(),
  client_uri: z.string().nullable().optional(),
  created_at: z.iso.datetime().optional(),
  deleted_at: z.iso.datetime().nullable().optional(),
  grant_types: z.string().optional(),
  id: z.uuid().optional(),
  logo_uri: z.string().nullable().optional(),
  redirect_uris: z.string().optional(),
  registration_type: z.string().optional(),
  updated_at: z.iso.datetime().optional(),
});

export const authOne_time_tokensRowSchema = z.object({
  created_at: z.iso.datetime(),
  id: z.uuid(),
  relates_to: z.string(),
  token_hash: z.jwt(),
  token_type: z.string(),
  updated_at: z.iso.datetime(),
  user_id: z.uuid(),
});

export const authOne_time_tokensInsertSchema = z.object({
  created_at: z.iso.datetime().optional(),
  id: z.uuid(),
  relates_to: z.string(),
  token_hash: z.jwt(),
  token_type: z.string(),
  updated_at: z.iso.datetime().optional(),
  user_id: z.uuid(),
});

export const authOne_time_tokensUpdateSchema = z.object({
  created_at: z.iso.datetime().optional(),
  id: z.uuid().optional(),
  relates_to: z.string().optional(),
  token_hash: z.jwt().optional(),
  token_type: z.string().optional(),
  updated_at: z.iso.datetime().optional(),
  user_id: z.uuid().optional(),
});

export const authRefresh_tokensRowSchema = z.object({
  created_at: z.iso.datetime().nullable(),
  id: z.number().int().positive(),
  instance_id: z.uuid().nullable(),
  parent: z.string().nullable(),
  revoked: z.boolean().nullable(),
  session_id: z.uuid().nullable(),
  token: z.jwt().nullable(),
  updated_at: z.iso.datetime().nullable(),
  user_id: z.uuid().nullable(),
});

export const authRefresh_tokensInsertSchema = z.object({
  created_at: z.iso.datetime().nullable().optional(),
  id: z.number().int().positive().optional(),
  instance_id: z.uuid().nullable().optional(),
  parent: z.string().nullable().optional(),
  revoked: z.boolean().nullable().optional(),
  session_id: z.uuid().nullable().optional(),
  token: z.jwt().nullable().optional(),
  updated_at: z.iso.datetime().nullable().optional(),
  user_id: z.uuid().nullable().optional(),
});

export const authRefresh_tokensUpdateSchema = z.object({
  created_at: z.iso.datetime().nullable().optional(),
  id: z.number().int().positive().optional(),
  instance_id: z.uuid().nullable().optional(),
  parent: z.string().nullable().optional(),
  revoked: z.boolean().nullable().optional(),
  session_id: z.uuid().nullable().optional(),
  token: z.jwt().nullable().optional(),
  updated_at: z.iso.datetime().nullable().optional(),
  user_id: z.uuid().nullable().optional(),
});

export const authSaml_providersRowSchema = z.object({
  attribute_mapping: z.any().nullable(),
  created_at: z.iso.datetime().nullable(),
  entity_id: z.uuid(),
  id: z.uuid(),
  metadata_url: z.url().nullable(),
  metadata_xml: z.string(),
  name_id_format: z.string().nullable(),
  sso_provider_id: z.uuid(),
  updated_at: z.iso.datetime().nullable(),
});

export const authSaml_providersInsertSchema = z.object({
  attribute_mapping: z.any().nullable().optional(),
  created_at: z.iso.datetime().nullable().optional(),
  entity_id: z.uuid(),
  id: z.uuid(),
  metadata_url: z.url().nullable().optional(),
  metadata_xml: z.string(),
  name_id_format: z.string().nullable().optional(),
  sso_provider_id: z.uuid(),
  updated_at: z.iso.datetime().nullable().optional(),
});

export const authSaml_providersUpdateSchema = z.object({
  attribute_mapping: z.any().nullable().optional(),
  created_at: z.iso.datetime().nullable().optional(),
  entity_id: z.uuid().optional(),
  id: z.uuid().optional(),
  metadata_url: z.url().nullable().optional(),
  metadata_xml: z.string().optional(),
  name_id_format: z.string().nullable().optional(),
  sso_provider_id: z.uuid().optional(),
  updated_at: z.iso.datetime().nullable().optional(),
});

export const authSaml_relay_statesRowSchema = z.object({
  created_at: z.iso.datetime().nullable(),
  flow_state_id: z.uuid().nullable(),
  for_email: z.email().nullable(),
  id: z.uuid(),
  redirect_to: z.string().nullable(),
  request_id: z.uuid(),
  sso_provider_id: z.uuid(),
  updated_at: z.iso.datetime().nullable(),
});

export const authSaml_relay_statesInsertSchema = z.object({
  created_at: z.iso.datetime().nullable().optional(),
  flow_state_id: z.uuid().nullable().optional(),
  for_email: z.email().nullable().optional(),
  id: z.uuid(),
  redirect_to: z.string().nullable().optional(),
  request_id: z.uuid(),
  sso_provider_id: z.uuid(),
  updated_at: z.iso.datetime().nullable().optional(),
});

export const authSaml_relay_statesUpdateSchema = z.object({
  created_at: z.iso.datetime().nullable().optional(),
  flow_state_id: z.uuid().nullable().optional(),
  for_email: z.email().nullable().optional(),
  id: z.uuid().optional(),
  redirect_to: z.string().nullable().optional(),
  request_id: z.uuid().optional(),
  sso_provider_id: z.uuid().optional(),
  updated_at: z.iso.datetime().nullable().optional(),
});

export const authSchema_migrationsRowSchema = z.object({
  version: z.string(),
});

export const authSchema_migrationsInsertSchema = z.object({
  version: z.string(),
});

export const authSchema_migrationsUpdateSchema = z.object({
  version: z.string().optional(),
});

export const authSessionsRowSchema = z.object({
  aal: z.string().nullable(),
  created_at: z.iso.datetime().nullable(),
  factor_id: z.uuid().nullable(),
  id: z.uuid(),
  ip: z.string().nullable(),
  not_after: z.string().nullable(),
  refreshed_at: z.iso.datetime().nullable(),
  tag: z.string().nullable(),
  updated_at: z.iso.datetime().nullable(),
  user_agent: z.string().nullable(),
  user_id: z.uuid(),
});

export const authSessionsInsertSchema = z.object({
  aal: z.string().nullable().optional(),
  created_at: z.iso.datetime().nullable().optional(),
  factor_id: z.uuid().nullable().optional(),
  id: z.uuid(),
  ip: z.string().nullable().optional(),
  not_after: z.string().nullable().optional(),
  refreshed_at: z.iso.datetime().nullable().optional(),
  tag: z.string().nullable().optional(),
  updated_at: z.iso.datetime().nullable().optional(),
  user_agent: z.string().nullable().optional(),
  user_id: z.uuid(),
});

export const authSessionsUpdateSchema = z.object({
  aal: z.string().nullable().optional(),
  created_at: z.iso.datetime().nullable().optional(),
  factor_id: z.uuid().nullable().optional(),
  id: z.uuid().optional(),
  ip: z.string().nullable().optional(),
  not_after: z.string().nullable().optional(),
  refreshed_at: z.iso.datetime().nullable().optional(),
  tag: z.string().nullable().optional(),
  updated_at: z.iso.datetime().nullable().optional(),
  user_agent: z.string().nullable().optional(),
  user_id: z.uuid().optional(),
});

export const authSso_domainsRowSchema = z.object({
  created_at: z.iso.datetime().nullable(),
  domain: z.string(),
  id: z.uuid(),
  sso_provider_id: z.uuid(),
  updated_at: z.iso.datetime().nullable(),
});

export const authSso_domainsInsertSchema = z.object({
  created_at: z.iso.datetime().nullable().optional(),
  domain: z.string(),
  id: z.uuid(),
  sso_provider_id: z.uuid(),
  updated_at: z.iso.datetime().nullable().optional(),
});

export const authSso_domainsUpdateSchema = z.object({
  created_at: z.iso.datetime().nullable().optional(),
  domain: z.string().optional(),
  id: z.uuid().optional(),
  sso_provider_id: z.uuid().optional(),
  updated_at: z.iso.datetime().nullable().optional(),
});

export const authSso_providersRowSchema = z.object({
  created_at: z.iso.datetime().nullable(),
  disabled: z.boolean().nullable(),
  id: z.uuid(),
  resource_id: z.uuid().nullable(),
  updated_at: z.iso.datetime().nullable(),
});

export const authSso_providersInsertSchema = z.object({
  created_at: z.iso.datetime().nullable().optional(),
  disabled: z.boolean().nullable().optional(),
  id: z.uuid(),
  resource_id: z.uuid().nullable().optional(),
  updated_at: z.iso.datetime().nullable().optional(),
});

export const authSso_providersUpdateSchema = z.object({
  created_at: z.iso.datetime().nullable().optional(),
  disabled: z.boolean().nullable().optional(),
  id: z.uuid().optional(),
  resource_id: z.uuid().nullable().optional(),
  updated_at: z.iso.datetime().nullable().optional(),
});

export const authUsersRowSchema = z.object({
  aud: z.string().min(1).nullable(),
  banned_until: z.string().nullable(),
  confirmation_sent_at: z.iso.datetime().nullable(),
  confirmation_token: z.jwt().nullable(),
  confirmed_at: z.iso.datetime().nullable(),
  created_at: z.iso.datetime().nullable(),
  deleted_at: z.iso.datetime().nullable(),
  email: z.email().nullable(),
  email_change: z.email().nullable(),
  email_change_confirm_status: z.number().nullable(),
  email_change_sent_at: z.email().nullable(),
  email_change_token_current: z.email().nullable(),
  email_change_token_new: z.email().nullable(),
  email_confirmed_at: z.email().nullable(),
  encrypted_password: z.string()
        .min(6, "Password must be at least 6 characters long")
        .max(50, "Password must not exceed 50 characters")
        .regex(
          /^(?=.*[a-z])(?=.*[A-Z])(?=.*\d)(?=.*[@$!%*?&])[A-Za-z\d@$!%*?&]/,
          "Password must contain at least one uppercase letter, one lowercase letter, one number and one special character"
        ).nullable(),
  id: z.uuid(),
  instance_id: z.uuid().nullable(),
  invited_at: z.iso.datetime().nullable(),
  is_anonymous: z.boolean(),
  is_sso_user: z.boolean(),
  is_super_admin: z.boolean().nullable(),
  last_sign_in_at: z.iso.datetime().nullable(),
  phone: z.string().regex(/^[+]?[1-9]?[0-9]{7,15}$/, "Invalid phone number").nullable(),
  phone_change: z.string().regex(/^[+]?[1-9]?[0-9]{7,15}$/, "Invalid phone number").nullable(),
  phone_change_sent_at: z.string().regex(/^[+]?[1-9]?[0-9]{7,15}$/, "Invalid phone number").nullable(),
  phone_change_token: z.string().regex(/^[+]?[1-9]?[0-9]{7,15}$/, "Invalid phone number").nullable(),
  phone_confirmed_at: z.string().regex(/^[+]?[1-9]?[0-9]{7,15}$/, "Invalid phone number").nullable(),
  raw_app_meta_data: z.any().nullable(),
  raw_user_meta_data: z.any().nullable(),
  reauthentication_sent_at: z.iso.datetime().nullable(),
  reauthentication_token: z.jwt().nullable(),
  recovery_sent_at: z.iso.datetime().nullable(),
  recovery_token: z.jwt().nullable(),
  role: z.enum(UserRole).nullable(),
  updated_at: z.iso.datetime().nullable(),
});

export const authUsersInsertSchema = z.object({
  aud: z.string().min(1).nullable().optional(),
  banned_until: z.string().nullable().optional(),
  confirmation_sent_at: z.iso.datetime().nullable().optional(),
  confirmation_token: z.jwt().nullable().optional(),
  confirmed_at: z.iso.datetime().nullable().optional(),
  created_at: z.iso.datetime().nullable().optional(),
  deleted_at: z.iso.datetime().nullable().optional(),
  email: z.email().nullable().optional(),
  email_change: z.email().nullable().optional(),
  email_change_confirm_status: z.number().nullable().optional(),
  email_change_sent_at: z.email().nullable().optional(),
  email_change_token_current: z.email().nullable().optional(),
  email_change_token_new: z.email().nullable().optional(),
  email_confirmed_at: z.email().nullable().optional(),
  encrypted_password: z.string()
        .min(6, "Password must be at least 6 characters long")
        .max(50, "Password must not exceed 50 characters")
        .regex(
          /^(?=.*[a-z])(?=.*[A-Z])(?=.*\d)(?=.*[@$!%*?&])[A-Za-z\d@$!%*?&]/,
          "Password must contain at least one uppercase letter, one lowercase letter, one number and one special character"
        ).nullable().optional(),
  id: z.uuid(),
  instance_id: z.uuid().nullable().optional(),
  invited_at: z.iso.datetime().nullable().optional(),
  is_anonymous: z.boolean().optional(),
  is_sso_user: z.boolean().optional(),
  is_super_admin: z.boolean().nullable().optional(),
  last_sign_in_at: z.iso.datetime().nullable().optional(),
  phone: z.string().regex(/^[+]?[1-9]?[0-9]{7,15}$/, "Invalid phone number").nullable().optional(),
  phone_change: z.string().regex(/^[+]?[1-9]?[0-9]{7,15}$/, "Invalid phone number").nullable().optional(),
  phone_change_sent_at: z.string().regex(/^[+]?[1-9]?[0-9]{7,15}$/, "Invalid phone number").nullable().optional(),
  phone_change_token: z.string().regex(/^[+]?[1-9]?[0-9]{7,15}$/, "Invalid phone number").nullable().optional(),
  phone_confirmed_at: z.string().regex(/^[+]?[1-9]?[0-9]{7,15}$/, "Invalid phone number").nullable().optional(),
  raw_app_meta_data: z.any().nullable().optional(),
  raw_user_meta_data: z.any().nullable().optional(),
  reauthentication_sent_at: z.iso.datetime().nullable().optional(),
  reauthentication_token: z.jwt().nullable().optional(),
  recovery_sent_at: z.iso.datetime().nullable().optional(),
  recovery_token: z.jwt().nullable().optional(),
  role: z.enum(UserRole).nullable().optional(),
  updated_at: z.iso.datetime().nullable().optional(),
});

export const authUsersUpdateSchema = z.object({
  aud: z.string().min(1).nullable().optional(),
  banned_until: z.string().nullable().optional(),
  confirmation_sent_at: z.iso.datetime().nullable().optional(),
  confirmation_token: z.jwt().nullable().optional(),
  confirmed_at: z.iso.datetime().nullable().optional(),
  created_at: z.iso.datetime().nullable().optional(),
  deleted_at: z.iso.datetime().nullable().optional(),
  email: z.email().nullable().optional(),
  email_change: z.email().nullable().optional(),
  email_change_confirm_status: z.number().nullable().optional(),
  email_change_sent_at: z.email().nullable().optional(),
  email_change_token_current: z.email().nullable().optional(),
  email_change_token_new: z.email().nullable().optional(),
  email_confirmed_at: z.email().nullable().optional(),
  encrypted_password: z.string()
        .min(6, "Password must be at least 6 characters long")
        .max(50, "Password must not exceed 50 characters")
        .regex(
          /^(?=.*[a-z])(?=.*[A-Z])(?=.*\d)(?=.*[@$!%*?&])[A-Za-z\d@$!%*?&]/,
          "Password must contain at least one uppercase letter, one lowercase letter, one number and one special character"
        ).nullable().optional(),
  id: z.uuid().optional(),
  instance_id: z.uuid().nullable().optional(),
  invited_at: z.iso.datetime().nullable().optional(),
  is_anonymous: z.boolean().optional(),
  is_sso_user: z.boolean().optional(),
  is_super_admin: z.boolean().nullable().optional(),
  last_sign_in_at: z.iso.datetime().nullable().optional(),
  phone: z.string().regex(/^[+]?[1-9]?[0-9]{7,15}$/, "Invalid phone number").nullable().optional(),
  phone_change: z.string().regex(/^[+]?[1-9]?[0-9]{7,15}$/, "Invalid phone number").nullable().optional(),
  phone_change_sent_at: z.string().regex(/^[+]?[1-9]?[0-9]{7,15}$/, "Invalid phone number").nullable().optional(),
  phone_change_token: z.string().regex(/^[+]?[1-9]?[0-9]{7,15}$/, "Invalid phone number").nullable().optional(),
  phone_confirmed_at: z.string().regex(/^[+]?[1-9]?[0-9]{7,15}$/, "Invalid phone number").nullable().optional(),
  raw_app_meta_data: z.any().nullable().optional(),
  raw_user_meta_data: z.any().nullable().optional(),
  reauthentication_sent_at: z.iso.datetime().nullable().optional(),
  reauthentication_token: z.jwt().nullable().optional(),
  recovery_sent_at: z.iso.datetime().nullable().optional(),
  recovery_token: z.jwt().nullable().optional(),
  role: z.enum(UserRole).nullable().optional(),
  updated_at: z.iso.datetime().nullable().optional(),
});

export const cable_segmentsRowSchema = z.object({
  created_at: z.iso.datetime().nullable(),
  distance_km: z.number(),
  end_node_id: z.uuid(),
  end_node_type: z.string(),
  fiber_count: z.number().int().min(0),
  id: z.uuid(),
  original_cable_id: z.uuid(),
  segment_order: z.number(),
  start_node_id: z.uuid(),
  start_node_type: z.string(),
  updated_at: z.iso.datetime().nullable(),
});

export const cable_segmentsInsertSchema = z.object({
  created_at: z.iso.datetime().nullable().optional(),
  distance_km: z.number(),
  end_node_id: z.uuid(),
  end_node_type: z.string(),
  fiber_count: z.number().int().min(0),
  id: z.uuid().optional(),
  original_cable_id: z.uuid(),
  segment_order: z.number(),
  start_node_id: z.uuid(),
  start_node_type: z.string(),
  updated_at: z.iso.datetime().nullable().optional(),
});

export const cable_segmentsUpdateSchema = z.object({
  created_at: z.iso.datetime().nullable().optional(),
  distance_km: z.number().optional(),
  end_node_id: z.uuid().optional(),
  end_node_type: z.string().optional(),
  fiber_count: z.number().int().min(0).optional(),
  id: z.uuid().optional(),
  original_cable_id: z.uuid().optional(),
  segment_order: z.number().optional(),
  start_node_id: z.uuid().optional(),
  start_node_type: z.string().optional(),
  updated_at: z.iso.datetime().nullable().optional(),
});

export const employee_designationsRowSchema = z.object({
  created_at: z.iso.datetime().nullable(),
  id: z.uuid(),
  name: z.string().min(1, "Name cannot be empty").max(255, "Name is too long"),
  parent_id: z.uuid().nullable(),
  status: z.boolean().nullable(),
  updated_at: z.iso.datetime().nullable(),
});

export const employee_designationsInsertSchema = z.object({
  created_at: z.iso.datetime().nullable().optional(),
  id: z.uuid().optional(),
  name: z.string().min(1, "Name cannot be empty").max(255, "Name is too long"),
  parent_id: z.uuid().nullable().optional(),
  status: z.boolean().nullable().optional(),
  updated_at: z.iso.datetime().nullable().optional(),
});

export const employee_designationsUpdateSchema = z.object({
  created_at: z.iso.datetime().nullable().optional(),
  id: z.uuid().optional(),
  name: z.string().min(1, "Name cannot be empty").max(255, "Name is too long").optional(),
  parent_id: z.uuid().nullable().optional(),
  status: z.boolean().nullable().optional(),
  updated_at: z.iso.datetime().nullable().optional(),
});

export const employeesRowSchema = z.object({
  created_at: z.iso.datetime().nullable(),
  employee_addr: z.string().min(5, "Address must be at least 5 characters").max(500).nullable(),
  employee_contact: z.string().nullable(),
  employee_designation_id: z.uuid().nullable(),
  employee_dob: z.iso.date().nullable(),
  employee_doj: z.iso.date().nullable(),
  employee_email: z.email().nullable(),
  employee_name: z.string().min(1, "Name cannot be empty").max(255, "Name is too long"),
  employee_pers_no: z.string().nullable(),
  id: z.uuid(),
  maintenance_terminal_id: z.uuid().nullable(),
  remark: z.string().nullable(),
  status: z.boolean().nullable(),
  updated_at: z.iso.datetime().nullable(),
});

export const employeesInsertSchema = z.object({
  created_at: z.iso.datetime().nullable().optional(),
  employee_addr: z.string().min(5, "Address must be at least 5 characters").max(500).nullable().optional(),
  employee_contact: z.string().nullable().optional(),
  employee_designation_id: z.uuid().nullable().optional(),
  employee_dob: z.iso.date().nullable().optional(),
  employee_doj: z.iso.date().nullable().optional(),
  employee_email: z.email().nullable().optional(),
  employee_name: z.string().min(1, "Name cannot be empty").max(255, "Name is too long"),
  employee_pers_no: z.string().nullable().optional(),
  id: z.uuid().optional(),
  maintenance_terminal_id: z.uuid().nullable().optional(),
  remark: z.string().nullable().optional(),
  status: z.boolean().nullable().optional(),
  updated_at: z.iso.datetime().nullable().optional(),
});

export const employeesUpdateSchema = z.object({
  created_at: z.iso.datetime().nullable().optional(),
  employee_addr: z.string().min(5, "Address must be at least 5 characters").max(500).nullable().optional(),
  employee_contact: z.string().nullable().optional(),
  employee_designation_id: z.uuid().nullable().optional(),
  employee_dob: z.iso.date().nullable().optional(),
  employee_doj: z.iso.date().nullable().optional(),
  employee_email: z.email().nullable().optional(),
  employee_name: z.string().min(1, "Name cannot be empty").max(255, "Name is too long").optional(),
  employee_pers_no: z.string().nullable().optional(),
  id: z.uuid().optional(),
  maintenance_terminal_id: z.uuid().nullable().optional(),
  remark: z.string().nullable().optional(),
  status: z.boolean().nullable().optional(),
  updated_at: z.iso.datetime().nullable().optional(),
});

export const fiber_splicesRowSchema = z.object({
  created_at: z.iso.datetime().nullable(),
  id: z.uuid(),
  incoming_cable_id: z.uuid(),
  incoming_fiber_no: z.number(),
  jc_id: z.uuid(),
  logical_path_id: z.uuid().nullable(),
  loss_db: z.number().nullable(),
  otdr_length_km: z.number().nullable(),
  outgoing_cable_id: z.uuid().nullable(),
  outgoing_fiber_no: z.number().nullable(),
  splice_type: z.string(),
  status: z.string().min(1, "Status cannot be empty"),
  updated_at: z.iso.datetime().nullable(),
});

export const fiber_splicesInsertSchema = z.object({
  created_at: z.iso.datetime().nullable().optional(),
  id: z.uuid().optional(),
  incoming_cable_id: z.uuid(),
  incoming_fiber_no: z.number(),
  jc_id: z.uuid(),
  logical_path_id: z.uuid().nullable().optional(),
  loss_db: z.number().nullable().optional(),
  otdr_length_km: z.number().nullable().optional(),
  outgoing_cable_id: z.uuid().nullable().optional(),
  outgoing_fiber_no: z.number().nullable().optional(),
  splice_type: z.string().optional(),
  status: z.string().min(1, "Status cannot be empty").optional(),
  updated_at: z.iso.datetime().nullable().optional(),
});

export const fiber_splicesUpdateSchema = z.object({
  created_at: z.iso.datetime().nullable().optional(),
  id: z.uuid().optional(),
  incoming_cable_id: z.uuid().optional(),
  incoming_fiber_no: z.number().optional(),
  jc_id: z.uuid().optional(),
  logical_path_id: z.uuid().nullable().optional(),
  loss_db: z.number().nullable().optional(),
  otdr_length_km: z.number().nullable().optional(),
  outgoing_cable_id: z.uuid().nullable().optional(),
  outgoing_fiber_no: z.number().nullable().optional(),
  splice_type: z.string().optional(),
  status: z.string().min(1, "Status cannot be empty").optional(),
  updated_at: z.iso.datetime().nullable().optional(),
});

export const filesRowSchema = z.object({
  file_name: z.string().min(1, "Name cannot be empty").max(255, "Name is too long"),
  file_route: z.string(),
  file_size: z.string(),
  file_type: z.string(),
  file_url: z.url(),
  folder_id: z.uuid().nullable(),
  id: z.uuid(),
  uploaded_at: z.iso.datetime().nullable(),
  user_id: z.uuid(),
});

export const filesInsertSchema = z.object({
  file_name: z.string().min(1, "Name cannot be empty").max(255, "Name is too long"),
  file_route: z.string(),
  file_size: z.string(),
  file_type: z.string(),
  file_url: z.url(),
  folder_id: z.uuid().nullable().optional(),
  id: z.uuid().optional(),
  uploaded_at: z.iso.datetime().nullable().optional(),
  user_id: z.uuid(),
});

export const filesUpdateSchema = z.object({
  file_name: z.string().min(1, "Name cannot be empty").max(255, "Name is too long").optional(),
  file_route: z.string().optional(),
  file_size: z.string().optional(),
  file_type: z.string().optional(),
  file_url: z.url().optional(),
  folder_id: z.uuid().nullable().optional(),
  id: z.uuid().optional(),
  uploaded_at: z.iso.datetime().nullable().optional(),
  user_id: z.uuid().optional(),
});

export const foldersRowSchema = z.object({
  created_at: z.iso.datetime().nullable(),
  id: z.uuid(),
  name: z.string().min(1, "Name cannot be empty").max(255, "Name is too long"),
  user_id: z.uuid(),
});

export const foldersInsertSchema = z.object({
  created_at: z.iso.datetime().nullable().optional(),
  id: z.uuid().optional(),
  name: z.string().min(1, "Name cannot be empty").max(255, "Name is too long"),
  user_id: z.uuid(),
});

export const foldersUpdateSchema = z.object({
  created_at: z.iso.datetime().nullable().optional(),
  id: z.uuid().optional(),
  name: z.string().min(1, "Name cannot be empty").max(255, "Name is too long").optional(),
  user_id: z.uuid().optional(),
});

export const junction_closuresRowSchema = z.object({
  created_at: z.iso.datetime().nullable(),
  id: z.uuid(),
  node_id: z.uuid(),
  ofc_cable_id: z.uuid(),
  position_km: z.number().nullable(),
  updated_at: z.iso.datetime().nullable(),
});

export const junction_closuresInsertSchema = z.object({
  created_at: z.iso.datetime().nullable().optional(),
  id: z.uuid().optional(),
  node_id: z.uuid(),
  ofc_cable_id: z.uuid(),
  position_km: z.number().nullable().optional(),
  updated_at: z.iso.datetime().nullable().optional(),
});

export const junction_closuresUpdateSchema = z.object({
  created_at: z.iso.datetime().nullable().optional(),
  id: z.uuid().optional(),
  node_id: z.uuid().optional(),
  ofc_cable_id: z.uuid().optional(),
  position_km: z.number().nullable().optional(),
  updated_at: z.iso.datetime().nullable().optional(),
});

export const logical_fiber_pathsRowSchema = z.object({
  bandwidth_gbps: z.number().nullable(),
  commissioned_date: z.iso.datetime().nullable(),
  created_at: z.iso.datetime().nullable(),
  destination_port: z.string().nullable(),
  destination_system_id: z.uuid().nullable(),
  id: z.uuid(),
  operational_status_id: z.uuid().nullable(),
  path_name: z.string().min(1, "Name cannot be empty").max(255, "Name is too long").nullable(),
  path_role: z.string(),
  path_type_id: z.uuid().nullable(),
  remark: z.string().nullable(),
  service_type: z.string().nullable(),
  source_port: z.string().nullable(),
  source_system_id: z.uuid().nullable(),
  total_distance_km: z.number().nullable(),
  total_loss_db: z.number().nullable(),
  updated_at: z.iso.datetime().nullable(),
  wavelength_nm: z.number().nullable(),
  working_path_id: z.uuid().nullable(),
});

export const logical_fiber_pathsInsertSchema = z.object({
  bandwidth_gbps: z.number().nullable().optional(),
  commissioned_date: z.iso.datetime().nullable().optional(),
  created_at: z.iso.datetime().nullable().optional(),
  destination_port: z.string().nullable().optional(),
  destination_system_id: z.uuid().nullable().optional(),
  id: z.uuid().optional(),
  operational_status_id: z.uuid().nullable().optional(),
  path_name: z.string().min(1, "Name cannot be empty").max(255, "Name is too long").nullable().optional(),
  path_role: z.string().optional(),
  path_type_id: z.uuid().nullable().optional(),
  remark: z.string().nullable().optional(),
  service_type: z.string().nullable().optional(),
  source_port: z.string().nullable().optional(),
  source_system_id: z.uuid().nullable().optional(),
  total_distance_km: z.number().nullable().optional(),
  total_loss_db: z.number().nullable().optional(),
  updated_at: z.iso.datetime().nullable().optional(),
  wavelength_nm: z.number().nullable().optional(),
  working_path_id: z.uuid().nullable().optional(),
});

export const logical_fiber_pathsUpdateSchema = z.object({
  bandwidth_gbps: z.number().nullable().optional(),
  commissioned_date: z.iso.datetime().nullable().optional(),
  created_at: z.iso.datetime().nullable().optional(),
  destination_port: z.string().nullable().optional(),
  destination_system_id: z.uuid().nullable().optional(),
  id: z.uuid().optional(),
  operational_status_id: z.uuid().nullable().optional(),
  path_name: z.string().min(1, "Name cannot be empty").max(255, "Name is too long").nullable().optional(),
  path_role: z.string().optional(),
  path_type_id: z.uuid().nullable().optional(),
  remark: z.string().nullable().optional(),
  service_type: z.string().nullable().optional(),
  source_port: z.string().nullable().optional(),
  source_system_id: z.uuid().nullable().optional(),
  total_distance_km: z.number().nullable().optional(),
  total_loss_db: z.number().nullable().optional(),
  updated_at: z.iso.datetime().nullable().optional(),
  wavelength_nm: z.number().nullable().optional(),
  working_path_id: z.uuid().nullable().optional(),
});

export const lookup_typesRowSchema = z.object({
  category: z.string(),
  code: z.string().nullable(),
  created_at: z.iso.datetime().nullable(),
  description: z.string().max(10000, "Text is too long").nullable(),
  id: z.uuid(),
  is_system_default: z.boolean().nullable(),
  name: z.string().min(1, "Name cannot be empty").max(255, "Name is too long"),
  sort_order: z.number().nullable(),
  status: z.boolean().nullable(),
  updated_at: z.iso.datetime().nullable(),
});

export const lookup_typesInsertSchema = z.object({
  category: z.string(),
  code: z.string().nullable().optional(),
  created_at: z.iso.datetime().nullable().optional(),
  description: z.string().max(10000, "Text is too long").nullable().optional(),
  id: z.uuid().optional(),
  is_system_default: z.boolean().nullable().optional(),
  name: z.string().min(1, "Name cannot be empty").max(255, "Name is too long"),
  sort_order: z.number().nullable().optional(),
  status: z.boolean().nullable().optional(),
  updated_at: z.iso.datetime().nullable().optional(),
});

export const lookup_typesUpdateSchema = z.object({
  category: z.string().optional(),
  code: z.string().nullable().optional(),
  created_at: z.iso.datetime().nullable().optional(),
  description: z.string().max(10000, "Text is too long").nullable().optional(),
  id: z.uuid().optional(),
  is_system_default: z.boolean().nullable().optional(),
  name: z.string().min(1, "Name cannot be empty").max(255, "Name is too long").optional(),
  sort_order: z.number().nullable().optional(),
  status: z.boolean().nullable().optional(),
  updated_at: z.iso.datetime().nullable().optional(),
});

export const maintenance_areasRowSchema = z.object({
  address: z.string().min(5, "Address must be at least 5 characters").max(500).nullable(),
  area_type_id: z.uuid().nullable(),
  code: z.string().nullable(),
  contact_number: z.string().nullable(),
  contact_person: z.string().nullable(),
  created_at: z.iso.datetime().nullable(),
  email: z.email().nullable(),
  id: z.uuid(),
  latitude: z.number().nullable(),
  longitude: z.number().nullable(),
  name: z.string().min(1, "Name cannot be empty").max(255, "Name is too long"),
  parent_id: z.uuid().nullable(),
  status: z.boolean().nullable(),
  updated_at: z.iso.datetime().nullable(),
});

export const maintenance_areasInsertSchema = z.object({
  address: z.string().min(5, "Address must be at least 5 characters").max(500).nullable().optional(),
  area_type_id: z.uuid().nullable().optional(),
  code: z.string().nullable().optional(),
  contact_number: z.string().nullable().optional(),
  contact_person: z.string().nullable().optional(),
  created_at: z.iso.datetime().nullable().optional(),
  email: z.email().nullable().optional(),
  id: z.uuid().optional(),
  latitude: z.number().nullable().optional(),
  longitude: z.number().nullable().optional(),
  name: z.string().min(1, "Name cannot be empty").max(255, "Name is too long"),
  parent_id: z.uuid().nullable().optional(),
  status: z.boolean().nullable().optional(),
  updated_at: z.iso.datetime().nullable().optional(),
});

export const maintenance_areasUpdateSchema = z.object({
  address: z.string().min(5, "Address must be at least 5 characters").max(500).nullable().optional(),
  area_type_id: z.uuid().nullable().optional(),
  code: z.string().nullable().optional(),
  contact_number: z.string().nullable().optional(),
  contact_person: z.string().nullable().optional(),
  created_at: z.iso.datetime().nullable().optional(),
  email: z.email().nullable().optional(),
  id: z.uuid().optional(),
  latitude: z.number().nullable().optional(),
  longitude: z.number().nullable().optional(),
  name: z.string().min(1, "Name cannot be empty").max(255, "Name is too long").optional(),
  parent_id: z.uuid().nullable().optional(),
  status: z.boolean().nullable().optional(),
  updated_at: z.iso.datetime().nullable().optional(),
});

export const management_portsRowSchema = z.object({
  commissioned_on: z.string().nullable(),
  created_at: z.iso.datetime().nullable(),
  id: z.uuid(),
  name: z.string().min(1, "Name cannot be empty").max(255, "Name is too long").nullable(),
  node_id: z.uuid().nullable(),
  port_no: z.string(),
  remark: z.string().nullable(),
  status: z.boolean().nullable(),
  system_id: z.uuid().nullable(),
  updated_at: z.iso.datetime().nullable(),
});

export const management_portsInsertSchema = z.object({
  commissioned_on: z.string().nullable().optional(),
  created_at: z.iso.datetime().nullable().optional(),
  id: z.uuid().optional(),
  name: z.string().min(1, "Name cannot be empty").max(255, "Name is too long").nullable().optional(),
  node_id: z.uuid().nullable().optional(),
  port_no: z.string(),
  remark: z.string().nullable().optional(),
  status: z.boolean().nullable().optional(),
  system_id: z.uuid().nullable().optional(),
  updated_at: z.iso.datetime().nullable().optional(),
});

export const management_portsUpdateSchema = z.object({
  commissioned_on: z.string().nullable().optional(),
  created_at: z.iso.datetime().nullable().optional(),
  id: z.uuid().optional(),
  name: z.string().min(1, "Name cannot be empty").max(255, "Name is too long").nullable().optional(),
  node_id: z.uuid().nullable().optional(),
  port_no: z.string().optional(),
  remark: z.string().nullable().optional(),
  status: z.boolean().nullable().optional(),
  system_id: z.uuid().nullable().optional(),
  updated_at: z.iso.datetime().nullable().optional(),
});

export const nodesRowSchema = z.object({
  created_at: z.iso.datetime().nullable(),
  id: z.uuid(),
  latitude: z.number().nullable(),
  longitude: z.number().nullable(),
  maintenance_terminal_id: z.uuid().nullable(),
  name: z.string().min(1, "Name cannot be empty").max(255, "Name is too long"),
  node_type_id: z.uuid().nullable(),
  remark: z.string().nullable(),
  status: z.boolean().nullable(),
  updated_at: z.iso.datetime().nullable(),
});

export const nodesInsertSchema = z.object({
  created_at: z.iso.datetime().nullable().optional(),
  id: z.uuid().optional(),
  latitude: z.number().nullable().optional(),
  longitude: z.number().nullable().optional(),
  maintenance_terminal_id: z.uuid().nullable().optional(),
  name: z.string().min(1, "Name cannot be empty").max(255, "Name is too long"),
  node_type_id: z.uuid().nullable().optional(),
  remark: z.string().nullable().optional(),
  status: z.boolean().nullable().optional(),
  updated_at: z.iso.datetime().nullable().optional(),
});

export const nodesUpdateSchema = z.object({
  created_at: z.iso.datetime().nullable().optional(),
  id: z.uuid().optional(),
  latitude: z.number().nullable().optional(),
  longitude: z.number().nullable().optional(),
  maintenance_terminal_id: z.uuid().nullable().optional(),
  name: z.string().min(1, "Name cannot be empty").max(255, "Name is too long").optional(),
  node_type_id: z.uuid().nullable().optional(),
  remark: z.string().nullable().optional(),
  status: z.boolean().nullable().optional(),
  updated_at: z.iso.datetime().nullable().optional(),
});

export const ofc_cablesRowSchema = z.object({
  asset_no: z.string().nullable(),
  capacity: z.number(),
  commissioned_on: z.string().nullable(),
  created_at: z.iso.datetime().nullable(),
  current_rkm: z.number().nullable(),
  en_id: z.uuid(),
  id: z.uuid(),
  maintenance_terminal_id: z.uuid().nullable(),
  ofc_owner_id: z.uuid(),
  ofc_type_id: z.uuid(),
  remark: z.string().nullable(),
  route_name: z.string().min(1, "Name cannot be empty").max(255, "Name is too long"),
  sn_id: z.uuid(),
  status: z.boolean().nullable(),
  transnet_id: z.uuid().nullable(),
  transnet_rkm: z.number().nullable(),
  updated_at: z.iso.datetime().nullable(),
});

export const ofc_cablesInsertSchema = z.object({
  asset_no: z.string().nullable().optional(),
  capacity: z.number(),
  commissioned_on: z.string().nullable().optional(),
  created_at: z.iso.datetime().nullable().optional(),
  current_rkm: z.number().nullable().optional(),
  en_id: z.uuid(),
  id: z.uuid().optional(),
  maintenance_terminal_id: z.uuid().nullable().optional(),
  ofc_owner_id: z.uuid(),
  ofc_type_id: z.uuid(),
  remark: z.string().nullable().optional(),
  route_name: z.string().min(1, "Name cannot be empty").max(255, "Name is too long"),
  sn_id: z.uuid(),
  status: z.boolean().nullable().optional(),
  transnet_id: z.uuid().nullable().optional(),
  transnet_rkm: z.number().nullable().optional(),
  updated_at: z.iso.datetime().nullable().optional(),
});

export const ofc_cablesUpdateSchema = z.object({
  asset_no: z.string().nullable().optional(),
  capacity: z.number().optional(),
  commissioned_on: z.string().nullable().optional(),
  created_at: z.iso.datetime().nullable().optional(),
  current_rkm: z.number().nullable().optional(),
  en_id: z.uuid().optional(),
  id: z.uuid().optional(),
  maintenance_terminal_id: z.uuid().nullable().optional(),
  ofc_owner_id: z.uuid().optional(),
  ofc_type_id: z.uuid().optional(),
  remark: z.string().nullable().optional(),
  route_name: z.string().min(1, "Name cannot be empty").max(255, "Name is too long").optional(),
  sn_id: z.uuid().optional(),
  status: z.boolean().nullable().optional(),
  transnet_id: z.uuid().nullable().optional(),
  transnet_rkm: z.number().nullable().optional(),
  updated_at: z.iso.datetime().nullable().optional(),
});

export const ofc_connectionsRowSchema = z.object({
  connection_category: z.string(),
  connection_type: z.string(),
  created_at: z.iso.datetime().nullable(),
  destination_port: z.string().nullable(),
  en_dom: z.string().nullable(),
  en_power_dbm: z.number().nullable(),
  fiber_no_en: z.number(),
  fiber_no_sn: z.number(),
  fiber_role: z.string().nullable(),
  id: z.uuid(),
  logical_path_id: z.uuid().nullable(),
  ofc_id: z.uuid(),
  otdr_distance_en_km: z.number().nullable(),
  otdr_distance_sn_km: z.number().nullable(),
  path_segment_order: z.number().nullable(),
  remark: z.string().nullable(),
  route_loss_db: z.number().nullable(),
  sn_dom: z.string().nullable(),
  sn_power_dbm: z.number().nullable(),
  source_port: z.string().nullable(),
  status: z.boolean().nullable(),
  system_id: z.uuid().nullable(),
  updated_at: z.iso.datetime().nullable(),
});

export const ofc_connectionsInsertSchema = z.object({
  connection_category: z.string().optional(),
  connection_type: z.string().optional(),
  created_at: z.iso.datetime().nullable().optional(),
  destination_port: z.string().nullable().optional(),
  en_dom: z.string().nullable().optional(),
  en_power_dbm: z.number().nullable().optional(),
  fiber_no_en: z.number(),
  fiber_no_sn: z.number(),
  fiber_role: z.string().nullable().optional(),
  id: z.uuid().optional(),
  logical_path_id: z.uuid().nullable().optional(),
  ofc_id: z.uuid(),
  otdr_distance_en_km: z.number().nullable().optional(),
  otdr_distance_sn_km: z.number().nullable().optional(),
  path_segment_order: z.number().nullable().optional(),
  remark: z.string().nullable().optional(),
  route_loss_db: z.number().nullable().optional(),
  sn_dom: z.string().nullable().optional(),
  sn_power_dbm: z.number().nullable().optional(),
  source_port: z.string().nullable().optional(),
  status: z.boolean().nullable().optional(),
  system_id: z.uuid().nullable().optional(),
  updated_at: z.iso.datetime().nullable().optional(),
});

export const ofc_connectionsUpdateSchema = z.object({
  connection_category: z.string().optional(),
  connection_type: z.string().optional(),
  created_at: z.iso.datetime().nullable().optional(),
  destination_port: z.string().nullable().optional(),
  en_dom: z.string().nullable().optional(),
  en_power_dbm: z.number().nullable().optional(),
  fiber_no_en: z.number().optional(),
  fiber_no_sn: z.number().optional(),
  fiber_role: z.string().nullable().optional(),
  id: z.uuid().optional(),
  logical_path_id: z.uuid().nullable().optional(),
  ofc_id: z.uuid().optional(),
  otdr_distance_en_km: z.number().nullable().optional(),
  otdr_distance_sn_km: z.number().nullable().optional(),
  path_segment_order: z.number().nullable().optional(),
  remark: z.string().nullable().optional(),
  route_loss_db: z.number().nullable().optional(),
  sn_dom: z.string().nullable().optional(),
  sn_power_dbm: z.number().nullable().optional(),
  source_port: z.string().nullable().optional(),
  status: z.boolean().nullable().optional(),
  system_id: z.uuid().nullable().optional(),
  updated_at: z.iso.datetime().nullable().optional(),
});

export const ring_based_systemsRowSchema = z.object({
  maintenance_area_id: z.uuid().nullable(),
  ring_id: z.uuid().nullable(),
  system_id: z.uuid(),
});

export const ring_based_systemsInsertSchema = z.object({
  maintenance_area_id: z.uuid().nullable().optional(),
  ring_id: z.uuid().nullable().optional(),
  system_id: z.uuid(),
});

export const ring_based_systemsUpdateSchema = z.object({
  maintenance_area_id: z.uuid().nullable().optional(),
  ring_id: z.uuid().nullable().optional(),
  system_id: z.uuid().optional(),
});

export const ringsRowSchema = z.object({
  created_at: z.iso.datetime().nullable(),
  description: z.string().max(10000, "Text is too long").nullable(),
  id: z.uuid(),
  maintenance_terminal_id: z.uuid().nullable(),
  name: z.string().min(1, "Name cannot be empty").max(255, "Name is too long"),
  ring_type_id: z.uuid().nullable(),
  status: z.boolean().nullable(),
  total_nodes: z.number().nullable(),
  updated_at: z.iso.datetime().nullable(),
});

export const ringsInsertSchema = z.object({
  created_at: z.iso.datetime().nullable().optional(),
  description: z.string().max(10000, "Text is too long").nullable().optional(),
  id: z.uuid().optional(),
  maintenance_terminal_id: z.uuid().nullable().optional(),
  name: z.string().min(1, "Name cannot be empty").max(255, "Name is too long"),
  ring_type_id: z.uuid().nullable().optional(),
  status: z.boolean().nullable().optional(),
  total_nodes: z.number().nullable().optional(),
  updated_at: z.iso.datetime().nullable().optional(),
});

export const ringsUpdateSchema = z.object({
  created_at: z.iso.datetime().nullable().optional(),
  description: z.string().max(10000, "Text is too long").nullable().optional(),
  id: z.uuid().optional(),
  maintenance_terminal_id: z.uuid().nullable().optional(),
  name: z.string().min(1, "Name cannot be empty").max(255, "Name is too long").optional(),
  ring_type_id: z.uuid().nullable().optional(),
  status: z.boolean().nullable().optional(),
  total_nodes: z.number().nullable().optional(),
  updated_at: z.iso.datetime().nullable().optional(),
});

export const sdh_connectionsRowSchema = z.object({
  a_customer: z.string().nullable(),
  a_slot: z.string().nullable(),
  b_customer: z.string().nullable(),
  b_slot: z.string().nullable(),
  carrier: z.string().nullable(),
  stm_no: z.string().nullable(),
  system_connection_id: z.uuid(),
});

export const sdh_connectionsInsertSchema = z.object({
  a_customer: z.string().nullable().optional(),
  a_slot: z.string().nullable().optional(),
  b_customer: z.string().nullable().optional(),
  b_slot: z.string().nullable().optional(),
  carrier: z.string().nullable().optional(),
  stm_no: z.string().nullable().optional(),
  system_connection_id: z.uuid(),
});

export const sdh_connectionsUpdateSchema = z.object({
  a_customer: z.string().nullable().optional(),
  a_slot: z.string().nullable().optional(),
  b_customer: z.string().nullable().optional(),
  b_slot: z.string().nullable().optional(),
  carrier: z.string().nullable().optional(),
  stm_no: z.string().nullable().optional(),
  system_connection_id: z.uuid().optional(),
});

export const sdh_node_associationsRowSchema = z.object({
  id: z.uuid(),
  node_id: z.uuid(),
  node_ip: z.string().nullable(),
  node_position: z.string().nullable(),
  sdh_system_id: z.uuid(),
});

export const sdh_node_associationsInsertSchema = z.object({
  id: z.uuid().optional(),
  node_id: z.uuid(),
  node_ip: z.string().nullable().optional(),
  node_position: z.string().nullable().optional(),
  sdh_system_id: z.uuid(),
});

export const sdh_node_associationsUpdateSchema = z.object({
  id: z.uuid().optional(),
  node_id: z.uuid().optional(),
  node_ip: z.string().nullable().optional(),
  node_position: z.string().nullable().optional(),
  sdh_system_id: z.uuid().optional(),
});

export const sdh_systemsRowSchema = z.object({
  gne: z.string().nullable(),
  make: z.string().nullable(),
  system_id: z.uuid(),
});

export const sdh_systemsInsertSchema = z.object({
  gne: z.string().nullable().optional(),
  make: z.string().nullable().optional(),
  system_id: z.uuid(),
});

export const sdh_systemsUpdateSchema = z.object({
  gne: z.string().nullable().optional(),
  make: z.string().nullable().optional(),
  system_id: z.uuid().optional(),
});

export const sfp_based_connectionsRowSchema = z.object({
  bandwidth_allocated_mbps: z.number().nullable(),
  customer_name: z.string().min(1, "Name cannot be empty").max(255, "Name is too long").nullable(),
  fiber_in: z.number().nullable(),
  fiber_out: z.number().nullable(),
  sfp_capacity: z.string().nullable(),
  sfp_port: z.string().nullable(),
  sfp_serial_no: z.string().nullable(),
  sfp_type_id: z.uuid().nullable(),
  system_connection_id: z.uuid(),
});

export const sfp_based_connectionsInsertSchema = z.object({
  bandwidth_allocated_mbps: z.number().nullable().optional(),
  customer_name: z.string().min(1, "Name cannot be empty").max(255, "Name is too long").nullable().optional(),
  fiber_in: z.number().nullable().optional(),
  fiber_out: z.number().nullable().optional(),
  sfp_capacity: z.string().nullable().optional(),
  sfp_port: z.string().nullable().optional(),
  sfp_serial_no: z.string().nullable().optional(),
  sfp_type_id: z.uuid().nullable().optional(),
  system_connection_id: z.uuid(),
});

export const sfp_based_connectionsUpdateSchema = z.object({
  bandwidth_allocated_mbps: z.number().nullable().optional(),
  customer_name: z.string().min(1, "Name cannot be empty").max(255, "Name is too long").nullable().optional(),
  fiber_in: z.number().nullable().optional(),
  fiber_out: z.number().nullable().optional(),
  sfp_capacity: z.string().nullable().optional(),
  sfp_port: z.string().nullable().optional(),
  sfp_serial_no: z.string().nullable().optional(),
  sfp_type_id: z.uuid().nullable().optional(),
  system_connection_id: z.uuid().optional(),
});

export const system_connectionsRowSchema = z.object({
  bandwidth_mbps: z.number().nullable(),
  commissioned_on: z.string().nullable(),
  connected_system_id: z.uuid().nullable(),
  created_at: z.iso.datetime().nullable(),
  en_id: z.uuid().nullable(),
  en_interface: z.string().nullable(),
  en_ip: z.string().nullable(),
  id: z.uuid(),
  media_type_id: z.uuid().nullable(),
  remark: z.string().nullable(),
  sn_id: z.uuid().nullable(),
  sn_interface: z.string().nullable(),
  sn_ip: z.string().nullable(),
  status: z.boolean().nullable(),
  system_id: z.uuid(),
  updated_at: z.iso.datetime().nullable(),
  vlan: z.string().nullable(),
});

export const system_connectionsInsertSchema = z.object({
  bandwidth_mbps: z.number().nullable().optional(),
  commissioned_on: z.string().nullable().optional(),
  connected_system_id: z.uuid().nullable().optional(),
  created_at: z.iso.datetime().nullable().optional(),
  en_id: z.uuid().nullable().optional(),
  en_interface: z.string().nullable().optional(),
  en_ip: z.string().nullable().optional(),
  id: z.uuid().optional(),
  media_type_id: z.uuid().nullable().optional(),
  remark: z.string().nullable().optional(),
  sn_id: z.uuid().nullable().optional(),
  sn_interface: z.string().nullable().optional(),
  sn_ip: z.string().nullable().optional(),
  status: z.boolean().nullable().optional(),
  system_id: z.uuid(),
  updated_at: z.iso.datetime().nullable().optional(),
  vlan: z.string().nullable().optional(),
});

export const system_connectionsUpdateSchema = z.object({
  bandwidth_mbps: z.number().nullable().optional(),
  commissioned_on: z.string().nullable().optional(),
  connected_system_id: z.uuid().nullable().optional(),
  created_at: z.iso.datetime().nullable().optional(),
  en_id: z.uuid().nullable().optional(),
  en_interface: z.string().nullable().optional(),
  en_ip: z.string().nullable().optional(),
  id: z.uuid().optional(),
  media_type_id: z.uuid().nullable().optional(),
  remark: z.string().nullable().optional(),
  sn_id: z.uuid().nullable().optional(),
  sn_interface: z.string().nullable().optional(),
  sn_ip: z.string().nullable().optional(),
  status: z.boolean().nullable().optional(),
  system_id: z.uuid().optional(),
  updated_at: z.iso.datetime().nullable().optional(),
  vlan: z.string().nullable().optional(),
});

export const systemsRowSchema = z.object({
  commissioned_on: z.string().nullable(),
  created_at: z.iso.datetime().nullable(),
  id: z.uuid(),
  ip_address: z.string().nullable(),
  maintenance_terminal_id: z.uuid().nullable(),
  node_id: z.uuid(),
  remark: z.string().nullable(),
  s_no: z.string().nullable(),
  status: z.boolean().nullable(),
  system_name: z.string().min(1, "Name cannot be empty").max(255, "Name is too long").nullable(),
  system_type_id: z.uuid(),
  updated_at: z.iso.datetime().nullable(),
});

export const systemsInsertSchema = z.object({
  commissioned_on: z.string().nullable().optional(),
  created_at: z.iso.datetime().nullable().optional(),
  id: z.uuid().optional(),
  ip_address: z.string().nullable().optional(),
  maintenance_terminal_id: z.uuid().nullable().optional(),
  node_id: z.uuid(),
  remark: z.string().nullable().optional(),
  s_no: z.string().nullable().optional(),
  status: z.boolean().nullable().optional(),
  system_name: z.string().min(1, "Name cannot be empty").max(255, "Name is too long").nullable().optional(),
  system_type_id: z.uuid(),
  updated_at: z.iso.datetime().nullable().optional(),
});

export const systemsUpdateSchema = z.object({
  commissioned_on: z.string().nullable().optional(),
  created_at: z.iso.datetime().nullable().optional(),
  id: z.uuid().optional(),
  ip_address: z.string().nullable().optional(),
  maintenance_terminal_id: z.uuid().nullable().optional(),
  node_id: z.uuid().optional(),
  remark: z.string().nullable().optional(),
  s_no: z.string().nullable().optional(),
  status: z.boolean().nullable().optional(),
  system_name: z.string().min(1, "Name cannot be empty").max(255, "Name is too long").nullable().optional(),
  system_type_id: z.uuid().optional(),
  updated_at: z.iso.datetime().nullable().optional(),
});

export const user_profilesRowSchema = z.object({
  address: z.any().nullable(),
  avatar_url: z.url().nullable(),
  created_at: z.iso.datetime().nullable(),
  date_of_birth: z.iso.datetime().nullable(),
  designation: z.string().nullable(),
  first_name: z.string().min(1, "Name cannot be empty").max(255, "Name is too long"),
  id: z.uuid(),
  last_name: z.string().min(1, "Name cannot be empty").max(255, "Name is too long"),
  phone_number: z.string().regex(/^[+]?[1-9]?[0-9]{7,15}$/, "Invalid phone number").nullable(),
  preferences: z.any().nullable(),
  role: z.enum(UserRole).nullable(),
  status: z.string().min(1, "Status cannot be empty").nullable(),
  updated_at: z.iso.datetime().nullable(),
});

export const user_profilesInsertSchema = z.object({
  address: z.any().nullable().optional(),
  avatar_url: z.url().nullable().optional(),
  created_at: z.iso.datetime().nullable().optional(),
  date_of_birth: z.iso.datetime().nullable().optional(),
  designation: z.string().nullable().optional(),
  first_name: z.string().min(1, "Name cannot be empty").max(255, "Name is too long"),
  id: z.uuid(),
  last_name: z.string().min(1, "Name cannot be empty").max(255, "Name is too long"),
  phone_number: z.string().regex(/^[+]?[1-9]?[0-9]{7,15}$/, "Invalid phone number").nullable().optional(),
  preferences: z.any().nullable().optional(),
  role: z.enum(UserRole).nullable().optional(),
  status: z.string().min(1, "Status cannot be empty").nullable().optional(),
  updated_at: z.iso.datetime().nullable().optional(),
});

export const user_profilesUpdateSchema = z.object({
  address: z.any().nullable().optional(),
  avatar_url: z.url().nullable().optional(),
  created_at: z.iso.datetime().nullable().optional(),
  date_of_birth: z.iso.datetime().nullable().optional(),
  designation: z.string().nullable().optional(),
  first_name: z.string().min(1, "Name cannot be empty").max(255, "Name is too long").optional(),
  id: z.uuid().optional(),
  last_name: z.string().min(1, "Name cannot be empty").max(255, "Name is too long").optional(),
  phone_number: z.string().regex(/^[+]?[1-9]?[0-9]{7,15}$/, "Invalid phone number").nullable().optional(),
  preferences: z.any().nullable().optional(),
  role: z.enum(UserRole).nullable().optional(),
  status: z.string().min(1, "Status cannot be empty").nullable().optional(),
  updated_at: z.iso.datetime().nullable().optional(),
});

export const vmux_connectionsRowSchema = z.object({
  c_code: z.string().nullable(),
  channel: z.string().nullable(),
  subscriber: z.string().nullable(),
  system_connection_id: z.uuid(),
  tk: z.string().nullable(),
});

export const vmux_connectionsInsertSchema = z.object({
  c_code: z.string().nullable().optional(),
  channel: z.string().nullable().optional(),
  subscriber: z.string().nullable().optional(),
  system_connection_id: z.uuid(),
  tk: z.string().nullable().optional(),
});

export const vmux_connectionsUpdateSchema = z.object({
  c_code: z.string().nullable().optional(),
  channel: z.string().nullable().optional(),
  subscriber: z.string().nullable().optional(),
  system_connection_id: z.uuid().optional(),
  tk: z.string().nullable().optional(),
});

export const vmux_systemsRowSchema = z.object({
  system_id: z.uuid(),
  vm_id: z.uuid().nullable(),
});

export const vmux_systemsInsertSchema = z.object({
  system_id: z.uuid(),
  vm_id: z.uuid().nullable().optional(),
});

export const vmux_systemsUpdateSchema = z.object({
  system_id: z.uuid().optional(),
  vm_id: z.uuid().nullable().optional(),
});

export const v_employee_designations_with_countRowSchema = z.object({
  active_count: z.number().int().min(0).nullable(),
  created_at: z.iso.datetime().nullable(),
  id: z.uuid().nullable(),
  inactive_count: z.number().int().min(0).nullable(),
  name: z.string().min(1, "Name cannot be empty").max(255, "Name is too long").nullable(),
  parent_id: z.uuid().nullable(),
  status: z.boolean().nullable(),
  total_count: z.number().int().min(0).nullable(),
  updated_at: z.iso.datetime().nullable(),
});

export const v_employees_with_countRowSchema = z.object({
  active_count: z.number().int().min(0).nullable(),
  created_at: z.iso.datetime().nullable(),
  employee_addr: z.string().min(5, "Address must be at least 5 characters").max(500).nullable(),
  employee_contact: z.string().nullable(),
  employee_designation_id: z.uuid().nullable(),
  employee_designation_name: z.string().min(1, "Name cannot be empty").max(255, "Name is too long").nullable(),
  employee_dob: z.iso.date().nullable(),
  employee_doj: z.iso.date().nullable(),
  employee_email: z.email().nullable(),
  employee_name: z.string().min(1, "Name cannot be empty").max(255, "Name is too long").nullable(),
  employee_pers_no: z.string().nullable(),
  id: z.uuid().nullable(),
  inactive_count: z.number().int().min(0).nullable(),
  maintenance_terminal_id: z.uuid().nullable(),
  remark: z.string().nullable(),
  status: z.boolean().nullable(),
  total_count: z.number().int().min(0).nullable(),
  updated_at: z.iso.datetime().nullable(),
});

export const v_junction_closures_completeRowSchema = z.object({
  id: z.uuid().nullable(),
  latitude: z.number().nullable(),
  longitude: z.number().nullable(),
  name: z.string().min(1, "Name cannot be empty").max(255, "Name is too long").nullable(),
  node_id: z.uuid().nullable(),
  ofc_cable_id: z.uuid().nullable(),
  position_km: z.number().nullable(),
});

export const v_lookup_types_with_countRowSchema = z.object({
  active_count: z.number().int().min(0).nullable(),
  category: z.string().nullable(),
  code: z.string().nullable(),
  created_at: z.iso.datetime().nullable(),
  description: z.string().max(10000, "Text is too long").nullable(),
  id: z.uuid().nullable(),
  inactive_count: z.number().int().min(0).nullable(),
  is_system_default: z.boolean().nullable(),
  name: z.string().min(1, "Name cannot be empty").max(255, "Name is too long").nullable(),
  sort_order: z.number().nullable(),
  status: z.boolean().nullable(),
  total_count: z.number().int().min(0).nullable(),
  updated_at: z.iso.datetime().nullable(),
});

export const v_maintenance_areas_with_countRowSchema = z.object({
  active_count: z.number().int().min(0).nullable(),
  address: z.string().min(5, "Address must be at least 5 characters").max(500).nullable(),
  area_type_id: z.uuid().nullable(),
  code: z.string().nullable(),
  contact_number: z.string().nullable(),
  contact_person: z.string().nullable(),
  created_at: z.iso.datetime().nullable(),
  email: z.email().nullable(),
  id: z.uuid().nullable(),
  inactive_count: z.number().int().min(0).nullable(),
  latitude: z.number().nullable(),
  longitude: z.number().nullable(),
  maintenance_area_type_category: z.string().nullable(),
  maintenance_area_type_code: z.string().nullable(),
  maintenance_area_type_created_at: z.iso.datetime().nullable(),
  maintenance_area_type_is_system_default: z.boolean().nullable(),
  maintenance_area_type_name: z.string().min(1, "Name cannot be empty").max(255, "Name is too long").nullable(),
  maintenance_area_type_sort_order: z.number().nullable(),
  maintenance_area_type_status: z.boolean().nullable(),
  maintenance_area_type_updated_at: z.iso.datetime().nullable(),
  name: z.string().min(1, "Name cannot be empty").max(255, "Name is too long").nullable(),
  parent_id: z.uuid().nullable(),
  status: z.boolean().nullable(),
  total_count: z.number().int().min(0).nullable(),
  updated_at: z.iso.datetime().nullable(),
});

export const v_nodes_completeRowSchema = z.object({
  active_count: z.number().int().min(0).nullable(),
  created_at: z.iso.datetime().nullable(),
  id: z.uuid().nullable(),
  inactive_count: z.number().int().min(0).nullable(),
  latitude: z.number().nullable(),
  longitude: z.number().nullable(),
  maintenance_area_code: z.string().nullable(),
  maintenance_area_name: z.string().min(1, "Name cannot be empty").max(255, "Name is too long").nullable(),
  maintenance_area_type_name: z.string().min(1, "Name cannot be empty").max(255, "Name is too long").nullable(),
  maintenance_terminal_id: z.uuid().nullable(),
  name: z.string().min(1, "Name cannot be empty").max(255, "Name is too long").nullable(),
  node_type_code: z.string().nullable(),
  node_type_id: z.uuid().nullable(),
  node_type_name: z.string().min(1, "Name cannot be empty").max(255, "Name is too long").nullable(),
  remark: z.string().nullable(),
  status: z.boolean().nullable(),
  total_count: z.number().int().min(0).nullable(),
  updated_at: z.iso.datetime().nullable(),
});

export const v_ofc_cables_completeRowSchema = z.object({
  active_count: z.number().int().min(0).nullable(),
  asset_no: z.string().nullable(),
  capacity: z.number().nullable(),
  commissioned_on: z.string().nullable(),
  created_at: z.iso.datetime().nullable(),
  current_rkm: z.number().nullable(),
  en_id: z.uuid().nullable(),
  en_name: z.string().min(1, "Name cannot be empty").max(255, "Name is too long").nullable(),
  id: z.uuid().nullable(),
  inactive_count: z.number().int().min(0).nullable(),
  maintenance_area_code: z.string().nullable(),
  maintenance_area_name: z.string().min(1, "Name cannot be empty").max(255, "Name is too long").nullable(),
  maintenance_terminal_id: z.uuid().nullable(),
  ofc_owner_code: z.string().nullable(),
  ofc_owner_id: z.uuid().nullable(),
  ofc_owner_name: z.string().min(1, "Name cannot be empty").max(255, "Name is too long").nullable(),
  ofc_type_code: z.string().nullable(),
  ofc_type_id: z.uuid().nullable(),
  ofc_type_name: z.string().min(1, "Name cannot be empty").max(255, "Name is too long").nullable(),
  remark: z.string().nullable(),
  route_name: z.string().min(1, "Name cannot be empty").max(255, "Name is too long").nullable(),
  sn_id: z.uuid().nullable(),
  sn_name: z.string().min(1, "Name cannot be empty").max(255, "Name is too long").nullable(),
  status: z.boolean().nullable(),
  total_count: z.number().int().min(0).nullable(),
  transnet_id: z.uuid().nullable(),
  transnet_rkm: z.number().nullable(),
  updated_at: z.iso.datetime().nullable(),
});

export const v_ofc_connections_completeRowSchema = z.object({
  active_count: z.number().int().min(0).nullable(),
  connection_category: z.string().nullable(),
  connection_type: z.string().nullable(),
  created_at: z.iso.datetime().nullable(),
  destination_port: z.string().nullable(),
  en_dom: z.string().nullable(),
  en_id: z.uuid().nullable(),
  en_name: z.string().min(1, "Name cannot be empty").max(255, "Name is too long").nullable(),
  en_power_dbm: z.number().nullable(),
  fiber_no_en: z.number().nullable(),
  fiber_no_sn: z.number().nullable(),
  fiber_role: z.string().nullable(),
  id: z.uuid().nullable(),
  inactive_count: z.number().int().min(0).nullable(),
  logical_path_id: z.uuid().nullable(),
  maintenance_area_name: z.string().min(1, "Name cannot be empty").max(255, "Name is too long").nullable(),
  ofc_id: z.uuid().nullable(),
  ofc_route_name: z.string().min(1, "Name cannot be empty").max(255, "Name is too long").nullable(),
  ofc_type_name: z.string().min(1, "Name cannot be empty").max(255, "Name is too long").nullable(),
  otdr_distance_en_km: z.number().nullable(),
  otdr_distance_sn_km: z.number().nullable(),
  path_segment_order: z.number().nullable(),
  remark: z.string().nullable(),
  route_loss_db: z.number().nullable(),
  sn_dom: z.string().nullable(),
  sn_id: z.uuid().nullable(),
  sn_name: z.string().min(1, "Name cannot be empty").max(255, "Name is too long").nullable(),
  sn_power_dbm: z.number().nullable(),
  source_port: z.string().nullable(),
  status: z.boolean().nullable(),
  system_id: z.uuid().nullable(),
  system_name: z.string().min(1, "Name cannot be empty").max(255, "Name is too long").nullable(),
  total_count: z.number().int().min(0).nullable(),
  updated_at: z.iso.datetime().nullable(),
});

export const v_rings_with_countRowSchema = z.object({
  active_count: z.number().int().min(0).nullable(),
  created_at: z.iso.datetime().nullable(),
  description: z.string().max(10000, "Text is too long").nullable(),
  id: z.uuid().nullable(),
  inactive_count: z.number().int().min(0).nullable(),
  maintenance_area_area_type_id: z.uuid().nullable(),
  maintenance_area_code: z.string().nullable(),
  maintenance_area_contact_number: z.string().nullable(),
  maintenance_area_contact_person: z.string().nullable(),
  maintenance_area_created_at: z.iso.datetime().nullable(),
  maintenance_area_email: z.email().nullable(),
  maintenance_area_latitude: z.number().nullable(),
  maintenance_area_longitude: z.number().nullable(),
  maintenance_area_name: z.string().min(1, "Name cannot be empty").max(255, "Name is too long").nullable(),
  maintenance_area_parent_id: z.uuid().nullable(),
  maintenance_area_status: z.boolean().nullable(),
  maintenance_area_updated_at: z.iso.datetime().nullable(),
  maintenance_terminal_id: z.uuid().nullable(),
  name: z.string().min(1, "Name cannot be empty").max(255, "Name is too long").nullable(),
  ring_type_category: z.string().nullable(),
  ring_type_code: z.string().nullable(),
  ring_type_created_at: z.iso.datetime().nullable(),
  ring_type_id: z.uuid().nullable(),
  ring_type_is_system_default: z.boolean().nullable(),
  ring_type_name: z.string().min(1, "Name cannot be empty").max(255, "Name is too long").nullable(),
  ring_type_sort_order: z.number().nullable(),
  ring_type_status: z.boolean().nullable(),
  ring_type_updated_at: z.iso.datetime().nullable(),
  status: z.boolean().nullable(),
  total_count: z.number().int().min(0).nullable(),
  total_nodes: z.number().nullable(),
  updated_at: z.iso.datetime().nullable(),
});

export const v_system_connections_completeRowSchema = z.object({
  active_count: z.number().int().min(0).nullable(),
  bandwidth_allocated_mbps: z.number().nullable(),
  bandwidth_mbps: z.number().nullable(),
  commissioned_on: z.string().nullable(),
  connected_system_name: z.string().min(1, "Name cannot be empty").max(255, "Name is too long").nullable(),
  connected_system_type_name: z.string().min(1, "Name cannot be empty").max(255, "Name is too long").nullable(),
  created_at: z.iso.datetime().nullable(),
  customer_name: z.string().min(1, "Name cannot be empty").max(255, "Name is too long").nullable(),
  en_interface: z.string().nullable(),
  en_ip: z.string().nullable(),
  en_name: z.string().min(1, "Name cannot be empty").max(255, "Name is too long").nullable(),
  en_node_name: z.string().min(1, "Name cannot be empty").max(255, "Name is too long").nullable(),
  fiber_in: z.number().nullable(),
  fiber_out: z.number().nullable(),
  id: z.uuid().nullable(),
  inactive_count: z.number().int().min(0).nullable(),
  media_type_name: z.string().min(1, "Name cannot be empty").max(255, "Name is too long").nullable(),
  remark: z.string().nullable(),
  sdh_a_customer: z.string().nullable(),
  sdh_a_slot: z.string().nullable(),
  sdh_b_customer: z.string().nullable(),
  sdh_b_slot: z.string().nullable(),
  sdh_carrier: z.string().nullable(),
  sdh_stm_no: z.string().nullable(),
  sfp_capacity: z.string().nullable(),
  sfp_port: z.string().nullable(),
  sfp_serial_no: z.string().nullable(),
  sfp_type_name: z.string().min(1, "Name cannot be empty").max(255, "Name is too long").nullable(),
  sn_interface: z.string().nullable(),
  sn_ip: z.string().nullable(),
  sn_name: z.string().min(1, "Name cannot be empty").max(255, "Name is too long").nullable(),
  sn_node_name: z.string().min(1, "Name cannot be empty").max(255, "Name is too long").nullable(),
  status: z.boolean().nullable(),
  system_id: z.uuid().nullable(),
  system_name: z.string().min(1, "Name cannot be empty").max(255, "Name is too long").nullable(),
  system_type_name: z.string().min(1, "Name cannot be empty").max(255, "Name is too long").nullable(),
  total_count: z.number().int().min(0).nullable(),
  updated_at: z.iso.datetime().nullable(),
  vlan: z.string().nullable(),
  vmux_c_code: z.string().nullable(),
  vmux_channel: z.string().nullable(),
  vmux_subscriber: z.string().nullable(),
  vmux_tk: z.string().nullable(),
});

export const v_systems_completeRowSchema = z.object({
  active_count: z.number().int().min(0).nullable(),
  commissioned_on: z.string().nullable(),
  created_at: z.iso.datetime().nullable(),
  id: z.uuid().nullable(),
  inactive_count: z.number().int().min(0).nullable(),
  ip_address: z.string().nullable(),
  latitude: z.number().nullable(),
  longitude: z.number().nullable(),
  maintenance_terminal_id: z.uuid().nullable(),
  node_id: z.uuid().nullable(),
  node_name: z.string().min(1, "Name cannot be empty").max(255, "Name is too long").nullable(),
  remark: z.string().nullable(),
  ring_id: z.uuid().nullable(),
  ring_logical_area_name: z.string().min(1, "Name cannot be empty").max(255, "Name is too long").nullable(),
  s_no: z.string().nullable(),
  sdh_gne: z.string().nullable(),
  sdh_make: z.string().nullable(),
  status: z.boolean().nullable(),
  system_category: z.string().nullable(),
  system_maintenance_terminal_name: z.string().min(1, "Name cannot be empty").max(255, "Name is too long").nullable(),
  system_name: z.string().min(1, "Name cannot be empty").max(255, "Name is too long").nullable(),
  system_type_code: z.string().nullable(),
  system_type_id: z.uuid().nullable(),
  system_type_name: z.string().min(1, "Name cannot be empty").max(255, "Name is too long").nullable(),
  total_count: z.number().int().min(0).nullable(),
  updated_at: z.iso.datetime().nullable(),
  vmux_vm_id: z.uuid().nullable(),
});

export const v_user_profiles_extendedRowSchema = z.object({
  account_age_days: z.number().int().min(0).max(150).nullable(),
  address: z.any().nullable(),
  auth_updated_at: z.iso.datetime().nullable(),
  avatar_url: z.url().nullable(),
  computed_status: z.string().min(1, "Status cannot be empty").nullable(),
  created_at: z.iso.datetime().nullable(),
  date_of_birth: z.iso.datetime().nullable(),
  designation: z.string().nullable(),
  email: z.email().nullable(),
  email_confirmed_at: z.email().nullable(),
  first_name: z.string().min(1, "Name cannot be empty").max(255, "Name is too long").nullable(),
  full_name: z.string().min(1, "Name cannot be empty").max(255, "Name is too long").nullable(),
  id: z.uuid().nullable(),
  is_email_verified: z.boolean().nullable(),
  is_phone_verified: z.boolean().nullable(),
  is_super_admin: z.boolean().nullable(),
  last_activity_period: z.string().nullable(),
  last_name: z.string().min(1, "Name cannot be empty").max(255, "Name is too long").nullable(),
  last_sign_in_at: z.iso.datetime().nullable(),
  phone_confirmed_at: z.string().regex(/^[+]?[1-9]?[0-9]{7,15}$/, "Invalid phone number").nullable(),
  phone_number: z.string().regex(/^[+]?[1-9]?[0-9]{7,15}$/, "Invalid phone number").nullable(),
  preferences: z.any().nullable(),
  raw_app_meta_data: z.any().nullable(),
  raw_user_meta_data: z.any().nullable(),
  role: z.enum(UserRole).nullable(),
  status: z.string().min(1, "Status cannot be empty").nullable(),
  updated_at: z.iso.datetime().nullable(),
});

// ============= CONVENIENCE EXPORTS =============

export const schemas = {
  authAudit_log_entriesRowSchema,
  authAudit_log_entriesInsertSchema,
  authAudit_log_entriesUpdateSchema,
  authFlow_stateRowSchema,
  authFlow_stateInsertSchema,
  authFlow_stateUpdateSchema,
  authIdentitiesRowSchema,
  authIdentitiesInsertSchema,
  authIdentitiesUpdateSchema,
  authInstancesRowSchema,
  authInstancesInsertSchema,
  authInstancesUpdateSchema,
  authMfa_amr_claimsRowSchema,
  authMfa_amr_claimsInsertSchema,
  authMfa_amr_claimsUpdateSchema,
  authMfa_challengesRowSchema,
  authMfa_challengesInsertSchema,
  authMfa_challengesUpdateSchema,
  authMfa_factorsRowSchema,
  authMfa_factorsInsertSchema,
  authMfa_factorsUpdateSchema,
  authOauth_clientsRowSchema,
  authOauth_clientsInsertSchema,
  authOauth_clientsUpdateSchema,
  authOne_time_tokensRowSchema,
  authOne_time_tokensInsertSchema,
  authOne_time_tokensUpdateSchema,
  authRefresh_tokensRowSchema,
  authRefresh_tokensInsertSchema,
  authRefresh_tokensUpdateSchema,
  authSaml_providersRowSchema,
  authSaml_providersInsertSchema,
  authSaml_providersUpdateSchema,
  authSaml_relay_statesRowSchema,
  authSaml_relay_statesInsertSchema,
  authSaml_relay_statesUpdateSchema,
  authSchema_migrationsRowSchema,
  authSchema_migrationsInsertSchema,
  authSchema_migrationsUpdateSchema,
  authSessionsRowSchema,
  authSessionsInsertSchema,
  authSessionsUpdateSchema,
  authSso_domainsRowSchema,
  authSso_domainsInsertSchema,
  authSso_domainsUpdateSchema,
  authSso_providersRowSchema,
  authSso_providersInsertSchema,
  authSso_providersUpdateSchema,
  authUsersRowSchema,
  authUsersInsertSchema,
  authUsersUpdateSchema,
  cable_segmentsRowSchema,
  cable_segmentsInsertSchema,
  cable_segmentsUpdateSchema,
  employee_designationsRowSchema,
  employee_designationsInsertSchema,
  employee_designationsUpdateSchema,
  employeesRowSchema,
  employeesInsertSchema,
  employeesUpdateSchema,
  fiber_splicesRowSchema,
  fiber_splicesInsertSchema,
  fiber_splicesUpdateSchema,
  filesRowSchema,
  filesInsertSchema,
  filesUpdateSchema,
  foldersRowSchema,
  foldersInsertSchema,
  foldersUpdateSchema,
  junction_closuresRowSchema,
  junction_closuresInsertSchema,
  junction_closuresUpdateSchema,
  logical_fiber_pathsRowSchema,
  logical_fiber_pathsInsertSchema,
  logical_fiber_pathsUpdateSchema,
  lookup_typesRowSchema,
  lookup_typesInsertSchema,
  lookup_typesUpdateSchema,
  maintenance_areasRowSchema,
  maintenance_areasInsertSchema,
  maintenance_areasUpdateSchema,
  management_portsRowSchema,
  management_portsInsertSchema,
  management_portsUpdateSchema,
  nodesRowSchema,
  nodesInsertSchema,
  nodesUpdateSchema,
  ofc_cablesRowSchema,
  ofc_cablesInsertSchema,
  ofc_cablesUpdateSchema,
  ofc_connectionsRowSchema,
  ofc_connectionsInsertSchema,
  ofc_connectionsUpdateSchema,
  ring_based_systemsRowSchema,
  ring_based_systemsInsertSchema,
  ring_based_systemsUpdateSchema,
  ringsRowSchema,
  ringsInsertSchema,
  ringsUpdateSchema,
  sdh_connectionsRowSchema,
  sdh_connectionsInsertSchema,
  sdh_connectionsUpdateSchema,
  sdh_node_associationsRowSchema,
  sdh_node_associationsInsertSchema,
  sdh_node_associationsUpdateSchema,
  sdh_systemsRowSchema,
  sdh_systemsInsertSchema,
  sdh_systemsUpdateSchema,
  sfp_based_connectionsRowSchema,
  sfp_based_connectionsInsertSchema,
  sfp_based_connectionsUpdateSchema,
  system_connectionsRowSchema,
  system_connectionsInsertSchema,
  system_connectionsUpdateSchema,
  systemsRowSchema,
  systemsInsertSchema,
  systemsUpdateSchema,
  user_profilesRowSchema,
  user_profilesInsertSchema,
  user_profilesUpdateSchema,
  vmux_connectionsRowSchema,
  vmux_connectionsInsertSchema,
  vmux_connectionsUpdateSchema,
  vmux_systemsRowSchema,
  vmux_systemsInsertSchema,
  vmux_systemsUpdateSchema,
  v_employee_designations_with_countRowSchema,
  v_employees_with_countRowSchema,
  v_junction_closures_completeRowSchema,
  v_lookup_types_with_countRowSchema,
  v_maintenance_areas_with_countRowSchema,
  v_nodes_completeRowSchema,
  v_ofc_cables_completeRowSchema,
  v_ofc_connections_completeRowSchema,
  v_rings_with_countRowSchema,
  v_system_connections_completeRowSchema,
  v_systems_completeRowSchema,
  v_user_profiles_extendedRowSchema,
} as const;

// ============= TYPE EXPORTS =============

export type AuthAudit_log_entriesRowSchema = z.infer<typeof authAudit_log_entriesRowSchema>;
export type AuthAudit_log_entriesInsertSchema = z.infer<typeof authAudit_log_entriesInsertSchema>;
export type AuthAudit_log_entriesUpdateSchema = z.infer<typeof authAudit_log_entriesUpdateSchema>;
export type AuthFlow_stateRowSchema = z.infer<typeof authFlow_stateRowSchema>;
export type AuthFlow_stateInsertSchema = z.infer<typeof authFlow_stateInsertSchema>;
export type AuthFlow_stateUpdateSchema = z.infer<typeof authFlow_stateUpdateSchema>;
export type AuthIdentitiesRowSchema = z.infer<typeof authIdentitiesRowSchema>;
export type AuthIdentitiesInsertSchema = z.infer<typeof authIdentitiesInsertSchema>;
export type AuthIdentitiesUpdateSchema = z.infer<typeof authIdentitiesUpdateSchema>;
export type AuthInstancesRowSchema = z.infer<typeof authInstancesRowSchema>;
export type AuthInstancesInsertSchema = z.infer<typeof authInstancesInsertSchema>;
export type AuthInstancesUpdateSchema = z.infer<typeof authInstancesUpdateSchema>;
export type AuthMfa_amr_claimsRowSchema = z.infer<typeof authMfa_amr_claimsRowSchema>;
export type AuthMfa_amr_claimsInsertSchema = z.infer<typeof authMfa_amr_claimsInsertSchema>;
export type AuthMfa_amr_claimsUpdateSchema = z.infer<typeof authMfa_amr_claimsUpdateSchema>;
export type AuthMfa_challengesRowSchema = z.infer<typeof authMfa_challengesRowSchema>;
export type AuthMfa_challengesInsertSchema = z.infer<typeof authMfa_challengesInsertSchema>;
export type AuthMfa_challengesUpdateSchema = z.infer<typeof authMfa_challengesUpdateSchema>;
export type AuthMfa_factorsRowSchema = z.infer<typeof authMfa_factorsRowSchema>;
export type AuthMfa_factorsInsertSchema = z.infer<typeof authMfa_factorsInsertSchema>;
export type AuthMfa_factorsUpdateSchema = z.infer<typeof authMfa_factorsUpdateSchema>;
export type AuthOauth_clientsRowSchema = z.infer<typeof authOauth_clientsRowSchema>;
export type AuthOauth_clientsInsertSchema = z.infer<typeof authOauth_clientsInsertSchema>;
export type AuthOauth_clientsUpdateSchema = z.infer<typeof authOauth_clientsUpdateSchema>;
export type AuthOne_time_tokensRowSchema = z.infer<typeof authOne_time_tokensRowSchema>;
export type AuthOne_time_tokensInsertSchema = z.infer<typeof authOne_time_tokensInsertSchema>;
export type AuthOne_time_tokensUpdateSchema = z.infer<typeof authOne_time_tokensUpdateSchema>;
export type AuthRefresh_tokensRowSchema = z.infer<typeof authRefresh_tokensRowSchema>;
export type AuthRefresh_tokensInsertSchema = z.infer<typeof authRefresh_tokensInsertSchema>;
export type AuthRefresh_tokensUpdateSchema = z.infer<typeof authRefresh_tokensUpdateSchema>;
export type AuthSaml_providersRowSchema = z.infer<typeof authSaml_providersRowSchema>;
export type AuthSaml_providersInsertSchema = z.infer<typeof authSaml_providersInsertSchema>;
export type AuthSaml_providersUpdateSchema = z.infer<typeof authSaml_providersUpdateSchema>;
export type AuthSaml_relay_statesRowSchema = z.infer<typeof authSaml_relay_statesRowSchema>;
export type AuthSaml_relay_statesInsertSchema = z.infer<typeof authSaml_relay_statesInsertSchema>;
export type AuthSaml_relay_statesUpdateSchema = z.infer<typeof authSaml_relay_statesUpdateSchema>;
export type AuthSchema_migrationsRowSchema = z.infer<typeof authSchema_migrationsRowSchema>;
export type AuthSchema_migrationsInsertSchema = z.infer<typeof authSchema_migrationsInsertSchema>;
export type AuthSchema_migrationsUpdateSchema = z.infer<typeof authSchema_migrationsUpdateSchema>;
export type AuthSessionsRowSchema = z.infer<typeof authSessionsRowSchema>;
export type AuthSessionsInsertSchema = z.infer<typeof authSessionsInsertSchema>;
export type AuthSessionsUpdateSchema = z.infer<typeof authSessionsUpdateSchema>;
export type AuthSso_domainsRowSchema = z.infer<typeof authSso_domainsRowSchema>;
export type AuthSso_domainsInsertSchema = z.infer<typeof authSso_domainsInsertSchema>;
export type AuthSso_domainsUpdateSchema = z.infer<typeof authSso_domainsUpdateSchema>;
export type AuthSso_providersRowSchema = z.infer<typeof authSso_providersRowSchema>;
export type AuthSso_providersInsertSchema = z.infer<typeof authSso_providersInsertSchema>;
export type AuthSso_providersUpdateSchema = z.infer<typeof authSso_providersUpdateSchema>;
export type AuthUsersRowSchema = z.infer<typeof authUsersRowSchema>;
export type AuthUsersInsertSchema = z.infer<typeof authUsersInsertSchema>;
export type AuthUsersUpdateSchema = z.infer<typeof authUsersUpdateSchema>;
export type Cable_segmentsRowSchema = z.infer<typeof cable_segmentsRowSchema>;
export type Cable_segmentsInsertSchema = z.infer<typeof cable_segmentsInsertSchema>;
export type Cable_segmentsUpdateSchema = z.infer<typeof cable_segmentsUpdateSchema>;
export type Employee_designationsRowSchema = z.infer<typeof employee_designationsRowSchema>;
export type Employee_designationsInsertSchema = z.infer<typeof employee_designationsInsertSchema>;
export type Employee_designationsUpdateSchema = z.infer<typeof employee_designationsUpdateSchema>;
export type EmployeesRowSchema = z.infer<typeof employeesRowSchema>;
export type EmployeesInsertSchema = z.infer<typeof employeesInsertSchema>;
export type EmployeesUpdateSchema = z.infer<typeof employeesUpdateSchema>;
export type Fiber_splicesRowSchema = z.infer<typeof fiber_splicesRowSchema>;
export type Fiber_splicesInsertSchema = z.infer<typeof fiber_splicesInsertSchema>;
export type Fiber_splicesUpdateSchema = z.infer<typeof fiber_splicesUpdateSchema>;
export type FilesRowSchema = z.infer<typeof filesRowSchema>;
export type FilesInsertSchema = z.infer<typeof filesInsertSchema>;
export type FilesUpdateSchema = z.infer<typeof filesUpdateSchema>;
export type FoldersRowSchema = z.infer<typeof foldersRowSchema>;
export type FoldersInsertSchema = z.infer<typeof foldersInsertSchema>;
export type FoldersUpdateSchema = z.infer<typeof foldersUpdateSchema>;
export type Junction_closuresRowSchema = z.infer<typeof junction_closuresRowSchema>;
export type Junction_closuresInsertSchema = z.infer<typeof junction_closuresInsertSchema>;
export type Junction_closuresUpdateSchema = z.infer<typeof junction_closuresUpdateSchema>;
export type Logical_fiber_pathsRowSchema = z.infer<typeof logical_fiber_pathsRowSchema>;
export type Logical_fiber_pathsInsertSchema = z.infer<typeof logical_fiber_pathsInsertSchema>;
export type Logical_fiber_pathsUpdateSchema = z.infer<typeof logical_fiber_pathsUpdateSchema>;
export type Lookup_typesRowSchema = z.infer<typeof lookup_typesRowSchema>;
export type Lookup_typesInsertSchema = z.infer<typeof lookup_typesInsertSchema>;
export type Lookup_typesUpdateSchema = z.infer<typeof lookup_typesUpdateSchema>;
export type Maintenance_areasRowSchema = z.infer<typeof maintenance_areasRowSchema>;
export type Maintenance_areasInsertSchema = z.infer<typeof maintenance_areasInsertSchema>;
export type Maintenance_areasUpdateSchema = z.infer<typeof maintenance_areasUpdateSchema>;
export type Management_portsRowSchema = z.infer<typeof management_portsRowSchema>;
export type Management_portsInsertSchema = z.infer<typeof management_portsInsertSchema>;
export type Management_portsUpdateSchema = z.infer<typeof management_portsUpdateSchema>;
export type NodesRowSchema = z.infer<typeof nodesRowSchema>;
export type NodesInsertSchema = z.infer<typeof nodesInsertSchema>;
export type NodesUpdateSchema = z.infer<typeof nodesUpdateSchema>;
export type Ofc_cablesRowSchema = z.infer<typeof ofc_cablesRowSchema>;
export type Ofc_cablesInsertSchema = z.infer<typeof ofc_cablesInsertSchema>;
export type Ofc_cablesUpdateSchema = z.infer<typeof ofc_cablesUpdateSchema>;
export type Ofc_connectionsRowSchema = z.infer<typeof ofc_connectionsRowSchema>;
export type Ofc_connectionsInsertSchema = z.infer<typeof ofc_connectionsInsertSchema>;
export type Ofc_connectionsUpdateSchema = z.infer<typeof ofc_connectionsUpdateSchema>;
export type Ring_based_systemsRowSchema = z.infer<typeof ring_based_systemsRowSchema>;
export type Ring_based_systemsInsertSchema = z.infer<typeof ring_based_systemsInsertSchema>;
export type Ring_based_systemsUpdateSchema = z.infer<typeof ring_based_systemsUpdateSchema>;
export type RingsRowSchema = z.infer<typeof ringsRowSchema>;
export type RingsInsertSchema = z.infer<typeof ringsInsertSchema>;
export type RingsUpdateSchema = z.infer<typeof ringsUpdateSchema>;
export type Sdh_connectionsRowSchema = z.infer<typeof sdh_connectionsRowSchema>;
export type Sdh_connectionsInsertSchema = z.infer<typeof sdh_connectionsInsertSchema>;
export type Sdh_connectionsUpdateSchema = z.infer<typeof sdh_connectionsUpdateSchema>;
export type Sdh_node_associationsRowSchema = z.infer<typeof sdh_node_associationsRowSchema>;
export type Sdh_node_associationsInsertSchema = z.infer<typeof sdh_node_associationsInsertSchema>;
export type Sdh_node_associationsUpdateSchema = z.infer<typeof sdh_node_associationsUpdateSchema>;
export type Sdh_systemsRowSchema = z.infer<typeof sdh_systemsRowSchema>;
export type Sdh_systemsInsertSchema = z.infer<typeof sdh_systemsInsertSchema>;
export type Sdh_systemsUpdateSchema = z.infer<typeof sdh_systemsUpdateSchema>;
export type Sfp_based_connectionsRowSchema = z.infer<typeof sfp_based_connectionsRowSchema>;
export type Sfp_based_connectionsInsertSchema = z.infer<typeof sfp_based_connectionsInsertSchema>;
export type Sfp_based_connectionsUpdateSchema = z.infer<typeof sfp_based_connectionsUpdateSchema>;
export type System_connectionsRowSchema = z.infer<typeof system_connectionsRowSchema>;
export type System_connectionsInsertSchema = z.infer<typeof system_connectionsInsertSchema>;
export type System_connectionsUpdateSchema = z.infer<typeof system_connectionsUpdateSchema>;
export type SystemsRowSchema = z.infer<typeof systemsRowSchema>;
export type SystemsInsertSchema = z.infer<typeof systemsInsertSchema>;
export type SystemsUpdateSchema = z.infer<typeof systemsUpdateSchema>;
export type User_profilesRowSchema = z.infer<typeof user_profilesRowSchema>;
export type User_profilesInsertSchema = z.infer<typeof user_profilesInsertSchema>;
export type User_profilesUpdateSchema = z.infer<typeof user_profilesUpdateSchema>;
export type Vmux_connectionsRowSchema = z.infer<typeof vmux_connectionsRowSchema>;
export type Vmux_connectionsInsertSchema = z.infer<typeof vmux_connectionsInsertSchema>;
export type Vmux_connectionsUpdateSchema = z.infer<typeof vmux_connectionsUpdateSchema>;
export type Vmux_systemsRowSchema = z.infer<typeof vmux_systemsRowSchema>;
export type Vmux_systemsInsertSchema = z.infer<typeof vmux_systemsInsertSchema>;
export type Vmux_systemsUpdateSchema = z.infer<typeof vmux_systemsUpdateSchema>;
export type V_employee_designations_with_countRowSchema = z.infer<typeof v_employee_designations_with_countRowSchema>;
export type V_employees_with_countRowSchema = z.infer<typeof v_employees_with_countRowSchema>;
export type V_junction_closures_completeRowSchema = z.infer<typeof v_junction_closures_completeRowSchema>;
export type V_lookup_types_with_countRowSchema = z.infer<typeof v_lookup_types_with_countRowSchema>;
export type V_maintenance_areas_with_countRowSchema = z.infer<typeof v_maintenance_areas_with_countRowSchema>;
export type V_nodes_completeRowSchema = z.infer<typeof v_nodes_completeRowSchema>;
export type V_ofc_cables_completeRowSchema = z.infer<typeof v_ofc_cables_completeRowSchema>;
export type V_ofc_connections_completeRowSchema = z.infer<typeof v_ofc_connections_completeRowSchema>;
export type V_rings_with_countRowSchema = z.infer<typeof v_rings_with_countRowSchema>;
export type V_system_connections_completeRowSchema = z.infer<typeof v_system_connections_completeRowSchema>;
export type V_systems_completeRowSchema = z.infer<typeof v_systems_completeRowSchema>;
export type V_user_profiles_extendedRowSchema = z.infer<typeof v_user_profiles_extendedRowSchema>;

```

<!-- path: schemas/form-specific.ts -->
```typescript
// =================================================================
// FORM SPECIFIC TYPE EXPORTS
// =================================================================

import z from 'zod';
import { signupSchema, userSchema } from '@/schemas/auth';
import {
  employeeDesignationSchema,
  employeeSchema,
  lookupTypeSchema,
  maintenanceAreaSchema,
} from '@/schemas/masters';
import {
  managementPortSchema,
  nodeSchema,
  ofcCableSchema,
  ofcConnectionSchema,
  ringSchema,
  sdhNodeAssociationSchema,
  systemConnectionSchema,
  systemSchema,
} from '@/schemas/core';
import {
  cpanConnectionSchema,
  cpanSystemSchema,
  maanConnectionSchema,
  maanSystemSchema,
  sdhConnectionSchema,
  sdhSystemSchema,
  vmuxConnectionSchema,
  vmuxSystemSchema,
} from '@/schemas/system-specific';
import { userProfileSchema } from '@/schemas/user';
import { emptyStringToNumber, optionalDate } from '@/schemas/helpers';
import { logicalFiberPathSchema, logicalPathSegmentSchema } from '@/schemas/advanced';

// =================================================================
// TYPE EXPORTS
// =================================================================
export type LookupType = z.infer<typeof lookupTypeSchema>;
export type MaintenanceArea = z.infer<typeof maintenanceAreaSchema>;
export type EmployeeDesignation = z.infer<typeof employeeDesignationSchema>;
export type Employee = z.infer<typeof employeeSchema>;
export type Ring = z.infer<typeof ringSchema>;
export type Node = z.infer<typeof nodeSchema>;
export type OfcCable = z.infer<typeof ofcCableSchema>;
export type OfcConnection = z.infer<typeof ofcConnectionSchema>;
export type SystemConnection = z.infer<typeof systemConnectionSchema>;
export type ManagementPort = z.infer<typeof managementPortSchema>;
export type SdhNodeAssociation = z.infer<typeof sdhNodeAssociationSchema>;
export type CpanSystem = z.infer<typeof cpanSystemSchema>;
export type MaanSystem = z.infer<typeof maanSystemSchema>;
export type SdhSystem = z.infer<typeof sdhSystemSchema>;
export type VmuxSystem = z.infer<typeof vmuxSystemSchema>;
export type CpanConnection = z.infer<typeof cpanConnectionSchema>;
export type MaanConnection = z.infer<typeof maanConnectionSchema>;
export type SdhConnection = z.infer<typeof sdhConnectionSchema>;
export type VmuxConnection = z.infer<typeof vmuxConnectionSchema>;
export type UserProfile = z.infer<typeof userProfileSchema>;
export type UserFormData = z.infer<typeof userSchema>;
export type SignupFormData = z.infer<typeof signupSchema>;

export type System = z.infer<typeof systemSchema>;

export const nodeFormSchema = nodeSchema.omit({
  id: true,
  created_at: true,
  updated_at: true,
});
export type NodeFormData = z.infer<typeof nodeFormSchema>;

export const employeeFormSchema = employeeSchema.omit({
  id: true,
  created_at: true,
  updated_at: true,
  status: true,
});
export type EmployeeFormData = z.infer<typeof employeeFormSchema>;

export const userProfileFormSchema = userProfileSchema.omit({
  created_at: true,
  updated_at: true,
});
export type UserProfileFormData = z.infer<typeof userProfileFormSchema>;

export const maintenanceAreaFormSchema = maintenanceAreaSchema.omit({
  id: true,
  created_at: true,
  updated_at: true,
});
export type MaintenanceAreaFormData = z.infer<typeof maintenanceAreaFormSchema>;

export const ringFormSchema = ringSchema.omit({
  id: true,
  created_at: true,
  updated_at: true,
});
export type RingFormData = z.infer<typeof ringFormSchema>;

export const ofcCableFormSchema = ofcCableSchema.omit({
  id: true,
  created_at: true,
  updated_at: true,
});
export type OfcCableFormData = z.infer<typeof ofcCableFormSchema>;

// Form schema - accepts Date objects, outputs strings for database
export const systemFormSchema = systemSchema
  .omit({
    id: true,
    created_at: true,
    updated_at: true,
  })
  .extend({
    commissioned_on: optionalDate, // Form uses Date object
  })
  .transform((data) => ({
    ...data,
    commissioned_on: data.commissioned_on ? data.commissioned_on.toISOString() : null,
  }));

export type SystemFormData = z.input<typeof systemFormSchema>; // What form expects (Date)
export type SystemFormOutput = z.output<typeof systemFormSchema>; // What database gets (string)

export const ofcConnectionFormSchema = ofcConnectionSchema
  .omit({
    id: true,
    created_at: true,
    updated_at: true,
  })
  .extend({
    route_loss_db: z.union([z.number(), z.string()]).optional().nullable(),
    sn_dom: optionalDate.optional().nullable(),
    en_dom: optionalDate.optional().nullable(),
    otdr_distance_sn_km: emptyStringToNumber.optional().nullable(),
    sn_power_dbm: emptyStringToNumber.optional().nullable(),
    otdr_distance_en_km: emptyStringToNumber.optional().nullable(),
    en_power_dbm: emptyStringToNumber.optional().nullable(),
  });
export type OfcConnectionFormData = z.infer<typeof ofcConnectionFormSchema>;

export type LogicalFiberPath = z.infer<typeof logicalFiberPathSchema>;
export type LogicalPathSegment = z.infer<typeof logicalPathSegmentSchema>;

```

<!-- path: schemas/auth.ts -->
```typescript
import z from "zod";

export const userSchema = z.object({
  email: z.email("Invalid email address"),
  password: z
    .string()
    .min(6, "Password must be at least 6 characters long")
    .max(50, "Password must not exceed 50 characters")
    .regex(
      /^(?=.*[a-z])(?=.*[A-Z])(?=.*\d)(?=.*[@$!%*?&])[A-Za-z\d@$!%*?&]/,
      "Password must contain at least one uppercase letter, one lowercase letter, one number and one special character"
    ),
});

export const signupSchema = userSchema
  .extend({
    firstName: z
      .string()
      .min(1, "First name is required")
      .max(50, "First name must not exceed 50 characters"),
    lastName: z
      .string()
      .min(1, "Last name is required")
      .max(50, "Last name must not exceed 50 characters"),
    confirmPassword: z.string().min(6, "Confirm password is required"),
  })
  .refine((data) => data.password === data.confirmPassword, {
    message: "Passwords must match",
    path: ["confirmPassword"],
  });


```

<!-- path: schemas/index.ts -->
```typescript
export * from "@/schemas/auth";
export * from "@/schemas/masters";
export * from "@/schemas/core";
export * from "@/schemas/system-specific";
export * from "@/schemas/helpers";
export * from "@/schemas/user";
export * from "@/schemas/form-specific";
export * from "@/schemas/advanced";

```

<!-- path: schemas/user.ts -->
```typescript
// =================================================================
// USER MANAGEMENT
// =================================================================

import z from "zod";

export const userProfileSchema = z.object({
  id: z.uuid().optional(),
  first_name: z.string().min(1, { message: "First name cannot be empty." }).nullable(),
  last_name: z.string().min(1, { message: "Last name cannot be empty." }).nullable(),
  avatar_url: z.url({ message: "Invalid URL format." })
    .optional()
    .or(z.literal("")).nullable(),
  phone_number: z
    .string()
    .regex(/^\+?[1-9]\d{1,14}$/, "Invalid phone number format.")
    .optional()
    .or(z.literal(""))
    .nullable(),
  date_of_birth: z.coerce
    .date()
    .optional()
    .nullable()
    .refine(
      (date) => !date || (date > new Date("1900-01-01") && date < new Date()),
      {
        message: "Please enter a valid date of birth.",
      }
    ),
  role: z
    .enum([
      "admin",
      "viewer",
      "cpan_admin",
      "maan_admin",
      "sdh_admin",
      "vmux_admin",
      "mng_admin",
    ])
    .default("viewer"),
  designation: z.string().optional().nullable(),
  address: z
    .object({
      street: z.string().optional(),
      city: z.string().optional(),
      state: z.string().optional(),
      zip_code: z.string().optional(),
      country: z.string().optional(),
    })
    .default({})
    .optional().nullable(),
  preferences: z.object({
    language: z.string().optional(),
    notifications: z.boolean().optional(),
  })
  .default({})
  .optional().nullable(),
  status: z.enum(["active", "inactive", "suspended"]).default("inactive"),
  created_at: z.coerce.date().optional(),
  updated_at: z.coerce.date().optional(),
});


```

<!-- path: hooks/useOutdatedBrowserCheck.tsx -->
```typescript
import { useEffect, useState } from 'react';

const LOCAL_KEY = 'isOutdatedBrowser';

function detectOutdatedBrowser(): boolean {
  const ua = navigator.userAgent;
  let isOutdated = false;

  const isIE = /MSIE|Trident/.test(ua);
  const legacyEdgeMatch = ua.match(/Edge\/(\d+)/);
  const chromeMatch = ua.match(/Chrome\/(\d+)/);
  const firefoxMatch = ua.match(/Firefox\/(\d+)/);
  const safariMatch = ua.match(/Version\/(\d+).+Safari/);
  const edgeMatch = ua.match(/Edg\/(\d+)/);

  if (isIE) {
    isOutdated = true;
  } else if (legacyEdgeMatch) {
    const version = parseInt(legacyEdgeMatch[1]);
    if (version < 80) isOutdated = true;
  } else if (chromeMatch) {
    const version = parseInt(chromeMatch[1]);
    if (version < 110) isOutdated = true;
  } else if (firefoxMatch) {
    const version = parseInt(firefoxMatch[1]);
    if (version < 100) isOutdated = true;
  } else if (safariMatch) {
    const version = parseInt(safariMatch[1]);
    if (version < 15) isOutdated = true;
  } else if (edgeMatch) {
    const version = parseInt(edgeMatch[1]);
    if (version < 110) isOutdated = true;
  }

  const missingFeatures = [
    () => typeof Promise !== 'function' || typeof Symbol !== 'function',
    () => !CSS.supports('display', 'flex'),
    () => !CSS.supports('position', 'sticky'),
    () => !CSS.supports('backdrop-filter', 'blur(1px)'),
    () => typeof IntersectionObserver === 'undefined',
    () => typeof localStorage === 'undefined',
    () => typeof sessionStorage === 'undefined',
  ].some(fn => fn());

  return isOutdated || missingFeatures;
}

export function useOutdatedBrowserCheck(): boolean | null {
  const [isOutdated, setIsOutdated] = useState<boolean | null>(null);

  useEffect(() => {
    const cached = localStorage.getItem(LOCAL_KEY);
    if (cached !== null) {
      setIsOutdated(cached === 'true');
      return;
    }

    const result = detectOutdatedBrowser();
    localStorage.setItem(LOCAL_KEY, String(result));
    setIsOutdated(result);
  }, []);

  return isOutdated;
}

```

<!-- path: hooks/useEntityManagement.ts -->
```typescript
"use client";

import { BaseEntity, EntityWithChildren, isHierarchicalEntity, UseEntityManagementProps } from "@/components/common/entity-management/types";
import { useMemo, useState } from "react";

export function useEntityManagement<T extends BaseEntity>({ entitiesQuery, config, onEdit, onDelete, onToggleStatus, onCreateNew }: UseEntityManagementProps<T>) {
  const [searchTerm, setSearchTerm] = useState("");
  const [viewMode, setViewMode] = useState<"tree" | "list">("list");
  const [showFilters, setShowFilters] = useState(false);
  const [filters, setFilters] = useState<Record<string, string>>({});
  const [selectedEntityId, setSelectedEntityId] = useState<string | null>(null);
  const [showDetailsPanel, setShowDetailsPanel] = useState(false);
  const [expandedEntities, setExpandedEntities] = useState<Set<string>>(new Set());

  const allEntities = entitiesQuery.data || [];

  // Search functionality
  const searchedEntities = useMemo(() => {
    if (!searchTerm) return allEntities;

    return allEntities.filter((entity) =>
      config.searchFields.some((field) => {
        const value = entity[field];
        return value && String(value).toLowerCase().includes(searchTerm.toLowerCase());
      })
    );
  }, [allEntities, searchTerm, config.searchFields]);

  // Filter functionality
  const filteredEntities = useMemo(() => {
    return searchedEntities.filter((entity) => {
      return Object.entries(filters).every(([key, value]) => {
        if (!value) return true;

        const entityValue = (entity as any)[key];
        if (key === "status") {
          return entityValue.toString() === value;
        }
        return entityValue === value;
      });
    });
  }, [searchedEntities, filters]);

  // Build hierarchical structure for tree view
  const hierarchicalEntities = useMemo((): EntityWithChildren<T>[] => {
    if (!config.isHierarchical) return filteredEntities.map((entity) => ({ ...entity, children: [] }));

    // Create a map to store entities with their children
    const entityMap = new Map<string, EntityWithChildren<T>>();

    // Initialize all entities with empty children arrays
    filteredEntities.forEach((entity) => {
      entityMap.set(entity.id, { ...entity, children: [] });
    });

    const rootEntities: EntityWithChildren<T>[] = [];

    // Build the hierarchy
    filteredEntities.forEach((entity) => {
      const entityWithChildren = entityMap.get(entity.id);
      if (!entityWithChildren) return;

      if (isHierarchicalEntity(entity) && entity.parent_id) {
        // This entity has a parent, add it to parent's children
        const parent = entityMap.get(entity.parent_id);
        if (parent) {
          parent.children.push(entityWithChildren);
        } else {
          // Parent not in filtered results, treat as root
          rootEntities.push(entityWithChildren);
        }
      } else {
        // This is a root entity
        rootEntities.push(entityWithChildren);
      }
    });

    return rootEntities;
  }, [filteredEntities, config.isHierarchical]);

  const selectedEntity = allEntities.find((entity) => entity.id === selectedEntityId) || null;

  // Event handlers
  const handleEntitySelect = (id: string) => {
    setSelectedEntityId(id);
    setShowDetailsPanel(true);
  };

  const toggleExpanded = (id: string) => {
    setExpandedEntities((prev) => {
      const newSet = new Set(prev);
      if (newSet.has(id)) {
        newSet.delete(id);
      } else {
        newSet.add(id);
      }
      return newSet;
    });
  };

  const handleOpenCreateForm = () => {
    onCreateNew();
  };

  const handleOpenEditForm = () => {
    if (selectedEntity) {
      onEdit(selectedEntity);
    }
  };

  return {
    // State
    searchTerm,
    viewMode,
    showFilters,
    filters,
    selectedEntityId,
    showDetailsPanel,
    expandedEntities,

    // Computed data
    allEntities,
    filteredEntities,
    hierarchicalEntities,
    selectedEntity,

    // Handlers
    setSearchTerm,
    setViewMode,
    setShowFilters,
    setFilters,
    setShowDetailsPanel,
    handleEntitySelect,
    toggleExpanded,
    handleOpenCreateForm,
    handleOpenEditForm,
    onToggleStatus,
    onDelete,
  };
}

```

<!-- path: hooks/useDelete.ts -->
```typescript
import { useState } from "react";
import { useTableDelete } from "@/hooks/database";
import { createClient } from "@/utils/supabase/client";
import { TableName } from "@/hooks/database";

export const useDelete = ({ tableName, onSuccess }: { tableName: TableName; onSuccess?: () => void }) => {
  const supabase = createClient();
  const [itemToDelete, setItemToDelete] = useState<{ id: string; name: string } | null>(null);

  const { mutate: deleteMutation, isPending } = useTableDelete(supabase, tableName as TableName, {
    onSuccess: () => {
      onSuccess?.();
      setItemToDelete(null);
    },
  });

  const deleteSingle = (item: { id: string; name: string }) => {
    setItemToDelete(item);
  };

  const handleConfirm = () => {
    if (itemToDelete) {
      deleteMutation(itemToDelete.id);
    }
  };

  const handleCancel = () => {
    setItemToDelete(null);
  };

  return {
    isConfirmModalOpen: itemToDelete !== null,
    isPending,
    itemToDelete,
    confirmationMessage: `Are you sure you want to delete "${itemToDelete?.name}"? This action cannot be undone.`,
    deleteSingle,
    handleConfirm,
    handleCancel,
  };
};
```

<!-- path: hooks/useCreateOfcConnection.ts -->
```typescript
import { useCallback, useMemo } from 'react';
import { SupabaseClient } from '@supabase/supabase-js';
import { Database } from '@/types/supabase-types';
import { useMutation, useQueryClient } from '@tanstack/react-query';
import { usePagedOfcCablesComplete } from './database';
import { Row } from './database';

type OfcConnection = Row<'ofc_connections'>;
interface useCreateOfcConnectionProps {
  supabase: SupabaseClient<Database>;
  cableId: string;
  rawConnections: OfcConnection[];
  refetchOfcConnections: () => void;
  isLoadingOfcConnections: boolean;
}

export const useCreateOfcConnection = ({
  supabase,
  cableId,
  rawConnections,
  refetchOfcConnections,
  isLoadingOfcConnections,
}: useCreateOfcConnectionProps) => {
  const queryClient = useQueryClient();

  // Get OFC cable by Id
  const { data: cable, isLoading: isLoadingCable } = usePagedOfcCablesComplete(
    supabase,
    {
      filters: { id: cableId },
      limit: 1,
      offset: 0,
    }
  );

  // Return the appropriate data based on sorting preference
  const existingConnections = useMemo(() => {
    const connections = rawConnections || [];
    return connections;
  }, [rawConnections]);

  // Mutation for creating new connections (unchanged)
  const { mutateAsync: createConnections } = useMutation({
    mutationFn: async (newConnections: OfcConnection[]) => {
      const { data, error } = await supabase
        .from('ofc_connections')
        .insert(newConnections);
      if (error) throw error;
      return data;
    },
    onSuccess: () => {
      // Invalidate and refetch the connections query after successful insertion
      queryClient.invalidateQueries({ queryKey: ['ofc_connections'] });
      refetchOfcConnections();
    },
  });

  // createMissingConnections (unchanged)
  const createMissingConnections = useCallback(async (): Promise<void> => {
    if (!cable || !cable[0]) return;

    // Get fresh connection count to avoid stale data
    const { data: currentConnections, error } = await supabase
      .from('ofc_connections')
      .select('id')
      .eq('ofc_id', cableId);

    if (error) {
      console.error('Failed to fetch current connections:', error);
      throw error;
    }

    const currentConnectionCount = currentConnections?.length || 0;
    const cableCapacity = cable[0].capacity as number;
    const missingCount = cableCapacity - currentConnectionCount;

    if (missingCount <= 0) {
      console.log('No missing connections to create');
      return;
    }



    // Create an array of new connections to insert
    const newConnections = Array.from({ length: missingCount }, (_, index) => {
      const connection: Partial<OfcConnection> = {
        ofc_id: cableId,
        fiber_no_sn: currentConnectionCount + index + 1,
        fiber_no_en: currentConnectionCount + index + 1,
        connection_type: 'straight', // Or a default value
        connection_category: 'OFC_JOINT_TYPES', // Or a default value
        fiber_role: 'working', // Or a default value
        status: true,
        // --- All optional fields are explicitly set to null for clarity ---
        system_id: null, // <-- The only missing field, now added
        en_dom: null,
        en_power_dbm: null,
        logical_path_id: null,
        otdr_distance_en_km: null,
        otdr_distance_sn_km: null,
        path_segment_order: null,
        remark: null,
        route_loss_db: null,
        sn_dom: null,
        sn_power_dbm: null,
        // created_at and updated_at are best handled by the database itself
      };
      return connection;
    });

    try {
      console.log(`Creating ${newConnections.length} new connections`);
      await createConnections(newConnections as OfcConnection[]);
    } catch (error) {
      console.error('Failed to create connections:', error);
      throw error;
    }
  }, [cable, cableId, createConnections, supabase]);

  // ensureConnectionsExist (unchanged)
  const ensureConnectionsExist = useCallback(async (): Promise<void> => {
    if (isLoadingCable || isLoadingOfcConnections) {
      console.log('Still loading data, skipping connection creation');
      return;
    }

    try {
      await createMissingConnections();
    } catch (error) {
      console.error('Error ensuring connections exist:', error);
      throw error;
    }
  }, [isLoadingCable, isLoadingOfcConnections, createMissingConnections]);

  return {
    cable: cable?.[0],
    existingConnections, // Now optionally client-sorted, but maintains same structure
    isLoadingOfc: isLoadingCable,
    ensureConnectionsExist,
    createMissingConnections,
  };
};

```

<!-- path: hooks/useAuth.ts -->
```typescript
// hooks/useAuth.ts
"use client";

import { useEffect, useMemo, useCallback } from "react";
import { createClient } from "@/utils/supabase/client";
import { useAuthStore } from "@/stores/authStore";
import { toast } from "sonner";

// Auth Hook
export const useAuth = () => {
  const { user, authState, setUser, setAuthState, logout: logoutStore, executeWithLoading, isAuthenticated, isLoading, getUserId } = useAuthStore();
  const supabase = useMemo(() => createClient(), []);

  // Initialize auth state - runs only once
  useEffect(() => {
    let isMounted = true;
    const subscription = supabase.auth.onAuthStateChange(async (event, session) => {
      if (isMounted) {
        setUser(session?.user ?? null);
      }
    }).data.subscription;

    const initAuth = async () => {
      try {
        // First try to get existing session without forcing refresh
        const { data: { session: existingSession } } = await supabase.auth.getSession();
        
        if (existingSession?.user) {
          if (isMounted) setUser(existingSession.user);
          return;
        }

        // Only force refresh if no existing session
        const { data: { session }, error } = await supabase.auth.refreshSession();

        if (error) {
          if (isMounted) setAuthState("unauthenticated");
          return;
        }

        if (session?.user && isMounted) {
          setUser(session.user);
        } else if (isMounted) {
          setAuthState("unauthenticated");
        }
      } catch (error) {
        if (isMounted) {
          console.error("Failed to initialize auth:", error instanceof Error ? error.message : "Unknown error");
          setAuthState("unauthenticated");
        }
      }
    };

    initAuth();

    return () => {
      isMounted = false;
      subscription?.unsubscribe();
    };
  }, [supabase, setUser, setAuthState]);

  // Memoized auth methods
  const signUp = useCallback(async (credentials: { email: string; password: string; firstName: string; lastName: string }) => {
    return executeWithLoading(async () => {
      try {
        const { data, error } = await supabase.auth.signUp({
          email: credentials.email,
          password: credentials.password,
          options: {
            data: {
              first_name: credentials.firstName,
              last_name: credentials.lastName,
            },
          },
        });

        if (error) throw error;
        if (data.user && !data.session) {
          toast.success("Signup successful! Please check your email for verification.");
        }
        return { data, error: null };
      } catch (error) {
        const message = error instanceof Error ? error.message : "Signup failed";
        toast.error(message);
        return { data: null, error: message };
      }
    });
  }, [executeWithLoading, supabase.auth]);

  const signIn = useCallback(async (email: string, password: string) => {
    return executeWithLoading(async () => {
      try {
        const { data, error } = await supabase.auth.signInWithPassword({ email, password });
        if (error) throw error;
        toast.success("Signed in successfully!");
        return { data, error: null };
      } catch (error) {
        const message = error instanceof Error ? error.message : "Sign in failed";
        toast.error(message);
        return { data: null, error: message };
      }
    });
  }, [executeWithLoading, supabase.auth]);

  const signInWithMagicLink = useCallback(async (email: string) => {
    return executeWithLoading(async () => {
      try {
        const { data, error } = await supabase.auth.signInWithOtp({
          email,
          options: { shouldCreateUser: true },
        });
        if (error) throw error;
        toast.success("Check your email for the magic link!");
        return { data, error: null };
      } catch (error) {
        const message = error instanceof Error ? error.message : "Failed to send magic link";
        toast.error(message);
        return { data: null, error: message };
      }
    });
  }, [executeWithLoading, supabase.auth]);

  const signInWithGoogle = useCallback(async () => {
    try {
      const { data, error } = await supabase.auth.signInWithOAuth({
        provider: "google",
        options: { 
          redirectTo: `${window.location.origin}/auth/callback`,
          // Skip browser redirect to prevent page reload
          skipBrowserRedirect: true
        },
      });
      
      if (error) throw error;
      
      // If we have a URL, perform the redirect manually
      if (data?.url) {
        window.location.href = data.url;
      }
      
      return { data, error: null };
    } catch (error) {
      sessionStorage.removeItem('oauth_in_progress');
      const message = error instanceof Error ? error.message : "Google sign in failed";
      toast.error(message);
      return { data: null, error: message };
    }
  }, [supabase.auth]);

  const logout = useCallback(async () => {
    try {
      const { error } = await supabase.auth.signOut();
      if (error) throw error;
      logoutStore();
      toast.success("Signed out successfully!");
    } catch (error) {
      const message = error instanceof Error ? error.message : "Logout failed";
      toast.error(message);
      logoutStore();
      throw error;
    }
  }, [supabase.auth, logoutStore]);

  const forgotPassword = useCallback(async (email: string) => {
    return executeWithLoading(async () => {
      try {
        const { error } = await supabase.auth.resetPasswordForEmail(email, {
          redirectTo: `${window.location.origin}/reset-password`,
        });
        if (error) throw error;
        return { error: null };
      } catch (error) {
        const message = error instanceof Error ? error.message : "Failed to send reset email";
        toast.error(message);
        return { error: message };
      } finally {
        setAuthState("unauthenticated");
      }
    });
  }, [executeWithLoading, supabase.auth, setAuthState]);

  const resetPassword = useCallback(async (newPassword: string) => {
    return executeWithLoading(async () => {
      try {
        const { error } = await supabase.auth.updateUser({ password: newPassword });
        if (error) throw error;
        toast.success("Password updated successfully!");
        return { error: null };
      } catch (error) {
        const message = error instanceof Error ? error.message : "Password update failed";
        toast.error(message);
        return { error: message };
      }
    });
  }, [executeWithLoading, supabase.auth]);

  const syncSession = useCallback(async () => {
    try {
      const { data: { session }, error } = await supabase.auth.refreshSession();
      if (error) {
        console.error("Session sync error:", error);
        return false;
      }
      if (session?.user) {
        setUser(session.user);
        return true;
      }
      return false;
    } catch (error) {
      console.error("Failed to sync session:", error);
      return false;
    }
  }, [supabase.auth, setUser]);

  const checkSession = useCallback(async () => {
    return executeWithLoading(async () => {
      const { data: { session } } = await supabase.auth.getSession();
      setUser(session?.user || null);
      return session;
    });
  }, [executeWithLoading, supabase.auth, setUser]);

  // Memoize the entire return value
  return useMemo(() => ({
    // State
    user,
    authState,
    isLoading: isLoading(),
    isAuthenticated: isAuthenticated(),
    userId: getUserId(),

    // Actions
    signUp,
    signIn,
    signInWithMagicLink,
    signInWithGoogle,
    logout,
    forgotPassword,
    resetPassword,
    syncSession,
    checkSession,
  }), [
    user,
    authState,
    isLoading,
    isAuthenticated,
    getUserId,
    signUp,
    signIn,
    signInWithMagicLink,
    signInWithGoogle,
    logout,
    forgotPassword,
    resetPassword,
    syncSession,
    checkSession
  ]);
};
```

<!-- path: hooks/database/bulk-queries.ts -->
```typescript
/* eslint-disable @typescript-eslint/no-explicit-any */
import { useMutation, useQueryClient } from "@tanstack/react-query";
import { SupabaseClient } from "@supabase/supabase-js";
import { Database } from "@/types/supabase-types";
import { TableName, TableRow, TableInsert, TableUpdate, Filters, OrderBy, PerformanceOptions } from "./queries-type-helpers";
import { applyFilters } from "./utility-functions";

// Enhanced bulk operations hook with filter support
export function useTableBulkOperations<T extends TableName>(supabase: SupabaseClient<Database>, tableName: T, batchSize = 1000) {
  const queryClient = useQueryClient();

  const bulkInsert = useMutation({
    mutationFn: async (data: TableInsert<T>[]): Promise<TableRow<T>[]> => {
      const results: TableRow<T>[] = [];
      for (let i = 0; i < data.length; i += batchSize) {
        const batch = data.slice(i, i + batchSize) as any;
        const { data: batchResult, error } = await supabase.from(tableName).insert(batch).select();
        if (error) throw error;
        results.push(...(batchResult as TableRow<T>[]));
      }
      return results;
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ["table", tableName] });
      queryClient.invalidateQueries({ queryKey: ["unique", tableName] });
    },
  });

  // Enhanced bulk update with filter support
  const bulkUpdate = useMutation({
    mutationFn: async (params: {
      updates: { id: string; data: TableUpdate<T> }[];
      filters?: Filters; // Optional filters to apply to ALL updates
    }): Promise<TableRow<T>[]> => {
      const { updates, filters } = params;
      const results: TableRow<T>[] = [];

      for (let i = 0; i < updates.length; i += batchSize) {
        const batch = updates.slice(i, i + batchSize);

        const batchPromises = batch.map(async ({ id, data }) => {
          let query = supabase
            .from(tableName)
            .update(data as any)
            .eq("id" as any, id);

          // Apply additional filters if provided
          if (filters) {
            query = applyFilters(query, filters);
          }

          const { data: result, error } = await query.select();
          if (error) throw error;
          return result as TableRow<T>[];
        });

        const batchResults = await Promise.all(batchPromises);
        results.push(...batchResults.flat());
      }

      return results;
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ["table", tableName] });
      queryClient.invalidateQueries({ queryKey: ["unique", tableName] });
    },
  });

  // Enhanced bulk delete with filter support
  const bulkDelete = useMutation({
    mutationFn: async (params: {
      ids?: string[];
      filters?: Filters; // Optional: delete by filters instead of/in addition to IDs
      deleteAll?: boolean; // Safety flag for deleting all records
    }): Promise<void> => {
      const { ids, filters, deleteAll = false } = params;

      // Safety check: require either IDs, filters, or explicit deleteAll flag
      if (!ids && !filters && !deleteAll) {
        throw new Error("Must provide either ids, filters, or set deleteAll to true");
      }

      if (ids && ids.length > 0) {
        // Delete by IDs (existing behavior, but with optional additional filters)
        for (let i = 0; i < ids.length; i += batchSize) {
          const batch = ids.slice(i, i + batchSize);
          let query = supabase
            .from(tableName)
            .delete()
            .in("id" as any, batch);

          // Apply additional filters if provided
          if (filters) {
            query = applyFilters(query, filters);
          }

          const { error } = await query;
          if (error) throw error;
        }
      } else if (filters || deleteAll) {
        // Delete by filters only
        let query = supabase.from(tableName).delete();

        if (filters) {
          query = applyFilters(query, filters);
        }

        const { error } = await query;
        if (error) throw error;
      }
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ["table", tableName] });
      queryClient.invalidateQueries({ queryKey: ["unique", tableName] });
    },
  });

  const bulkUpsert = useMutation({
    mutationFn: async (data: TableInsert<T>[]): Promise<TableRow<T>[]> => {
      const results: TableRow<T>[] = [];
      for (let i = 0; i < data.length; i += batchSize) {
        const batch = data.slice(i, i + batchSize) as any;
        const { data: batchResult, error } = await supabase.from(tableName).upsert(batch).select();
        if (error) throw error;
        results.push(...(batchResult as TableRow<T>[]));
      }
      return results;
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ["table", tableName] });
      queryClient.invalidateQueries({ queryKey: ["unique", tableName] });
    },
  });

  // New: Bulk insert with conditional logic based on existing data
  const bulkInsertByFilters = useMutation({
    mutationFn: async (params: {
      data: TableInsert<T>[];
      conflictResolution?: "skip" | "update" | "error"; // How to handle conflicts
      checkFilters?: Filters; // Check if records matching these filters exist
      onConflict?: string; // Column(s) to check for conflicts (e.g., 'email' or 'email,username')
    }): Promise<TableRow<T>[]> => {
      const { data, conflictResolution = "error", checkFilters, onConflict } = params;

      if (checkFilters) {
        // Check for existing records that match the filters
        let checkQuery = supabase.from(tableName).select("id");
        checkQuery = applyFilters(checkQuery, checkFilters);

        const { data: existingRecords, error: checkError } = await checkQuery;
        if (checkError) throw checkError;

        if (existingRecords && existingRecords.length > 0) {
          switch (conflictResolution) {
            case "skip":
              return []; // Skip insertion if records exist
            case "error":
              throw new Error(`Records matching filters already exist: ${existingRecords.length} found`);
            case "update":
              // Convert to upsert operation
              const { data: upsertResult, error: upsertError } = await supabase
                .from(tableName)
                .upsert(data as any, { onConflict })
                .select();
              if (upsertError) throw upsertError;
              return upsertResult as TableRow<T>[];
          }
        }
      }

      // Proceed with normal insertion
      const results: TableRow<T>[] = [];
      for (let i = 0; i < data.length; i += batchSize) {
        const batch = data.slice(i, i + batchSize) as any;

        let insertQuery = supabase.from(tableName).insert(batch);

        // Handle conflicts at database level if onConflict is specified
        if (conflictResolution === "skip" && onConflict) {
          insertQuery = supabase.from(tableName).upsert(batch, {
            onConflict,
            ignoreDuplicates: true,
          });
        } else if (conflictResolution === "update" && onConflict) {
          insertQuery = supabase.from(tableName).upsert(batch, { onConflict });
        }

        const { data: batchResult, error } = await insertQuery.select();
        if (error) throw error;
        results.push(...(batchResult as TableRow<T>[]));
      }
      return results;
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ["table", tableName] });
      queryClient.invalidateQueries({ queryKey: ["unique", tableName] });
    },
  });

  // New: Bulk update by filters (update multiple records matching criteria)
  const bulkUpdateByFilters = useMutation({
    mutationFn: async (params: {
      data: TableUpdate<T>;
      filters: Filters;
      limit?: number; // Optional safety limit
    }): Promise<TableRow<T>[]> => {
      const { data, filters, limit } = params;

      let query = supabase.from(tableName).update(data as any);

      // Apply filters
      query = applyFilters(query, filters);

      // Apply limit if provided (for safety)
      if (limit) {
        query = query.limit(limit);
      }

      const { data: result, error } = await query.select();
      if (error) throw error;
      return result as TableRow<T>[];
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ["table", tableName] });
      queryClient.invalidateQueries({ queryKey: ["unique", tableName] });
    },
  });

  // New: Bulk upsert with filter-based conflict detection
  const bulkUpsertByFilters = useMutation({
    mutationFn: async (params: {
      data: TableInsert<T>[];
      onConflict?: string; // Column(s) for conflict detection
      checkFilters?: Filters; // Pre-check existing records
      updateColumns?: string[]; // Which columns to update on conflict (if not specified, updates all)
    }): Promise<TableRow<T>[]> => {
      const { data, onConflict, checkFilters, updateColumns } = params;

      // Optional: Check existing records first
      if (checkFilters) {
        try {
          // Create a new query builder
          let checkQuery = supabase.from(tableName).select("*", { count: "exact" });

          // Apply the filters
          checkQuery = applyFilters(checkQuery, checkFilters);

          // Execute the query
          const { data: existingRecords, error: checkError, count } = await checkQuery;

          if (checkError) {
            throw checkError;
          }

          console.log(`Found ${count || 0} existing records matching filters`);
        } catch (error) {
          throw error;
        }
      }

      const results: TableRow<T>[] = [];
      for (let i = 0; i < data.length; i += batchSize) {
        const batch = data.slice(i, i + batchSize) as any;

        const upsertOptions: any = {};
        if (onConflict) {
          upsertOptions.onConflict = onConflict;
        }
        if (updateColumns) {
          upsertOptions.columns = updateColumns;
        }

        const { data: batchResult, error } = await supabase.from(tableName).upsert(batch, upsertOptions).select();

        if (error) throw error;
        results.push(...(batchResult as TableRow<T>[]));
      }
      return results;
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ["table", tableName] });
      queryClient.invalidateQueries({ queryKey: ["unique", tableName] });
    },
  });

  // New: Conditional bulk operations (perform operation only if conditions are met)
  const conditionalBulkUpdate = useMutation({
    mutationFn: async (params: {
      updates: Array<{
        id: string;
        data: TableUpdate<T>;
        conditions?: Filters; // Conditions that must be met for this specific update
      }>;
      globalFilters?: Filters; // Filters applied to all updates
    }): Promise<TableRow<T>[]> => {
      const { updates, globalFilters } = params;
      const results: TableRow<T>[] = [];

      for (let i = 0; i < updates.length; i += batchSize) {
        const batch = updates.slice(i, i + batchSize);

        const batchPromises = batch.map(async ({ id, data, conditions }) => {
          let query = supabase
            .from(tableName)
            .update(data as any)
            .eq("id" as any, id);

          // Apply global filters
          if (globalFilters) {
            query = applyFilters(query, globalFilters);
          }

          // Apply individual conditions
          if (conditions) {
            query = applyFilters(query, conditions);
          }

          const { data: result, error } = await query.select();
          if (error) throw error;
          return result as TableRow<T>[];
        });

        const batchResults = await Promise.all(batchPromises);
        results.push(...batchResults.flat());
      }

      return results;
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ["table", tableName] });
      queryClient.invalidateQueries({ queryKey: ["unique", tableName] });
    },
  });

  return {
    bulkInsert,
    bulkUpdate,
    bulkDelete,
    bulkUpsert,
    bulkUpdateByFilters,
    bulkInsertByFilters,
    bulkUpsertByFilters,
    conditionalBulkUpdate,
  };
}

```

<!-- path: hooks/database/path-queries.ts -->
```typescript
// path: hooks/database/path-queries.ts
"use client";

import { useQuery } from "@tanstack/react-query";
import { createClient } from "@/utils/supabase/client";
import { FiberTrace, FiberTraceNode } from "@/components/route-manager/types"; // Import updated types
import { toast } from "sonner";
import { useRpcQuery } from "./rpc-queries"; // Use our generic RPC hook

const supabase = createClient();

/**
 * Fetches the detailed, ordered path segments for a given logical path.
 */
export function useSystemPath(logicalPathId: string | null) {
  return useRpcQuery(
    supabase,
    'get_system_path_details',
    { p_path_id: logicalPathId },
    { enabled: !!logicalPathId }
  );
}

/**
 * Fetches the list of continuously available fiber numbers for a given path.
 */
export function useAvailableFibers(pathId: string | null) {
  return useRpcQuery(
    supabase,
    'get_continuous_available_fibers',
    { p_path_id: pathId },
    { enabled: !!pathId }
  );
}

/**
 * Hook to trace a fiber's complete path using the recursive RPC function.
 */
export function useFiberTrace(cableId: string | null, fiberNo: number | null) {
  return useQuery({
    queryKey: ['fiber-trace', cableId, fiberNo],
    queryFn: async (): Promise<FiberTrace[] | null> => {
      if (!cableId || fiberNo === null) return null;

      const { data, error } = await supabase.rpc('trace_fiber_path', {
        p_start_cable_id: cableId,
        p_start_fiber_no: fiberNo
      });

      if (error) {
        toast.error(`Trace failed: ${error.message}`);
        throw error;
      }

      return data as FiberTrace[] || [];
    },
    enabled: !!cableId && fiberNo !== null,
  });
}
```

<!-- path: hooks/database/basic-mutation-hooks.ts -->
```typescript
/* eslint-disable @typescript-eslint/no-explicit-any */
import { useMutation, useQueryClient } from "@tanstack/react-query";
import { SupabaseClient } from "@supabase/supabase-js";
import { Database } from "@/types/supabase-types";
import { TableName, TableRow, TableInsert, TableUpdate, OptimisticContext, UseTableMutationOptions } from "./queries-type-helpers";

// Generic toggle status hook
export function useToggleStatus<T extends TableName>(supabase: SupabaseClient<Database>, tableName: T, options?: UseTableMutationOptions<TableRow<T>, { id: string; status: boolean; nameField?: keyof TableRow<T> }, OptimisticContext>) {
  const queryClient = useQueryClient();
  const { invalidateQueries = true, optimisticUpdate = true, ...mutationOptions } = options || {};

  return useMutation<TableRow<T>, Error, { id: string; status: boolean; nameField?: keyof TableRow<T> }, OptimisticContext>({
    mutationFn: async ({ id, status }): Promise<TableRow<T>> => {
      const { data, error } = await supabase
        .from(tableName)
        .update({ status, updated_at: new Date().toISOString() } as any)
        .eq("id" as any, id)
        .select()
        .single();
      if (error) throw error;
      return data as TableRow<T>;
    },
    onMutate: optimisticUpdate
      ? async ({ id, status }) => {
          await queryClient.cancelQueries({ queryKey: ["table", tableName] });
          const previousData = queryClient.getQueriesData({ queryKey: ["table", tableName] });
          queryClient.setQueriesData({ queryKey: ["table", tableName] }, (old: TableRow<T>[] | undefined) => {
            if (!old) return [];
            return old.map((item) => ("id" in item && (item as { id: unknown }).id === id ? { ...item, status, updated_at: new Date().toISOString() } : item)) as TableRow<T>[];
          });
          return { previousData };
        }
      : undefined,
    onError: optimisticUpdate
      ? (err, variables, context) => {
          context?.previousData?.forEach(([queryKey, data]) => queryClient.setQueryData(queryKey, data));
        }
      : undefined,
    onSuccess: (data, variables, context) => {
      if (invalidateQueries) {
        queryClient.invalidateQueries({ queryKey: ["table", tableName] });
        queryClient.invalidateQueries({ queryKey: ["unique", tableName] });
      }
      options?.onSuccess?.(data, variables, context);
    },
    ...mutationOptions,
  });
}

// Optimized insert mutation with batching
export function useTableInsert<T extends TableName>(supabase: SupabaseClient<Database>, tableName: T, options?: UseTableMutationOptions<TableRow<T>[], TableInsert<T> | TableInsert<T>[], OptimisticContext>) {
  const queryClient = useQueryClient();
  const { invalidateQueries = true, optimisticUpdate = false, batchSize = 1000, ...mutationOptions } = options || {};

  return useMutation<TableRow<T>[], Error, TableInsert<T> | TableInsert<T>[], OptimisticContext>({
    mutationFn: async (data: TableInsert<T> | TableInsert<T>[]): Promise<TableRow<T>[]> => {
      const payload = (Array.isArray(data) ? data : [data]) as any;

      // Batch large inserts for better performance
      if (payload.length > batchSize) {
        const batches = [];
        for (let i = 0; i < payload.length; i += batchSize) {
          batches.push(payload.slice(i, i + batchSize));
        }

        const results = await Promise.all(
          batches.map(async (batch) => {
            const { data: result, error } = await supabase.from(tableName).insert(batch).select();
            if (error) throw error;
            return result as TableRow<T>[];
          })
        );

        return results.flat();
      }

      const { data: result, error } = await supabase.from(tableName).insert(payload).select();

      if (error) throw error;
      return result as TableRow<T>[];
    },
    onMutate: optimisticUpdate
      ? async (newData) => {
          await queryClient.cancelQueries({ queryKey: ["table", tableName] });

          const previousData = queryClient.getQueriesData({
            queryKey: ["table", tableName],
          });

          queryClient.setQueriesData({ queryKey: ["table", tableName] }, (old: TableRow<T>[] | undefined) => {
            if (!old) return [];
            const newItems = Array.isArray(newData) ? newData : [newData];
            return [
              ...old,
              ...newItems.map((item, index) => ({
                ...item,
                id: `temp-${Date.now()}-${index}`,
              })),
            ] as TableRow<T>[];
          });

          return { previousData };
        }
      : undefined,
    onError: optimisticUpdate
      ? (err, newData, context) => {
          if (context?.previousData) {
            context.previousData.forEach(([queryKey, data]) => {
              queryClient.setQueryData(queryKey, data);
            });
          }
        }
      : undefined,
    onSuccess: (data, variables, context) => {
      if (invalidateQueries) {
        queryClient.invalidateQueries({ queryKey: ["table", tableName] });
        queryClient.invalidateQueries({ queryKey: ["unique", tableName] });
      }
      options?.onSuccess?.(data, variables, context);
    },
    ...mutationOptions,
  });
}

// Enhanced update mutation with optimizations
export function useTableUpdate<T extends TableName>(supabase: SupabaseClient<Database>, tableName: T, options?: UseTableMutationOptions<TableRow<T>[], { id: string; data: TableUpdate<T> }, OptimisticContext>) {
  const queryClient = useQueryClient();
  const { invalidateQueries = true, optimisticUpdate = false, ...mutationOptions } = options || {};

  return useMutation<TableRow<T>[], Error, { id: string; data: TableUpdate<T> }, OptimisticContext>({
    mutationFn: async ({ id, data }: { id: string; data: TableUpdate<T> }): Promise<TableRow<T>[]> => {
      const { data: result, error } = await supabase
        .from(tableName)
        .update(data as any)
        .eq("id" as any, id)
        .select();

      if (error) throw error;
      return result as TableRow<T>[];
    },
    onMutate: optimisticUpdate
      ? async ({ id, data: newData }) => {
          await queryClient.cancelQueries({ queryKey: ["table", tableName] });

          const previousData = queryClient.getQueriesData({
            queryKey: ["table", tableName],
          });

          queryClient.setQueriesData({ queryKey: ["table", tableName] }, (old: TableRow<T>[] | undefined) => {
            if (!old) return [];
            return old.map((item) => ("id" in item && (item as { id: unknown }).id === id ? { ...item, ...newData } : item)) as TableRow<T>[];
          });

          return { previousData };
        }
      : undefined,
    onError: optimisticUpdate
      ? (err, variables, context) => {
          if (context?.previousData) {
            context.previousData.forEach(([queryKey, data]) => {
              queryClient.setQueryData(queryKey, data);
            });
          }
        }
      : undefined,
    onSuccess: (data, variables, context) => {
      if (invalidateQueries) {
        queryClient.invalidateQueries({ queryKey: ["table", tableName] });
        queryClient.invalidateQueries({ queryKey: ["unique", tableName] });
      }
      options?.onSuccess?.(data, variables, context);
    },
    ...mutationOptions,
  });
}

// Enhanced delete mutation
export function useTableDelete<T extends TableName>(supabase: SupabaseClient<Database>, tableName: T, options?: UseTableMutationOptions<void, string | string[], OptimisticContext>) {
  const queryClient = useQueryClient();
  const { invalidateQueries = true, optimisticUpdate = false, batchSize = 1000, ...mutationOptions } = options || {};

  return useMutation<void, Error, string | string[], OptimisticContext>({
    mutationFn: async (id: string | string[]): Promise<void> => {
      const ids = Array.isArray(id) ? id : [id];

      // Batch large deletes for better performance
      if (ids.length > batchSize) {
        const batches = [];
        for (let i = 0; i < ids.length; i += batchSize) {
          batches.push(ids.slice(i, i + batchSize));
        }

        await Promise.all(
          batches.map(async (batch) => {
            const { error } = await supabase
              .from(tableName)
              .delete()
              .in("id" as any, batch);
            if (error) throw error;
          })
        );
        return;
      }

      const { error } = await supabase
        .from(tableName)
        .delete()
        .in("id" as any, ids);

      if (error) throw error;
    },
    onMutate: optimisticUpdate
      ? async (id) => {
          await queryClient.cancelQueries({ queryKey: ["table", tableName] });

          const previousData = queryClient.getQueriesData({
            queryKey: ["table", tableName],
          });
          const ids = Array.isArray(id) ? id : [id];

          queryClient.setQueriesData({ queryKey: ["table", tableName] }, (old: TableRow<T>[] | undefined) => {
            if (!old) return [];
            return old.filter((item) => !("id" in item) || !ids.includes((item as { id: string }).id)) as TableRow<T>[];
          });

          return { previousData };
        }
      : undefined,
    onError: optimisticUpdate
      ? (err, variables, context) => {
          if (context?.previousData) {
            context.previousData.forEach(([queryKey, data]) => {
              queryClient.setQueryData(queryKey, data);
            });
          }
        }
      : undefined,
    onSuccess: (data, variables, context) => {
      if (invalidateQueries) {
        queryClient.invalidateQueries({ queryKey: ["table", tableName] });
        queryClient.invalidateQueries({ queryKey: ["unique", tableName] });
      }
      options?.onSuccess?.(data, variables, context);
    },
    ...mutationOptions,
  });
}

```

<!-- path: hooks/database/file-queries.ts -->
```typescript
import { useMutation, useQuery, useQueryClient } from "@tanstack/react-query";
import { createClient } from "@/utils/supabase/client";
import { Database } from "@/types/supabase-types";

type FileRecord = Database["public"]["Tables"]["files"]["Row"];
type FileInsert = Database["public"]["Tables"]["files"]["Insert"];
type FileUpdate = Database["public"]["Tables"]["files"]["Update"];

export function useFiles(folderId?: string | null) {
  const supabase = createClient();
  
  return useQuery({
    queryKey: ["files", folderId],
    queryFn: async () => {
      let query = supabase
        .from("files")
        .select("*");
      
      if (folderId) {
        query = query.eq("folder_id", folderId);
      }
      
      const { data, error } = await query.order("uploaded_at", { ascending: false });
      
      if (error) {
        throw new Error(error.message);
      }
      
      return data || [];
    },
    enabled: true,
  });
}

export function useUploadFile() {
  const supabase = createClient();
  const queryClient = useQueryClient();
  
  return useMutation({
    mutationFn: async (fileData: FileInsert) => {
      const { data, error } = await supabase
        .from("files")
        .insert(fileData)
        .select()
        .single();
        
      if (error) {
        throw new Error(error.message);
      }
      
      return data;
    },
    onSuccess: (data, variables) => {
      queryClient.invalidateQueries({ 
        queryKey: ["files", variables.folder_id] 
      });
    },
  });
}

export function useDeleteFile() {
  const supabase = createClient();
  const queryClient = useQueryClient();
  
  return useMutation({
    mutationFn: async ({
      id,
      folderId,
    }: {
      id: string;
      folderId?: string | null;
    }) => {
      const { error } = await supabase
        .from("files")
        .delete()
        .eq("id", id);
        
      if (error) {
        throw new Error(error.message);
      }
      
      return { id };
    },
    onSuccess: (_, variables) => {
      queryClient.invalidateQueries({ 
        queryKey: ["files", variables.folderId] 
      });
    },
  });
}

export function useUpdateFile() {
  const supabase = createClient();
  const queryClient = useQueryClient();
  
  return useMutation({
    mutationFn: async ({
      id,
      updates,
    }: {
      id: string;
      updates: FileUpdate;
    }) => {
      const { data, error } = await supabase
        .from("files")
        .update(updates)
        .eq("id", id)
        .select()
        .single();
        
      if (error) {
        throw new Error(error.message);
      }
      
      return data;
    },
    onSuccess: (data) => {
      queryClient.invalidateQueries({ 
        queryKey: ["files", data.folder_id] 
      });
    },
  });
}

```

<!-- path: hooks/database/utility-functions.ts -->
```typescript
/* eslint-disable @typescript-eslint/no-explicit-any */
import { QueryKey } from '@tanstack/react-query';
import {
  AggregationOptions,
  DeduplicationOptions,
  EnhancedOrderBy,
  FilterOperator,
  Filters,
  OrderBy,
  PerformanceOptions,
} from './queries-type-helpers';
import { Json } from '@/types/supabase-types';
// The rich 'Filters' type is no longer needed for the RPCs.
// We'll define a simpler type.
export type RpcFilters = Record<string, string | number | boolean | string[] | null>;

/**
 * Converts a filter object from the UI into a simple JSON object
 * suitable for our generic RPC functions.
 *
 * @param filters The filter object from the UI state.
 * @returns A Json-compatible object.
 */
export function buildRpcFilters(filters: RpcFilters): Json {
  const rpcFilters: { [key: string]: Json | undefined } = {};

  for (const key in filters) {
    const filterValue = filters[key];

    // Only include filters that have a meaningful value
    if (filterValue !== null && filterValue !== undefined && filterValue !== '') {
      rpcFilters[key] = filterValue as Json;
    }
  }

  // Special handling for the 'or' filter, which should be a string
  if (filters.or && typeof filters.or === 'string') {
    rpcFilters.or = filters.or;
  }

  return rpcFilters;
}

// // Usage example:
// const myFilters: RpcFilters = {
//   status: true,
//   name: 'Central', // For ILIKE
//   node_type_id: ['uuid1', 'uuid2'], // For IN
//   // For a complex OR, you would construct the PostgREST string
//   or: '(maintenance_area_name.ilike.*North*,code.eq.NRT)'
// };

// --- UTILITY FUNCTIONS ---
export const createQueryKey = (
  tableName: string,
  filters?: Filters,
  columns?: string,
  orderBy?: OrderBy[],
  deduplication?: DeduplicationOptions,
  aggregation?: AggregationOptions,
  enhancedOrderBy?: EnhancedOrderBy[],
  limit?: number,
  offset?: number
): QueryKey => {
  const key: unknown[] = ['table', tableName];
  const params: Record<string, unknown> = {
    filters,
    columns,
    orderBy,
    deduplication,
    aggregation,  
    enhancedOrderBy,
    limit,
    offset,
  };
  const cleanParams = Object.fromEntries(
    Object.entries(params).filter(
      ([, value]) => value !== undefined && value !== null
    )
  );
  if (Object.keys(cleanParams).length > 0) key.push(cleanParams);
  return key;
};

export const createRpcQueryKey = (
  functionName: string,
  args?: Record<string, unknown>,
  performance?: PerformanceOptions
): QueryKey => {
  const key: unknown[] = ['rpc', functionName];
  const params = { args, performance };
  const cleanParams = Object.fromEntries(
    Object.entries(params).filter(
      ([, value]) => value !== undefined && value !== null
    )
  );
  if (Object.keys(cleanParams).length > 0) key.push(cleanParams);
  return key;
};

export const createUniqueValuesKey = (
  tableName: string,
  column: string,
  filters?: Filters,
  orderBy?: OrderBy[],
  enhancedOrderBy?: EnhancedOrderBy[]
): QueryKey => [
  'unique',
  tableName,
  column,
  { filters, orderBy, enhancedOrderBy }
];

export function applyFilters(query: any, filters: Filters): any {
  let modifiedQuery = query;
  Object.entries(filters).forEach(([key, value]) => {
    if (value === undefined || value === null) return;

    if (key === '$or' || key === 'or') {
      if (typeof value === 'string') {
        modifiedQuery = modifiedQuery.or(value);
      } else {
        console.warn('Unsupported $or filter format; expected a raw string.');
      }
      return;
    }

    if (
      typeof value === 'object' &&
      !Array.isArray(value) &&
      'operator' in value
    ) {
      const { operator, value: filterValue } = value as {
        operator: FilterOperator;
        value: unknown;
      };

      if (
        operator in modifiedQuery &&
        typeof (modifiedQuery as any)[operator] === 'function'
      ) {
        modifiedQuery = modifiedQuery[operator](key, filterValue);
      } else {
        console.warn(`Unsupported or dynamic operator used: ${operator}`);
      }
    } else if (Array.isArray(value)) {
      modifiedQuery = modifiedQuery.in(key, value);
    } else {
      modifiedQuery = modifiedQuery.eq(key, value);
    }
  });
  return modifiedQuery;
}

// Enhanced version with better type safety and validation
export function applyOrdering(query: any, orderBy: OrderBy[]): any {
  let modifiedQuery = query;

  orderBy.forEach(({ column, ascending = true, nullsFirst, foreignTable }) => {
    // Validate column name to prevent injection
    if (!column || typeof column !== 'string') {
      console.warn(`Invalid column name: ${column}`);
      return;
    }

    // Build the column reference
    const orderColumn = foreignTable ? `${foreignTable}.${column}` : column;

    // Build options object
    const options: { ascending: boolean; nullsFirst?: boolean } = { ascending };
    if (nullsFirst !== undefined) {
      options.nullsFirst = nullsFirst;
    }

    try {
      modifiedQuery = modifiedQuery.order(orderColumn, options);
    } catch (error) {
      console.error(`Error applying order by ${orderColumn}:`, error);
      // Continue with other orderings even if one fails
    }
  });

  return modifiedQuery;
}

// Alternative version with more explicit type handling for EnhancedOrderBy
export function applyEnhancedOrdering(
  query: any,
  orderBy: EnhancedOrderBy[]
): any {
  let modifiedQuery = query;

  orderBy.forEach(
    ({ column, ascending = true, nullsFirst, foreignTable, dataType }) => {
      // Validate column name to prevent injection
      if (!column || typeof column !== 'string') {
        console.warn(`Invalid column name: ${column}`);
        return;
      }

      const orderColumn = foreignTable ? `${foreignTable}.${column}` : column;

      const options: any = { ascending };
      if (nullsFirst !== undefined) {
        options.nullsFirst = nullsFirst;
      }

      // Optional: Add type-specific handling
      if (dataType) {
        switch (dataType) {
          case 'numeric':
            // Supabase handles numeric sorting automatically
            break;
          case 'text':
            // For case-insensitive text sorting, you'd need custom SQL
            // This is handled at the PostgreSQL level
            break;
          case 'date':
          case 'timestamp':
            // Date sorting is handled well by default
            break;
          default:
            break;
        }
      }

      try {
        modifiedQuery = modifiedQuery.order(orderColumn, options);
      } catch (error) {
        console.error(
          `Error applying enhanced order by ${orderColumn}:`,
          error
        );
      }
    }
  );

  return modifiedQuery;
}

export function buildDeduplicationQuery(
  tableName: string,
  deduplication: DeduplicationOptions,
  filters?: Filters,
  orderBy?: OrderBy[]
): string {
  const { columns, orderBy: dedupOrderBy } = deduplication;
  const partitionBy = columns.join(', ');
  const rowNumberOrder = dedupOrderBy?.length
    ? dedupOrderBy
        .map((o) => `${o.column} ${o.ascending !== false ? 'ASC' : 'DESC'}`)
        .join(', ')
    : 'id ASC';

  let finalOrderClause = '';
  if (orderBy && orderBy.length > 0) {
    const orderParts = orderBy.map(
      (o) =>
        `${o.column} ${o.ascending !== false ? 'ASC' : 'DESC'}${
          o.nullsFirst !== undefined
            ? o.nullsFirst
              ? ' NULLS FIRST'
              : ' NULLS LAST'
            : ''
        }`
    );
    finalOrderClause = `ORDER BY ${orderParts.join(', ')}`;
  }

  let whereClause = '';
  if (filters && Object.keys(filters).length > 0) {
    const conditions = Object.entries(filters)
      .filter(([, value]) => value !== undefined && value !== null)
      .map(([key, value]) => {
        if (
          value &&
          typeof value === 'object' &&
          !Array.isArray(value) &&
          'operator' in value
        ) {
          const filterValue =
            typeof value.value === 'string'
              ? `'${value.value.toString().replace(/'/g, "''")}'`
              : value.value;
          return `${key} = ${filterValue}`;
        }
        if (Array.isArray(value)) {
          const arrayValues = value
            .map((v) =>
              typeof v === 'string' ? `'${v.replace(/'/g, "''")}'` : v
            )
            .join(',');
          return `${key} IN (${arrayValues})`;
        }
        const filterValue =
          typeof value === 'string' ? `'${value.replace(/'/g, "''")}'` : value;
        return `${key} = ${filterValue}`;
      });

    if (conditions.length > 0)
      whereClause = `WHERE ${conditions.join(' AND ')}`;
  }

  return `
    WITH deduplicated AS (
      SELECT *, ROW_NUMBER() OVER (PARTITION BY ${partitionBy} ORDER BY ${rowNumberOrder}) as rn
      FROM ${tableName}
      ${whereClause}
    )
    SELECT * FROM deduplicated WHERE rn = 1 ${finalOrderClause}
  `;
}

/**
 * Converts a rich "Filters" object (used by the PostgREST query builder)
 * into a simple key-value JSON object suitable for RPC functions.
 * It strips out complex operators and preserves simple values.
 *
 * @param filters The rich Filters object.
 * @returns A Json-compatible object.
 */
export function convertRichFiltersToSimpleJson(filters: Filters): Json {
  const simpleFilters: { [key: string]: Json | undefined } = {};

  for (const key in filters) {
    // Skip the client-side only '$or' operator
    if (key === '$or') {
      continue;
    }

    const filterValue = filters[key];

    // Check if the value is a simple primitive (string, number, boolean, or null)
    if (
      typeof filterValue === 'string' ||
      typeof filterValue === 'number' ||
      typeof filterValue === 'boolean' ||
      filterValue === null
    ) {
      simpleFilters[key] = filterValue;
    }
    // You can also handle simple arrays if your RPCs support the 'IN' operator
    else if (Array.isArray(filterValue)) {
      simpleFilters[key] = filterValue;
    }
    // We explicitly IGNORE complex objects like { operator: 'neq', value: '...' }
    // because the RPC function doesn't know how to handle them.
  }

  return simpleFilters;
}

```

<!-- path: hooks/database/route-manager-hooks.ts -->
```typescript
// path: hooks/database/route-manager-hooks.ts

import { useMutation, useQuery, useQueryClient } from '@tanstack/react-query';
import { createClient } from '@/utils/supabase/client';
import { JcSplicingDetails, AutoSpliceResult } from '@/components/route-manager/types';
import { toast } from 'sonner';
import {
  Ofc_cablesRowSchema,
  V_junction_closures_completeRowSchema,
  V_ofc_cables_completeRowSchema,
} from '@/schemas/zod-schemas';

export type OfcForSelection = Pick<Ofc_cablesRowSchema, 'id' | 'route_name' | 'capacity'>;

export type JunctionClosure = Pick<V_junction_closures_completeRowSchema, 'id' | 'node_id' | 'name' | 'ofc_cable_id' | 'latitude' | 'longitude' | 'position_km'>;

export type CableRoute = {
  id: V_ofc_cables_completeRowSchema['id'];
  route_name: V_ofc_cables_completeRowSchema['route_name'];
  capacity: V_ofc_cables_completeRowSchema['capacity'];
  current_rkm: V_ofc_cables_completeRowSchema['current_rkm'];
  start_node: {
    id: V_ofc_cables_completeRowSchema['sn_id'];
    name: V_ofc_cables_completeRowSchema['sn_name'];
  };
  end_node: {
    id: V_ofc_cables_completeRowSchema['en_id'];
    name: V_ofc_cables_completeRowSchema['en_name'];
  };
};

// Detailed data for a selected route, fetched on the client
export interface RouteDetailsPayload {
  route: CableRoute;
  junction_closures: JunctionClosure[];
}

const supabase = createClient();

/** Fetches a list of all OFC cables that have at least one related row in ofc_connections for the selection dropdown. */
export function useOfcRoutesForSelection() {
  return useQuery({
    queryKey: ['ofc-routes-for-selection'],
    queryFn: async (): Promise<OfcForSelection[]> => {
      const { data, error } = await supabase
        .from('ofc_cables')
        // Only include cables that have at least one related row in ofc_connections
        // Using PostgREST's inner join filter syntax: related_table!inner()
        .select('id, route_name, capacity, ofc_connections!inner(id)')
        .order('route_name');
      if (error) throw error;
      // Ensure we only return the fields required by OfcForSelection
      type Row = {
        id: string;
        route_name: string;
        capacity: number;
        ofc_connections: { id: string }[];
      };
      const rows = (data || []) as Row[];
      return rows.map((row) => ({
        id: row.id,
        route_name: row.route_name,
        capacity: row.capacity,
      }));
    },
    staleTime: 5 * 60 * 1000,
  });
}

/** Fetches detailed info for a single OFC Cable, including its JCs. */
export function useRouteDetails(routeId: string | null) {
  return useQuery({
    queryKey: ['route-details', routeId],
    queryFn: async (): Promise<RouteDetailsPayload | null> => {
      console.log("routeId",routeId);
      if (!routeId) return null;
      // Fetch from the complete view which already has the node names
      const { data: routeData, error: routeError } = await supabase
        .from('v_ofc_cables_complete')
        .select('*')
        .eq('id', routeId)
        .single();
      if (routeError) throw routeError;
      if (!routeData) return null;

      const { data: jcData, error: jcError } = await supabase
        .from('v_junction_closures_complete')
        .select('*')
        .eq('ofc_cable_id', routeId)
        .order('position_km');
      if (jcError) throw jcError;

      // Type-safe mapping from the view row to the payload structure
      const route: RouteDetailsPayload['route'] = {
        id: routeData.node_id!,
        route_name: routeData.route_name!,
        start_node: { id: routeData.sn_id!, name: routeData.sn_name || 'Unknown SN' },
        end_node: { id: routeData.en_id!, name: routeData.en_name || 'Unknown EN' },
        capacity: routeData.capacity!,
        current_rkm: routeData.current_rkm,
      };

      return { route, junction_closures: jcData as JunctionClosure[] };
    },
    enabled: !!routeId,
    // staleTime: 5 * 60 * 1000,
  });
}

/** Fetches only the relevant cables that can be spliced at a given JC. */
export function useCablesForJc(jcId: string | null) {
  return useQuery({
    queryKey: ['cables-for-jc', jcId],
    queryFn: async (): Promise<OfcForSelection[]> => {
      if (!jcId) return [];
      const { data, error } = await supabase.rpc('get_cables_at_jc', { p_jc_id: jcId });
      if (error) throw error;
      return (data as OfcForSelection[]) || [];
    },
    enabled: !!jcId,
  });
}

/** Fetches all data needed for the splice matrix editor for a single JC. */
export function useJcSplicingDetails(jcId: string | null) {
  return useQuery({
    queryKey: ['jc-splicing-details', jcId],
    queryFn: async (): Promise<JcSplicingDetails | null> => {
      if (!jcId) return null;
      const { data, error } = await supabase.rpc('get_jc_splicing_details', { p_jc_id: jcId });
      if (error) throw error;
      return data as JcSplicingDetails;
    },
    enabled: !!jcId,
  });
}

/** Hook to delete a Junction Closure. */
export function useDeleteJc() {
  const queryClient = useQueryClient();
  return useMutation({
    mutationFn: async (jcId: string) => {
      const { error } = await supabase.from('junction_closures').delete().eq('id', jcId);
      if (error) throw error;
    },
    onSuccess: (_, jcId) => {
      toast.success('Junction Closure deleted successfully.');
      queryClient.invalidateQueries({ queryKey: ['route-details'] });
      queryClient.invalidateQueries({ queryKey: ['jc-splicing-details', jcId] });
    },
    onError: (error) => toast.error(`Failed to delete JC: ${error.message}`),
  });
}

/** Hook to call the `manage_splice` RPC function. */
export function useManageSplice() {
  const queryClient = useQueryClient();
  return useMutation({
    mutationFn: async (variables: {
      action: 'create' | 'delete' | 'update_otdr';
      jcId: string;
      spliceId?: string;
      incomingCableId?: string;
      incomingFiberNo?: number;
      outgoingCableId?: string;
      outgoingFiberNo?: number;
      spliceType?: 'pass_through' | 'branch' | 'termination';
      otdrLengthKm?: number;
    }) => {
      const { data, error } = await supabase.rpc('manage_splice', {
        p_action: variables.action,
        p_jc_id: variables.jcId,
        p_splice_id: variables.spliceId,
        p_incoming_cable_id: variables.incomingCableId,
        p_incoming_fiber_no: variables.incomingFiberNo,
        p_outgoing_cable_id: variables.outgoingCableId,
        p_outgoing_fiber_no: variables.outgoingFiberNo,
        p_splice_type: variables.spliceType,
        p_otdr_length_km: variables.otdrLengthKm,
      });
      if (error) throw error;
      return data;
    },
    onSuccess: (_, variables) =>
      queryClient.invalidateQueries({ queryKey: ['jc-splicing-details', variables.jcId] }),
  });
}

/** Hook to call the `auto_splice_straight` RPC function. */
export function useAutoSplice() {
  const queryClient = useQueryClient();
  return useMutation({
    mutationFn: async (variables: { jcId: string; cable1Id: string; cable2Id: string }) => {
      const { data, error } = await supabase.rpc('auto_splice_straight', {
        p_jc_id: variables.jcId,
        p_cable1_id: variables.cable1Id,
        p_cable2_id: variables.cable2Id,
      });
      if (error) throw error;
      return data;
    },
    onSuccess: (data: unknown, variables) => {
      const result = data as AutoSpliceResult; // Type assertion
      const count = result?.splices_created || 0;
      toast.success(`${count} straight splices created successfully!`);
      queryClient.invalidateQueries({ queryKey: ['jc-splicing-details', variables.jcId] });
    },
    onError: (error) => toast.error(`Auto-splice failed: ${error.message}`),
  });
}

```

<!-- path: hooks/database/advanced-bulk-queries.ts -->
```typescript
/* eslint-disable @typescript-eslint/no-explicit-any */
import { useMutation, useQueryClient } from "@tanstack/react-query";
import { SupabaseClient } from "@supabase/supabase-js";
import { Database } from "@/types/supabase-types";
import { TableName, TableRow, TableUpdate, Filters, OrderBy, PerformanceOptions } from "./queries-type-helpers";
import { applyFilters, applyOrdering } from "./utility-functions";

// Enhanced bulk operations with more advanced filtering and performance features
export function useAdvancedBulkOperations<T extends TableName>(
  supabase: SupabaseClient<Database>,
  tableName: T,
  options?: {
    batchSize?: number;
    maxRetries?: number;
    retryDelay?: number;
    onProgress?: (completed: number, total: number) => void;
  }
) {
  const queryClient = useQueryClient();
  const { maxRetries = 3, retryDelay = 1000, onProgress } = options || {};

  // Helper function for retrying operations
  const withRetry = async <TResult>(operation: () => Promise<TResult>, retries = maxRetries): Promise<TResult> => {
    try {
      return await operation();
    } catch (error) {
      if (retries > 0) {
        await new Promise((resolve) => setTimeout(resolve, retryDelay));
        return withRetry(operation, retries - 1);
      }
      throw error;
    }
  };

  // Advanced bulk update with complex filtering and progress tracking
  const advancedBulkUpdate = useMutation({
    mutationFn: async (params: {
      criteria: {
        filters: Filters;
        data: TableUpdate<T>;
        orderBy?: OrderBy[];
        limit?: number;
      }[];
      performanceOptions?: PerformanceOptions;
    }): Promise<TableRow<T>[]> => {
      const { criteria, performanceOptions } = params;
      const allResults: TableRow<T>[] = [];
      let completed = 0;
      const total = criteria.length;

      for (const { filters, data, orderBy, limit } of criteria) {
        await withRetry(async () => {
          let query = supabase.from(tableName).update(data as any);

          // Apply filters
          query = applyFilters(query, filters);

          // Apply ordering if specified
          if (orderBy && orderBy.length > 0) {
            query = applyOrdering(query, orderBy);
          }

          // Apply limit if specified
          if (limit) {
            query = query.limit(limit);
          }

          // Apply performance options
          if (performanceOptions?.timeout) {
            query = query.abortSignal(AbortSignal.timeout(performanceOptions.timeout));
          }

          const { data: result, error } = await query.select();
          if (error) throw error;

          allResults.push(...(result as TableRow<T>[]));
          completed++;
          onProgress?.(completed, total);
        });
      }

      return allResults;
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ["table", tableName] });
      queryClient.invalidateQueries({ queryKey: ["unique", tableName] });
    },
  });

  // Advanced bulk delete with complex criteria
  const advancedBulkDelete = useMutation({
    mutationFn: async (params: {
      criteria: Array<{
        filters?: Filters;
        ids?: string[];
        orderBy?: OrderBy[];
        limit?: number;
      }>;
      safetyLimit?: number; // Global safety limit
      performanceOptions?: PerformanceOptions;
    }): Promise<{ deletedCount: number; details: Array<{ criteriaIndex: number; deletedCount: number }> }> => {
      const { criteria, safetyLimit, performanceOptions } = params;
      let totalDeleted = 0;
      const details: Array<{ criteriaIndex: number; deletedCount: number }> = [];
      let completed = 0;
      const total = criteria.length;

      for (let i = 0; i < criteria.length; i++) {
        const { filters, ids, orderBy, limit } = criteria[i];

        await withRetry(async () => {
          let query = supabase.from(tableName).delete();

          // Apply ID filters if provided
          if (ids && ids.length > 0) {
            query = query.in("id" as any, ids);
          }

          // Apply other filters
          if (filters) {
            query = applyFilters(query, filters);
          }

          // Apply ordering (useful for limited deletes)
          if (orderBy && orderBy.length > 0) {
            query = applyOrdering(query, orderBy);
          }

          // Apply limit (either specified or safety limit)
          const effectiveLimit = Math.min(limit || Number.MAX_SAFE_INTEGER, safetyLimit || Number.MAX_SAFE_INTEGER);

          if (effectiveLimit < Number.MAX_SAFE_INTEGER) {
            query = query.limit(effectiveLimit);
          }

          // Apply performance options
          if (performanceOptions?.timeout) {
            query = query.abortSignal(AbortSignal.timeout(performanceOptions.timeout));
          }

          // First, count the records that will be deleted
          let countQuery = supabase.from(tableName).select("*", { count: "exact", head: true });

          if (ids && ids.length > 0) {
            countQuery = countQuery.in("id" as any, ids);
          }
          if (filters) {
            countQuery = applyFilters(countQuery, filters);
          }
          if (orderBy && orderBy.length > 0) {
            countQuery = applyOrdering(countQuery, orderBy);
          }
          if (effectiveLimit < Number.MAX_SAFE_INTEGER) {
            countQuery = countQuery.limit(effectiveLimit);
          }

          const { count: recordCount, error: countError } = await countQuery;
          if (countError) throw countError;

          // Now perform the actual delete
          const { error } = await query;
          if (error) throw error;

          const deletedInThisCriteria = recordCount || 0;
          totalDeleted += deletedInThisCriteria;
          details.push({ criteriaIndex: i, deletedCount: deletedInThisCriteria });

          completed++;
          onProgress?.(completed, total);
        });
      }

      return { deletedCount: totalDeleted, details };
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ["table", tableName] });
      queryClient.invalidateQueries({ queryKey: ["unique", tableName] });
    },
  });

  // Batch operation with transaction-like behavior (all or nothing)
  const transactionalBulkOperation = useMutation({
    mutationFn: async (params: {
      operations: Array<{
        type: "insert" | "update" | "delete";
        data?: any;
        filters?: Filters;
        ids?: string[];
      }>;
    }): Promise<{ success: boolean; results: any[]; errors?: Error[] }> => {
      const { operations } = params;
      const results: any[] = [];
      const errors: Error[] = [];

      // In a real implementation, you might want to use database transactions
      // For now, we'll simulate transaction-like behavior with rollback on error

      try {
        for (const operation of operations) {
          switch (operation.type) {
            case "insert":
              if (!operation.data) throw new Error("Insert operation requires data");
              const { data: insertData, error: insertError } = await supabase.from(tableName).insert(operation.data).select();
              if (insertError) throw insertError;
              results.push(insertData);
              break;

            case "update":
              if (!operation.data) throw new Error("Update operation requires data");
              let updateQuery = supabase.from(tableName).update(operation.data);

              if (operation.ids) {
                updateQuery = updateQuery.in("id" as any, operation.ids);
              }
              if (operation.filters) {
                updateQuery = applyFilters(updateQuery, operation.filters);
              }

              const { data: updateData, error: updateError } = await updateQuery.select();
              if (updateError) throw updateError;
              results.push(updateData);
              break;

            case "delete":
              let deleteQuery = supabase.from(tableName).delete();

              if (operation.ids) {
                deleteQuery = deleteQuery.in("id" as any, operation.ids);
              }
              if (operation.filters) {
                deleteQuery = applyFilters(deleteQuery, operation.filters);
              }

              const { error: deleteError } = await deleteQuery;
              if (deleteError) throw deleteError;
              results.push({ deleted: true });
              break;
          }
        }

        return { success: true, results };
      } catch (error) {
        errors.push(error as Error);
        // In a real database transaction, you would rollback here
        return { success: false, results: [], errors };
      }
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ["table", tableName] });
      queryClient.invalidateQueries({ queryKey: ["unique", tableName] });
    },
  });

  return {
    advancedBulkUpdate,
    advancedBulkDelete,
    transactionalBulkOperation,
  };
}

```

<!-- path: hooks/database/core-queries.ts -->
```typescript
/* eslint-disable @typescript-eslint/no-explicit-any */
import {
  useQuery,
  useInfiniteQuery,
  InfiniteData,
} from '@tanstack/react-query';
import { SupabaseClient } from '@supabase/supabase-js';
import { Database, Json } from '@/types/supabase-types';
import {
  TableOrViewName,
  TableName,
  Row,
  RowWithCount,
  DeduplicationOptions,
  InfiniteQueryPage,
  UseTableQueryOptions,
  UseTableInfiniteQueryOptions,
  UseTableRecordOptions,
  UseUniqueValuesOptions,
} from './queries-type-helpers';
import {
  applyFilters,
  applyOrdering,
  buildDeduplicationQuery,
  createQueryKey,
  createUniqueValuesKey,
} from './utility-functions';

// Generic table query hook with enhanced features
export function useTableQuery<
  T extends TableOrViewName,
  TData = RowWithCount<Row<T>>[]
>(
  supabase: SupabaseClient<Database>,
  tableName: T,
  options?: UseTableQueryOptions<T, TData>
) {
  const {
    columns = '*',
    filters,
    orderBy,
    limit,
    offset,
    deduplication,
    aggregation,
    performance,
    includeCount = false,
    ...queryOptions
  } = options || {};

  type QueryFnData = RowWithCount<Row<T>>[];

  return useQuery({
    queryKey: createQueryKey(
      tableName,
      filters,
      columns,
      orderBy,
      deduplication, // 5th argument
      aggregation,   // 6th argument
      undefined,     // 7th argument (enhancedOrderBy not used here)
      limit,         // 8th argument
      offset         // 9th argument
    ),
    queryFn: async (): Promise<QueryFnData> => {
      if (deduplication) {
        const sql = buildDeduplicationQuery(
          tableName as string,
          deduplication,
          filters,
          orderBy
        );
        const { data: rpcData, error: rpcError } = await supabase.rpc(
          'execute_sql',
          { sql_query: sql }
        );
        if (rpcError) throw rpcError;
        if (rpcData && (rpcData as any).error)
          throw new Error(`Database RPC Error: ${(rpcData as any).error}`);
        return (rpcData as any)?.result || [];
      }

      if (aggregation) {
        const { data, error } = await supabase.rpc('aggregate_query', {
          table_name: tableName,
          aggregation_options: aggregation as unknown as Json,
          filters: (filters || {}) as unknown as Json,
          order_by: (orderBy || []) as unknown as Json,
        });
        if (error) throw error;
        return (data as any)?.result || [];
      }

      // When includeCount is requested, use Supabase's metadata count to support relation selects.
      // We then project the count back onto each row as `total_count` for backward compatibility.
      let query = includeCount
        ? supabase
            .from(tableName as any)
            .select(columns as string, { count: 'exact' })
        : supabase.from(tableName as any).select(columns as string);

      if (filters) query = applyFilters(query, filters);
      if (orderBy?.length) query = applyOrdering(query, orderBy);
      if (limit !== undefined) query = query.limit(limit);
      if (offset !== undefined)
        query = query.range(offset, offset + (limit || 1000) - 1);
      if (performance?.timeout)
        query = query.abortSignal(AbortSignal.timeout(performance.timeout));

      const { data, error, count } = (await query) as any;
      if (error) throw error;
      const rows = (data as unknown as Row<T>[]) || [];
      if (!includeCount) return rows as unknown as QueryFnData;
      const total = typeof count === 'number' ? count : 0;
      // Attach total_count to each row to emulate window-count behavior
      const withCount = rows.map((r) => ({
        ...(r as any),
        total_count: total,
      }));
      return withCount as unknown as QueryFnData;
    },
    ...queryOptions,
  });
}

// Infinite scroll query hook for large datasets
export function useTableInfiniteQuery<
  T extends TableOrViewName,
  TData = InfiniteData<InfiniteQueryPage<T>>
>(
  supabase: SupabaseClient<Database>,
  tableName: T,
  options?: UseTableInfiniteQueryOptions<T, TData>
) {
  const {
    columns = '*',
    filters,
    orderBy,
    pageSize = 20,
    performance,
    ...queryOptions
  } = options || {};

  return useInfiniteQuery({
    queryKey: createQueryKey(
      tableName,
      filters,
      columns,
      orderBy,
      undefined,
      undefined,
      undefined,
      pageSize
    ),
    queryFn: async ({ pageParam = 0 }) => {
      let query = supabase
        .from(tableName as any)
        .select(columns, { count: 'exact' });

      if (filters) query = applyFilters(query, filters);
      if (orderBy?.length) query = applyOrdering(query, orderBy);

      const startIdx = pageParam * pageSize;
      query = query.range(startIdx, startIdx + pageSize - 1);

      if (performance?.timeout)
        query = query.abortSignal(AbortSignal.timeout(performance.timeout));

      const { data, error, count } = await query;
      if (error) throw error;

      const results = (data as unknown as Row<T>[]) || [];

      return {
        data: results,
        nextCursor: results.length === pageSize ? pageParam + 1 : undefined,
        count: count ?? 0,
      };
    },
    getNextPageParam: (lastPage) => lastPage.nextCursor,
    initialPageParam: 0,
    ...queryOptions,
  });
}

// Generic single record query hook (optimized)
export function useTableRecord<
  T extends TableOrViewName,
  TData = Row<T> | null
>(
  supabase: SupabaseClient<Database>,
  tableName: T,
  id: string | null,
  options?: UseTableRecordOptions<T, TData>
) {
  const { columns = '*', performance, ...queryOptions } = options || {};

  return useQuery({
    queryKey: createQueryKey(tableName, { id: id as any }, columns),
    queryFn: async (): Promise<Row<T> | null> => {
      if (!id) return null;

      let query = supabase
        .from(tableName as any)
        .select(columns)
        .eq('id', id);

      if (performance?.timeout)
        query = query.abortSignal(AbortSignal.timeout(performance.timeout));

      const { data, error } = await query.maybeSingle();

      if (error) {
        if (error.code === 'PGRST116') return null; // Not found, which is a valid null result
        throw error;
      }
      return (data as unknown as Row<T>) || null;
    },
    enabled: !!id && (queryOptions?.enabled ?? true),
    staleTime: 5 * 60 * 1000,
    ...queryOptions,
  });
}

// Get unique values for a specific column
export function useUniqueValues<T extends TableOrViewName, TData = unknown[]>(
  supabase: SupabaseClient<Database>,
  tableName: T,
  column: string,
  options?: UseUniqueValuesOptions<T, TData>
) {
  const { filters, orderBy, limit, ...queryOptions } = options || {};

  return useQuery({
    queryKey: createUniqueValuesKey(tableName, column, filters, orderBy),
    queryFn: async (): Promise<unknown[]> => {
      const { data, error } = await supabase.rpc('get_unique_values', {
        p_table_name: tableName,
        p_column_name: column,
        p_filters: (filters || {}) as unknown as Json,
        p_order_by: (orderBy || []) as unknown as Json,
        p_limit_count: limit,
      });
      if (error) {
        console.error(
          'RPC unique values failed, falling back to direct query',
          error
        );
        // Fallback implementation
        let fallbackQuery = supabase.from(tableName as any).select(column);
        if (filters) fallbackQuery = applyFilters(fallbackQuery, filters);
        if (orderBy?.length)
          fallbackQuery = applyOrdering(fallbackQuery, orderBy);
        if (limit) fallbackQuery = fallbackQuery.limit(limit);

        const { data: fallbackData, error: fallbackError } =
          await fallbackQuery;
        if (fallbackError) throw fallbackError;
        return [
          ...new Set(
            (fallbackData as any[])?.map((item) => item[column]) || []
          ),
        ];
      }
      return (data as any)?.map((item: any) => item.value) || [];
    },
    staleTime: 10 * 60 * 1000,
    ...queryOptions,
  });
}

// Deduplicated rows hook
export function useDeduplicated<T extends TableName>(
  supabase: SupabaseClient<Database>,
  tableName: T,
  deduplicationOptions: DeduplicationOptions,
  options?: Omit<UseTableQueryOptions<T>, 'deduplication'>
) {
  return useTableQuery(supabase, tableName, {
    ...options,
    deduplication: deduplicationOptions,
  });
}

// Relationship query hook with optimizations
export function useTableWithRelations<
  T extends TableName,
  TData = RowWithCount<Row<T>>[]
>(
  supabase: SupabaseClient<Database>,
  tableName: T,
  relations: string[],
  options?: UseTableQueryOptions<T, TData>
) {
  const columnsString =
    relations.length > 0 ? `*, ${relations.join(', ')}` : '*';

  return useTableQuery<T, TData>(supabase, tableName, {
    ...options,
    columns: columnsString,
  });
}

```

<!-- path: hooks/database/rpc-hook-factory.ts -->
```typescript
// path: hooks/database/rpc-hook-factory.ts
import { useQuery, UseQueryOptions, UseQueryResult } from "@tanstack/react-query";
import { SupabaseClient } from "@supabase/supabase-js";
import { Database, Json } from "@/types/supabase-types";
import { RpcFunctionName, RpcFunctionArgs, RpcFunctionReturns } from "./queries-type-helpers";
import { DEFAULTS } from "@/config/constants";

// Define a specific interface for the arguments our paged RPC functions accept.
// This solves the "is not assignable to type 'never'" error.
interface PagedRpcArgs {
  p_limit: number;
  p_offset: number;
  p_order_by: string;
  p_order_dir: 'asc' | 'desc';
  p_filters: Json;
}

// Type for the options our hook will accept. It's clean and simple.
type PagedRpcHookOptions = {
  limit?: number;
  offset?: number;
  orderBy?: string;
  orderDir?: "asc" | "desc";
  filters?: Json;
};

// Generic type for the actual query options passed to TanStack Query.
// This allows users to pass standard options like `staleTime`, `enabled`, etc.
type PagedRpcQueryOptions<TResult> = Omit<
  UseQueryOptions<TResult, Error>,
  'queryKey' | 'queryFn'
>;

/**
 * A factory function that creates a reusable and type-safe TanStack Query hook
 * for any of your paginated RPC functions.
 * @param functionName The name of the PostgreSQL RPC function.
 * @param queryKeyPrefix A unique prefix for the query key.
 * @param defaultOrderBy The default column to sort by.
 */
export function createPagedRpcHook<
  TName extends RpcFunctionName,
  TResult = RpcFunctionReturns<TName> // The result type is now correctly INFERRED from the function name
>(
  functionName: TName, // TName is now constrained to be a valid RpcFunctionName
  queryKeyPrefix: string,
  defaultOrderBy: string
) {
  // This is the returned custom hook
  return function usePagedRpc(
    supabase: SupabaseClient<Database>,
    hookOptions: PagedRpcHookOptions = {},
    queryOptions: PagedRpcQueryOptions<TResult> = {}
  ): UseQueryResult<TResult, Error> {
    const {
      limit = DEFAULTS.PAGE_SIZE,
      offset = 0,
      orderBy = defaultOrderBy,
      orderDir = "asc",
      filters = {},
    } = hookOptions;

    const queryKey = [queryKeyPrefix, { limit, offset, orderBy, orderDir, filters }];

    const queryFn = async (): Promise<TResult> => {
      const rpcArgs: PagedRpcArgs = {
        p_limit: limit,
        p_offset: offset,
        p_order_by: orderBy,
        p_order_dir: orderDir,
        p_filters: filters,
      };

      const { data, error } = await supabase.rpc(
        functionName,
        rpcArgs as RpcFunctionArgs<TName>
      );

      if (error) {
        console.error(`Error fetching from RPC '${String(functionName)}':`, error);
        throw new Error(error.message);
      }
      
      return (data ?? []) as TResult;
    };

    return useQuery<TResult, Error>({
      queryKey,
      queryFn,
      ...queryOptions,
    });
  };
}
```

<!-- path: hooks/database/index.ts -->
```typescript
// hooks/database/index.ts - Main export file
export * from './queries-type-helpers'
export * from './utility-functions'
export * from './core-queries'
export * from './basic-mutation-hooks'
export * from './bulk-queries'
export * from './advanced-bulk-queries'

// Additional specialized hooks for complex operations
export * from './rpc-queries'
// Performance and Cache hooks
export * from './cache-performance'









```

<!-- path: hooks/database/path-mutations.ts -->
```typescript
"use client";

import { useMutation, useQueryClient } from "@tanstack/react-query";
import { createClient } from "@/utils/supabase/client";
import { toast } from "sonner";

const supabase = createClient();

/**
 * Hook to call the RPC function for deleting a path segment and reordering the rest.
 */
export function useDeletePathSegment() {
  const queryClient = useQueryClient();
  return useMutation({
    mutationFn: async ({ segmentId, pathId }: { segmentId: string, pathId: string }) => {
      const { error } = await supabase.rpc('delete_path_segment_and_reorder', {
        p_segment_id: segmentId,
        p_path_id: pathId,
      });
      if (error) throw error;
    },
    onSuccess: (_, { pathId }) => {
      toast.success("Path segment deleted.");
      queryClient.invalidateQueries({ queryKey: ['system-path', pathId] });
    },
    onError: (err) => toast.error(`Failed to delete segment: ${err.message}`),
  });
}

/**
 * Hook to call the RPC function for reordering path segments via drag-and-drop.
 */
export function useReorderPathSegments() {
  const queryClient = useQueryClient();
  return useMutation({
    mutationFn: async ({ pathId, segmentIds }: { pathId: string, segmentIds: string[] }) => {
      const { error } = await supabase.rpc('reorder_path_segments', {
        p_path_id: pathId,
        p_segment_ids: segmentIds,
      });
      if (error) throw error;
    },
    onSuccess: (_, { pathId }) => {
      toast.success("Path reordered successfully.");
      queryClient.invalidateQueries({ queryKey: ['system-path', pathId] });
    },
    onError: (err) => toast.error(`Failed to reorder path: ${err.message}`),
  });
}

// ... (keep existing hooks)

/**
 * Hook to call the RPC function for provisioning a fiber onto a path.
 */
export function useProvisionFiber() {
  const queryClient = useQueryClient();
  return useMutation({
      mutationFn: async ({ pathId, fiberNo }: { pathId: string, fiberNo: number }) => {
          const { error } = await supabase.rpc('provision_fiber_on_path', {
              p_path_id: pathId,
              p_fiber_no: fiberNo
          });
          if (error) throw error;
      },
      onSuccess: (_, { pathId }) => {
          toast.success("Fiber provisioned successfully!");
          // Refetch everything related to paths and connections to update the UI state
          queryClient.invalidateQueries({ queryKey: ['system-path', pathId] });
          queryClient.invalidateQueries({ queryKey: ['available-fibers', pathId] }); 
          queryClient.invalidateQueries({ queryKey: ['ofc_connections'] });
      },
      onError: (err) => toast.error(`Provisioning failed: ${err.message}`),
  });
}

export function useProvisionRingPath() {
  const queryClient = useQueryClient();
  return useMutation({
      mutationFn: async (variables: { 
          systemId: string;
          pathName: string;
          workingFiber: number;
          protectionFiber: number;
          physicalPathId: string; 
      }) => {
          const { error } = await supabase.rpc('provision_ring_path', {
              p_system_id: variables.systemId,
              p_path_name: variables.pathName,
              p_working_fiber_no: variables.workingFiber,
              p_protection_fiber_no: variables.protectionFiber,
              p_physical_path_id: variables.physicalPathId
          });
          if (error) throw error;
      },
      onSuccess: (_, variables) => {
          toast.success("Ring path provisioned successfully!");
          // Invalidate all related queries to refresh the UI state completely
          queryClient.invalidateQueries({ queryKey: ['system-path', variables.physicalPathId] });
          queryClient.invalidateQueries({ queryKey: ['available-fibers', variables.physicalPathId] }); 
          queryClient.invalidateQueries({ queryKey: ['logical_fiber_paths'] });
          queryClient.invalidateQueries({ queryKey: ['ofc_connections'] });
          queryClient.invalidateQueries({ queryKey: ['v_cable_utilization'] });
      },
      onError: (err) => toast.error(`Provisioning failed: ${err.message}`),
  });
}
```

<!-- path: hooks/database/rpc-queries.ts -->
```typescript
// path: hooks/database/rpc-queries.ts
import { useQuery, useMutation, useQueryClient, UseQueryOptions } from '@tanstack/react-query';
import { SupabaseClient } from '@supabase/supabase-js';
import { Database } from '@/types/supabase-types';
import {
  RpcFunctionName,
  RpcFunctionArgs,
  RpcFunctionReturns,
  UseRpcQueryOptions,
  UseTableMutationOptions,
  PagedSystemsCompleteResult,
  PagedNodesCompleteResult,
  PagedOfcConnectionsCompleteResult,
  PagedSystemConnectionsCompleteResult,
  PagedLookupTypesWithCountResult,
  PagedMaintenanceAreasWithCountResult,
  PagedEmployeeDesignationsWithCountResult,
  PagedEmployeesWithCountResult,
  PagedRingsWithCountResult,
  PagedOfcCablesCompleteResult
} from './queries-type-helpers';
import { buildRpcFilters, createRpcQueryKey, RpcFilters } from './utility-functions';
import { createPagedRpcHook } from './rpc-hook-factory';
import { DEFAULTS } from '@/config/constants';

// =================================================================
// Section 1: Generated Hooks for Paginated Views
// =================================================================

// FIX: We no longer pass the <Paged...Result> generic.
// TypeScript now infers the return type automatically from the function name.
export const usePagedNodesComplete = createPagedRpcHook(
  'get_paged_nodes_complete', 'paged-nodes', 'name'
);

export const usePagedOfcCablesComplete = createPagedRpcHook(
  'get_paged_ofc_cables_complete', 'paged-ofc-cables', 'route_name'
);

export const usePagedOfcConnectionsComplete = createPagedRpcHook(
  'get_paged_ofc_connections_complete', 'paged-ofc-connections', 'fiber_no_sn'
);

export const usePagedSystemsComplete = createPagedRpcHook(
  'get_paged_systems_complete', 'paged-systems', 'system_name'
);

export const usePagedSystemConnectionsComplete = createPagedRpcHook(
  'get_paged_system_connections_complete', 'paged-system-connections', 'system_name'
);

export const usePagedLookupTypesWithCount = createPagedRpcHook(
  'get_paged_lookup_types_with_count', 'paged-lookup-types', 'name'
);

export const usePagedMaintenanceAreasWithCount = createPagedRpcHook(
  'get_paged_maintenance_areas_with_count', 'paged-maintenance-areas', 'name'
);

export const usePagedEmployeeDesignationsWithCount = createPagedRpcHook(
  'get_paged_employee_designations_with_count', 'paged-employee-designations', 'name'
);

export const usePagedEmployeesWithCount = createPagedRpcHook(
  'get_paged_employees_with_count', 'paged-employees', 'employee_name'
);

export const usePagedRingsWithCount = createPagedRpcHook(
  'get_paged_rings_with_count', 'paged-rings', 'name'
);

// =================================================================
// Section 2: Generic & Specific RPC Hooks (Non-Paginated)
// =================================================================

// Generic RPC query hook for any non-paginated function
export function useRpcQuery<
  T extends RpcFunctionName,
  TData = RpcFunctionReturns<T>
>(
  supabase: SupabaseClient<Database>,
  functionName: T,
  args?: RpcFunctionArgs<T>,
  options?: UseRpcQueryOptions<T, TData>
) {
  const { performance, ...queryOptions } = options || {};

  return useQuery({
    queryKey: createRpcQueryKey(functionName, args, performance),
    queryFn: async (): Promise<RpcFunctionReturns<T>> => {
      const { data, error } = await supabase.rpc(
        functionName,
        args || ({} as RpcFunctionArgs<T>)
      );
      if (error) throw error;
      return data as RpcFunctionReturns<T>;
    },
    staleTime: 3 * 60 * 1000, // Default stale time for RPCs
    ...queryOptions,
  });
}

// Generic RPC mutation hook
export function useRpcMutation<T extends RpcFunctionName>(
  supabase: SupabaseClient<Database>,
  functionName: T,
  options?: UseTableMutationOptions<RpcFunctionReturns<T>, RpcFunctionArgs<T>>
) {
  const queryClient = useQueryClient();
  const { invalidateQueries = true, ...mutationOptions } = options || {};

  return useMutation({
    mutationFn: async (
      args: RpcFunctionArgs<T>
    ): Promise<RpcFunctionReturns<T>> => {
      const { data, error } = await supabase.rpc(
        functionName,
        args || ({} as RpcFunctionArgs<T>)
      );
      if (error) throw error;
      return data as RpcFunctionReturns<T>;
    },
    onSuccess: (data, variables, context, mutation) => {
      if (invalidateQueries) {
        // A generic mutation should invalidate all table and rpc data
        // as we don't know what it changed.
        queryClient.invalidateQueries({ queryKey: ['table'] });
        queryClient.invalidateQueries({ queryKey: ['rpc'] });
      }
      options?.onSuccess?.(data, variables, context, mutation);
    },
    ...mutationOptions,
  });
}

// Specific hook for the dashboard overview
export function useDashboardOverview(
  supabase: SupabaseClient<Database>,
  options?: UseRpcQueryOptions<'get_dashboard_overview'>
) {
  // Note: The third argument (args) is an empty object because this RPC takes no parameters.
  return useRpcQuery(supabase, 'get_dashboard_overview', {}, options);
}

// Define the shape of the JSONB object returned by the new SQL function
export interface PagedDataResult<T> {
  data: T[];
  total_count: number;
  active_count: number;
  inactive_count: number;
}

// Hook options
interface UsePagedDataOptions {
  limit?: number;
  offset?: number;
  orderBy?: string;
  orderDir?: 'asc' | 'desc';
  filters?: RpcFilters;
}

// A helper function to safely check if the RPC response is valid.
// This is a "type guard" in TypeScript.
function isPagedDataResult<T>(obj: unknown): obj is PagedDataResult<T> {
  if (typeof obj !== 'object' || obj === null) return false;
  const o = obj as Record<string, unknown>;
  return (
    Array.isArray(o['data']) &&
    typeof o['total_count'] === 'number' &&
    typeof o['active_count'] === 'number' &&
    typeof o['inactive_count'] === 'number'
  );
}

/**
 * A generic hook to fetch paginated data from any view using the 'get_paged_data' RPC.
 * @param viewName The name of the table or view to query.
 * @param hookOptions Pagination, ordering, and filtering options.
 * @param queryOptions Standard TanStack Query options.
 */
export function usePagedData<T>(
  supabase: SupabaseClient<Database>,
  viewName: string | null,
  hookOptions: UsePagedDataOptions = {},
  queryOptions: Omit<UseQueryOptions<PagedDataResult<T>, Error>, 'queryKey' | 'queryFn'> = {}
) {
  const {
    limit = DEFAULTS.PAGE_SIZE,
    offset = 0,
    orderBy = 'name',
    orderDir = 'asc',
    filters = {},
  } = hookOptions;

  const rpcFilters = buildRpcFilters(filters);
  const queryKey = ['paged-data', viewName, { limit, offset, orderBy, orderDir, filters: rpcFilters }];

  const queryFn = async (): Promise<PagedDataResult<T>> => {
    // Define a safe default value that matches the expected return type.
    const defaultValue: PagedDataResult<T> = {
      data: [],
      total_count: 0,
      active_count: 0,
      inactive_count: 0,
    };

    if (!viewName) {
      return defaultValue;
    }

    const { data, error } = await supabase.rpc('get_paged_data', {
      p_view_name: viewName,
      p_limit: limit,
      p_offset: offset,
      p_order_by: orderBy,
      p_order_dir: orderDir,
      p_filters: rpcFilters,
    });

    if (error) {
      console.error(`Error fetching paginated data for '${viewName}':`, error);
      throw new Error(error.message);
    }

    // --- START OF FIX ---
    // Use the type guard to validate the shape of the response.
    if (isPagedDataResult<T>(data)) {
      // If the check passes, TypeScript now knows 'data' is of type PagedDataResult<T>.
      return data;
    } else {
      // If the response is not what we expected, log a warning and return the safe default.
      console.warn(`Unexpected response structure for 'get_paged_data' on view '${viewName}'.`, data);
      return defaultValue;
    }
    // --- END OF FIX ---
  };

  return useQuery<PagedDataResult<T>, Error>({
    queryKey,
    queryFn,
    enabled: !!viewName && (queryOptions.enabled ?? true),
    ...queryOptions,
  });
}
```

<!-- path: hooks/database/cache-performance.ts -->
```typescript
import { useQueryClient, QueryClient } from "@tanstack/react-query";
import { Filters, RpcFunctionArgs, RpcFunctionName, RpcFunctionReturns, TableName, TableRow, UseTableQueryOptions } from "./queries-type-helpers";
import { SupabaseClient } from "@supabase/supabase-js";
import { Database } from "@/types/supabase-types";
import { applyFilters, applyOrdering, createQueryKey, createRpcQueryKey } from "./utility-functions";

// Performance monitoring hook
export function useQueryPerformance() {
  const queryClient = useQueryClient();

  const getQueryStats = () => {
    const cache = queryClient.getQueryCache();
    const queries = cache.getAll();

    return {
      totalQueries: queries.length,
      staleQueries: queries.filter((q) => q.isStale()).length,
      inactiveQueries: queries.filter((q) => q.getObserversCount() === 0).length,
      fetchingQueries: queries.filter((q) => q.state.status === "pending").length,
      cacheSizeBytes: JSON.stringify(cache).length,
    };
  };

  const clearStaleQueries = () => {
    queryClient.removeQueries({
      predicate: (query) => query.isStale() && query.state.status !== "pending",
    });
  };

  const prefetchCriticalData = async (supabase: SupabaseClient<Database>, criticalTables: TableName[]) => {
    const promises = criticalTables.map((tableName) =>
      queryClient.prefetchQuery({
        queryKey: ["table", tableName],
        queryFn: async () => {
          const { data, error } = await supabase.from(tableName).select("*").limit(100);
          if (error) throw error;
          return data;
        },
        staleTime: 10 * 60 * 1000, // 10 minutes
      })
    );

    await Promise.all(promises);
  };

  return {
    getQueryStats,
    clearStaleQueries,
    prefetchCriticalData,
  };
}

// Specialized hooks for RPC functions (keeping existing ones)
// This type is generated automatically by the Supabase CLI!
// Define the return type with more precision
// Use `Array<T>` syntax for clarity and add `| null` to handle initial/error states.

// Enhanced cache utilities with performance optimizations
export const tableQueryUtils = {
  invalidateTable: (queryClient: QueryClient, tableName: string) => {
    queryClient.invalidateQueries({ queryKey: ["table", tableName] });
    queryClient.invalidateQueries({ queryKey: ["unique", tableName] });
  },

  invalidateAllTables: (queryClient: QueryClient) => {
    queryClient.invalidateQueries({ queryKey: ["table"] });
    queryClient.invalidateQueries({ queryKey: ["unique"] });
  },

  invalidateRpc: (queryClient: QueryClient, functionName: string) => {
    queryClient.invalidateQueries({ queryKey: ["rpc", functionName] });
  },

  invalidateAllRpc: (queryClient: QueryClient) => {
    queryClient.invalidateQueries({ queryKey: ["rpc"] });
  },

  prefetchTable: async <T extends TableName>(queryClient: QueryClient, supabase: SupabaseClient<Database>, tableName: T, options?: UseTableQueryOptions<T>) => {
    return queryClient.prefetchQuery({
      queryKey: createQueryKey(
        tableName,
        options?.filters,
        options?.columns,
        options?.orderBy,
        options?.deduplication, // 5th argument
        options?.aggregation,   // 6th argument
        undefined,              // 7th argument (enhancedOrderBy is not used in prefetch)
        options?.limit,         // 8th argument
        options?.offset         // 9th argument
      ),
      queryFn: async (): Promise<TableRow<T>[]> => {
        let query = supabase.from(tableName).select(options?.columns || "*");

        if (options?.filters) {
          query = applyFilters(query, options.filters);
        }

        if (options?.orderBy) {
          query = applyOrdering(query, options.orderBy);
        }

        if (options?.limit) {
          query = query.limit(options.limit);
        }

        const { data, error } = await query;
        if (error) throw error;
        return (data as TableRow<T>[]) || [];
      },
      staleTime: 5 * 60 * 1000,
    });
  },

  prefetchRpc: async <T extends RpcFunctionName>(queryClient: QueryClient, supabase: SupabaseClient<Database>, functionName: T, args?: RpcFunctionArgs<T>) => {
    return queryClient.prefetchQuery({
      queryKey: createRpcQueryKey(functionName, args),
      queryFn: async (): Promise<RpcFunctionReturns<T>> => {
        const { data, error } = await supabase.rpc(functionName, args || ({} as RpcFunctionArgs<T>));
        if (error) throw error;
        return data as RpcFunctionReturns<T>;
      },
      staleTime: 3 * 60 * 1000,
    });
  },

  // Optimized cache management
  setQueryData: <T extends TableName>(queryClient: QueryClient, tableName: T, data: TableRow<T>[], filters?: Filters, columns?: string) => {
    queryClient.setQueryData(createQueryKey(tableName, filters, columns), data);
  },

  getQueryData: <T extends TableName>(queryClient: QueryClient, tableName: T, filters?: Filters, columns?: string): TableRow<T>[] | undefined => {
    return queryClient.getQueryData(createQueryKey(tableName, filters, columns));
  },

  // Performance monitoring
  getTableCacheStats: (queryClient: QueryClient, tableName: string) => {
    const cache = queryClient.getQueryCache();
    const tableQueries = cache.findAll({
      queryKey: ["table", tableName],
    });

    return {
      queryCount: tableQueries.length,
      staleCount: tableQueries.filter((q) => q.isStale()).length,
      fetchingCount: tableQueries.filter((q) => q.state.status === "pending").length,
      errorCount: tableQueries.filter((q) => q.state.status === "error").length,
      totalDataSize: tableQueries.reduce((acc, query) => {
        const data = query.state.data;
        return acc + (data ? JSON.stringify(data).length : 0);
      }, 0),
    };
  },

  // Cleanup utilities
  removeStaleQueries: (
    queryClient: QueryClient,
    maxAge = 10 * 60 * 1000 // 10 minutes
  ) => {
    queryClient.removeQueries({
      predicate: (query) => {
        const isOld = Date.now() - query.state.dataUpdatedAt > maxAge;
        return isOld && query.isStale() && query.state.status !== "pending";
      },
    });
  },

  // Batch operations
  batchInvalidate: (queryClient: QueryClient, operations: Array<{ type: "table" | "rpc"; name: string }>) => {
    operations.forEach(({ type, name }) => {
      queryClient.invalidateQueries({ queryKey: [type, name] });
    });
  },
};

```

<!-- path: hooks/database/queries-type-helpers.ts -->
```typescript
// hooks/database/queries-type-helpers.ts

import { UseQueryOptions, UseMutationOptions, UseInfiniteQueryOptions, InfiniteData } from "@tanstack/react-query";
import { Database, Tables, TablesInsert, TablesUpdate, Json } from "@/types/supabase-types";

// --- TYPE HELPERS ---

// The type to include Date as a possible type
export type TableInsertWithDates<T extends TableName> = {
  [K in keyof TablesInsert<T>]?: TablesInsert<T>[K] | Date | null;
};

export type TableUpdateWithDates<T extends TableName> = {
  [K in keyof TablesUpdate<T>]?: TablesUpdate<T>[K] | Date | null;
};

// A table is a source that can be read from and written to.
export type TableName = keyof Database["public"]["Tables"];

// Auth tables are tables that can only be read from.
export type AuthTable = keyof Database["auth"]["Tables"];

// A view is a source that can only be read from.
export type ViewName = keyof Database["public"]["Views"];

// A generic type for any readable source (table or view).
export type TableOrViewName = TableName | ViewName;

// A generic type for any readable source (table or view).
export type AuthTableOrViewName = AuthTable | ViewName | TableName;

// Helper function to check if the table name is a table (not a view)
export const isTableName = (name: AuthTableOrViewName): name is TableName => {
  // List of view names - add your view names here
  const viewNames = [
    'v_nodes_complete',
    'v_ofc_cables_complete',
    'v_ofc_connections_complete',
    'v_system_connections_complete',
    'v_systems_complete',
    // 'vmux_connections',
    // 'vmux_systems',
    // Add other view names here
  ];
  const authViewNames = [
    'users',
  ];
  return !viewNames.includes(name as string) && !authViewNames.includes(name as string);
};

// Table-specific types for mutation operations (insert, update, delete).
export type TableRow<T extends TableName> = Tables<T>;
export type TableInsert<T extends TableName> = TablesInsert<T>;
export type TableUpdate<T extends TableName> = TablesUpdate<T>;

// A generic row type for any read operation (works with both tables and views).
export type Row<T extends AuthTableOrViewName> = T extends TableName ? Tables<T> : T extends ViewName ? Database["public"]["Views"][T]["Row"] : T extends AuthTable ? Database["auth"]["Tables"][T]["Row"] : never;

// RPC function type helpers.
export type RpcFunctionName = keyof Database["public"]["Functions"];
export type RpcFunctionArgs<T extends RpcFunctionName> = Database["public"]["Functions"][T]["Args"];
export type RpcFunctionReturns<T extends RpcFunctionName> = Database["public"]["Functions"][T]["Returns"];

// --- ADVANCED TYPES FOR HOOK OPTIONS ---

export type FilterOperator = "eq" | "neq" | "gt" | "gte" | "lt" | "lte" | "like" | "ilike" | "in" | "not.in" | "contains" | "containedBy" | "overlaps" | "sl" | "sr" | "nxl" | "nxr" | "adj" | "is" | "isdistinct" | "fts" | "plfts" | "phfts" | "wfts" | "or";

export type FilterValue = string | number | boolean | null | string[] | number[] | { operator: FilterOperator; value: unknown };

export type Filters = Record<string, FilterValue>;

export type OrderBy = {
  column: string;
  ascending?: boolean;
  nullsFirst?: boolean;
  foreignTable?: string;
};

export // Updated OrderBy interface to support optional type hints
interface EnhancedOrderBy {
  column: string;
  ascending?: boolean;
  nullsFirst?: boolean;
  foreignTable?: string;
  dataType?: 'text' | 'numeric' | 'date' | 'timestamp' | 'boolean' | 'json';
}

export type DeduplicationOptions = {
  columns: string[];
  orderBy?: OrderBy[];
};

export type AggregationOptions = {
  count?: boolean | string;
  sum?: string[];
  avg?: string[];
  min?: string[];
  max?: string[];
  groupBy?: string[];
};

export type PerformanceOptions = {
  useIndex?: string;
  explain?: boolean;
  timeout?: number;
  connection?: "read" | "write";
};

// The shape of data returned by queries, potentially with a total count.
export type RowWithCount<T> = T & { total_count?: number };

// --- HOOK OPTIONS INTERFACES ---

// Options for querying multiple records from tables OR views.
export interface UseTableQueryOptions<T extends TableOrViewName, TData = RowWithCount<Row<T>>[]> extends Omit<UseQueryOptions<RowWithCount<Row<T>>[], Error, TData>, "queryKey" | "queryFn"> {
  columns?: string;
  filters?: Filters;
  orderBy?: OrderBy[];
  limit?: number;
  offset?: number;
  deduplication?: DeduplicationOptions;
  aggregation?: AggregationOptions;
  performance?: PerformanceOptions;
  includeCount?: boolean;
}

// Options for infinite scrolling over tables OR views.
export type InfiniteQueryPage<T extends TableOrViewName> = {
  data: Row<T>[];
  nextCursor?: number;
  count?: number;
};

export interface UseTableInfiniteQueryOptions<T extends TableOrViewName, TData = InfiniteData<InfiniteQueryPage<T>>>
  extends Omit<UseInfiniteQueryOptions<InfiniteQueryPage<T>, Error, TData, readonly unknown[], number | undefined>, "queryKey" | "queryFn" | "getNextPageParam" | "initialPageParam"> {
  columns?: string;
  filters?: Filters;
  orderBy?: OrderBy[];
  pageSize?: number;
  performance?: PerformanceOptions;
}

// Options for querying a single record from a table OR view.
export interface UseTableRecordOptions<T extends TableOrViewName, TData = Row<T> | null> extends Omit<UseQueryOptions<Row<T> | null, Error, TData>, "queryKey" | "queryFn"> {
  columns?: string;
  performance?: PerformanceOptions;
}

// Options for getting unique values from a table OR view.
export interface UseUniqueValuesOptions<T extends TableOrViewName, TData = unknown[]> extends Omit<UseQueryOptions<unknown[], Error, TData>, "queryKey" | "queryFn"> {
  tableName: T;
  filters?: Filters;
  orderBy?: OrderBy[];
  limit?: number;
  performance?: PerformanceOptions;
}

export interface UseRpcQueryOptions<T extends RpcFunctionName, TData = RpcFunctionReturns<T>> extends Omit<UseQueryOptions<RpcFunctionReturns<T>, Error, TData>, "queryKey" | "queryFn"> {
  performance?: PerformanceOptions;
}

// Options for mutations, which apply ONLY to tables.
export interface UseTableMutationOptions<TData = unknown, TVariables = unknown, TContext = unknown> extends Omit<UseMutationOptions<TData, Error, TVariables, TContext>, "mutationFn"> {
  invalidateQueries?: boolean;
  optimisticUpdate?: boolean;
  batchSize?: number;
}

export interface OptimisticContext {
  previousData?: [readonly unknown[], unknown][];
}

export type PagedSystemsCompleteResult = Array<Database["public"]["Functions"]["get_paged_v_systems_complete"]["Returns"][number]> | null;

export type UsePagedSystemsCompleteOptions = {
  limit?: number;
  offset?: number;
  orderBy?: string;
  orderDir?: "asc" | "desc";
  filters?: Json;
  queryOptions?: Omit<UseQueryOptions<PagedSystemsCompleteResult>, "queryKey" | "queryFn">;
};

// --- TYPES FOR EXCEL UPLOAD HOOK ---

/**
 * Defines how to map a column from the Excel file to a database column.
 * @template T - The name of the table to upload to.
 */
export interface UploadColumnMapping<T extends TableName> {
  /** The exact header name in the Excel file (e.g., "Product Name"). */
  excelHeader: string;
  /** The corresponding key in the database table (e.g., "product_name"). */
  dbKey: keyof TableInsert<T> & string;
  /** An optional function to transform the cell's value before uploading. */
  transform?: (value: unknown) => unknown;
  /** If true, the value must be non-empty after transform; otherwise the row is rejected. */
  required?: boolean;
}

/**
 * Specifies the type of upload operation to perform.
 * - 'insert': Adds all rows as new records. Fails if a record violates a unique constraint.
 * - 'upsert': Inserts new records or updates existing ones based on a conflict column.
 */
export type UploadType = "insert" | "upsert";

/**
 * Options required to initiate an Excel file upload.
 * @template T - The name of the table to upload to.
 */
export interface UploadOptions<T extends TableName> {
  /** The file object from a file input element. */
  file: File;
  /** An array defining how to map Excel columns to database columns. */
  columns: UploadColumnMapping<T>[];
  /** The type of database operation to perform. Defaults to 'upsert'. */
  uploadType?: UploadType;
  /**
   * The database column to use for conflict resolution in an 'upsert' operation.
   * This is REQUIRED for 'upsert'.
   * e.g., 'id' or 'sku' if you want to update rows with matching IDs or SKUs.
   */
  conflictColumn?: keyof TableInsert<T> & string;
}

/**
 * The result of a successful upload operation.
 */
export interface UploadResult {
  successCount: number;
  errorCount: number;
  totalRows: number;
  errors: { rowIndex: number; data: unknown; error: string }[];
}

/**
 * Configuration options for the useExcelUpload hook itself.
 * @template T - The name of the table to upload to.
 */
export interface UseExcelUploadOptions<T extends TableName> {
  onSuccess?: (data: UploadResult, variables: UploadOptions<T>) => void;
  onError?: (error: Error, variables: UploadOptions<T>) => void;
  showToasts?: boolean;
  batchSize?: number;
}

// FIX: Add the return type for the new RPC function
export type PagedOfcCablesCompleteResult = 
  Array<Database["public"]["Functions"]["get_paged_ofc_cables_complete"]["Returns"][number]> | null;

// FIX: Add the options type for the new hook we will create
// export type UsePagedOfcCablesCompleteOptions = {
//   limit?: number;
//   offset?: number;
//   orderBy?: string;
//   orderDir?: "asc" | "desc";
//   filters?: Json;
//   queryOptions?: Omit<UseQueryOptions<PagedOfcCablesCompleteResult, Error>, "queryKey" | "queryFn">;
// };

export type PagedNodesCompleteResult = Array<Database["public"]["Functions"]["get_paged_nodes_complete"]["Returns"][number]> | null;

// export type UsePagedNodesCompleteOptions = {
//   limit?: number;
//   offset?: number;
//   orderBy?: string;
//   orderDir?: "asc" | "desc";
//   filters?: Json;
//   queryOptions?: Omit<UseQueryOptions<PagedNodesCompleteResult, Error>, "queryKey" | "queryFn">;
// };

export type PagedOfcConnectionsCompleteResult = 
  Array<Database["public"]["Functions"]["get_paged_ofc_connections_complete"]["Returns"][number]> | null;

// FIX: Add the options type for the new hook we will create
// export type UsePagedOfcConnectionsCompleteOptions = {
//   limit?: number;
//   offset?: number;
//   orderBy?: string;
//   orderDir?: "asc" | "desc";
//   filters?: Json;
//   queryOptions?: Omit<UseQueryOptions<PagedOfcConnectionsCompleteResult, Error>, "queryKey" | "queryFn">;
// };

export type PagedSystemConnectionsCompleteResult = Array<Database["public"]["Functions"]["get_paged_system_connections_complete"]["Returns"][number]> | null;

// export type UsePagedSystemConnectionsCompleteOptions = {
//   limit?: number;
//   offset?: number;
//   orderBy?: string;
//   orderDir?: "asc" | "desc";
//   filters?: Json;
//   queryOptions?: Omit<UseQueryOptions<PagedSystemConnectionsCompleteResult>, "queryKey" | "queryFn">;
// };

export type PagedLookupTypesWithCountResult = Array<Database["public"]["Functions"]["get_paged_lookup_types_with_count"]["Returns"][number]> | null;

// export type UsePagedLookupTypesWithCountOptions = {
//   limit?: number;
//   offset?: number;
//   orderBy?: string;
//   orderDir?: "asc" | "desc";
//   filters?: Json;
//   queryOptions?: Omit<UseQueryOptions<PagedLookupTypesWithCountResult, Error>, "queryKey" | "queryFn">;
// };

export type PagedMaintenanceAreasWithCountResult = Array<Database["public"]["Functions"]["get_paged_maintenance_areas_with_count"]["Returns"][number]> | null;

// export type UsePagedMaintenanceAreasWithCountOptions = {
//   limit?: number;
//   offset?: number;
//   orderBy?: string;
//   orderDir?: "asc" | "desc";
//   filters?: Json;
//   queryOptions?: Omit<UseQueryOptions<PagedMaintenanceAreasWithCountResult, Error>, "queryKey" | "queryFn">;
// };

export type PagedEmployeeDesignationsWithCountResult = Array<Database["public"]["Functions"]["get_paged_employee_designations_with_count"]["Returns"][number]> | null;

// export type UsePagedEmployeeDesignationsWithCountOptions = {
//   limit?: number;
//   offset?: number;
//   orderBy?: string;
//   orderDir?: "asc" | "desc";
//   filters?: Json;
//   queryOptions?: Omit<UseQueryOptions<PagedEmployeeDesignationsWithCountResult, Error>, "queryKey" | "queryFn">;
// };

export type PagedEmployeesWithCountResult = Array<Database["public"]["Functions"]["get_paged_employees_with_count"]["Returns"][number]> | null;

// export type UsePagedEmployeesWithCountOptions = {
//   limit?: number;
//   offset?: number;
//   orderBy?: string;
//   orderDir?: "asc" | "desc";
//   filters?: Json;
//   queryOptions?: Omit<UseQueryOptions<PagedEmployeesWithCountResult, Error>, "queryKey" | "queryFn">;
// };

export type PagedRingsWithCountResult = Array<Database["public"]["Functions"]["get_paged_rings_with_count"]["Returns"][number]> | null;

// export type UsePagedRingsWithCountOptions = {
//   limit?: number;
//   offset?: number;
//   orderBy?: string;
//   orderDir?: "asc" | "desc";
//   filters?: Json;
//   queryOptions?: Omit<UseQueryOptions<PagedRingsWithCountResult, Error>, "queryKey" | "queryFn">;
// };

// Define a type for the function's return data for full type safety
export type DashboardOverviewData = {
  system_status_counts: { [key: string]: number };
  node_status_counts: { [key: string]: number };
  path_operational_status: { [key: string]: number };
  cable_utilization_summary: {
    average_utilization_percent: number;
    high_utilization_count: number;
    total_cables: number;
  };
  user_activity_last_30_days: {
    date: string;
    count: number;
  }[];
  systems_per_maintenance_area: { [key: string]: number };
};
```

<!-- path: hooks/database/excel-queries/excel-download.ts -->
```typescript

import { AuthTableOrViewName, isTableName, Row, TableName, ViewName } from "../queries-type-helpers";
import * as ExcelJS from "exceljs";
import { SupabaseClient } from "@supabase/supabase-js";
import { Database } from "@/types/supabase-types";
import { useMutation } from "@tanstack/react-query";
import { applyCellFormatting, convertFiltersToRPCParams, DownloadOptions, ExcelDownloadResult, formatCellValue, getDefaultStyles, RPCConfig, sanitizeFileName, UseExcelDownloadOptions } from "./excel-helpers";
import { toast } from "sonner";
import { applyFilters } from "../utility-functions";

// Extended types for new functionality
interface OrderByOption {
column: string;
ascending?: boolean;
}

interface EnhancedDownloadOptions<T extends AuthTableOrViewName> extends DownloadOptions<T> {
orderBy?: OrderByOption[];
wrapText?: boolean;
autoFitColumns?: boolean;
}

interface EnhancedUseExcelDownloadOptions<T extends AuthTableOrViewName> extends UseExcelDownloadOptions<T> {
defaultOrderBy?: OrderByOption[];
defaultWrapText?: boolean;
defaultAutoFitColumns?: boolean;
}

// Hook for RPC-based downloads with full type safety
export function useRPCExcelDownload<T extends AuthTableOrViewName>(
  supabase: SupabaseClient<Database>,
  options?: EnhancedUseExcelDownloadOptions<T>
) {
  const {
    showToasts = true,
    batchSize = 50000,
    defaultOrderBy,
    defaultWrapText = true,
    defaultAutoFitColumns = true,
    ...mutationOptions
  } = options || {};

  return useMutation<
    ExcelDownloadResult,
    Error,
    EnhancedDownloadOptions<T> & { rpcConfig: RPCConfig }
  >({
    mutationFn: async (downloadOptions): Promise<ExcelDownloadResult> => {
      try {
        const defaultStyles = getDefaultStyles();
        const mergedOptions = {
          sheetName: "Data",
          maxRows: batchSize,
          customStyles: defaultStyles,
          orderBy: defaultOrderBy,
          wrapText: defaultWrapText,
          autoFitColumns: defaultAutoFitColumns,
          ...downloadOptions,
        };

        const {
          fileName = `export-${new Date().toISOString().split("T")[0]}.xlsx`,
          filters,
          columns,
          sheetName,
          maxRows,
          rpcConfig,
          orderBy,
          wrapText,
          autoFitColumns,
        } = mergedOptions;

        const styles = { ...defaultStyles, ...mergedOptions.customStyles };

        if (!columns || columns.length === 0)
          throw new Error("No columns specified for export");
        if (!rpcConfig)
          throw new Error("RPC configuration is required for this hook");

        const exportColumns = columns.filter((col) => !col.excludeFromExport);
        if (exportColumns.length === 0)
          throw new Error("All columns are excluded from export");

        toast.info("Fetching data via RPC...");

        // Prepare RPC parameters
        const rpcParams = {
          ...rpcConfig.parameters,
          ...convertFiltersToRPCParams(filters),
        };

        if (maxRows) {
          rpcParams.row_limit = maxRows;
        }

        // Add ordering parameters to RPC if supported
        if (orderBy && orderBy.length > 0) {
          rpcParams.order_by = orderBy.map(order => 
            `${order.column}.${order.ascending !== false ? 'asc' : 'desc'}`
          ).join(',');
        }

        // Execute RPC call with proper error handling
        const { data, error } = await supabase.rpc(
          rpcConfig.functionName as keyof Database["public"]["Functions"],
          rpcParams
        );

        if (error) throw new Error(`RPC call failed: ${error.message}`);
        if (!data || (Array.isArray(data) && data.length === 0)) {
          throw new Error("No data returned from RPC function");
        }

        // Ensure data is an array
        let dataArray = Array.isArray(data) ? data : [data];
        
        // Apply client-side ordering if RPC doesn't support it
        if (orderBy && orderBy.length > 0) {
          dataArray = dataArray.sort((a, b) => {
            for (const order of orderBy) {
              // Safe property access with type guards
              const aVal = (a && typeof a === 'object' && !Array.isArray(a)) 
                ? (a as Record<string, unknown>)[order.column] 
                : undefined;
              const bVal = (b && typeof b === 'object' && !Array.isArray(b)) 
                ? (b as Record<string, unknown>)[order.column] 
                : undefined;
              
              if (aVal === bVal) continue;
              
              let comparison = 0;
              if (aVal == null && bVal != null) comparison = 1;
              else if (aVal != null && bVal == null) comparison = -1;
              else if (aVal != null && bVal != null) {
                if (aVal < bVal) comparison = -1;
                else if (aVal > bVal) comparison = 1;
              }
              
              return order.ascending !== false ? comparison : -comparison;
            }
            return 0;
          });
        }
        
        toast.success(
          `Fetched ${dataArray.length} records. Generating Excel file...`
        );

        const workbook = new ExcelJS.Workbook();
        const worksheet = workbook.addWorksheet(sheetName || "Data");

        // Set column properties with enhanced options
        worksheet.columns = exportColumns.map((col) => ({
          key: String(col.dataIndex),
          width: typeof col.width === "number" ? col.width / 8 : 20,
        }));

        // Add header row with enhanced styling
        const headerTitles = exportColumns.map((col) => col.title);
        const headerRow = worksheet.addRow(headerTitles);
        headerRow.height = 25;

        exportColumns.forEach((col, index) => {
          const cell = headerRow.getCell(index + 1);
          if (styles.headerFont) cell.font = styles.headerFont;
          if (styles.headerFill) cell.fill = styles.headerFill;
          
          // Enhanced header alignment with text wrapping
          cell.alignment = { 
            horizontal: "center", 
            vertical: "middle",
            wrapText: wrapText || false
          };

          if (styles.borderStyle) {
            cell.border = {
              top: styles.borderStyle.top,
              bottom: styles.borderStyle.bottom,
              right: styles.borderStyle.right,
              left: index === 0 ? styles.borderStyle.left : undefined,
            };
          }
        });

        // Add data rows with enhanced styling
        dataArray.forEach((record, rowIndex: number) => {
          // Ensure we only process object-like rows
          if (record === null || typeof record !== "object" || Array.isArray(record)) {
            return; // skip non-object rows
          }

          const obj = record as Record<string, unknown>;
          const rowData: Record<string, unknown> = {};
          exportColumns.forEach((col) => {
            const key = String(col.dataIndex);
            const value = obj[key];
            rowData[key] = formatCellValue(value, col);
          });
          const excelRow = worksheet.addRow(rowData);

          // Enhanced cell styling with wrap text support
          exportColumns.forEach((col, colIndex) => {
            const cell = excelRow.getCell(colIndex + 1);

            if (styles.dataFont) cell.font = styles.dataFont;

            if (rowIndex % 2 === 1 && styles.alternateRowFill) {
              cell.fill = styles.alternateRowFill;
            }

            // Apply text wrapping and alignment
            cell.alignment = {
              ...cell.alignment,
              wrapText: wrapText || false,
              vertical: 'top' // Better for wrapped text
            };

            applyCellFormatting(cell, col);

            if (styles.borderStyle) {
              const isLastDataRow = rowIndex === dataArray.length - 1;
              cell.border = {
                right: styles.borderStyle.right,
                left: colIndex === 0 ? styles.borderStyle.left : undefined,
                top: styles.borderStyle.top,
                bottom: isLastDataRow ? styles.borderStyle.bottom : undefined,
              };
            }
          });
        });

        // Auto-fit columns if enabled
        if (autoFitColumns) {
          exportColumns.forEach((col, index) => {
            const column = worksheet.getColumn(index + 1);
            let maxLength = col.title.length;
            
            // Calculate max content length for auto-fitting
            dataArray.forEach((record) => {
              if (record && typeof record === "object" && !Array.isArray(record)) {
                const obj = record as Record<string, unknown>;
                const key = String(col.dataIndex);
                const value = obj[key];
                const cellText = String(formatCellValue(value, col) || '');
                
                // For wrapped text, consider line breaks
                if (wrapText) {
                  const lines = cellText.split('\n');
                  const maxLineLength = Math.max(...lines.map(line => line.length));
                  maxLength = Math.max(maxLength, maxLineLength);
                } else {
                  maxLength = Math.max(maxLength, cellText.length);
                }
              }
            });
            
            // Set reasonable bounds for column width
            const calculatedWidth = Math.min(Math.max(maxLength + 2, 10), 50);
            column.width = calculatedWidth;
          });
        }

        // Freeze header row
        worksheet.views = [{ state: "frozen", ySplit: 1 }];

        // Generate and download file
        const buffer = await workbook.xlsx.writeBuffer();
        const sanitizedFileName = sanitizeFileName(fileName);
        const blob = new Blob([buffer], {
          type: "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet",
        });

        const link = document.createElement("a");
        link.href = URL.createObjectURL(blob);
        link.download = sanitizedFileName;
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
        URL.revokeObjectURL(link.href);

        toast.success(
          `Excel file "${sanitizedFileName}" downloaded successfully!`
        );
        return {
          fileName: sanitizedFileName,
          rowCount: dataArray.length,
          columnCount: exportColumns.length,
        };
      } catch (error) {
        const errorMessage =
          error instanceof Error ? error.message : "Unknown error occurred";
        if (showToasts) {
          toast.error(`Download failed: ${errorMessage}`);
        }
        throw error;
      }
    },
    ...mutationOptions,
  });
}

// // Hook for traditional table/view downloads with enhanced features
// export function useTableExcelDownload<T extends AuthTableOrViewName>(
//   supabase: SupabaseClient<Database>,
//   tableName: T,
//   options?: EnhancedUseExcelDownloadOptions<T>
// ) {
//   const {
//     showToasts = true,
//     batchSize = 50000,
//     defaultOrderBy,
//     defaultWrapText = true,
//     defaultAutoFitColumns = true,
//     ...mutationOptions
//   } = options || {};

//   return useMutation<
//     ExcelDownloadResult,
//     Error,
//     Omit<EnhancedDownloadOptions<T>, "rpcConfig">
//   >({
//     mutationFn: async (downloadOptions): Promise<ExcelDownloadResult> => {
//       try {
//         const defaultStyles = getDefaultStyles();
//         const mergedOptions = {
//           sheetName: "Data",
//           maxRows: batchSize,
//           customStyles: defaultStyles,
//           orderBy: defaultOrderBy,
//           wrapText: defaultWrapText,
//           autoFitColumns: defaultAutoFitColumns,
//           ...downloadOptions,
//         };

//         const {
//           fileName = `${String(tableName)}-${
//             new Date().toISOString().split("T")[0]
//           }.xlsx`,
//           filters,
//           columns,
//           sheetName,
//           maxRows,
//           orderBy,
//           wrapText,
//           autoFitColumns,
//         } = mergedOptions;

//         const styles = { ...defaultStyles, ...mergedOptions.customStyles };

//         if (!columns || columns.length === 0)
//           throw new Error("No columns specified for export");
//         const exportColumns = columns.filter((col) => !col.excludeFromExport);
//         if (exportColumns.length === 0)
//           throw new Error("All columns are excluded from export");

//         toast.info("Fetching data for download...");

//         const selectFields = exportColumns
//           .map((col) => col.dataIndex)
//           .join(",");
//         let query = isTableName(tableName)
//           ? supabase.from(tableName as TableName).select(selectFields)
//           : supabase.from(tableName as ViewName).select(selectFields);

//         if (filters) query = applyFilters(query, filters);
        
//         // Apply ordering to the Supabase query
//         if (orderBy && orderBy.length > 0) {
//           orderBy.forEach(order => {
//             query = query.order(order.column, { ascending: order.ascending !== false });
//           });
//         }
        
//         if (maxRows) query = query.limit(maxRows);

//         const { data, error } = await query;

//         if (error) throw new Error(`Failed to fetch data: ${error.message}`);
//         if (!data || data.length === 0)
//           throw new Error("No data found for the selected criteria");

//         const typedData = data as Row<T>[];
//         toast.success(
//           `Fetched ${typedData.length} records. Generating Excel file...`
//         );

//         // Excel generation logic with enhanced features
//         const workbook = new ExcelJS.Workbook();
//         const worksheet = workbook.addWorksheet(sheetName || "Data");

//         worksheet.columns = exportColumns.map((col) => ({
//           key: String(col.dataIndex),
//           width: typeof col.width === "number" ? col.width / 8 : 20,
//         }));

//         const headerTitles = exportColumns.map((col) => col.title);
//         const headerRow = worksheet.addRow(headerTitles);
//         headerRow.height = wrapText ? 30 : 25; // Increase height for wrapped text

//         exportColumns.forEach((col, index) => {
//           const cell = headerRow.getCell(index + 1);
//           if (styles.headerFont) cell.font = styles.headerFont;
//           if (styles.headerFill) cell.fill = styles.headerFill;
          
//           // Enhanced header alignment with text wrapping
//           cell.alignment = { 
//             horizontal: "center", 
//             vertical: "middle",
//             wrapText: wrapText || false
//           };

//           if (styles.borderStyle) {
//             cell.border = {
//               top: styles.borderStyle.top,
//               bottom: styles.borderStyle.bottom,
//               right: styles.borderStyle.right,
//               left: index === 0 ? styles.borderStyle.left : undefined,
//             };
//           }
//         });

//         // Add data rows with enhanced styling
//         typedData.forEach((record, rowIndex) => {
//           const rowData: Record<string, unknown> = {};
//           exportColumns.forEach((col) => {
//             const key = col.dataIndex as keyof Row<T> & string;
//             rowData[key] = formatCellValue(record[key], col);
//           });
//           const excelRow = worksheet.addRow(rowData);
          
//           // Set row height for wrapped text
//           if (wrapText) {
//             excelRow.height = 20; // Minimum height, will auto-expand
//           }

//           exportColumns.forEach((col, colIndex) => {
//             const cell = excelRow.getCell(colIndex + 1);

//             if (styles.dataFont) cell.font = styles.dataFont;

//             if (rowIndex % 2 === 1 && styles.alternateRowFill) {
//               cell.fill = styles.alternateRowFill;
//             }

//             // Apply text wrapping and alignment
//             cell.alignment = {
//               ...cell.alignment,
//               wrapText: wrapText || false,
//               vertical: 'top' // Better for wrapped text
//             };

//             applyCellFormatting(cell, col);

//             if (styles.borderStyle) {
//               const isLastDataRow = rowIndex === typedData.length - 1;
//               cell.border = {
//                 right: styles.borderStyle.right,
//                 left: colIndex === 0 ? styles.borderStyle.left : undefined,
//                 top: styles.borderStyle.top,
//                 bottom: isLastDataRow ? styles.borderStyle.bottom : undefined,
//               };
//             }
//           });
//         });

//         // Auto-fit columns if enabled
//         if (autoFitColumns) {
//           exportColumns.forEach((col, index) => {
//             const column = worksheet.getColumn(index + 1);
//             let maxLength = col.title.length;
            
//             // Calculate max content length for auto-fitting
//             typedData.forEach((record) => {
//               const key = col.dataIndex as keyof Row<T> & string;
//               const value = record[key];
//               const cellText = String(formatCellValue(value, col) || '');
              
//               // For wrapped text, consider line breaks
//               if (wrapText) {
//                 const lines = cellText.split('\n');
//                 const maxLineLength = Math.max(...lines.map(line => line.length));
//                 maxLength = Math.max(maxLength, maxLineLength);
//               } else {
//                 maxLength = Math.max(maxLength, cellText.length);
//               }
//             });
            
//             // Set reasonable bounds for column width
//             const calculatedWidth = Math.min(Math.max(maxLength + 2, 10), wrapText ? 30 : 50);
//             column.width = calculatedWidth;
//           });
//         }

//         // Freeze header row
//         worksheet.views = [{ state: "frozen", ySplit: 1 }];

//         // Generate and download file
//         const buffer = await workbook.xlsx.writeBuffer();
//         const sanitizedFileName = sanitizeFileName(fileName);
//         const blob = new Blob([buffer], {
//           type: "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet",
//         });

//         const link = document.createElement("a");
//         link.href = URL.createObjectURL(blob);
//         link.download = sanitizedFileName;
//         document.body.appendChild(link);
//         link.click();
//         document.body.removeChild(link);
//         URL.revokeObjectURL(link.href);

//         toast.success(
//           `Excel file "${sanitizedFileName}" downloaded successfully!`
//         );
//         return {
//           fileName: sanitizedFileName,
//           rowCount: dataArray.length,
//           columnCount: exportColumns.length,
//         };
//       } catch (error) {
//         const errorMessage =
//           error instanceof Error ? error.message : "Unknown error occurred";
//         if (showToasts) {
//           toast.error(`Download failed: ${errorMessage}`);
//         }
//         throw error;
//       }
//     },
//     ...mutationOptions,
//   });
// }

// Hook for traditional table/view downloads with enhanced features
export function useTableExcelDownload<T extends AuthTableOrViewName>(
  supabase: SupabaseClient<Database>,
  tableName: T,
  options?: EnhancedUseExcelDownloadOptions<T>
) {
  const {
    showToasts = true,
    batchSize = 50000,
    defaultOrderBy,
    defaultWrapText = true,
    defaultAutoFitColumns = true,
    ...mutationOptions
  } = options || {};

  return useMutation<
    ExcelDownloadResult,
    Error,
    Omit<EnhancedDownloadOptions<T>, "rpcConfig">
  >({
    mutationFn: async (downloadOptions): Promise<ExcelDownloadResult> => {
      try {
        const defaultStyles = getDefaultStyles();
        const mergedOptions = {
          sheetName: "Data",
          maxRows: batchSize,
          customStyles: defaultStyles,
          orderBy: defaultOrderBy,
          wrapText: defaultWrapText,
          autoFitColumns: defaultAutoFitColumns,
          ...downloadOptions,
        };

        const {
          fileName = `${String(tableName)}-${
            new Date().toISOString().split("T")[0]
          }.xlsx`,
          filters,
          columns,
          sheetName,
          maxRows,
          orderBy,
          wrapText,
          autoFitColumns,
        } = mergedOptions;

        const styles = { ...defaultStyles, ...mergedOptions.customStyles };

        if (!columns || columns.length === 0)
          throw new Error("No columns specified for export");
        const exportColumns = columns.filter((col) => !col.excludeFromExport);
        if (exportColumns.length === 0)
          throw new Error("All columns are excluded from export");

        toast.info("Fetching data for download...");

        const selectFields = exportColumns
          .map((col) => col.dataIndex)
          .join(",");
        let query = isTableName(tableName)
          ? supabase.from(tableName as TableName).select(selectFields)
          : supabase.from(tableName as ViewName).select(selectFields);

        if (filters) query = applyFilters(query, filters);
        
        // Apply ordering to the Supabase query
        if (orderBy && orderBy.length > 0) {
          orderBy.forEach(order => {
            query = query.order(order.column, { ascending: order.ascending !== false });
          });
        }
        
        if (maxRows) query = query.limit(maxRows);

        const { data, error } = await query;

        if (error) throw new Error(`Failed to fetch data: ${error.message}`);
        if (!data || data.length === 0)
          throw new Error("No data found for the selected criteria");

        const typedData = data as Row<T>[];
        toast.success(
          `Fetched ${typedData.length} records. Generating Excel file...`
        );

        // Excel generation logic with enhanced features
        const workbook = new ExcelJS.Workbook();
        const worksheet = workbook.addWorksheet(sheetName || "Data");

        worksheet.columns = exportColumns.map((col) => ({
          key: String(col.dataIndex),
          width: typeof col.width === "number" ? col.width / 8 : 20,
        }));

        const headerTitles = exportColumns.map((col) => col.title);
        const headerRow = worksheet.addRow(headerTitles);
        headerRow.height = wrapText ? 30 : 25; // Increase height for wrapped text

        exportColumns.forEach((col, index) => {
          const cell = headerRow.getCell(index + 1);
          if (styles.headerFont) cell.font = styles.headerFont;
          if (styles.headerFill) cell.fill = styles.headerFill;
          
          // Enhanced header alignment with text wrapping
          cell.alignment = { 
            horizontal: "center", 
            vertical: "middle",
            wrapText: wrapText || false
          };

          if (styles.borderStyle) {
            cell.border = {
              top: styles.borderStyle.top,
              bottom: styles.borderStyle.bottom,
              right: styles.borderStyle.right,
              left: index === 0 ? styles.borderStyle.left : undefined,
            };
          }
        });

        // Add data rows with enhanced styling
        typedData.forEach((record, rowIndex) => {
          const rowData: Record<string, unknown> = {};
          exportColumns.forEach((col) => {
            const key = col.dataIndex as keyof Row<T> & string;
            rowData[key] = formatCellValue(record[key], col);
          });
          const excelRow = worksheet.addRow(rowData);
          
          // Set row height for wrapped text
          if (wrapText) {
            excelRow.height = 20; // Minimum height, will auto-expand
          }

          exportColumns.forEach((col, colIndex) => {
            const cell = excelRow.getCell(colIndex + 1);

            if (styles.dataFont) cell.font = styles.dataFont;

            if (rowIndex % 2 === 1 && styles.alternateRowFill) {
              cell.fill = styles.alternateRowFill;
            }

            // Apply text wrapping and alignment
            cell.alignment = {
              ...cell.alignment,
              wrapText: wrapText || false,
              vertical: 'top' // Better for wrapped text
            };

            applyCellFormatting(cell, col);

            if (styles.borderStyle) {
              const isLastDataRow = rowIndex === typedData.length - 1;
              cell.border = {
                right: styles.borderStyle.right,
                left: colIndex === 0 ? styles.borderStyle.left : undefined,
                top: styles.borderStyle.top,
                bottom: isLastDataRow ? styles.borderStyle.bottom : undefined,
              };
            }
          });
        });

        // Auto-fit columns if enabled
        if (autoFitColumns) {
          exportColumns.forEach((col, index) => {
            const column = worksheet.getColumn(index + 1);
            let maxLength = col.title.length;
            
            // Calculate max content length for auto-fitting
            typedData.forEach((record) => {
              const key = col.dataIndex as keyof Row<T> & string;
              const value = record[key];
              const cellText = String(formatCellValue(value, col) || '');
              
              // For wrapped text, consider line breaks
              if (wrapText) {
                const lines = cellText.split('\n');
                const maxLineLength = Math.max(...lines.map(line => line.length));
                maxLength = Math.max(maxLength, maxLineLength);
              } else {
                maxLength = Math.max(maxLength, cellText.length);
              }
            });
            
            // Set reasonable bounds for column width
            const calculatedWidth = Math.min(Math.max(maxLength + 2, 10), wrapText ? 30 : 50);
            column.width = calculatedWidth;
          });
        }

        worksheet.views = [{ state: "frozen", ySplit: 1 }];

        const buffer = await workbook.xlsx.writeBuffer();
        const sanitizedFileName = sanitizeFileName(fileName);
        const blob = new Blob([buffer], {
          type: "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet",
        });

        const link = document.createElement("a");
        link.href = URL.createObjectURL(blob);
        link.download = sanitizedFileName;
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
        URL.revokeObjectURL(link.href);

        toast.success(
          `Excel file "${sanitizedFileName}" downloaded successfully!`
        );
        return {
          fileName: sanitizedFileName,
          rowCount: typedData.length,
          columnCount: exportColumns.length,
        };
      } catch (error) {
        const errorMessage =
          error instanceof Error ? error.message : "Unknown error occurred";
        if (
          showToasts &&
          errorMessage !== "No data found for the selected criteria"
        ) {
          toast.error(`Download failed: ${errorMessage}`);
        }
        throw error;
      }
    },
    ...mutationOptions,
  });
}
//   // Basic usage with ordering
// const mutation = useTableExcelDownload(supabase, 'users', {
//   defaultOrderBy: [
//     { column: 'created_at', ascending: false },
//     { column: 'name', ascending: true }
//   ]
// });

// // Download with custom options
// mutation.mutate({
//   columns: userColumns,
//   orderBy: [{ column: 'email', ascending: true }],
//   wrapText: true,
//   autoFitColumns: false,
//   fileName: 'user-report.xlsx'
// });

// // RPC download with ordering
// const rpcMutation = useRPCExcelDownload(supabase, {
//   defaultWrapText: false,
//   defaultOrderBy: [{ column: 'priority', ascending: false }]
// });
```

<!-- path: hooks/database/excel-queries/excel-helpers.ts -->
```typescript
// hooks/database/excel-queries.ts
import * as ExcelJS from "exceljs";
import { Filters, UploadResult } from "@/hooks/database";
import { AuthTableOrViewName, Row } from "@/hooks/database";

//================================================================================
// TYPES AND INTERFACES
//================================================================================

export interface Column<T> {
  key: string;
  title: string;
  dataIndex: string;
  width?: number | string;
  sortable?: boolean;
  searchable?: boolean;
  filterable?: boolean;
  editable?: boolean;
  render?: (value: unknown, record: T, index: number) => React.ReactNode;
  filterOptions?: { label: string; value: unknown }[];
  align?: "left" | "center" | "right";
  hidden?: boolean;
  excelFormat?: "text" | "number" | "date" | "currency" | "percentage" | "json";
  excludeFromExport?: boolean;
}

// Generic RPC Configuration that works with any function
export interface RPCConfig<TParams = Record<string, unknown>> {
  functionName: string;
  parameters?: TParams;
  selectFields?: string;
}

// NOTE: T refers to a table/view name. Columns should describe a Row<T>.
export interface DownloadOptions<
  T extends AuthTableOrViewName = AuthTableOrViewName
> {
  fileName?: string;
  filters?: Filters;
  columns?: Column<Row<T>>[];
  sheetName?: string;
  maxRows?: number;
  customStyles?: ExcelStyles;
  rpcConfig?: RPCConfig;
}

export interface ExcelStyles {
  headerFont?: Partial<ExcelJS.Font>;
  headerFill?: ExcelJS.FillPattern;
  dataFont?: Partial<ExcelJS.Font>;
  alternateRowFill?: ExcelJS.FillPattern;
  borderStyle?: Partial<ExcelJS.Borders>;
}

export interface ExcelDownloadResult {
  fileName: string;
  rowCount: number;
  columnCount: number;
}

export interface UseExcelDownloadOptions<
  T extends AuthTableOrViewName = AuthTableOrViewName
> {
  onSuccess?: (
    data: ExcelDownloadResult,
    variables: DownloadOptions<T>
  ) => void;
  onError?: (error: Error, variables: DownloadOptions<T>) => void;
  showToasts?: boolean;
  batchSize?: number;
  defaultRPCConfig?: RPCConfig;
}

// Enhanced error tracking interfaces
export interface ValidationError {
  rowIndex: number;
  column: string;
  value: unknown;
  error: string;
  data?: Record<string, unknown>;
}

export interface ProcessingLog {
  rowIndex: number;
  excelRowNumber: number;
  originalData: Record<string, unknown>;
  processedData: Record<string, unknown>;
  validationErrors: ValidationError[];
  isSkipped: boolean;
  skipReason?: string;
}

export interface EnhancedUploadResult extends UploadResult {
  processingLogs: ProcessingLog[];
  validationErrors: ValidationError[];
  skippedRows: number;
}

//================================================================================
// UTILITY FUNCTIONS
//================================================================================

export const createFillPattern = (color: string): ExcelJS.FillPattern => ({
  type: "pattern",
  pattern: "solid",
  fgColor: { argb: color },
});

export const formatCellValue = <T = unknown>(
  value: unknown,
  column: Column<T>
): unknown => {
  if (value === null || value === undefined) return "";
  
  // Handle number types first
  if (typeof value === 'number') {
    return value;
  }
  
  // Handle object values
  if (typeof value === 'object' && value !== null) {
    // If it's a Date object
    if (value instanceof Date) {
      return value;
    }
    // If it's an array, join with comma
    if (Array.isArray(value)) {
      return value.join(', ');
    }
    // For other objects, try to stringify
    try {
      const str = JSON.stringify(value);
      // If it's a JSON object string, parse and get a simple string representation
      if (str.startsWith('{') || str.startsWith('[')) {
        const parsed = JSON.parse(str);
        if (typeof parsed === 'object' && parsed !== null) {
          // For objects, get values and join
          if (Array.isArray(parsed)) {
            return parsed.join(', ');
          }
          return Object.values(parsed).filter(v => v !== undefined && v !== null).join(', ');
        }
        return String(parsed);
      }
      return str;
    } catch {
      return String(value);
    }
  }

  // Handle non-object values
  switch (column.excelFormat) {
    case "date":
      return value instanceof Date ? value : new Date(value as string);
    case "number":
      return typeof value === "string" ? parseFloat(value) || 0 : value;
    case "currency":
      return typeof value === "string"
        ? parseFloat(value.replace(/[^0-9.-]/g, "")) || 0
        : value;
    case "percentage":
      return typeof value === "number"
        ? value / 100
        : parseFloat(String(value)) / 100 || 0;
    case "json": {
      if (typeof value === "string") {
        try {
          const parsed = JSON.parse(value);
          return JSON.stringify(parsed);
        } catch {
          return value;
        }
      }
      return String(value);
    }
    default:
      return String(value);
  }
};

export const applyCellFormatting = <T = unknown>(
  cell: ExcelJS.Cell,
  column: Column<T>
): void => {
  switch (column.excelFormat) {
    case "date":
      cell.numFmt = "mm/dd/yyyy";
      break;
    case "currency":
      cell.numFmt = '"$"#,##0.00';
      break;
    case "percentage":
      cell.numFmt = "0.00%";
      break;
    case "number":
      cell.numFmt = "#,##0.00";
      break;
  }
  if (column.align) {
    cell.alignment = { horizontal: column.align };
  }
};

export const getDefaultStyles = (): ExcelStyles => ({
  headerFont: { bold: true, color: { argb: "FFFFFFFF" }, size: 12 },
  headerFill: createFillPattern("FF2563EB"),
  dataFont: { size: 11 },
  alternateRowFill: createFillPattern("FFF8F9FA"),
  borderStyle: {
    top: { style: "thin" },
    left: { style: "thin" },
    bottom: { style: "thin" },
    right: { style: "thin" },
  },
});

export const sanitizeFileName = (fileName: string): string => {
  return fileName.replace(/[^a-z0-9.-]/gi, "_").replace(/_{2,}/g, "_");
};

export const convertFiltersToRPCParams = (
  filters?: Filters
): Record<string, unknown> => {
  if (!filters) return {};

  const rpcParams: Record<string, unknown> = {};

  Object.entries(filters).forEach(([key, value]) => {
    if (value !== undefined && value !== null && value !== "") {
      rpcParams[key] = value;
    }
  });

  return rpcParams;
};

// Safe UUID generator: uses crypto.randomUUID if available, otherwise a lightweight fallback
export const generateUUID = (): string => {
  const g = globalThis as { crypto?: { randomUUID?: () => string } };
  if (g && g.crypto && typeof g.crypto.randomUUID === "function") {
    return g.crypto.randomUUID();
  }
  // RFC4122 version 4 fallback
  return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, (c) => {
    const r = (Math.random() * 16) | 0;
    const v = c === "x" ? r : (r & 0x3) | 0x8;
    return v.toString(16);
  });
};

// Enhanced logging utilities
export const logRowProcessing = (
  rowIndex: number,
  excelRowNumber: number,
  originalData: Record<string, unknown>,
  processedData: Record<string, unknown>,
  validationErrors: ValidationError[] = [],
  isSkipped = false,
  skipReason?: string
): ProcessingLog => {
  const log: ProcessingLog = {
    rowIndex,
    excelRowNumber,
    originalData,
    processedData,
    validationErrors,
    isSkipped,
    skipReason,
  };

  console.group(` Processing Row ${excelRowNumber} (Index: ${rowIndex})`);
  console.log(" Original Data:", originalData);
  console.log(" Processed Data:", processedData);

  if (validationErrors.length > 0) {
    console.warn(" Validation Errors:", validationErrors);
  }

  if (isSkipped) {
    console.warn(" Row Skipped:", skipReason);
  }

  console.groupEnd();

  return log;
};

export const logColumnTransformation = (
  rowIndex: number,
  column: string,
  originalValue: unknown,
  transformedValue: unknown,
  error?: string
): void => {
  console.log(` Column "${column}" (Row ${rowIndex + 2}):`);
  console.log(
    `   Original: ${JSON.stringify(originalValue)} (${typeof originalValue})`
  );
  console.log(
    `   Transformed: ${JSON.stringify(
      transformedValue
    )} (${typeof transformedValue})`
  );

  if (error) {
    console.error(`    Error: ${error}`);
  }
};

// Enhanced value validation
export const validateValue = (
  value: unknown,
  columnName: string,
  isRequired: boolean
): ValidationError | null => {
  if (isRequired) {
    const isEmpty =
      value === null ||
      value === undefined ||
      (typeof value === "string" && value.trim() === "");

    if (isEmpty) {
      return {
        rowIndex: -1, // Will be set by caller
        column: columnName,
        value,
        error: `Required field "${columnName}" is empty`,
      };
    }
  }

  // Type-specific validations
  if (value !== null && value !== undefined && value !== "") {
    // Check for UUID format if column suggests it's an ID
    if ((columnName === "id" || columnName.endsWith("_id") ) && columnName !== "transnet_id") {
      const uuidRegex =
        /^[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i;
      const strValue = String(value).trim();
      if (strValue && !uuidRegex.test(strValue) && strValue !== "") {
        return {
          rowIndex: -1,
          column: columnName,
          value,
          error: `Invalid UUID format for "${columnName}": ${strValue}`,
        };
      }
    }

    // Check for email format
    if (columnName.toLowerCase().includes("email")) {
      const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
      const strValue = String(value).trim();
      if (strValue && !emailRegex.test(strValue)) {
        return {
          rowIndex: -1,
          column: columnName,
          value,
          error: `Invalid email format for "${columnName}": ${strValue}`,
        };
      }
    }

    // Check for IP address format
    const isIPField =
      columnName === "ip_address" ||
      columnName.endsWith("_ip") ||
      columnName.includes("ipaddr");
    if (isIPField) {
      const ipRegex =
        /^(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$/;
      const strValue = String(value).trim();
      if (strValue && !ipRegex.test(strValue)) {
        return {
          rowIndex: -1,
          column: columnName,
          value,
          error: `Invalid IP address format for "${columnName}": ${strValue}`,
        };
      }
    }
  }

  return null;
};

```

<!-- path: hooks/database/excel-queries/index.ts -->
```typescript
export * from "./excel-download";
export * from "./excel-upload";
```

<!-- path: hooks/database/excel-queries/excel-upload.ts -->
```typescript
import * as XLSX from "xlsx";
import { TableInsert, TableName, UploadOptions, UseExcelUploadOptions } from "../queries-type-helpers";
import { SupabaseClient } from "@supabase/supabase-js";
import { Database } from "@/types/supabase-types";
import { useMutation, useQueryClient } from "@tanstack/react-query";
import { EnhancedUploadResult, generateUUID, logColumnTransformation, logRowProcessing, ProcessingLog, validateValue, ValidationError } from "./excel-helpers";
import { toast } from "sonner";

//================================================================================
// UPLOAD FUNCTIONS
//================================================================================

/**
 * Reads a File object and returns its contents as a 2D array using xlsx.
 * @param file The File object to read.
 * @returns A Promise that resolves to a 2D array of the sheet data.
 */
const parseExcelFile = (file: File): Promise<unknown[][]> => {
    return new Promise((resolve, reject) => {
      const reader = new FileReader();
  
      reader.onload = (event: ProgressEvent<FileReader>) => {
        try {
          if (!event.target?.result) {
            throw new Error("File reading failed.");
          }
          const buffer = event.target.result as ArrayBuffer;
          const workbook = XLSX.read(buffer, { type: "array" });
          const worksheetName = workbook.SheetNames[0];
          const worksheet = workbook.Sheets[worksheetName];
          if (!worksheet) {
            throw new Error("No worksheet found in the file.");
          }
          // header: 1 tells sheet_to_json to return an array of arrays
          // defval: '' preserves empty cells so column indices stay aligned
          const data = XLSX.utils.sheet_to_json<unknown[]>(worksheet, {
            header: 1,
            defval: "",
          });
          resolve(data);
        } catch (error) {
          reject(error);
        }
      };
  
      reader.onerror = (error) => {
        reject(new Error(`FileReader error: ${error.type}`));
      };
  
      reader.readAsArrayBuffer(file);
    });
  };
  
  //================================================================================
  // MAIN ENHANCED UPLOAD HOOK
  //================================================================================
  
  /**
   * Enhanced React hook for uploading data from an Excel file to a Supabase table using 'xlsx'.
   * Includes comprehensive logging and error tracking.
   */
  export function useExcelUpload<T extends TableName>(
    supabase: SupabaseClient<Database>,
    tableName: T,
    options?: UseExcelUploadOptions<T>
  ) {
    const {
      showToasts = true,
      batchSize = 500,
      ...mutationOptions
    } = options || {};
    const queryClient = useQueryClient();
  
    return useMutation<EnhancedUploadResult, Error, UploadOptions<T>>({
      mutationFn: async (
        uploadOptions: UploadOptions<T>
      ): Promise<EnhancedUploadResult> => {
        const {
          file,
          columns,
          uploadType = "upsert",
          conflictColumn,
        } = uploadOptions;
  
        console.group(" Excel Upload Process Started");
        console.log(" File:", file.name, `(${file.size} bytes)`);
        console.log(" Table:", tableName);
        console.log(" Upload Type:", uploadType);
        console.log(" Conflict Column:", conflictColumn);
        console.log(" Column Mappings:", columns);
  
        if (uploadType === "upsert" && !conflictColumn) {
          throw new Error(
            "A 'conflictColumn' must be specified for 'upsert' operations."
          );
        }
  
        const processingLogs: ProcessingLog[] = [];
        const allValidationErrors: ValidationError[] = [];
  
        toast.info("Reading and parsing Excel file...");
  
        // 1. Parse the Excel file using our xlsx utility function
        const jsonData = await parseExcelFile(file);
  
        console.log(" Raw Excel Data:", {
          totalRows: jsonData.length,
          headers: jsonData[0],
          sampleData: jsonData.slice(1, 4), // Show first 3 data rows
        });
  
        if (!jsonData || jsonData.length < 2) {
          toast.warning(
            "No data found in the Excel file. (A header row and at least one data row are required)."
          );
          console.groupEnd();
          return { 
            successCount: 0, 
            errorCount: 0, 
            totalRows: 0, 
            errors: [],
            processingLogs,
            validationErrors: allValidationErrors,
            skippedRows: 0,
          };
        }
  
        // 2. Map Excel headers to their column index for efficient lookup
        const excelHeaders: string[] = jsonData[0] as string[];
        const headerMap: Record<string, number> = {};
        console.log(" Excel Headers:", excelHeaders);
        
        excelHeaders.forEach((header, index) => {
          const cleanHeader = String(header).trim().toLowerCase();
          headerMap[cleanHeader] = index;
          console.log(`   [${index}]: "${header}" -> "${cleanHeader}"`);
        });
        
        const isFirstColumnId =
          String(excelHeaders?.[0] ?? "").toLowerCase() === "id";
        console.log(" First column is ID:", isFirstColumnId);
  
        // 3. Validate that all required columns from the mapping exist in the file
        const getHeaderIndex = (name: string): number | undefined =>
          headerMap[String(name).trim().toLowerCase()];
  
        console.group(" Column Mapping Validation");
        for (const mapping of columns) {
          const idx = getHeaderIndex(mapping.excelHeader);
          console.log(` "${mapping.excelHeader}" -> "${mapping.dbKey}":`, 
            idx !== undefined ? `Column ${idx}` : " NOT FOUND");
          
          // Allow missing 'id' header so we can auto-generate UUIDs during processing
          if (idx === undefined && mapping.dbKey !== "id") {
            console.error(` Required column "${mapping.excelHeader}" not found in Excel file`);
            throw new Error(
              `Required column "${mapping.excelHeader}" not found in the Excel file.`
            );
          }
        }
        console.groupEnd();
  
        toast.info(
          `Found ${jsonData.length - 1} rows. Preparing data for upload...`
        );
  
        // 4. Process rows and transform data into the format for Supabase
        const dataRows = jsonData.slice(1);
  
        // Helper: determine if a row is effectively empty (ignoring 'id')
        const isRowEffectivelyEmpty = (row: unknown[]): boolean => {
          for (const mapping of columns) {
            if (mapping.dbKey === "id") continue; // ignore id when checking emptiness
            const idx = getHeaderIndex(mapping.excelHeader);
            const v = idx !== undefined ? row[idx] : undefined;
            if (v !== undefined && String(v).trim() !== "") {
              return false; // has some non-empty value in a non-id column
            }
          }
          return true;
        };
  
        // Filter out rows that are empty across all non-id columns, keep index for error reporting
        const filteredRows = dataRows
          .map((row, idx) => ({ row: row as unknown[], idx }))
          .filter(({ row }) => !isRowEffectivelyEmpty(row));
  
        console.log(` Filtered ${dataRows.length} rows down to ${filteredRows.length} non-empty rows`);
  
        // Initialize upload result early to record pre-insert validation errors
        const uploadResult: EnhancedUploadResult = {
          successCount: 0,
          errorCount: 0,
          totalRows: 0,
          errors: [],
          processingLogs,
          validationErrors: allValidationErrors,
          skippedRows: 0,
        };
  
        let recordsToProcess: TableInsert<T>[] = [];

        // Helpers capture the hook's generic T via closure over tableName
        const insertBatch = async (
          rows: TableInsert<T>[]
        ) => {
          // T is a generic (union of table names) here; Supabase's overloads require a concrete table literal.
          // A localized cast is used to bridge this at the single boundary to Supabase.
          // eslint-disable-next-line @typescript-eslint/no-explicit-any
          return supabase.from(tableName).insert(rows as any);
        };

        const upsertBatch = async (
          rows: TableInsert<T>[],
          onConflict: string
        ) => {
          // eslint-disable-next-line @typescript-eslint/no-explicit-any
          return supabase.from(tableName).upsert(rows as any, { onConflict });
        };

        const upsertOne = async (
          row: TableInsert<T>,
          onConflict: string
        ) => {
          // eslint-disable-next-line @typescript-eslint/no-explicit-any
          return supabase.from(tableName).upsert(row as any, { onConflict });
        };
  
        console.group(" Row Processing Phase");
        
        for (let i = 0; i < filteredRows.length; i++) {
          const { row, idx } = filteredRows[i];
          const excelRowNumber = idx + 2; // +2 because Excel is 1-indexed and we skip header
          
          const originalData: Record<string, unknown> = {};
          const processedData: Record<string, unknown> = {};
          const rowValidationErrors: ValidationError[] = [];
          let isSkipped = false;
          let skipReason: string | undefined;
  
          // Build original data object for logging
          excelHeaders.forEach((header, headerIdx) => {
            originalData[header] = row[headerIdx];
          });
  
          // Secondary safeguard: determine if row has any meaningful non-id value
          const rowHasContent = columns.some((mapping) => {
            if (mapping.dbKey === "id") return false;
            const idx = getHeaderIndex(mapping.excelHeader);
            const v = idx !== undefined ? row[idx] : undefined;
            return v !== undefined && String(v).trim() !== "";
          });
  
          if (!rowHasContent) {
            // Skip rows that are effectively empty across non-id columns
            isSkipped = true;
            skipReason = "Row is empty across all non-id columns";
            uploadResult.skippedRows++;
            
            const log = logRowProcessing(
              i, 
              excelRowNumber, 
              originalData, 
              processedData, 
              rowValidationErrors, 
              isSkipped, 
              skipReason
            );
            processingLogs.push(log);
            continue;
          }
  
          // Process each column mapping
          for (const mapping of columns) {
            const colIndex = getHeaderIndex(mapping.excelHeader);
            // Guard: only index row when we have a valid column index
            let rawValue = colIndex !== undefined ? row[colIndex] : undefined;
  
            console.group(` Processing "${mapping.dbKey}" (Excel: "${mapping.excelHeader}")`);
            console.log(` Column Index: ${colIndex}`);
            console.log(` Raw Value:`, rawValue, `(${typeof rawValue})`);
  
            try {
              // Normalize empty strings to null for UUID-like fields
              if (
                (mapping.dbKey === "id" ||
                  mapping.dbKey.endsWith("_id") ||
                  mapping.dbKey === "parent_id") &&
                (rawValue === "" || rawValue === undefined)
              ) {
                rawValue = null;
                console.log(" Normalized empty UUID field to null");
              }
  
              // Normalize IP address-like fields for inet columns: trim and empty -> null
              // Targets include: 'ip_address', any key ending with '_ip', or containing 'ipaddr'
              {
                const key = String(mapping.dbKey || "").toLowerCase();
                const isIPField =
                  key === "ip_address" ||
                  key.endsWith("_ip") ||
                  key.includes("ipaddr");
                if (isIPField && typeof rawValue === "string") {
                  const trimmed = rawValue.trim();
                  rawValue = trimmed === "" ? null : trimmed;
                  console.log(" Processed IP field:", rawValue);
                }
              }
  
              // Only generate a UUID for `id` if the row actually has content
              if (mapping.dbKey === "id" && rowHasContent) {
                // If first Excel column is id/ID and current mapping is for 'id', auto-generate UUID when empty
                if (
                  isFirstColumnId &&
                  (rawValue === null ||
                    rawValue === undefined ||
                    String(rawValue).trim() === "")
                ) {
                  rawValue = generateUUID();
                  console.log(" Generated UUID for empty ID:", rawValue);
                }
                // If 'id' header is entirely missing, still generate a UUID
                if (colIndex === undefined) {
                  rawValue = generateUUID();
                  console.log(" Generated UUID for missing ID column:", rawValue);
                }
              }
  
              // Use the transform function if available, otherwise use the raw value
              let finalValue: unknown;
              if (mapping.transform) {
                try {
                  finalValue = mapping.transform(rawValue);
                  console.log(" Transformed value:", finalValue, `(${typeof finalValue})`);
                } catch (transformError) {
                  const errorMsg = transformError instanceof Error 
                    ? transformError.message 
                    : "Transform function failed";
                  console.error(" Transform error:", errorMsg);
                  
                  const validationError: ValidationError = {
                    rowIndex: i,
                    column: mapping.dbKey,
                    value: rawValue,
                    error: `Transform failed for "${mapping.dbKey}": ${errorMsg}`,
                  };
                  rowValidationErrors.push(validationError);
                  allValidationErrors.push(validationError);
                  finalValue = rawValue; // Use raw value as fallback
                }
              } else {
                finalValue = rawValue;
              }
  
              // Validate the processed value
              const validationError = validateValue(
                finalValue, 
                mapping.dbKey, 
                mapping.required || false
              );
              
              if (validationError) {
                validationError.rowIndex = i;
                rowValidationErrors.push(validationError);
                allValidationErrors.push(validationError);
                console.error(" Validation failed:", validationError.error);
              }
  
              // Assign the processed value to the correct database key
              // Normalize empty strings to null to satisfy numeric/date/inet columns
              let assignValue =
                finalValue !== undefined
                  ? finalValue
                  : rawValue !== undefined
                  ? rawValue
                  : null;
              
              if (typeof assignValue === "string" && assignValue.trim() === "") {
                assignValue = null;
                console.log(" Normalized empty string to null");
              }
              
              processedData[mapping.dbKey] = assignValue;
              console.log(" Final assigned value:", assignValue, `(${typeof assignValue})`);
  
              logColumnTransformation(
                i,
                mapping.dbKey,
                rawValue,
                assignValue
              );
  
            } catch (columnError) {
              const errorMsg = columnError instanceof Error 
                ? columnError.message 
                : "Unknown column processing error";
              console.error(" Column processing error:", errorMsg);
              
              const validationError: ValidationError = {
                rowIndex: i,
                column: mapping.dbKey,
                value: rawValue,
                error: `Column processing failed: ${errorMsg}`,
              };
              rowValidationErrors.push(validationError);
              allValidationErrors.push(validationError);
            } finally {
              console.groupEnd();
            }
          }
  
          // Check if row has validation errors
          const hasRequiredFieldErrors = rowValidationErrors.some(err => 
            err.error.includes("Required field") || err.error.includes("Missing required")
          );
  
          if (hasRequiredFieldErrors) {
            // Record a validation error for this row and skip it
            isSkipped = true;
            skipReason = `Validation failed: ${rowValidationErrors.map(e => e.error).join("; ")}`;
            uploadResult.errorCount += 1;
            uploadResult.skippedRows++;
            
            uploadResult.errors.push({
              rowIndex: excelRowNumber,
              data: processedData as Record<string, unknown>,
              error: skipReason,
            });
          } else {
            // Add to records to process
            recordsToProcess.push(processedData as TableInsert<T>);
          }
  
          // Log the complete row processing
          const log = logRowProcessing(
            i,
            excelRowNumber,
            originalData,
            processedData,
            rowValidationErrors,
            isSkipped,
            skipReason
          );
          processingLogs.push(log);
        }
        
        console.groupEnd(); // End Row Processing Phase
  
        console.log(` Processing Summary:`);
        console.log(`   Total filtered rows: ${filteredRows.length}`);
        console.log(`   Records to process: ${recordsToProcess.length}`);
        console.log(`   Skipped rows: ${uploadResult.skippedRows}`);
        console.log(`   Validation errors: ${allValidationErrors.length}`);
  
        // Deduplicate by conflict columns to avoid Postgres error:
        // "ON CONFLICT DO UPDATE command cannot affect row a second time"
        if (uploadType === "upsert" && conflictColumn) {
          console.group(" Deduplication Process");
          
          const conflictCols = String(conflictColumn)
            .split(",")
            .map((s) => s.trim())
            .filter((s) => s.length > 0);
  
          console.log(" Conflict columns:", conflictCols);
  
          if (conflictCols.length > 0) {
            const seen = new Set<string>();
            const deduped: TableInsert<T>[] = [];
            let duplicateCount = 0;
            
            for (const rec of recordsToProcess) {
              const values = conflictCols.map((c) => (rec as Record<string, unknown>)[c]);
              const allPresent = values.every(
                (v) =>
                  v !== undefined &&
                  v !== null &&
                  !(typeof v === "string" && v === "")
              );
              
              if (!allPresent) {
                // Do not dedupe records missing conflict values; still avoid PK updates on composite keys
                if (!conflictCols.includes("id")) {
                  delete (rec as Record<string, unknown>).id;
                }
                deduped.push(rec);
                console.log(" Added record with missing conflict values (no deduplication)");
                continue;
              }
  
              // Normalize strings for dedupe to match DB uniqueness (trim + lowercase)
              const normalized = values.map((v) =>
                typeof v === "string" ? v.trim().toLowerCase() : v
              );
              const key = JSON.stringify(normalized);
              
              if (!seen.has(key)) {
                seen.add(key);
                if (!conflictCols.includes("id")) {
                  delete (rec as Record<string, unknown>).id;
                }
                deduped.push(rec);
                console.log(` Added unique record with key: ${key}`);
              } else {
                duplicateCount++;
                console.log(`  Skipped duplicate record with key: ${key}`);
              }
            }
            
            console.log(` Deduplication results:`);
            console.log(`   Original records: ${recordsToProcess.length}`);
            console.log(`   After deduplication: ${deduped.length}`);
            console.log(`   Duplicates removed: ${duplicateCount}`);
            
            recordsToProcess = deduped;
          }
          
          console.groupEnd();
        }
  
        // 5. Perform batch upload to Supabase
        uploadResult.totalRows = recordsToProcess.length;
        console.log(` Starting Supabase upload for ${uploadResult.totalRows} records`);
  
        if (recordsToProcess.length === 0) {
          console.log(" No records to upload after processing");
          toast.warning("No valid records found to upload after processing.");
          console.groupEnd();
          return uploadResult;
        }
  
        console.group(" Supabase Upload Process");
  
        for (let i = 0; i < recordsToProcess.length; i += batchSize) {
          const batch = recordsToProcess.slice(i, i + batchSize);
          const progress = Math.round(
            ((i + batch.length) / recordsToProcess.length) * 100
          );
          toast.info(`Uploading batch ${Math.floor(i / batchSize) + 1}... (${progress}%)`);
          
          console.log(` Processing batch ${Math.floor(i / batchSize) + 1}:`);
          console.log(`   Range: ${i} - ${i + batch.length - 1}`);
          console.log(`   Batch size: ${batch.length}`);
          console.log(`   Progress: ${progress}%`);
          console.log(" Batch data sample:", batch.slice(0, 2)); // Show first 2 records
  
          // If using composite conflict keys, upsert rows one-by-one to avoid
          // "ON CONFLICT DO UPDATE command cannot affect row a second time"
          const isCompositeConflict =
            uploadType === "upsert" &&
            conflictColumn &&
            String(conflictColumn).split(",").length > 1;
            
          if (isCompositeConflict) {
            console.log(" Using individual upserts for composite conflict keys");
            
            for (let j = 0; j < batch.length; j++) {
              const row = batch[j];
              console.log(` Upserting individual record ${i + j + 1}:`, row);
              
              try {
                const { error } = await upsertOne(row as TableInsert<T>, conflictColumn as string);
                  
                if (error) {
                  console.error(` Individual upsert failed for record ${i + j + 1}:`, error);
                  uploadResult.errorCount += 1;
                  uploadResult.errors.push({
                    rowIndex: i + j,
                    data: row as Record<string, unknown>,
                    error: error.message,
                  });
                  if (showToasts) {
                    toast.error(
                      `Error at record ${i + j + 1}: ${error.message}`
                    );
                  }
                } else {
                  console.log(` Individual upsert successful for record ${i + j + 1}`);
                  uploadResult.successCount += 1;
                }
              } catch (unexpectedError) {
                const errorMsg = unexpectedError instanceof Error 
                  ? unexpectedError.message 
                  : "Unexpected error during individual upsert";
                console.error(` Unexpected error during individual upsert:`, unexpectedError);
                uploadResult.errorCount += 1;
                uploadResult.errors.push({
                  rowIndex: i + j,
                  data: row as Record<string, unknown>,
                  error: errorMsg,
                });
              }
            }
            continue;
          }
  
          // Regular batch processing
          console.log(` Executing batch ${uploadType} operation`);
          
          try {
            let query;
            if (uploadType === "insert") {
              console.log(" Using INSERT operation");
              query = insertBatch(batch as TableInsert<T>[]);
            } else {
              console.log(` Using UPSERT operation with conflict: ${conflictColumn}`);
              query = upsertBatch(batch as TableInsert<T>[], conflictColumn as string);
            }
  
            const { error } = await query;
            
            if (error) {
              // Handle foreign key constraint violation specifically
              if (error.code === '23503' && error.message.includes('ofc_cables_sn_id_fkey')) {
                // Type-safe access to sn_id
                type RecordWithSnId = { sn_id?: unknown };
                const getSnId = (record: unknown): string | undefined => {
                  if (record && typeof record === 'object' && 'sn_id' in record) {
                    const value = (record as RecordWithSnId).sn_id;
                    return value !== null && value !== undefined ? String(value) : undefined;
                  }
                  return undefined;
                };
                
                // Extract all unique sn_ids from the batch that caused the error
                const invalidSnIds = [...new Set(
                  batch.map(record => getSnId(record)).filter((id): id is string => Boolean(id))
                )];
                
                // Log detailed error information
                console.error('Foreign key violation details:', {
                  table: tableName,
                  constraint: 'ofc_cables_sn_id_fkey',
                  invalidValues: invalidSnIds,
                  error: error.message
                });
                
                // Add validation errors for each affected row
                batch.forEach((record, index) => {
                  const snId = getSnId(record);
                  if (snId) {
                    uploadResult.validationErrors.push({
                      rowIndex: i + index,
                      column: 'sn_id',
                      value: snId,
                      error: `Foreign key violation: sn_id '${snId}' does not exist in the nodes table`,
                      data: { column: 'sn_id', value: snId, constraint: 'ofc_cables_sn_id_fkey' }
                    });
                  }
                });
                
                // Add a summary error to the upload result
                const errorMessage = `Foreign key violation: ${invalidSnIds.length} invalid sn_id value(s) found in batch. ` +
                  `Invalid values: ${invalidSnIds.join(', ')}`;
                uploadResult.errorCount += batch.length;
                uploadResult.errors.push({
                  rowIndex: i,
                  data: batch,
                  error: errorMessage
                });
                
                // Show user-friendly error message
                if (showToasts) {
                  toast.error(
                    `Foreign key violation: ${invalidSnIds.length} invalid sn_id value(s) found. ` +
                    'Check the console for details.',
                    { duration: 10000 }
                  );
                }
              } else {
                // Handle other types of errors
                const errorDetails: Record<string, unknown> = {};
                if (error.code === '23503') {
                  errorDetails.constraint = error.message.match(/constraint "(.*?)"/)?.[1];
                  errorDetails.detail = error.message;
                }
                
                uploadResult.errorCount += batch.length;
                uploadResult.errors.push({
                  rowIndex: i,
                  data: batch,
                  error: error.message,
                  ...(Object.keys(errorDetails).length > 0 ? { details: errorDetails } : {})
                });
                
                if (showToasts) {
                  toast.error(`Error in batch starting at record ${i + 1}: ${error.message}`);
                }
              }
            } else {
              console.log(` Batch operation successful for ${batch.length} records`);
              uploadResult.successCount += batch.length;
            }
          } catch (unexpectedError) {
            const errorMsg = unexpectedError instanceof Error 
              ? unexpectedError.message 
              : "Unexpected error during batch operation";
            console.error(` Unexpected error during batch operation:`, unexpectedError);
            uploadResult.errorCount += batch.length;
            uploadResult.errors.push({
              rowIndex: i,
              data: batch,
              error: errorMsg,
            });
          }
        }
        
        console.groupEnd(); // End Supabase Upload Process
  
        // 6. Finalize and report
        console.group(" Upload Results Summary");
        console.log(` Successful uploads: ${uploadResult.successCount}`);
        console.log(` Failed uploads: ${uploadResult.errorCount}`);
        console.log(`  Skipped rows: ${uploadResult.skippedRows}`);
        console.log(` Total processing logs: ${processingLogs.length}`);
        console.log(`  Total validation errors: ${allValidationErrors.length}`);
        
        if (uploadResult.errors.length > 0) {
          console.log(" Upload errors:", uploadResult.errors);
        }
        
        if (allValidationErrors.length > 0) {
          console.log(" Validation errors:", allValidationErrors);
        }
        console.groupEnd();
  
        if (uploadResult.errorCount > 0) {
          if (showToasts) {
            toast.warning(
              `${uploadResult.successCount} rows uploaded successfully, but ${uploadResult.errorCount} failed. Check console for details.`
            );
          }
        } else {
          if (showToasts) {
            toast.success(
              `Successfully uploaded ${uploadResult.successCount} of ${uploadResult.totalRows} records.`
            );
          }
          
          // Invalidate related queries instead of reloading the page to preserve UI state
          try {
            await queryClient.invalidateQueries({
              predicate: (q) => {
                const key = q.queryKey as unknown[];
                if (!Array.isArray(key)) return false;
                // Match if any segment equals the tableName or contains it as a substring (to catch views/RPC keys like "v_ofc_cables_complete")
                return key.some((seg) => {
                  if (seg === tableName) return true;
                  if (typeof seg === "string" && seg.toLowerCase().includes(String(tableName).toLowerCase())) return true;
                  return false;
                });
              },
            });
            // Force refetch so UI reflects changes immediately even if staleTime is large
            await queryClient.refetchQueries({
              predicate: (q) => {
                const key = q.queryKey as unknown[];
                if (!Array.isArray(key)) return false;
                return key.some((seg) => {
                  if (seg === tableName) return true;
                  if (typeof seg === "string" && seg.toLowerCase().includes(String(tableName).toLowerCase())) return true;
                  return false;
                });
              },
              type: "active",
            });
            console.log(" Query cache invalidated successfully");
          } catch (err) {
            console.warn(" Failed to invalidate queries after upload", err);
          }
        }
  
        console.groupEnd(); // End Excel Upload Process
        return uploadResult;
      },
      ...mutationOptions,
    });
  }
```

<!-- path: hooks/useRoleFunctions.ts -->
```typescript
// hooks/database/functions.ts - Hooks for Supabase functions
import { useQuery, UseQueryResult } from '@tanstack/react-query'
import { createClient } from '@/utils/supabase/client'
import React from 'react'
import { useAuth } from '@/hooks/useAuth'

// Types for better type safety
type UserRole = string | null
type SuperAdminStatus = boolean | null

interface UserPermissions {
  role: UserRole
  isSuperAdmin: SuperAdminStatus
  isLoading: boolean
  error: Error | null
  isError: boolean
  refetch: () => void
}

/**
 * Hook to get the current user's role with automatic session refresh if needed
 */
export const useMyRole = (): UseQueryResult<UserRole, Error> => {
  const supabase = createClient()
  const { user, authState, syncSession } = useAuth()
  
  return useQuery({
    queryKey: ['my-role', user?.id],
    queryFn: async (): Promise<UserRole> => {
      try {
        const { data, error } = await supabase.rpc('get_my_role')

        // If we get null data, try refreshing the session and retry
        if (data === null) {
          const sessionRefreshed = await syncSession()
          if (sessionRefreshed) {
            const { data: retryData, error: retryError } = await supabase.rpc('get_my_role')
            if (retryError) throw retryError
            return retryData as UserRole
          }
        }

        if (error) {
          console.error('Role fetch error:', error)
          throw new Error(`Failed to get user role: ${error.message}`)
        }
        
        return data as UserRole
      } catch (err) {
        console.error('Role query error:', err)
        throw err
      }
    },
    staleTime: 10 * 60 * 1000, // 10 minutes
    gcTime: 15 * 60 * 1000, // 15 minutes
    retry: (failureCount, error) => {
      // Don't retry on authentication errors
      if (error.message.includes('JWT') || error.message.includes('auth')) {
        return false
      }
      return failureCount < 2
    },
    retryDelay: (attemptIndex) => Math.min(1000 * 2 ** attemptIndex, 30000),
    enabled: authState === "authenticated" && !!user?.id,
    refetchOnWindowFocus: false,
    networkMode: 'offlineFirst'
  })
}

/**
 * Hook to check if the current user is a super admin
 */
export const useIsSuperAdmin = (): UseQueryResult<SuperAdminStatus, Error> => {
  const supabase = createClient()
  const { user, authState, syncSession } = useAuth()
  
  return useQuery({
    queryKey: ['is-super-admin', user?.id],
    queryFn: async (): Promise<SuperAdminStatus> => {
      try {
        const { data, error } = await supabase.rpc('is_super_admin')

        // If we get null data, try refreshing the session and retry
        if (data === null) {
          const sessionRefreshed = await syncSession()
          if (sessionRefreshed) {
            const { data: retryData, error: retryError } = await supabase.rpc('is_super_admin')
            if (retryError) throw retryError
            return retryData as SuperAdminStatus
          }
        }
        
        if (error) {
          console.error('Super admin check error:', error)
          throw new Error(`Failed to check super admin status: ${error.message}`)
        }
        
        return data as SuperAdminStatus
      } catch (err) {
        console.error('Super admin query error:', err)
        throw err
      }
    },
    staleTime: 10 * 60 * 1000, // 10 minutes
    gcTime: 15 * 60 * 1000, // 15 minutes
    retry: (failureCount, error) => {
      if (error.message.includes('JWT') || error.message.includes('auth')) {
        return false
      }
      return failureCount < 2
    },
    retryDelay: (attemptIndex) => Math.min(1000 * 2 ** attemptIndex, 30000),
    enabled: authState === "authenticated" && !!user?.id,
    refetchOnWindowFocus: false,
    networkMode: 'offlineFirst'
  })
}

/**
 * Combined hook that returns both role and super admin status
 * with optimized refetching and error handling
 */
export const useUserPermissions = (): UserPermissions => {
  const roleQuery = useMyRole()
  const superAdminQuery = useIsSuperAdmin()
  
  const refetch = React.useCallback(() => {
    return Promise.allSettled([
      roleQuery.refetch(),
      superAdminQuery.refetch()
    ])
  }, [roleQuery, superAdminQuery])
  
  return {
    role: roleQuery.data ?? null,
    isSuperAdmin: superAdminQuery.data ?? null,
    isLoading: roleQuery.isLoading || superAdminQuery.isLoading,
    error: roleQuery.error || superAdminQuery.error || null,
    isError: roleQuery.isError || superAdminQuery.isError,
    refetch
  }
}

/**
 * Extended version of user permissions with utility methods
 */
export const useUserPermissionsExtended = () => {
  const permissions = useUserPermissions()
  
  const hasRole = React.useCallback((requiredRole: string): boolean => {
    return permissions.role === requiredRole
  }, [permissions.role])
  
  const hasAnyRole = React.useCallback((requiredRoles: string[]): boolean => {
    return permissions.role ? requiredRoles.includes(permissions.role) : false
  }, [permissions.role])
  
  const canAccess = React.useCallback((allowedRoles?: string[]): boolean => {
    // Super admin can access everything
    if (permissions.isSuperAdmin) return true
    
    // If no roles specified, just check if authenticated
    if (!allowedRoles || allowedRoles.length === 0) return !!permissions.role
    
    // Check if user has required role
    return hasAnyRole(allowedRoles)
  }, [permissions.isSuperAdmin, permissions.role, hasAnyRole])
  
  return {
    ...permissions,
    hasRole,
    hasAnyRole,
    canAccess,
    isReady: !permissions.isLoading && !permissions.error
  }
}

/**
 * Optimized hook for role-based conditional rendering
 * Uses memoization to prevent unnecessary re-renders
 */
export const useHasPermission = (allowedRoles?: string[]): boolean => {
  const { canAccess } = useUserPermissionsExtended()
  return React.useMemo(() => canAccess(allowedRoles), [canAccess, allowedRoles])
}

// Export types for use in other files
export type { UserRole, SuperAdminStatus, UserPermissions }
```

<!-- path: hooks/useCrudPage.ts -->
```typescript
"use client";

import { useState, useMemo, useCallback, useEffect } from "react";
import { useDebounce } from "use-debounce";
import { createClient } from "@/utils/supabase/client";
import {
  useTableWithRelations,
  useTableInsert,
  useTableUpdate,
  useToggleStatus,
  useTableBulkOperations,
  Filters,
  TableName,
  Row,
  TableInsert,
  TableUpdate,
  TableInsertWithDates,
} from "@/hooks/database";
import { toast } from "sonner";
import { useDeleteManager } from "@/hooks/useDeleteManager";
import { DEFAULTS } from "@/config/constants";

// A generic type to ensure records passed to actions have an 'id' and optionally a 'name'
type RecordWithId = {
  id: string | number;
  system_id?: string | number;
  system_connection_id?: string | number;
  name?: string;
  [key: string]: unknown;
};

/**
 * A comprehensive hook to manage the state and logic for a standard CRUD page.
 * @param tableName The name of the Supabase table.
 * @param options Configuration options for the hook.
 */
export function useCrudPage<T extends TableName>({
  tableName,
  relations = [],
  searchColumn = "name",
  orderByColumn = "name",
}: {
  tableName: T;
  relations?: string[];
  searchColumn: (keyof Row<T> & string) | "name";
  orderByColumn?: string;
}) {
  const supabase = createClient();

  // --- STATE MANAGEMENT ---
  const [currentPage, setCurrentPage] = useState(1);
  const [pageLimit, setPageLimit] = useState(DEFAULTS.PAGE_SIZE);
  const [searchQuery, setSearchQuery] = useState("");
  const [filters, setFilters] = useState<Filters>({});
  const [isModalOpen, setIsModalOpen] = useState(false);
  const [editingRecord, setEditingRecord] = useState<Row<T> | null>(null);
  const [debouncedSearch] = useDebounce(searchQuery, DEFAULTS.DEBOUNCE_DELAY);
  const [selectedRowIds, setSelectedRowIds] = useState<string[]>([]);

  // --- FILTERS ---
  const serverFilters = useMemo(() => {
    const combinedFilters: Filters = { ...filters };
    if (debouncedSearch) {
      combinedFilters[searchColumn] = {
        operator: "ilike",
        value: `%${debouncedSearch}%`,
      };
    }
    return combinedFilters;
  }, [filters, debouncedSearch, searchColumn]);

  // Reset pagination when filters change
  useEffect(() => {
    setCurrentPage(1);
  }, [debouncedSearch, filters]);

  // --- DATA FETCHING ---
  const { data, isLoading, error, refetch } = useTableWithRelations(
    supabase,
    tableName,
    relations,
    {
      filters: serverFilters,
      limit: pageLimit,
      offset: (currentPage - 1) * pageLimit,
      includeCount: true,
      orderBy: [{ column: orderByColumn, ascending: true }],
    }
  );

  const totalCount =
    (data?.[0] as { total_count: number })?.total_count ?? data?.length ?? 0;

  // --- MUTATIONS ---
  const { mutate: insertItem, isPending: isInserting } = useTableInsert(
    supabase,
    tableName,
    {
      onSuccess: () => {
        refetch();
        closeModal();
        toast.success("Record created successfully!");
      },
      onError: (err) => toast.error(`Creation failed: ${err.message}`),
    }
  );
  const { mutate: updateItem, isPending: isUpdating } = useTableUpdate(
    supabase,
    tableName,
    {
      onSuccess: () => {
        refetch();
        closeModal();
        toast.success("Record updated successfully!");
      },
      onError: (err) => toast.error(`Update failed: ${err.message}`),
    }
  );
  const { mutate: toggleStatus } = useToggleStatus(supabase, tableName, {
    onSuccess: () => refetch(),
    onError: (err) => toast.error(`Status toggle failed: ${err.message}`),
  });

  // *** INTEGRATE useDeleteManager ***
  const deleteManager = useDeleteManager({ tableName, onSuccess: refetch });

  // NEW: Bulk mutation hooks
  const { bulkDelete, bulkUpdate } = useTableBulkOperations(
    supabase,
    tableName
  );

  const isMutating =
    isInserting ||
    isUpdating ||
    deleteManager.isPending ||
    bulkDelete.isPending ||
    bulkUpdate.isPending;

  // --- HANDLERS ---
  const openAddModal = useCallback(() => {
    setEditingRecord(null);
    setIsModalOpen(true);
  }, []);
  const openEditModal = useCallback((record: Row<T>) => {
    setEditingRecord(record);
    setIsModalOpen(true);
  }, []);
  const closeModal = useCallback(() => {
    setIsModalOpen(false);
    setEditingRecord(null);
  }, []);

  const handleSave = useCallback(
    (formData: TableInsertWithDates<T>) => {
      // Convert ISO date strings back to Date objects for the database
      const processedData = { ...formData };

      // Handle date fields - adjust these field names as needed
      const dateFields = ['employee_dob', 'employee_doj', 'created_at', 'updated_at'] as const;
      
      dateFields.forEach((field) => {
        const fieldKey = field as keyof typeof processedData;
        if (field in processedData && processedData[fieldKey]) {
          const dateValue = processedData[fieldKey] as string | Date;
          (processedData as TableInsertWithDates<T>)[fieldKey] = new Date(dateValue) as unknown as TableInsertWithDates<T>[typeof fieldKey];
        }
      });

    if (editingRecord && "id" in editingRecord && editingRecord.id) {
      updateItem({
        id: String(editingRecord.id),
        data: processedData as TableUpdate<T>,
      });
    } else {
      insertItem(processedData as TableInsert<T>);
    }
  },
  [editingRecord, insertItem, updateItem]
);

  // The delete handler now just triggers the delete manager
  const handleDelete = useCallback(
    (record: RecordWithId) => {
      deleteManager.deleteSingle({
        id: String(record.id),
        name: record.name || String(record.id),
      });
    },
    [deleteManager]
  );

  const handleToggleStatus = useCallback(
    (record: RecordWithId & { status?: boolean | null }) => {
      toggleStatus({
        id: String(record.id),
        status: !(record.status ?? false),
      });
    },
    [toggleStatus]
  );

  // NEW: Bulk action handlers
  const handleRowSelect = useCallback(
    (rows: Array<Row<T> & { id?: string | number }>) => {
      setSelectedRowIds(
        rows
          .map((r) => r?.id)
          .filter((id): id is string => typeof id === "string")
      );
    },
    []
  );

  const handleClearSelection = useCallback(() => setSelectedRowIds([]), []);

  const handleBulkDelete = useCallback(() => {
    if (selectedRowIds.length === 0) return;
    if (
      window.confirm(
        `Are you sure you want to delete ${selectedRowIds.length} selected records?`
      )
    ) {
      bulkDelete.mutate(
        { ids: selectedRowIds },
        {
          onSuccess: () => {
            toast.success(`${selectedRowIds.length} records deleted.`);
            setSelectedRowIds([]);
            refetch();
          },
          onError: (err) => toast.error(`Bulk delete failed: ${err.message}`),
        }
      );
    }
  }, [selectedRowIds, bulkDelete, refetch]);

  const handleBulkUpdateStatus = useCallback(
    (status: "active" | "inactive") => {
      if (selectedRowIds.length === 0) return;
      const updates = selectedRowIds.map((id) => ({
        id,
        data: { status: status === "active" } as unknown as TableUpdate<T>,
      }));
      bulkUpdate.mutate(
        { updates },
        {
          onSuccess: () => {
            toast.success(`${selectedRowIds.length} records updated.`);
            setSelectedRowIds([]);
            refetch();
          },
          onError: (err) =>
            toast.error(`Bulk status update failed: ${err.message}`),
        }
      );
    },
    [selectedRowIds, bulkUpdate, refetch]
  );

  // --- RETURN VALUE ---
  return {
    // Data and state
    data: data || [],
    totalCount,
    isLoading,
    error,
    isMutating,
    refetch,

    // UI State
    pagination: { currentPage, pageLimit, setCurrentPage, setPageLimit },
    search: { searchQuery, setSearchQuery },
    filters: { filters, setFilters },
    modal: {
      isModalOpen,
      editingRecord,
      openAddModal,
      openEditModal,
      closeModal,
    },

    // Actions
    actions: { handleSave, handleDelete, handleToggleStatus },

    // Bulk Actions
    bulkActions: {
      selectedCount: selectedRowIds.length,
      handleBulkDelete,
      handleBulkUpdateStatus,
      handleClearSelection,
      handleRowSelect,
    },

    // Expose delete modal state and handlers directly
    deleteModal: {
      isOpen: deleteManager.isConfirmModalOpen,
      message: deleteManager.confirmationMessage,
      confirm: deleteManager.handleConfirm,
      cancel: deleteManager.handleCancel,
      isLoading: deleteManager.isPending,
    },
  };
}

```

<!-- path: hooks/useDeleteManager.ts -->
```typescript
// hooks/useDeleteManager.ts
import { useState, useCallback } from 'react';
import { toast } from 'sonner';
import { useTableDelete } from '@/hooks/database';
import { createClient } from '@/utils/supabase/client';
import { Database } from '@/types/supabase-types';
import { hasDetails } from '@/types/error-types';

interface DeleteItem {
  id: string;
  name: string;
  [key: string]: unknown;
}

interface BulkDeleteFilter {
  column: string;
  value: unknown;
  displayName: string;
}

interface UseDeleteManagerProps {
  tableName: keyof Database['public']['Tables'];
  onSuccess?: () => void;
}

export function useDeleteManager({ tableName, onSuccess }: UseDeleteManagerProps) {
  const [isConfirmModalOpen, setIsConfirmModalOpen] = useState(false);
  const [deleteConfig, setDeleteConfig] = useState<{
    type: 'single' | 'bulk';
    items?: DeleteItem[];
    filter?: BulkDeleteFilter;
  } | null>(null);

  const supabase = createClient();
  const { mutate: deleteRowsById, isPending } = useTableDelete(supabase, tableName);
  
  
  // Single item deletion
  const deleteSingle = useCallback((item: DeleteItem) => {
    setDeleteConfig({
      type: 'single',
      items: [item],
    });
    setIsConfirmModalOpen(true);
  }, []);

  // Multiple items deletion (by IDs)
  const deleteMultiple = useCallback((items: DeleteItem[]) => {
    setDeleteConfig({
      type: 'single', // Still uses ID-based deletion
      items,
    });
    setIsConfirmModalOpen(true);
  }, []);

  // Bulk deletion by filter
  const deleteBulk = useCallback((filter: BulkDeleteFilter) => {
    setDeleteConfig({
      type: 'bulk',
      filter,
    });
    setIsConfirmModalOpen(true);
  }, []);
  

  const handleConfirm = useCallback(async () => {
    if (!deleteConfig) return;

    setIsConfirmModalOpen(false);

    try {
      if (deleteConfig.type === 'single' && deleteConfig.items) {
        // Direct ID-based deletion
        const idsToDelete = deleteConfig.items.map(item => item.id);
        
        deleteRowsById(idsToDelete, {
          onSuccess: () => {
            const itemNames = deleteConfig.items!.map(item => item.name).join(', ');
            toast.success(
              deleteConfig.items!.length === 1
                ? `Successfully deleted "${itemNames}"`
                : `Successfully deleted ${deleteConfig.items!.length} items: ${itemNames}`
            );
            onSuccess?.();
          },
          onError: (err) => {
            console.error('Deletion failed:', err);
            if (hasDetails(err)) {
              toast.error('Failed to delete items'+ err.details);
            } else {
              toast.error('Failed to delete items');
            }
          },
        });
      } else if (deleteConfig.type === 'bulk' && deleteConfig.filter) {
        // First fetch IDs that match the filter, then delete
        const { data: rowsToDelete, error: fetchError } = await supabase
          .from(tableName)
          .select('id')
          .eq(deleteConfig.filter.column, deleteConfig.filter.value);

        if (fetchError) {
          throw fetchError;
        }

        if (!rowsToDelete || rowsToDelete.length === 0) {
          toast.error(`No items found matching "${deleteConfig.filter.displayName}" to delete.`);
          return;
        }

        const idsToDelete = rowsToDelete.map(row => row.id);
        
        deleteRowsById(idsToDelete, {
          onSuccess: () => {
            toast.success(
              `Successfully deleted ${idsToDelete.length} items from "${deleteConfig.filter!.displayName}"`
            );
            onSuccess?.();
          },
          onError: (err) => {
            console.error('Deletion failed:', err);
            if (hasDetails(err)) {
              toast.error('Failed to delete items'+ err.details);
            } else {
              toast.error('Failed to delete items');
            }
          },
        });
      }
    } catch (error) {
      console.error('Error during deletion:', error);
      toast.error('Failed to delete items');
    } finally {
      setDeleteConfig(null);
    }
  }, [deleteConfig, deleteRowsById, onSuccess, supabase, tableName]);

  const handleCancel = useCallback(() => {
    setIsConfirmModalOpen(false);
    setDeleteConfig(null);
  }, []);

  // Generate confirmation message
  const getConfirmationMessage = useCallback(() => {
    if (!deleteConfig) return '';

    if (deleteConfig.type === 'single' && deleteConfig.items) {
      const items = deleteConfig.items;
      if (items.length === 1) {
        return `Are you sure you want to delete "${items[0].name}"? This cannot be undone.`;
      }
      return `Are you sure you want to delete ${items.length} items? This cannot be undone.`;
    }

    if (deleteConfig.type === 'bulk' && deleteConfig.filter) {
      return `Are you sure you want to delete all items in "${deleteConfig.filter.displayName}"? This cannot be undone.`;
    }

    return 'Are you sure you want to delete? This cannot be undone.';
  }, [deleteConfig]);

  // console.log('Delete Config:', deleteConfig);
  // console.log('isConfirmModalOpen:', isConfirmModalOpen);
  
  

  return {
    // Actions
    deleteSingle,
    deleteMultiple,
    deleteBulk,
    handleConfirm,
    handleCancel,
    
    // State
    isConfirmModalOpen,
    isPending,
    confirmationMessage: getConfirmationMessage(),
    
    // For debugging/display
    deleteConfig,
  };
}


```

<!-- path: hooks/useIsMobile.tsx -->
```typescript
// hooks/useIsMobile.tsx
import { useState, useEffect } from 'react';

const useIsMobile = (breakpoint = 768) => {
  const [isMobile, setIsMobile] = useState(false);

  useEffect(() => {
    const checkDevice = () => {
      // Check screen width
      const isSmallScreen = window.innerWidth < breakpoint;
      
      // Check user agent for mobile indicators
      const userAgent = navigator.userAgent.toLowerCase();
      const mobileKeywords = [
        'mobile', 'android', 'iphone', 'ipad', 'ipod', 
        'blackberry', 'windows phone', 'opera mini'
      ];
      const isMobileAgent = mobileKeywords.some(keyword => 
        userAgent.includes(keyword)
      );
      
      // Check for touch capability
      const hasTouch = 'ontouchstart' in window || navigator.maxTouchPoints > 0;
      
      // Combine all checks - prioritize screen size but consider other factors
      const mobile = isSmallScreen || (isMobileAgent && hasTouch);
      
      setIsMobile(mobile);
    };

    // Initial check
    checkDevice();

    // Listen for resize events
    window.addEventListener('resize', checkDevice);
    
    // Listen for orientation changes (mobile specific)
    window.addEventListener('orientationchange', checkDevice);

    // Cleanup
    return () => {
      window.removeEventListener('resize', checkDevice);
      window.removeEventListener('orientationchange', checkDevice);
    };
  }, [breakpoint]);

  return isMobile;
};

export default useIsMobile;

// Usage examples:
// const isMobile = useIsMobile(); // Uses default 768px breakpoint
// const isMobile = useIsMobile(1024); // Custom breakpoint
// const isMobile = useIsMobile(480); // Smaller breakpoint for strict mobile-only
```

<!-- path: hooks/defaultUploadConfigs.ts -->
```typescript
import { TableNames } from "@/config/helper-types";
import { buildUploadConfig, TABLES } from "@/config/table-column-keys";

// Thin adapter: build per-table upload config from SSOT
const defaultUploadConfigs = () => {
  const result: Partial<
    Record<TableNames, ReturnType<typeof buildUploadConfig<TableNames>>>
  > = {};

  (Object.keys(TABLES) as TableNames[]).forEach((tableName) => {
    result[tableName] = buildUploadConfig(tableName);
  });

  return result as Record<
    TableNames,
    ReturnType<typeof buildUploadConfig<TableNames>>
  >;
};

export default defaultUploadConfigs;

```

<!-- path: hooks/useBulkSelection.ts -->
```typescript
import { useState, useCallback } from 'react';

interface UseSelectionReturn<T> {
  selectedItems: Set<T>;
  selectedCount: number;
  toggleSelection: (id: T) => void;
  toggleAllSelection: (allIds: T[]) => void;
  setSelectedItems: (ids: T[]) => void;
  clearSelection: () => void;
  isSelected: (id: T) => boolean;
  isAllSelected: (allIds: T[]) => boolean;
  isIndeterminate: (allIds: T[]) => boolean;
}

export function useSelection<T = string>(): UseSelectionReturn<T> {
  const [selectedItems, setSelectedItems] = useState<Set<T>>(new Set());

  // Clear selection
  const clearSelection = useCallback(() => {
    setSelectedItems(new Set());
  }, []);

  // Toggle single item selection
  const toggleSelection = useCallback((id: T) => {
    setSelectedItems(prev => {
      const newSet = new Set(prev);
      if (newSet.has(id)) {
        newSet.delete(id);
      } else {
        newSet.add(id);
      }
      return newSet;
    });
  }, []);

  // Set selected items
  const setSelected = useCallback((ids: T[]) => {
    setSelectedItems(new Set(ids));
  }, []);

  // Toggle all items selection
  const toggleAllSelection = useCallback((allIds: T[]) => {
    setSelectedItems(prev => {
      if (prev.size === allIds.length && allIds.length > 0) {
        return new Set(); // Clear all if all are selected
      } else {
        return new Set(allIds); // Select all
      }
    });
  }, []);

  // Check if item is selected
  const isSelected = useCallback((id: T) => {
    return selectedItems.has(id);
  }, [selectedItems]);

  // Check if all items are selected
  const isAllSelected = useCallback((allIds: T[]) => {
    return allIds.length > 0 && selectedItems.size === allIds.length;
  }, [selectedItems]);

  // Check if selection is indeterminate (some but not all selected)
  const isIndeterminate = useCallback((allIds: T[]) => {
    return selectedItems.size > 0 && selectedItems.size < allIds.length;
  }, [selectedItems]);

  return {
    selectedItems,
    selectedCount: selectedItems.size,
    toggleSelection,
    toggleAllSelection,
    setSelectedItems: setSelected,
    clearSelection,
    isSelected,
    isAllSelected,
    isIndeterminate,
  };
}
```

<!-- path: hooks/useCrudManager.ts -->
```typescript
"use client";

import { useState, useCallback, useEffect } from "react";
import { useDebounce } from "use-debounce";
import { createClient } from "@/utils/supabase/client";
import {
  useTableInsert,
  useTableUpdate,
  useToggleStatus,
  useTableBulkOperations,
  Filters,
  TableName,
  TableInsert,
  TableUpdate,
  TableInsertWithDates,
} from "@/hooks/database";
import { toast } from "sonner";
import { useDeleteManager } from "./useDeleteManager";

// --- TYPE DEFINITIONS for the Hook's Interface ---
export type RecordWithId = {
  id: string | number | null;
  system_id?: string | number | null;
  system_connection_id?: string | number | null;
  name?: string | null;
  first_name?: string | null;
  last_name?: string | null;
  [key: string]: unknown;
};

export interface DataQueryHookParams {
  currentPage: number;
  pageLimit: number;
  searchQuery: string;
  filters: Filters;
}

export interface DataQueryHookReturn<V> {
  data: V[];
  totalCount: number;
  activeCount: number;
  inactiveCount: number;
  isLoading: boolean;
  error: Error | null;
  refetch: () => void;
}

type DataQueryHook<V> = (params: DataQueryHookParams) => DataQueryHookReturn<V>;

type BaseRecord = { id: string | null; [key: string]: unknown };

export interface CrudManagerOptions<T extends TableName, V extends BaseRecord> {
  tableName: T;
  dataQueryHook: DataQueryHook<V>;
  searchColumn?: keyof V & string;
  processDataForSave?: (data: TableInsertWithDates<T>) => TableInsert<T>;
}

// --- THE HOOK ---
export function useCrudManager<T extends TableName, V extends BaseRecord>({
  tableName,
  dataQueryHook,
  processDataForSave,
}: CrudManagerOptions<T, V>) {
  const supabase = createClient();

  // --- STATE MANAGEMENT ---
  const [editingRecord, setEditingRecord] = useState<V | null>(null);
  const [viewingRecord, setViewingRecord] = useState<V | null>(null);
  const [currentPage, setCurrentPage] = useState(1);
  const [pageLimit, setPageLimit] = useState(10);
  const [searchQuery, setSearchQuery] = useState("");
  const [filters, setFilters] = useState<Filters>({});
  const [isEditModalOpen, setIsEditModalOpen] = useState(false);
  const [isViewModalOpen, setIsViewModalOpen] = useState(false);
  const [selectedRowIds, setSelectedRowIds] = useState<string[]>([]);
  const [debouncedSearch] = useDebounce(searchQuery, 400);

  // Reset pagination when filters change
  useEffect(() => {
    setCurrentPage(1);
  }, [debouncedSearch, filters]);

  // --- DATA FETCHING ---
  const { data, totalCount, activeCount, inactiveCount, isLoading, error, refetch } = dataQueryHook({
    currentPage,
    pageLimit,
    searchQuery: debouncedSearch,
    filters,
  });

  // --- MUTATIONS ---
  const { mutate: insertItem, isPending: isInserting } = useTableInsert(
    supabase,
    tableName,
    {
      onSuccess: () => {
        refetch();
        closeModal();
        toast.success("Record created successfully.");
      },
      onError: (error) => {
        toast.error(`Failed to create record: ${error.message}`);
      },
    }
  );

  const { mutate: updateItem, isPending: isUpdating } = useTableUpdate(
    supabase,
    tableName,
    {
      onSuccess: () => {
        refetch();
        closeModal();
        toast.success("Record updated successfully.");
      },
      onError: (error) => {
        toast.error(`Failed to update record: ${error.message}`);
      },
    }
  );

  const { mutate: toggleStatus } = useToggleStatus(supabase, tableName, {
    onSuccess: () => {
      refetch();
      toast.success("Status updated successfully.");
    },
    onError: (error) => {
      toast.error(`Failed to update status: ${error.message}`);
    },
  });

  // Initialize delete manager
  const deleteManager = useDeleteManager({ 
    tableName, 
    onSuccess: () => {
      refetch();
      handleClearSelection(); // Clear selection after successful delete
    }
  });

  const { bulkUpdate } = useTableBulkOperations(supabase, tableName);

  const isMutating =
    isInserting ||
    isUpdating ||
    deleteManager.isPending ||
    bulkUpdate.isPending;

  // --- MODAL HANDLERS ---
  const openAddModal = useCallback(() => {
    setEditingRecord(null);
    setIsEditModalOpen(true);
  }, []);

  const openEditModal = useCallback((record: V) => {
    setEditingRecord(record);
    setIsEditModalOpen(true);
  }, []);

  const openViewModal = useCallback((record: V) => {
    setViewingRecord(record);
    setIsViewModalOpen(true);
  }, []);

  const closeModal = useCallback(() => {
    setIsEditModalOpen(false);
    setEditingRecord(null);
    setIsViewModalOpen(false);
    setViewingRecord(null);
  }, []);

  // --- SAVE HANDLER ---
  const handleSave = useCallback(
    (formData: TableInsertWithDates<T>) => {
      // Convert ISO date strings back to Date objects for the database
      // const processedData = { ...formData };

      // Handle date fields - adjust these field names as needed
      // const dateFields = [
      //   "employee_dob",
      //   "employee_doj", 
      //   "created_at",
      //   "updated_at",
      // ] as const;

      // dateFields.forEach((field) => {
      //   const fieldKey = field as keyof typeof processedData;
      //   if (field in processedData && processedData[fieldKey]) {
      //     const dateValue = processedData[fieldKey] as string | Date;
      //     (processedData as TableInsertWithDates<T>)[fieldKey] = new Date(
      //       dateValue
      //     ) as unknown as TableInsertWithDates<T>[typeof fieldKey];
      //   }
      // });
      const processedData = processDataForSave 
        ? processDataForSave(formData) 
        : (formData as TableInsert<T>);

      if (editingRecord && "id" in editingRecord && editingRecord.id) {
        updateItem({
          id: String(editingRecord.id),
          data: processedData as TableUpdate<T>,
        });
      } else {
        insertItem(processedData as TableInsert<T>);
      }
    },
    [editingRecord, insertItem, updateItem]
  );

  // --- DELETE HANDLERS ---
  const handleDelete = useCallback(
    (record: RecordWithId) => {
      if (!record.id) {
        toast.error("Cannot delete record: Invalid ID");
        return;
      }

      const displayName = getDisplayName(record);
      deleteManager.deleteSingle({
        id: String(record.id),
        name: displayName,
      });
    },
    [deleteManager]
  );

  // --- UTILITY TO GET DISPLAY NAME ---
  const getDisplayName = useCallback((record: RecordWithId): string => {
    if (record.name) return String(record.name);
    if (record.first_name && record.last_name) {
      return `${record.first_name} ${record.last_name}`;
    }
    if (record.first_name) return String(record.first_name);
    return String(record.id) || 'Unknown';
  }, []);

  // --- STATUS TOGGLE HANDLER ---
  const handleToggleStatus = useCallback(
    (record: RecordWithId & { status?: boolean | null }) => {
      if (!record.id) {
        toast.error("Cannot update status: Invalid record ID");
        return;
      }

      toggleStatus({
        id: String(record.id),
        status: !(record.status ?? false),
      });
    },
    [toggleStatus]
  );

  // --- BULK SELECTION HANDLERS ---
  const handleRowSelect = useCallback(
    (rows: Array<V & { id?: string | number }>) => {
      const validIds = rows
        .map((r) => r.id)
        .filter((id): id is NonNullable<typeof id> => id != null)
        .map((id) => String(id));
      setSelectedRowIds(validIds);
    },
    []
  );

  const handleClearSelection = useCallback(() => {
    setSelectedRowIds([]);
  }, []);

  // --- BULK DELETE HANDLER ---
  const handleBulkDelete = useCallback(() => {
    if (selectedRowIds.length === 0) {
      toast.error("No records selected for deletion");
      return;
    }

    // Convert selected IDs back to records for display names
    const selectedRecords = data
      .filter((record) => selectedRowIds.includes(String(record.id)))
      .map((record) => ({
        id: String(record.id),
        name: getDisplayName(record as RecordWithId),
      }));

    deleteManager.deleteMultiple(selectedRecords);
  }, [selectedRowIds, data, deleteManager, getDisplayName]);

  // --- BULK STATUS UPDATE HANDLER ---
  const handleBulkUpdateStatus = useCallback(
    (status: "active" | "inactive") => {
      if (selectedRowIds.length === 0) return;
      const updates = selectedRowIds.map((id) => ({
        id,
        data: { status: status === "active" } as unknown as TableUpdate<T>,
      }));

      bulkUpdate.mutate(
        { updates },
        {
          onSuccess: () => {
            toast.success(
              `Successfully updated ${updates.length} records to ${status}`
            );
            setSelectedRowIds([]);
            refetch();
          },
          onError: (err) => {
            toast.error(`Failed to update status: ${err.message}`);
          },
        }
      );
    },
    [selectedRowIds, bulkUpdate, refetch]
  );

  // --- BULK DELETE BY FILTER ---
  const handleBulkDeleteByFilter = useCallback(
    (column: string, value: unknown, displayName: string) => {
      deleteManager.deleteBulk({
        column,
        value,
        displayName,
      });
    },
    [deleteManager]
  );

  // --- RETURN VALUE ---
  return {
    // Data
    data: data || [],
    totalCount,
    activeCount,
    inactiveCount,
    isLoading,
    error,
    isMutating,
    refetch,

    // Pagination
    pagination: { 
      currentPage, 
      pageLimit, 
      setCurrentPage, 
      setPageLimit 
    },

    // Search & Filters  
    search: { 
      searchQuery, 
      setSearchQuery 
    },
    filters: { 
      filters, 
      setFilters 
    },

    // Modals
    editModal: { 
      isOpen: isEditModalOpen, 
      record: editingRecord, 
      openAdd: openAddModal, 
      openEdit: openEditModal, 
      close: closeModal 
    },
    viewModal: { 
      isOpen: isViewModalOpen, 
      record: viewingRecord, 
      open: openViewModal, 
      close: closeModal 
    },

    // Actions
    actions: { 
      handleSave, 
      handleDelete, 
      handleToggleStatus 
    },

    // Bulk Actions
    bulkActions: { 
      selectedRowIds, 
      selectedCount: selectedRowIds.length, 
      handleBulkDelete, 
      handleBulkDeleteByFilter,
      handleBulkUpdateStatus, 
      handleClearSelection, 
      handleRowSelect 
    },

    // Delete Modal (for ConfirmModal component)
    deleteModal: { 
      isOpen: deleteManager.isConfirmModalOpen, 
      message: deleteManager.confirmationMessage, 
      onConfirm: deleteManager.handleConfirm, 
      onCancel: deleteManager.handleCancel, 
      loading: deleteManager.isPending 
    },

    // Utility functions
    utils: {
      getDisplayName,
    },
  };
}
```

<!-- path: hooks/useOrderedColumns.ts -->
```typescript
import { useMemo } from 'react';

const useOrderedColumns = <T extends { key: string }>(
  columns: T[],
  desiredOrder: string[]
): T[] => {
  return useMemo(() => {
    const ordered = desiredOrder
      .map(key => columns.find(col => col.key === key))
      .filter((col): col is T => col !== undefined);
    
    const remaining = columns.filter(col => !desiredOrder.includes(col.key));
    
    return [...ordered, ...remaining];
  }, [columns, desiredOrder]);
};

export default useOrderedColumns;
```

<!-- path: hooks/useSorting.ts -->
```typescript
import { useMemo, useState, useCallback } from 'react';

// Types
export type SortDirection = 'asc' | 'desc' | null;

export interface SortConfig<T> {
  key: keyof T | string;
  direction: SortDirection;
}

export interface SortOptions {
  caseSensitive?: boolean;
  numericSort?: boolean;
  locale?: string;
}

export interface UseSortingProps<T> {
  data: T[];
  defaultSortKey?: keyof T | string;
  defaultDirection?: SortDirection;
  options?: SortOptions;
}

export interface UseSortingReturn<T> {
  sortedData: T[];
  sortConfig: SortConfig<T>;
  setSortConfig: (config: SortConfig<T>) => void;
  handleSort: (key: keyof T | string) => void;
  resetSort: () => void;
  isSorted: boolean;
  getSortDirection: (key: keyof T | string) => SortDirection;
}

// Union type for supported sortable values
type SortableValue = string | number | Date | boolean | null | undefined;

// Helper function to get nested property value
function getNestedValue(obj: Record<string, unknown>, path: string): SortableValue {
  const keys = path.split('.');
  let current: unknown = obj;
  
  for (const key of keys) {
    if (current === null || current === undefined) {
      return undefined;
    }
    if (typeof current === 'object' && current !== null && key in current) {
      current = (current as Record<string, unknown>)[key];
    } else {
      return undefined;
    }
  }
  
  // Type guard to ensure we return only sortable values
  if (
    typeof current === 'string' ||
    typeof current === 'number' ||
    typeof current === 'boolean' ||
    current instanceof Date ||
    current === null ||
    current === undefined
  ) {
    return current as SortableValue;
  }
  
  // Convert other types to string for comparison
  return String(current);
}

// Helper function to compare values
function compareValues(
  a: SortableValue, 
  b: SortableValue, 
  direction: SortDirection, 
  options: SortOptions = {}
): number {
  const { caseSensitive = false, numericSort = true, locale = 'en' } = options;
  
  // Handle null/undefined values
  if (a == null && b == null) return 0;
  if (a == null) return direction === 'asc' ? -1 : 1;
  if (b == null) return direction === 'asc' ? 1 : -1;

  // Handle different data types
  if (typeof a === 'string' && typeof b === 'string') {
    const valueA = caseSensitive ? a : a.toLowerCase();
    const valueB = caseSensitive ? b : b.toLowerCase();
    
    // Use localeCompare for proper string sorting
    const result = valueA.localeCompare(valueB, locale, {
      numeric: numericSort,
      sensitivity: caseSensitive ? 'case' : 'base'
    });
    
    return direction === 'asc' ? result : -result;
  }

  // Handle numbers
  if (typeof a === 'number' && typeof b === 'number') {
    const result = a - b;
    return direction === 'asc' ? result : -result;
  }

  // Handle dates
  if (a instanceof Date && b instanceof Date) {
    const result = a.getTime() - b.getTime();
    return direction === 'asc' ? result : -result;
  }

  // Handle boolean values
  if (typeof a === 'boolean' && typeof b === 'boolean') {
    const result = Number(a) - Number(b);
    return direction === 'asc' ? result : -result;
  }

  // Fallback to string comparison for mixed types
  const stringA = String(a);
  const stringB = String(b);
  const result = stringA.localeCompare(stringB, locale, {
    numeric: numericSort,
    sensitivity: caseSensitive ? 'case' : 'base'
  });
  
  return direction === 'asc' ? result : -result;
}

// Main sorting hook
export function useSorting<T extends Record<string, unknown>>({
  data,
  defaultSortKey,
  defaultDirection = 'asc',
  options = {}
}: UseSortingProps<T>): UseSortingReturn<T> {
  
  const [sortConfig, setSortConfig] = useState<SortConfig<T>>({
    key: defaultSortKey || '',
    direction: defaultSortKey ? defaultDirection : null
  });

  // Memoized sorted data
  const sortedData = useMemo(() => {
    if (!sortConfig.key || !sortConfig.direction || !data.length) {
      return data;
    }

    return [...data].sort((a, b) => {
      const valueA = getNestedValue(a, String(sortConfig.key));
      const valueB = getNestedValue(b, String(sortConfig.key));
      
      return compareValues(valueA, valueB, sortConfig.direction, options);
    });
  }, [data, sortConfig, options]);

  // Handle sort column click
  const handleSort = useCallback((key: keyof T | string) => {
    setSortConfig(prevConfig => {
      if (prevConfig.key === key) {
        // Cycle through: asc -> desc -> null -> asc
        switch (prevConfig.direction) {
          case 'asc':
            return { key, direction: 'desc' };
          case 'desc':
            return { key: '', direction: null };
          default:
            return { key, direction: 'asc' };
        }
      } else {
        // New column, start with ascending
        return { key, direction: 'asc' };
      }
    });
  }, []);

  // Reset sorting
  const resetSort = useCallback(() => {
    setSortConfig({ key: '', direction: null });
  }, []);

  // Check if currently sorted
  const isSorted = Boolean(sortConfig.key && sortConfig.direction);

  // Get sort direction for a specific key
  const getSortDirection = useCallback((key: keyof T | string): SortDirection => {
    return sortConfig.key === key ? sortConfig.direction : null;
  }, [sortConfig]);

  return {
    sortedData,
    sortConfig,
    setSortConfig,
    handleSort,
    resetSort,
    isSorted,
    getSortDirection
  };
}

// Additional utility hooks for specific use cases

// Hook for multi-column sorting
export interface MultiSortConfig<T> {
  key: keyof T | string;
  direction: SortDirection;
  priority: number;
}

export function useMultiSorting<T extends Record<string, unknown>>(
  data: T[], 
  options: SortOptions = {}
) {
  const [sortConfigs, setSortConfigs] = useState<MultiSortConfig<T>[]>([]);

  const sortedData = useMemo(() => {
    if (!sortConfigs.length || !data.length) return data;

    return [...data].sort((a, b) => {
      for (const config of sortConfigs.sort((x, y) => x.priority - y.priority)) {
        if (!config.direction) continue;
        
        const valueA = getNestedValue(a, String(config.key));
        const valueB = getNestedValue(b, String(config.key));
        
        const result = compareValues(valueA, valueB, config.direction, options);
        if (result !== 0) return result;
      }
      return 0;
    });
  }, [data, sortConfigs, options]);

  const addSort = useCallback((key: keyof T | string, direction: SortDirection) => {
    if (!direction) return;
    
    setSortConfigs(prev => {
      const existing = prev.find(config => config.key === key);
      if (existing) {
        return prev.map(config => 
          config.key === key 
            ? { ...config, direction }
            : config
        );
      }
      return [...prev, { key, direction, priority: prev.length }];
    });
  }, []);

  const removeSort = useCallback((key: keyof T | string) => {
    setSortConfigs(prev => prev.filter(config => config.key !== key));
  }, []);

  const clearSort = useCallback(() => {
    setSortConfigs([]);
  }, []);

  return {
    sortedData,
    sortConfigs,
    addSort,
    removeSort,
    clearSort
  };
}

// Hook for search + sort combination
export function useSearchAndSort<T extends Record<string, unknown>>(
  data: T[],
  searchKeys: (keyof T | string)[],
  sortOptions: SortOptions = {}
) {
  const [searchTerm, setSearchTerm] = useState('');
  
  // Filter data based on search term
  const filteredData = useMemo(() => {
    if (!searchTerm.trim()) return data;
    
    return data.filter(item => 
      searchKeys.some(key => {
        const value = getNestedValue(item, String(key));
        return String(value || '').toLowerCase().includes(searchTerm.toLowerCase());
      })
    );
  }, [data, searchTerm, searchKeys]);

  // Apply sorting to filtered data
  const sortingResult = useSorting({
    data: filteredData,
    options: sortOptions
  });

  return {
    ...sortingResult,
    searchTerm,
    setSearchTerm,
    filteredCount: filteredData.length,
    totalCount: data.length
  };
}

// Utility type for extracting sortable keys from an object type
export type SortableKeys<T> = {
  [K in keyof T]: T[K] extends SortableValue ? K : never;
}[keyof T];

// Hook with strongly typed keys (optional, for better type safety)
export function useTypedSorting<T extends Record<string, unknown>>(
  data: T[],
  defaultSortKey?: SortableKeys<T>,
  defaultDirection: SortDirection = 'asc',
  options: SortOptions = {}
) {
  return useSorting({
    data,
    defaultSortKey,
    defaultDirection,
    options
  });
}
```

<!-- path: hooks/useColumnConfig.tsx -->
```typescript
import { useMemo, ReactNode, useEffect } from 'react';
import { TABLE_COLUMN_KEYS } from '@/config/table-column-keys';
import { Column } from '@/hooks/database/excel-queries/excel-helpers';
import { GenericRow, TableOrViewName } from '@/config/helper-types';
// import { inferColumnWidth } from "@/config/column-width";
import {
  inferDynamicColumnWidth,
  inferExcelFormat,
  toTitleCase,
} from '@/config/helper-functions';

/**
 * This is the final, compatible Column Configuration type.
 * It is generic and includes all properties from your `Column<T>` interface.
 */
export interface ColumnConfig<T extends TableOrViewName> {
  /** The unique, type-safe column name. Used as the React key. */
  key: keyof GenericRow<T> & string;
  /** The human-readable title for the column header. */
  title: string;
  /** The key for accessing data from a row object. We set it to be the same as `key`. */
  dataIndex: keyof GenericRow<T> & string;
  /** Optional: The data format for Excel exports. */
  excelFormat?: 'text' | 'number' | 'date' | 'currency' | 'percentage' | 'json';
  /** Optional: Flag to hide the column in the UI. */
  hidden?: boolean;
  /** Optional: Column width for UI tables. Use "auto" to fit content width. */
  width?: number | string;
  /** Optional: Allow sorting on this column. */
  sortable?: boolean;
  /** Optional: Allow searching on this column. */
  searchable?: boolean;
  /** Optional: Allow filtering on this column. */
  filterable?: boolean;
  /** Optional: A custom render function for the cell. */
  render?: (value: unknown, record: GenericRow<T>, index: number) => ReactNode;
  // ... and any other properties from your master Column<T> type.
  resizable?: boolean;
}

type ColumnOverrides<T extends TableOrViewName> = {
  // [K in keyof GenericRow<T>]?: Partial<
  //   Omit<Column<GenericRow<T>>, 'key' | 'dataIndex'>
  // >;
  [K in keyof GenericRow<T>]?: Partial<ColumnConfig<T>>;
};

interface UseDynamicColumnConfigOptions<T extends TableOrViewName> {
  overrides?: ColumnOverrides<T>;
  omit?: (keyof GenericRow<T> & string)[];
  data?: GenericRow<T>[];
}

/**
 * A hook that dynamically generates a detailed and type-safe column configuration array
 * that is fully compatible with the application's standard `Column<T>` interface.
 */
// FIX: The hook is now fully generic for tables and views.
export function useDynamicColumnConfig<T extends TableOrViewName>(
  tableName: T,
  options: UseDynamicColumnConfigOptions<T> = {}
): Column<GenericRow<T>>[] {
  const { overrides = {}, omit = [], data = [] } = options;

  const dateColumns = useMemo(
    () =>
      new Set([
        'date_of_birth',
        'last_sign_in_at',
        'created_at',
        'updated_at',
        'auth_updated_at',
        'email_confirmed_at',
        'phone_confirmed_at',
      ]),
    []
  ); // Memoize once

  // generate column widths dynamically
  const columnWidths = useMemo(() => {
    const widths: Record<string, number> = {};
    if (data.length > 0) {
      for (const colName of Object.keys(data[0] || {})) {
        widths[colName] = dateColumns.has(colName)
          ? 120
          : inferDynamicColumnWidth(colName, data);
      }
    }
    return widths;
  }, [data, dateColumns]);

  const columns = useMemo(() => {
    const keysToUse = TABLE_COLUMN_KEYS[tableName] as
      | (keyof GenericRow<T> & string)[]
      | undefined;

    if (!keysToUse) {
      console.warn(`No column keys found for table/view: ${tableName}`);
      return [];
    }

    const omitSet = new Set(omit);

    return (keysToUse as (keyof GenericRow<T> & string)[])
      .filter((key) => !omitSet.has(key))
      .map((key) => {
        const columnOverride =
          (key in overrides ? overrides[key as keyof typeof overrides] : {}) ||
          {};
        // console.log(key + ":" + columnWidths?.[key]);
        const defaultConfig: Column<GenericRow<T>> = {
          title: toTitleCase(key),
          dataIndex: key,
          key: key,
          excelFormat: inferExcelFormat(key),
          width: columnWidths?.[key],
        };

        return { ...defaultConfig, ...columnOverride };
      });
  }, [tableName, overrides, omit, columnWidths]);

  const columnsKeys = columns.map((col) => col.key);

  // useEffect(() => {
  //   console.log(`columns for ${tableName}`, columnsKeys);
  // // eslint-disable-next-line react-hooks/exhaustive-deps
  // }, []);

  return columns;
}

```

<!-- path: hooks/ofc/useCableSegmentation.ts -->
```typescript
// hooks/ofc/useCableSegmentation.ts
import { useState, useCallback } from 'react';
import { createClient } from '@/utils/supabase/client';
import { toast } from 'sonner';

export interface JunctionClosure {
  id: string;
  node_id: string;
  name: string;
  ofc_cable_id: string;
  position_km: number;
  created_at: string;
  updated_at: string;
}

export interface CableSegment {
  id: string;
  original_cable_id: string;
  segment_order: number;
  start_node_id: string;
  end_node_id: string;
  start_node_type: 'node' | 'jc';
  end_node_type: 'node' | 'jc';
  distance_km: number;
  fiber_count: number;
  created_at: string;
  updated_at: string;
}

export interface SpliceConfiguration {
  incoming_fiber_no: number;
  outgoing_fiber_no: number;
  splice_type: 'straight' | 'cross';
}

export const useCableSegmentation = () => {
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const supabase = createClient();

  const addJunctionClosure = useCallback(async (
    cableId: string,
    positionKm: number,
    name: string
  ): Promise<JunctionClosure | null> => {
    setIsLoading(true);
    setError(null);

    try {
      const { data, error: insertError } = await supabase
        .rpc('add_junction_closure', {
          p_ofc_cable_id: cableId,
          p_position_km: positionKm,
          p_name: name
        });

      if (insertError) {
        throw insertError;
      }

      toast.success('Junction Closure added successfully');
      return data as JunctionClosure;
    } catch (err: any) {
      setError(err.message);
      toast.error(`Failed to add Junction Closure: ${err.message}`);
      return null;
    } finally {
      setIsLoading(false);
    }
  }, [supabase]);

  const createCableSegments = useCallback(async (
    jcId: string,
    cableId: string
  ): Promise<CableSegment[]> => {
    console.log('=== CREATE CABLE SEGMENTS FUNCTION CALLED ===');
    console.log('Input parameters:', { jcId, cableId });
    setIsLoading(true);
    setError(null);

    console.log('=== CREATE CABLE SEGMENTS DEBUG ===');
    console.log('Calling create_cable_segments_on_jc_add with:', { p_jc_id: jcId, p_ofc_cable_id: cableId });

    try {
      const { data, error: segmentError } = await supabase
        .rpc('create_cable_segments_on_jc_add', {
          p_jc_id: jcId,
          p_ofc_cable_id: cableId
        });

      console.log('Function result:', { data, segmentError });

      if (segmentError) {
        console.error('Database function error:', segmentError);
        throw segmentError;
      }

      toast.success('Cable segments created successfully');
      return data as CableSegment[];
    } catch (err: any) {
      console.error('Error in createCableSegments:', err);
      console.error('Error details:', err.message, err.details, err.hint, err.code);
      setError(err.message);
      toast.error(`Failed to create cable segments: ${err.message}`);
      return [];
    } finally {
      setIsLoading(false);
    }
  }, [supabase]);

  const createInitialFiberConnections = useCallback(async (
    segmentId: string
  ): Promise<number> => {
    setIsLoading(true);
    setError(null);

    try {
      const { data, error: connectionError } = await supabase
        .rpc('create_initial_fiber_connections', {
          p_segment_id: segmentId
        });

      if (connectionError) {
        throw connectionError;
      }

      toast.success('Fiber connections created successfully');
      return data as number;
    } catch (err: any) {
      setError(err.message);
      toast.error(`Failed to create fiber connections: ${err.message}`);
      return 0;
    } finally {
      setIsLoading(false);
    }
  }, [supabase]);

  const updateFiberConnections = useCallback(async (
    jcId: string,
    incomingSegmentId: string,
    outgoingSegmentId: string,
    spliceConfig: SpliceConfiguration[]
  ): Promise<number> => {
    setIsLoading(true);
    setError(null);

    try {
      const { data, error: updateError } = await supabase
        .rpc('update_fiber_connections_on_splice', {
          p_jc_id: jcId,
          p_incoming_segment_id: incomingSegmentId,
          p_outgoing_segment_id: outgoingSegmentId,
          p_splice_config: spliceConfig
        });

      if (updateError) {
        throw updateError;
      }

      toast.success('Fiber connections updated successfully');
      return data as number;
    } catch (err: any) {
      setError(err.message);
      toast.error(`Failed to update fiber connections: ${err.message}`);
      return 0;
    } finally {
      setIsLoading(false);
    }
  }, [supabase]);

  const getFiberPath = useCallback(async (
    startNodeId: string,
    endNodeId: string,
    fiberNumber: number
  ) => {
    setIsLoading(true);
    setError(null);

    try {
      const { data, error: pathError } = await supabase
        .rpc('get_fiber_path', {
          p_start_node_id: startNodeId,
          p_end_node_id: endNodeId,
          p_fiber_number: fiberNumber
        });

      if (pathError) {
        throw pathError;
      }

      return data;
    } catch (err: any) {
      setError(err.message);
      toast.error(`Failed to get fiber path: ${err.message}`);
      return [];
    } finally {
      setIsLoading(false);
    }
  }, [supabase]);

  return {
    isLoading,
    error,
    addJunctionClosure,
    createCableSegments,
    createInitialFiberConnections,
    updateFiberConnections,
    getFiberPath,
  };
};

```

<!-- path: hooks/useDebounce.ts -->
```typescript
// @/hooks/useDebounce.ts
import { useState, useEffect } from 'react';

export function useDebounce<T>(value: T, delay: number): T {
  const [debouncedValue, setDebouncedValue] = useState<T>(value);

  useEffect(() => {
    const handler = setTimeout(() => {
      setDebouncedValue(value);
    }, delay);

    // Cleanup function to cancel the timeout if value changes before delay has passed
    return () => {
      clearTimeout(handler);
    };
  }, [value, delay]);

  return debouncedValue;
}
```

<!-- path: hooks/useCurrentTableName.ts -->
```typescript
// hooks/useCurrentTableName.ts
import { usePathname } from "next/navigation";
import { useMemo } from "react";
import { TableNames } from "@/config/helper-types";

export const useCurrentTableName = (tableName?: TableNames): TableNames | null => {
  const pathname = usePathname();

  return useMemo(() => {
    if (tableName) return tableName;

    const path = pathname || "";
    const segments = path.split("/").filter(Boolean); // Remove empty segments

    // Look for the dashboard segment and get the next segment as the route
    const dashboardIndex = segments.findIndex((segment) => segment === "dashboard");
    if (dashboardIndex === -1 || dashboardIndex >= segments.length - 1) {
      return null;
    }

    const routeSegment = segments[dashboardIndex + 1];

    // Map route segments to table names
    switch (routeSegment) {
      case "users":
        return "user_profiles";
      case "employees":
        return "employees";
      case "categories":
        return "lookup_types";
      case "designations":
        return "employee_designations";
      case "rings":
        return "rings";
      case "maintenance-areas":
        return "maintenance_areas";
      case "lookup":
        return "lookup_types";
      case "ofc":
        // Check if there's a third segment (ID) after ofc
        const hasId = segments.length > dashboardIndex + 2 && segments[dashboardIndex + 2];
        return hasId ? "ofc_connections" : "ofc_cables";
      case "ofc_connections":
        return "ofc_connections";
      case "nodes":
        return "nodes";
      case "systems":
        return "systems";
      case "cpan":
        return "cpan_systems";
      case "cpan_connections":
        return "cpan_connections";
      case "fiber-joints":
        return "fiber_joints";
      case "fiber-joint-connections":
        return "fiber_joint_connections";
      case "logical-fiber-paths":
        return "logical_fiber_paths";
      case "maan":
        return "maan_systems";
      case "maan_connections":
        return "maan_connections";
      case "management-ports":
        return "management_ports";
      case "sdh":
        return "sdh_systems";
      case "sdh_connections":
        return "sdh_connections";
      case "sdh_node_associations":
        return "sdh_node_associations";
      case "system-connections":
        return "system_connections";
      case "user-activity-logs":
        return "user_activity_logs";
      case "vmux":
        return "vmux_systems";
      case "vmux_connections":
        return "vmux_connections";
      default:
        return null;
    }
  }, [tableName, pathname]);
};

```

<!-- path: hooks/UseRouteBasedUploadConfigOptions.tsx -->
```typescript
// src/hooks/useRouteBasedUploadConfig.ts

import { useEffect, FC, ReactNode, useRef } from "react";
// Import the simplified store and its types
import {
  useUploadConfigStore,
  UploadConfig,
} from "@/stores/useUploadConfigStore";
import { useCurrentTableName } from "./useCurrentTableName";
import { TableNames } from "@/config/helper-types";
import { buildUploadConfig } from "@/config/table-column-keys";

export interface UseRouteBasedUploadConfigOptions {
  tableName?: TableNames;
  autoSetConfig?: boolean;
  customConfig?: Partial<UploadConfig<TableNames>>;
}

export const useRouteBasedUploadConfig = (
  options: UseRouteBasedUploadConfigOptions = {}
) => {
  const { tableName, autoSetConfig = true, customConfig } = options;
  const previousTableNameRef = useRef<TableNames | null>(null);

  // Get current table name from the new hook
  const currentTableName = useCurrentTableName(tableName);

  // Get the actions from the store
  const { setUploadConfig, getUploadConfig, clearUploadConfig } =
    useUploadConfigStore();

  // Proper cleanup and config management
  useEffect(() => {
    // Clear previous config when route changes
    if (
      previousTableNameRef.current &&
      previousTableNameRef.current !== currentTableName
    ) {
      clearUploadConfig(previousTableNameRef.current);
    }

    // Set new config if applicable
    if (autoSetConfig && currentTableName) {
      const generated = buildUploadConfig(currentTableName);
      const finalConfig = {
        ...generated,
        ...customConfig,
      } as UploadConfig<TableNames>;
      setUploadConfig(currentTableName, finalConfig);
    }

    // Update the ref with current table name
    previousTableNameRef.current = currentTableName;

    // Cleanup function - runs when component unmounts
    return () => {
      if (currentTableName) {
        clearUploadConfig(currentTableName);
      }
    };
  }, [
    currentTableName,
    autoSetConfig,
    customConfig,
    setUploadConfig,
    clearUploadConfig,
  ]);

  return {
    currentTableName,
    config: currentTableName ? getUploadConfig(currentTableName) : undefined,
  };
};

/**
 * A simple Provider component to easily wrap layouts or pages,
 * activating the route-based configuration logic.
 */
export const RouteBasedUploadConfigProvider: FC<{
  children: ReactNode;
  options?: UseRouteBasedUploadConfigOptions;
}> = ({ children, options = {} }) => {
  useRouteBasedUploadConfig(options);
  return <>{children}</>;
};

```

<!-- path: hooks/useAdminUsers.ts -->
```typescript
import { useQuery, useMutation, useQueryClient } from "@tanstack/react-query";
import { toast } from "sonner";
import { Database } from "@/types/supabase-types";
import { UserProfileData } from "@/components/users/user-types";
import { createClient } from "@/utils/supabase/client";

type ErrorType = {
  error: string;
  message: string;
  status?: number;
};

type Json = Record<string, any>;

type UserCreateInput = {
  id: string;  // This will be your custom UUID
  email: string;
  password: string;
  email_confirm?: boolean;
  first_name: string;
  last_name: string;
  role: string;
};

// Types
type AdminGetAllUsers =
  Database["public"]["Functions"]["admin_get_all_users"]["Args"];

type AdminGetAllUsersExtended =
  Database["public"]["Functions"]["admin_get_all_users_extended"]["Args"];

type AdminGetUserByID = Database['public']['Functions']['admin_get_user_by_id']['Args']

type AdminBulkDeleteUsersFunction =
  Database["public"]["Functions"]["admin_bulk_delete_users"]["Args"];

type AdminBulkUpdateUserRole =
  Database["public"]["Functions"]["admin_bulk_update_role"]["Args"];

type AdminBulkUpdateUserStatus =
  Database["public"]["Functions"]["admin_bulk_update_status"]["Args"];

type AdminUpdateUserProfile =
  Database["public"]["Functions"]["admin_update_user_profile"]["Args"];

export interface UserData {
  id: string;
  email: string;
  first_name: string;
  last_name: string;
  avatar_url: string;
  phone_number: string;
  date_of_birth: string;
  address: Json;
  preferences: Json;
  role: string;
  designation: string;
  status: string;
  is_email_verified: boolean;
  last_sign_in_at: string;
  created_at: string;
  updated_at: string;
  total_count: number;
}



// Query Keys
export const adminUserKeys = {
  all: ["admin-users"] as const,
  lists: () => [...adminUserKeys.all, "list"] as const,
  list: (filters: AdminGetAllUsers) =>
    [...adminUserKeys.lists(), filters] as const,
  details: () => [...adminUserKeys.all, "detail"] as const,
  detail: (id: string) => [...adminUserKeys.details(), id] as const,
  role: () => [...adminUserKeys.all, "my-role"] as const,
  userDetails: () => [...adminUserKeys.all, "my-details"] as const,
  superAdmin: () => [...adminUserKeys.all, "super-admin"] as const,
};

// Hook to get all users with filtering and pagination
export const useAdminGetAllUsers = (params: AdminGetAllUsers = {}) => {
  const supabase = createClient();
  return useQuery({
    queryKey: adminUserKeys.list(params),
    queryFn: async (): Promise<UserData[]> => {
      const { data, error } = await supabase.rpc("admin_get_all_users", params);

      if (error) {
        throw new Error(error.message);
      }

      return data || [];
    },
    staleTime: 5 * 60 * 1000, // 5 minutes
    gcTime: 10 * 60 * 1000, // 10 minutes
  });
};

export const useAdminGetAllUsersExtended = (params: AdminGetAllUsersExtended = {}) => {
  const supabase = createClient();
  return useQuery({
    queryKey: adminUserKeys.list(params),
    queryFn: async (): Promise<UserProfileData[]> => {
      const { data, error } = await supabase.rpc("admin_get_all_users_extended", params);

      if (error) {
        throw new Error(error.message);
      }

      return data as UserProfileData[] || [];
    },
    staleTime: 5 * 60 * 1000, // 5 minutes
    gcTime: 10 * 60 * 1000, // 10 minutes
  });
};

// Hook to get user by ID
export const useAdminGetUserById = (userId: string, enabled = true) => {
  const supabase = createClient();
  return useQuery({
    queryKey: adminUserKeys.detail(userId),
    queryFn: async (): Promise<UserProfileData | null> => {
      const { data, error } = await supabase.rpc("admin_get_user_by_id", {
        user_id: userId,
      });

      if (error) {
        throw new Error(error.message);
      }

      return data?.[0] as UserProfileData || null;
    },
    enabled: enabled && !!userId,
    staleTime: 5 * 60 * 1000,
  });
};

// Hook to get current user's role
export const useGetMyRole = () => {
  const supabase = createClient();
  return useQuery({
    queryKey: adminUserKeys.role(),
    queryFn: async (): Promise<string> => {
      const { data, error } = await supabase.rpc("get_my_role");

      if (error) {
        throw new Error(error.message);
      }

      return data || "";
    },
    staleTime: 15 * 60 * 1000, // 15 minutes (roles don't change often)
  });
};

// Hook to get current user's details
export const useGetMyUserDetails = () => {
  const supabase = createClient();
  return useQuery({
    queryKey: adminUserKeys.userDetails(),
    queryFn: async () => {
      const { data, error } = await supabase.rpc("get_my_user_details");

      if (error) {
        throw new Error(error.message);
      }

      return data?.[0] || null;
    },
    staleTime: 10 * 60 * 1000,
  });
};

// Hook to check if current user is super admin
export const useIsSuperAdmin = () => {
  const supabase = createClient();
  return useQuery({
    queryKey: adminUserKeys.superAdmin(),
    queryFn: async (): Promise<boolean> => {
      const { data, error } = await supabase.rpc("is_super_admin");

      if (error) {
        throw new Error(error.message);
      }

      return data || false;
    },
    staleTime: 15 * 60 * 1000,
  });
};

// Hook to update user profile
export const useAdminUpdateUserProfile = () => {
  const supabase = createClient();
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: async (params: AdminUpdateUserProfile): Promise<boolean> => {
      const { data, error } = await supabase.rpc(
        "admin_update_user_profile",
        params
      );

      if (error) {
        throw new Error(error.message);
      }

      return data || false;
    },
    onSuccess: (_, variables) => {
      toast.success("User profile updated successfully");

      // Invalidate and refetch relevant queries
      queryClient.invalidateQueries({ queryKey: adminUserKeys.lists() });
      queryClient.invalidateQueries({
        queryKey: adminUserKeys.detail(variables.user_id),
      });
    },
    onError: (error) => {
      toast.error(`Failed to update user profile: ${error.message}`);
    },
  });
};

// Hook to bulk delete users
export const useAdminBulkDeleteUsers = () => {
  const supabase = createClient();
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: async (
      params: AdminBulkDeleteUsersFunction
    ): Promise<boolean> => {
      const { data, error } = await supabase.rpc(
        "admin_bulk_delete_users",
        params
      );

      if (error) {
        throw new Error(error.message);
      }

      return data || false;
    },
    onSuccess: (_, variables) => {
      toast.success(
        `Successfully deleted ${variables.user_ids.length} user(s)`
      );

      // Invalidate all user lists
      queryClient.invalidateQueries({ queryKey: adminUserKeys.lists() });

      // Remove individual user queries from cache
      variables.user_ids.forEach((userId) => {
        queryClient.removeQueries({ queryKey: adminUserKeys.detail(userId) });
      });
    },
    onError: (error) => {
      toast.error(`Failed to delete users: ${error.message}`);
    },
  });
};

// Hook to bulk update user roles
export const useAdminBulkUpdateUserRole = () => {
  const supabase = createClient();
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: async (params: AdminBulkUpdateUserRole): Promise<boolean> => {
      const { data, error } = await supabase.rpc(
        "admin_bulk_update_role",
        params
      );

      if (error) {
        throw new Error(error.message);
      }

      return data || false;
    },
    onSuccess: (_, variables) => {
      toast.success(
        `Successfully updated role for ${variables.user_ids.length} user(s)`
      );

      // Invalidate relevant queries
      queryClient.invalidateQueries({ queryKey: adminUserKeys.lists() });

      // Invalidate individual user details
      variables.user_ids.forEach((userId) => {
        queryClient.invalidateQueries({
          queryKey: adminUserKeys.detail(userId),
        });
      });
    },
    onError: (error) => {
      toast.error(`Failed to update user roles: ${error.message}`);
    },
  });
};

// Hook to bulk update user status
export const useAdminBulkUpdateUserStatus = () => {
  const supabase = createClient();
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: async (params: AdminBulkUpdateUserStatus): Promise<boolean> => {
      const { data, error } = await supabase.rpc(
        "admin_bulk_update_status",
        params
      );

      if (error) {
        throw new Error(error.message);
      }

      return data || false;
    },
    onSuccess: (_, variables) => {
      toast.success(
        `Successfully updated status for ${variables.user_ids.length} user(s)`
      );

      // Invalidate relevant queries
      queryClient.invalidateQueries({ queryKey: adminUserKeys.lists() });

      // Invalidate individual user details
      variables.user_ids.forEach((userId) => {
        queryClient.invalidateQueries({
          queryKey: adminUserKeys.detail(userId),
        });
      });
    },
    onError: (error) => {
      toast.error(`Failed to update user status: ${error.message}`);
    },
  });
};

// Hook to create a new user
export const useAdminCreateUser = () => {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: async (userData: UserCreateInput) => {
      const res = await fetch("/api/admin/users", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify(userData),
      });

      const data = await res.json();

      if (!res.ok) {
        throw new Error(data.error || "Failed to create user");
      }

      return data;
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: adminUserKeys.lists() });
      toast.success("User created successfully");
    },
    onError: (error: Error) => {
      console.error("User creation error:", error);
      toast.error(error.message || "Failed to create user");
    },
  });
};


// Combined hook for multiple operations
interface UserOperations {
  createUser: ReturnType<typeof useAdminCreateUser>;
  updateUser: ReturnType<typeof useAdminUpdateUserProfile>;
  deleteUsers: ReturnType<typeof useAdminBulkDeleteUsers>;
  updateUserRoles: ReturnType<typeof useAdminBulkUpdateUserRole>;
  updateUserStatus: ReturnType<typeof useAdminBulkUpdateUserStatus>;
  isLoading: boolean;
}

export const useAdminUserOperations = (): UserOperations => {
  const createUser = useAdminCreateUser();
  const updateUser = useAdminUpdateUserProfile();
  const deleteUsers = useAdminBulkDeleteUsers();
  const updateUserRoles = useAdminBulkUpdateUserRole();
  const updateUserStatus = useAdminBulkUpdateUserStatus();

  return {
    createUser,
    updateUser,
    deleteUsers,
    updateUserRoles,
    updateUserStatus,
    isLoading: createUser.isPending || 
               updateUser.isPending || 
               deleteUsers.isPending || 
               updateUserRoles.isPending || 
               updateUserStatus.isPending
  };
};
```

<!-- path: hooks/useDebugSession.ts -->
```typescript
// hooks/useDebugSession.ts
import { useEffect, useState } from 'react'
import { createClient } from '@/utils/supabase/client'

export const useDebugSession = () => {
  const [sessionInfo, setSessionInfo] = useState<any>(null)
  const supabase = createClient()

  useEffect(() => {
    const checkSession = async () => {
      // Check current session
      const { data: { session }, error } = await supabase.auth.getSession()
      
      // Check headers that would be sent with requests
      const headers = await supabase.auth.getSession().then(({ data: { session } }) => ({
        'apikey': 'present',
        'authorization': session ? `Bearer ${session.access_token}` : 'none',
        'user_id': session?.user?.id || 'none'
      }))

      setSessionInfo({
        hasSession: !!session,
        userId: session?.user?.id,
        accessToken: session?.access_token ? 'present' : 'none',
        refreshToken: session?.refresh_token ? 'present' : 'none',
        expiresAt: session?.expires_at,
        headers,
        error: error?.message
      })

      console.log('Session Debug:', {
        hasSession: !!session,
        userId: session?.user?.id,
        accessToken: session?.access_token ? 'present' : 'none',
        headers,
        error: error?.message
      })
    }

    checkSession()

    // Listen for changes
    const { data: { subscription } } = supabase.auth.onAuthStateChange(
      (event, session) => {
        console.log('Auth state change:', event, session?.user?.id)
        checkSession()
      }
    )

    return () => subscription.unsubscribe()
  }, [])

  return sessionInfo
}
```

<!-- path: tsconfig.json -->
```json
{
  "$schema": "https://json.schemastore.org/tsconfig",
  "compilerOptions": {
    "target": "ES2017",
    "lib": ["dom", "dom.iterable", "esnext"],
    "allowJs": true,
    "skipLibCheck": true,
    "strict": true,
    "noEmit": true,
    "esModuleInterop": true,
    "module": "esnext",
    "moduleResolution": "bundler",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "jsx": "preserve",
    "incremental": true,
    "paths": {
      "@/*": ["./*"]
    },
    "plugins": [
      {
        "name": "next"
      }
    ]
  },
  "include": ["next-env.d.ts", "**/*.ts", "**/*.tsx", ".next/types/**/*.ts"],
  "exclude": [
    "node_modules",
    "components/table/DataTableDemo.tsx",
    "components/table/ExampleModalUsage.tsx",
    "**/* copy.tsx",
    "components/debug/**"
  ]
}

```

<!-- path: eslint.config.mjs -->
```mjs
import { dirname } from "path";
import { fileURLToPath } from "url";
import { FlatCompat } from "@eslint/eslintrc";

const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);

const compat = new FlatCompat({
  baseDirectory: __dirname,
});

const eslintConfig = [
  ...compat.extends("next/core-web-vitals", "next/typescript"),
];


export default eslintConfig;

```

<!-- path: components.json -->
```json
{
  "$schema": "https://ui.shadcn.com/schema.json",
  "style": "new-york",
  "rsc": true,
  "tsx": true,
  "tailwind": {
    "config": "",
    "css": "app/globals.css",
    "baseColor": "slate",
    "cssVariables": true,
    "prefix": ""
  },
  "aliases": {
    "components": "@/components",
    "utils": "@/lib/utils",
    "ui": "@/components/ui",
    "lib": "@/lib",
    "hooks": "@/hooks"
  },
  "iconLibrary": "lucide"
}
```

<!-- path: utils/classNames.tsx -->
```typescript
import clsx from 'clsx';
import { twMerge } from 'tailwind-merge';

interface CnFunction {
    (...args: Parameters<typeof clsx>): string;
}

export const cn: CnFunction = (...args) => {
    return twMerge(clsx(...args));
};
```

<!-- path: utils/caseConverter.ts -->
```typescript
/**
 * Type-safe case conversion utilities for JavaScript objects
 * Supports deep nested objects and arrays with proper TypeScript inference
 */

// === TYPE DEFINITIONS ===

/**
 * Primitive values that don't need transformation
 * Note: Functions are treated as primitives and returned as-is
 */
type Primitive = string | number | boolean | null | undefined | Date | RegExp;

/**
 * Check if a value is a plain object (not Date, Array, etc.)
 */
type IsPlainObject<T> = T extends Primitive
  ? false
  : T extends readonly unknown[]
  ? false
  : T extends Record<string, unknown>
  ? true
  : false;

/**
 * Transform object keys while preserving type structure
 */
type TransformKeys<T, U extends string> = T extends Primitive
  ? T
  : T extends readonly (infer Item)[]
  ? readonly TransformKeys<Item, U>[]
  : IsPlainObject<T> extends true
  ? {
      [K in keyof T as K extends string ? U : K]: TransformKeys<T[K], U>
    }
  : T;

// Case transformation type mappings
type CamelCase<S extends string> = S extends `${infer P1}_${infer P2}`
  ? `${P1}${Capitalize<CamelCase<P2>>}`
  : S;

type SnakeCase<S extends string> = S extends `${infer C}${infer T}`
  ? C extends Lowercase<C>
    ? `${C}${SnakeCase<T>}`
    : `_${Lowercase<C>}${SnakeCase<T>}`
  : S;

type KebabCase<S extends string> = S extends `${infer C}${infer T}`
  ? C extends Lowercase<C>
    ? `${C}${KebabCase<T>}`
    : `-${Lowercase<C>}${KebabCase<T>}`
  : S;

type PascalCase<S extends string> = Capitalize<CamelCase<S>>;

type ScreamingSnakeCase<S extends string> = Uppercase<
  S extends `${infer C}${infer T}`
    ? C extends Lowercase<C>
      ? `${C}${ScreamingSnakeCase<T>}`
      : `_${Lowercase<C>}${ScreamingSnakeCase<T>}`
    : S
>;

// === UTILITY FUNCTIONS ===

/**
 * Type guard to check if a value is a plain object
 */
function isPlainObject(value: unknown): value is Record<string, unknown> {
  return (
    value !== null &&
    typeof value === 'object' &&
    !Array.isArray(value) &&
    !(value instanceof Date) &&
    !(value instanceof RegExp) &&
    typeof value !== 'function'
  );
}

/**
 * Type guard to check if a value is primitive
 */
function isPrimitive(value: unknown): value is Primitive {
  return (
    value === null ||
    value === undefined ||
    typeof value === 'string' ||
    typeof value === 'number' ||
    typeof value === 'boolean' ||
    value instanceof Date ||
    value instanceof RegExp ||
    typeof value === 'function'
  );
}

// === KEY TRANSFORMATION FUNCTIONS ===

/**
 * Convert string to camelCase
 */
function toCamelCaseKey(key: string): string {
  return key.replace(/_([a-z])/g, (_, letter: string) => letter.toUpperCase());
}

/**
 * Convert string to snake_case
 */
function toSnakeCaseKey(key: string): string {
  return key.replace(/[A-Z]/g, (letter: string) => `_${letter.toLowerCase()}`);
}

/**
 * Convert string to PascalCase
 */
function toPascalCaseKey(key: string): string {
  const camelKey = toCamelCaseKey(key);
  return camelKey.charAt(0).toUpperCase() + camelKey.slice(1);
}

/**
 * Convert string to kebab-case
 */
function toKebabCaseKey(key: string): string {
  return key
    .replace(/([a-z0-9])([A-Z])/g, '$1-$2')
    .replace(/_/g, '-')
    .toLowerCase();
}

/**
 * Convert string to SCREAMING_SNAKE_CASE
 */
function toScreamingSnakeCaseKey(key: string): string {
  return key
    .replace(/([a-z0-9])([A-Z])/g, '$1_$2')
    .replace(/-/g, '_')
    .toUpperCase();
}

// === GENERIC CONVERTER FACTORY ===

/**
 * Key transformation function type
 */
type KeyTransformer = (key: string) => string;

/**
 * Creates a type-safe object converter function
 */
function createConverter<T extends KeyTransformer>(transformer: T) {
  function convert<TInput>(input: TInput): TransformKeys<TInput, string> {
    if (isPrimitive(input)) {
      return input as TransformKeys<TInput, string>;
    }

    if (Array.isArray(input)) {
      return input.map(convert) as TransformKeys<TInput, string>;
    }

    if (isPlainObject(input)) {
      const result: Record<string, unknown> = {};
      
      for (const [key, value] of Object.entries(input)) {
        const transformedKey = transformer(key);
        result[transformedKey] = convert(value);
      }
      
      return result as TransformKeys<TInput, string>;
    }

    return input as TransformKeys<TInput, string>;
  }

  return convert;
}

// === EXPORTED CONVERTERS ===

/**
 * Converts object keys to camelCase
 * 
 * @example
 * ```typescript
 * const input = { user_name: 'John', user_age: 30 };
 * const output = toCamelCase(input);
 * // Result: { userName: 'John', userAge: 30 }
 * ```
 */
export const toCamelCase = createConverter(toCamelCaseKey);

/**
 * Converts object keys to snake_case
 * 
 * @example
 * ```typescript
 * const input = { userName: 'John', userAge: 30 };
 * const output = toSnakeCase(input);
 * // Result: { user_name: 'John', user_age: 30 }
 * ```
 */
export const toSnakeCase = createConverter(toSnakeCaseKey);

/**
 * Converts object keys to PascalCase
 * 
 * @example
 * ```typescript
 * const input = { user_name: 'John', user_age: 30 };
 * const output = toPascalCase(input);
 * // Result: { UserName: 'John', UserAge: 30 }
 * ```
 */
export const toPascalCase = createConverter(toPascalCaseKey);

/**
 * Converts object keys to kebab-case
 * 
 * @example
 * ```typescript
 * const input = { userName: 'John', userAge: 30 };
 * const output = toKebabCase(input);
 * // Result: { 'user-name': 'John', 'user-age': 30 }
 * ```
 */
export const toKebabCase = createConverter(toKebabCaseKey);

/**
 * Converts object keys to SCREAMING_SNAKE_CASE
 * 
 * @example
 * ```typescript
 * const input = { userName: 'John', userAge: 30 };
 * const output = toScreamingSnakeCase(input);
 * // Result: { USER_NAME: 'John', USER_AGE: 30 }
 * ```
 */
export const toScreamingSnakeCase = createConverter(toScreamingSnakeCaseKey);

// === ADVANCED USAGE ===

/**
 * Creates a custom converter with a user-defined transformation function
 * 
 * @param transformer - Function that transforms a single key
 * @returns A converter function that applies the transformation recursively
 * 
 * @example
 * ```typescript
 * const addPrefix = createCustomConverter(key => `prefix_${key}`);
 * const input = { name: 'John', age: 30 };
 * const output = addPrefix(input);
 * // Result: { prefix_name: 'John', prefix_age: 30 }
 * ```
 */
export const createCustomConverter = createConverter;

// === TYPE EXPORTS FOR ADVANCED USAGE ===

export type {
  TransformKeys,
  KeyTransformer,
  CamelCase,
  SnakeCase,
  KebabCase,
  PascalCase,
  ScreamingSnakeCase,
  Primitive,
  IsPlainObject
};

// === USAGE EXAMPLES ===

/**
 * Example usage with Supabase or similar database libraries
 * 
 * @example
 * ```typescript
 * interface UserProfile {
 *   id: string;
 *   firstName: string;
 *   lastName: string;
 *   createdAt: Date;
 * }
 * 
 * // Converting from database (snake_case) to frontend (camelCase)
 * const { data } = await supabase.from('user_profiles').select('*');
 * const profiles: UserProfile[] = data?.map(toCamelCase) ?? [];
 * 
 * // Converting from frontend (camelCase) to database (snake_case)
 * const newProfile: Partial<UserProfile> = {
 *   firstName: 'John',
 *   lastName: 'Doe'
 * };
 * await supabase.from('user_profiles').insert(toSnakeCase(newProfile));
 * ```
 */

/**
 * Example with nested objects and arrays
 * 
 * @example
 * ```typescript
 * const complexData = {
 *   user_profile: {
 *     personal_info: {
 *       first_name: 'Jane',
 *       last_name: 'Smith'
 *     },
 *     contact_methods: [
 *       { method_type: 'email', contact_value: 'jane@example.com' },
 *       { method_type: 'phone', contact_value: '+1234567890' }
 *     ]
 *   },
 *   created_at: new Date(),
 *   is_active: true
 * };
 * 
 * const camelCaseData = toCamelCase(complexData);
 * // TypeScript knows the exact shape of the result!
 * // camelCaseData.userProfile.personalInfo.firstName is properly typed
 * ```
 */
```

<!-- path: utils/hashPassword.ts -->
```typescript
import bcrypt from "bcrypt";

export async function hashPassword(password: string) {
  const saltRounds = 10; // standard
  return await bcrypt.hash(password, saltRounds);
}

```

<!-- path: utils/validationUtils.ts -->
```typescript
/**
 * Enhanced Validation Utility Functions
 * Improved security, robustness, and modern best practices
 */

// Types for better type safety
export interface ValidationResult {
  isValid: boolean;
  errors: string[];
}

export interface FileValidationOptions {
  maxSize?: number; // in bytes
  allowedTypes?: string[];
  allowedExtensions?: string[];
  minSize?: number;
}

export interface PasswordOptions {
  minLength?: number;
  requireUppercase?: boolean;
  requireLowercase?: boolean;
  requireNumbers?: boolean;
  requireSpecialChars?: boolean;
  maxLength?: number;
}

// Enhanced email validation with more comprehensive regex
export const isValidEmail = (email: string): boolean => {
  if (!email || typeof email !== 'string') return false;
  
  // More comprehensive email regex following RFC 5322 guidelines
  const emailRegex = /^[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/;
  
  // Additional checks
  if (email.length > 254) return false; // RFC 5321 limit
  if (email.includes('..')) return false; // Consecutive dots not allowed
  
  return emailRegex.test(email.trim().toLowerCase());
};

// Enhanced password validation with configurable options
export const validatePassword = (
  password: string, 
  options: PasswordOptions = {}
): ValidationResult => {
  const {
    minLength = 8,
    requireUppercase = true,
    requireLowercase = true,
    requireNumbers = true,
    requireSpecialChars = true,
    maxLength = 128
  } = options;

  const errors: string[] = [];
  
  if (!password || typeof password !== 'string') {
    errors.push('Password is required');
    return { isValid: false, errors };
  }

  if (password.length < minLength) {
    errors.push(`Password must be at least ${minLength} characters long`);
  }

  if (password.length > maxLength) {
    errors.push(`Password must be no more than ${maxLength} characters long`);
  }
  
  if (requireUppercase && !/[A-Z]/.test(password)) {
    errors.push('Password must contain at least one uppercase letter');
  }
  
  if (requireLowercase && !/[a-z]/.test(password)) {
    errors.push('Password must contain at least one lowercase letter');
  }
  
  if (requireNumbers && !/\d/.test(password)) {
    errors.push('Password must contain at least one number');
  }
  
  if (requireSpecialChars && !/[!@#$%^&*(),.?":{}|<>_+=\-\[\]\\;'\/~`]/.test(password)) {
    errors.push('Password must contain at least one special character');
  }

  // Check for common weak patterns
  if (password.toLowerCase().includes('password')) {
    errors.push('Password cannot contain the word "password"');
  }

  if (/(.)\1{2,}/.test(password)) {
    errors.push('Password cannot contain more than 2 consecutive identical characters');
  }

  return {
    isValid: errors.length === 0,
    errors
  };
};

// Enhanced phone number validation with country code support
export const isValidPhoneNumber = (phone: string, countryCode?: string): boolean => {
  if (!phone || typeof phone !== 'string') return false;
  
  // Remove all non-digit characters except +
  const cleanPhone = phone.replace(/[^\d+]/g, '');
  
  // Basic international format validation
  if (countryCode === 'US') {
    // US phone number: 10 digits
    const usPhoneRegex = /^(\+1)?[2-9]\d{2}[2-9]\d{2}\d{4}$/;
    return usPhoneRegex.test(cleanPhone);
  }
  
  // International format: + followed by 1-15 digits
  const intlPhoneRegex = /^\+[1-9]\d{1,14}$/;
  // National format: 7-15 digits
  const nationalPhoneRegex = /^[1-9]\d{6,14}$/;
  
  return intlPhoneRegex.test(cleanPhone) || nationalPhoneRegex.test(cleanPhone);
};

// Enhanced name validation
export const isValidName = (name: string, options: { minLength?: number; maxLength?: number } = {}): ValidationResult => {
  const { minLength = 2, maxLength = 50 } = options;
  const errors: string[] = [];

  if (!name || typeof name !== 'string') {
    errors.push('Name is required');
    return { isValid: false, errors };
  }

  const trimmedName = name.trim();
  
  if (trimmedName.length < minLength) {
    errors.push(`Name must be at least ${minLength} characters long`);
  }
  
  if (trimmedName.length > maxLength) {
    errors.push(`Name must be no more than ${maxLength} characters long`);
  }

  // Allow letters, spaces, hyphens, apostrophes, and common international characters
  if (!/^[a-zA-Z-\u0100-\u017F\u0180-\u024F\u1E00-\u1EFF\s\-'\.]+$/.test(trimmedName)) {
    errors.push('Name can only contain letters, spaces, hyphens, and apostrophes');
  }

  // Prevent excessive consecutive spaces or special characters
  if (/\s{2,}/.test(trimmedName) || /[\-'\.]{2,}/.test(trimmedName)) {
    errors.push('Name cannot contain consecutive spaces or special characters');
  }

  return {
    isValid: errors.length === 0,
    errors
  };
};

// Enhanced URL validation
export const isValidUrl = (url: string, options: { allowedProtocols?: string[] } = {}): boolean => {
  if (!url || typeof url !== 'string') return false;
  
  const { allowedProtocols = ['http:', 'https:'] } = options;
  
  try {
    const parsedUrl = new URL(url.trim());
    
    // Check if protocol is allowed
    if (!allowedProtocols.includes(parsedUrl.protocol)) {
      return false;
    }
    
    // Additional security checks
    if (parsedUrl.hostname === '') return false;
    if (parsedUrl.hostname.includes('..')) return false;
    
    return true;
  } catch {
    return false;
  }
};

// Enhanced required field validation with better type checking
export const isRequired = (value: unknown): boolean => {
  if (value === null || value === undefined) return false;
  if (typeof value === 'string') return value.trim().length > 0;
  if (typeof value === 'number') return !isNaN(value);
  if (typeof value === 'boolean') return true;
  if (Array.isArray(value)) return value.length > 0;
  if (typeof value === 'object') return Object.keys(value).length > 0;
  return Boolean(value);
};

// Enhanced numeric validation
export const isValidNumber = (value: unknown, min?: number, max?: number): ValidationResult => {
  const errors: string[] = [];
  
  let num: number;
  if (typeof value === 'string') {
    num = parseFloat(value.trim());
  } else if (typeof value === 'number') {
    num = value;
  } else {
    errors.push('Value must be a number');
    return { isValid: false, errors };
  }
  
  if (isNaN(num) || !isFinite(num)) {
    errors.push('Value must be a valid number');
    return { isValid: false, errors };
  }
  
  if (min !== undefined && num < min) {
    errors.push(`Value must be at least ${min}`);
  }
  
  if (max !== undefined && num > max) {
    errors.push(`Value must be no more than ${max}`);
  }

  return {
    isValid: errors.length === 0,
    errors
  };
};

// Enhanced integer validation
export const isValidInteger = (value: unknown, min?: number, max?: number): ValidationResult => {
  const errors: string[] = [];
  
  let num: number;
  if (typeof value === 'string') {
    num = parseInt(value.trim(), 10);
  } else if (typeof value === 'number') {
    num = value;
  } else {
    errors.push('Value must be an integer');
    return { isValid: false, errors };
  }
  
  if (isNaN(num) || !Number.isInteger(num)) {
    errors.push('Value must be a valid integer');
    return { isValid: false, errors };
  }
  
  if (min !== undefined && num < min) {
    errors.push(`Value must be at least ${min}`);
  }
  
  if (max !== undefined && num > max) {
    errors.push(`Value must be no more than ${max}`);
  }

  return {
    isValid: errors.length === 0,
    errors
  };
};

// Enhanced time validation with format options
export const isValidTime = (time: string, format: '12' | '24' = '24'): ValidationResult => {
  const errors: string[] = [];
  
  if (!time || typeof time !== 'string') {
    errors.push('Time is required');
    return { isValid: false, errors };
  }

  const trimmedTime = time.trim();
  
  if (format === '24') {
    // 24-hour format: HH:MM or HH:MM:SS
    const timeRegex = /^([0-1]?[0-9]|2[0-3]):[0-5][0-9](:[0-5][0-9])?$/;
    if (!timeRegex.test(trimmedTime)) {
      errors.push('Time must be in HH:MM or HH:MM:SS format (24-hour)');
    }
  } else {
    // 12-hour format: HH:MM AM/PM
    const timeRegex = /^(0?[1-9]|1[0-2]):[0-5][0-9]\s?(AM|PM|am|pm)$/;
    if (!timeRegex.test(trimmedTime)) {
      errors.push('Time must be in HH:MM AM/PM format');
    }
  }

  return {
    isValid: errors.length === 0,
    errors
  };
};

// Enhanced date validation
export const isValidDate = (date: string | Date): ValidationResult => {
  const errors: string[] = [];
  
  let parsedDate: Date;
  
  if (date instanceof Date) {
    parsedDate = date;
  } else if (typeof date === 'string') {
    if (!date.trim()) {
      errors.push('Date is required');
      return { isValid: false, errors };
    }
    parsedDate = new Date(date.trim());
  } else {
    errors.push('Date must be a string or Date object');
    return { isValid: false, errors };
  }
  
  if (isNaN(parsedDate.getTime())) {
    errors.push('Invalid date format');
  }

  // Check for reasonable date range (year 1900-2100)
  const year = parsedDate.getFullYear();
  if (year < 1900 || year > 2100) {
    errors.push('Date must be between 1900 and 2100');
  }

  return {
    isValid: errors.length === 0,
    errors
  };
};

// Enhanced future date validation
export const isFutureDate = (date: string | Date, allowToday = false): ValidationResult => {
  const dateValidation = isValidDate(date);
  if (!dateValidation.isValid) {
    return dateValidation;
  }

  const errors: string[] = [];
  const inputDate = typeof date === 'string' ? new Date(date.trim()) : date;
  const now = new Date();
  
  // Set time to start of day for comparison
  const today = new Date(now.getFullYear(), now.getMonth(), now.getDate());
  const compareDate = new Date(inputDate.getFullYear(), inputDate.getMonth(), inputDate.getDate());
  
  if (allowToday ? compareDate < today : compareDate <= today) {
    errors.push(allowToday ? 'Date must be today or in the future' : 'Date must be in the future');
  }

  return {
    isValid: errors.length === 0,
    errors
  };
};

// Enhanced past date validation
export const isPastDate = (date: string | Date, allowToday = false): ValidationResult => {
  const dateValidation = isValidDate(date);
  if (!dateValidation.isValid) {
    return dateValidation;
  }

  const errors: string[] = [];
  const inputDate = typeof date === 'string' ? new Date(date.trim()) : date;
  const now = new Date();
  
  // Set time to start of day for comparison
  const today = new Date(now.getFullYear(), now.getMonth(), now.getDate());
  const compareDate = new Date(inputDate.getFullYear(), inputDate.getMonth(), inputDate.getDate());
  
  if (allowToday ? compareDate > today : compareDate >= today) {
    errors.push(allowToday ? 'Date must be today or in the past' : 'Date must be in the past');
  }

  return {
    isValid: errors.length === 0,
    errors
  };
};

// Enhanced file validation
export const validateFile = (
  file: File,
  options: FileValidationOptions = {}
): ValidationResult => {
  const errors: string[] = [];

  if (!file || !(file instanceof File)) {
    errors.push('Valid file is required');
    return { isValid: false, errors };
  }

  // Check minimum file size
  if (options.minSize && file.size < options.minSize) {
    errors.push(`File size must be at least ${formatFileSize(options.minSize)}`);
  }

  // Check maximum file size
  if (options.maxSize && file.size > options.maxSize) {
    errors.push(`File size must be less than ${formatFileSize(options.maxSize)}`);
  }

  // Check file type
  if (options.allowedTypes && options.allowedTypes.length > 0) {
    if (!options.allowedTypes.includes(file.type)) {
      errors.push(`File type "${file.type}" is not allowed. Allowed types: ${options.allowedTypes.join(', ')}`);
    }
  }

  // Check file extension
  if (options.allowedExtensions && options.allowedExtensions.length > 0) {
    const extension = file.name.split('.').pop()?.toLowerCase();
    if (!extension || !options.allowedExtensions.map(ext => ext.toLowerCase()).includes(extension)) {
      errors.push(`File extension must be one of: ${options.allowedExtensions.join(', ')}`);
    }
  }

  // Check for potentially dangerous file names
  if (/[<>:"|?*]/.test(file.name)) {
    errors.push('File name contains invalid characters');
  }

  return {
    isValid: errors.length === 0,
    errors
  };
};

// Enhanced file size formatter
export const formatFileSize = (bytes: number): string => {
  if (bytes === 0) return '0 Bytes';
  if (bytes < 0) return 'Invalid size';
  
  const k = 1024;
  const sizes = ['Bytes', 'KB', 'MB', 'GB', 'TB'];
  const i = Math.floor(Math.log(bytes) / Math.log(k));
  
  if (i >= sizes.length) return 'File too large';
  
  const size = bytes / Math.pow(k, i);
  return `${size.toFixed(i === 0 ? 0 : 2)} ${sizes[i]}`;
};

// Enhanced sanitization with more comprehensive XSS prevention
export const sanitizeInput = (input: string): string => {
  if (!input || typeof input !== 'string') return '';
  
  return input
    .replace(/&/g, '&amp;')    // Must be first
    .replace(/</g, '&lt;')
    .replace(/>/g, '&gt;')
    .replace(/"/g, '&quot;')
    .replace(/'/g, '&#x27;')
    .replace(/\//g, '&#x2F;')
    .replace(/\\/g, '&#x5C;')
    .replace(/`/g, '&#x60;')
    .replace(/=/g, '&#x3D;');
};

// Credit card validation (Luhn algorithm)
export const isValidCreditCard = (cardNumber: string): ValidationResult => {
  const errors: string[] = [];
  
  if (!cardNumber || typeof cardNumber !== 'string') {
    errors.push('Card number is required');
    return { isValid: false, errors };
  }

  // Remove spaces and hyphens
  const cleanCard = cardNumber.replace(/[\s-]/g, '');
  
  // Check if all digits
  if (!/^\d+$/.test(cleanCard)) {
    errors.push('Card number must contain only digits');
    return { isValid: false, errors };
  }

  // Check length
  if (cleanCard.length < 13 || cleanCard.length > 19) {
    errors.push('Card number must be between 13 and 19 digits');
    return { isValid: false, errors };
  }

  // Luhn algorithm
  let sum = 0;
  let alternate = false;
  
  for (let i = cleanCard.length - 1; i >= 0; i--) {
    let n = parseInt(cleanCard.charAt(i), 10);
    
    if (alternate) {
      n *= 2;
      if (n > 9) {
        n = (n % 10) + 1;
      }
    }
    
    sum += n;
    alternate = !alternate;
  }

  if (sum % 10 !== 0) {
    errors.push('Invalid card number');
  }

  return {
    isValid: errors.length === 0,
    errors
  };
};

// Enhanced validation schemas
export const validationSchemas = {
  register: {
    firstName: (value: string) => {
      const nameValidation = isValidName(value);
      return {
        isValid: isRequired(value) && nameValidation.isValid,
        error: !isRequired(value) ? 'First name is required' : nameValidation.errors[0] || ''
      };
    },
    lastName: (value: string) => {
      const nameValidation = isValidName(value);
      return {
        isValid: isRequired(value) && nameValidation.isValid,
        error: !isRequired(value) ? 'Last name is required' : nameValidation.errors[0] || ''
      };
    },
    email: (value: string) => ({
      isValid: isRequired(value) && isValidEmail(value),
      error: !isRequired(value) ? 'Email is required' : 
             !isValidEmail(value) ? 'Please enter a valid email address' : ''
    }),
    password: (value: string) => {
      const validation = validatePassword(value);
      return {
        isValid: validation.isValid,
        error: validation.errors[0] || ''
      };
    },
    confirmPassword: (value: string, password: string) => ({
      isValid: isRequired(value) && value === password,
      error: !isRequired(value) ? 'Please confirm your password' : 
             value !== password ? 'Passwords do not match' : ''
    })
  },

  login: {
    email: (value: string) => ({
      isValid: isRequired(value) && isValidEmail(value),
      error: !isRequired(value) ? 'Email is required' : 
             !isValidEmail(value) ? 'Please enter a valid email address' : ''
    }),
    password: (value: string) => ({
      isValid: isRequired(value),
      error: !isRequired(value) ? 'Password is required' : ''
    })
  }
};

// Enhanced generic form validator with better type safety
export const validateForm = <T extends Record<string, unknown>>(
  data: T,
  schema: Record<keyof T, (value: T[keyof T], ...args: unknown[]) => { isValid: boolean; error: string }>
): { isValid: boolean; errors: Record<keyof T, string> } => {
  const errors = {} as Record<keyof T, string>;
  let isValid = true;

  (Object.keys(schema) as Array<keyof T>).forEach(key => {
    try {
      const validation = schema[key](data[key]);
      if (!validation.isValid) {
        errors[key] = validation.error;
        isValid = false;
      }
    } catch (error) {
      console.error(`Validation error for field ${String(key)}:`, error);
      errors[key] = 'Validation error occurred';
      isValid = false;
    }
  });

  return { isValid, errors };
};

// Comprehensive validation utilities object
const validationUtils = {
  isValidEmail,
  validatePassword,
  isValidPhoneNumber,
  isValidName,
  isValidUrl,
  isRequired,
  isValidNumber,
  isValidInteger,
  isValidTime,
  isValidDate,
  isFutureDate,
  isPastDate,
  validateFile,
  formatFileSize,
  sanitizeInput,
  isValidCreditCard,
  validationSchemas,
  validateForm
};

export default validationUtils;
```

<!-- path: utils/formatters.ts -->
```typescript
/**
 * Professional data formatting utility library
 * Provides comprehensive formatting functions with optimizations and error handling
 */

// Types and interfaces
export interface NumberFormatOptions extends Intl.NumberFormatOptions {
  locale?: string;
}

export interface PhoneFormatOptions {
  format?: 'US' | 'international' | 'E164';
}

export interface ListFormatOptions {
  conjunction?: 'and' | 'or';
  style?: 'long' | 'short' | 'narrow';
  type?: 'conjunction' | 'disjunction' | 'unit';
}

export interface StringCaseOptions {
  preserveAcronyms?: boolean;
  delimiter?: string;
}

export interface ValidationError {
  field: string;
  message: string;
  code?: string;
}

// Performance optimizations - cached formatters
const formattersCache = new Map<string, Intl.NumberFormat | Intl.DateTimeFormat | Intl.ListFormat>();

// Overloaded function signatures for type safety
function getCachedFormatter(
  type: 'number',
  locale: string,
  options: Intl.NumberFormatOptions
): Intl.NumberFormat;
function getCachedFormatter(
  type: 'date',
  locale: string,
  options: Intl.DateTimeFormatOptions
): Intl.DateTimeFormat;
function getCachedFormatter(
  type: 'list',
  locale: string,
  options: Intl.ListFormatOptions
): Intl.ListFormat;
function getCachedFormatter(
  type: 'number' | 'date' | 'list',
  locale: string,
  options: Intl.NumberFormatOptions | Intl.DateTimeFormatOptions | Intl.ListFormatOptions
): Intl.NumberFormat | Intl.DateTimeFormat | Intl.ListFormat {
  const key = `${type}-${locale}-${JSON.stringify(options)}`;
  
  if (!formattersCache.has(key)) {
    let formatter: Intl.NumberFormat | Intl.DateTimeFormat | Intl.ListFormat;
    switch (type) {
      case 'number':
        formatter = new Intl.NumberFormat(locale, options as Intl.NumberFormatOptions);
        break;
      case 'date':
        formatter = new Intl.DateTimeFormat(locale, options as Intl.DateTimeFormatOptions);
        break;
      case 'list':
        formatter = new Intl.ListFormat(locale, options as Intl.ListFormatOptions);
        break;
      default:
        throw new Error(`Unsupported formatter type: ${type}`);
    }
    formattersCache.set(key, formatter);
  }
  
  return formattersCache.get(key)!;
}

// =============================================================================
// NUMBER FORMATTERS
// =============================================================================

/**
 * Format a number with locale-aware formatting
 */
export const formatNumber = (
  num: number,
  options: NumberFormatOptions = {}
): string => {
  if (!Number.isFinite(num)) {
    return num.toString();
  }

  const { locale = 'en-US', ...intlOptions } = options;
  const formatter = getCachedFormatter('number', locale, intlOptions);
  
  return formatter.format(num);
};

/**
 * Format a number as currency
 */
export const formatCurrency = (
  amount: number,
  currency: string = 'USD',
  locale: string = 'en-US',
  options: Intl.NumberFormatOptions = {}
): string => {
  return formatNumber(amount, {
    locale,
    style: 'currency',
    currency,
    ...options
  });
};

/**
 * Format a number as percentage
 */
export const formatPercentage = (
  value: number,
  decimals: number = 1,
  locale: string = 'en-US'
): string => {
  return formatNumber(value / 100, {
    locale,
    style: 'percent',
    minimumFractionDigits: decimals,
    maximumFractionDigits: decimals
  });
};

/**
 * Format a score with optional fraction display
 */
export const formatScore = (
  score: number,
  total: number,
  options: {
    showFraction?: boolean;
    decimals?: number;
    locale?: string;
  } = {}
): string => {
  const { showFraction = true, decimals = 1, locale = 'en-US' } = options;
  
  if (total <= 0) {
    return showFraction ? `${score}/0 (0%)` : '0%';
  }

  const percentage = (score / total) * 100;
  const formattedPercentage = formatPercentage(percentage, decimals, locale);
  
  return showFraction 
    ? `${formatNumber(score, { locale })}/${formatNumber(total, { locale })} (${formattedPercentage})`
    : formattedPercentage;
};

/**
 * Format file size in human-readable format
 */
export const formatFileSize = (
  bytes: number,
  options: {
    binary?: boolean;
    decimals?: number;
    locale?: string;
  } = {}
): string => {
  const { binary = false, decimals = 2, locale = 'en-US' } = options;
  
  if (bytes === 0) return '0 B';
  if (!Number.isFinite(bytes) || bytes < 0) return 'Invalid size';

  const base = binary ? 1024 : 1000;
  const sizes = binary 
    ? ['B', 'KiB', 'MiB', 'GiB', 'TiB', 'PiB'] 
    : ['B', 'KB', 'MB', 'GB', 'TB', 'PB'];
  
  const i = Math.floor(Math.log(bytes) / Math.log(base));
  const size = bytes / Math.pow(base, i);
  
  return `${formatNumber(size, { 
    locale,
    minimumFractionDigits: i === 0 ? 0 : decimals,
    maximumFractionDigits: i === 0 ? 0 : decimals
  })} ${sizes[i]}`;
};

// =============================================================================
// STRING FORMATTERS
// =============================================================================

/**
 * Convert string to title case with smart handling
 */
export const toTitleCase = (
  str: string,
  options: StringCaseOptions = {}
): string => {
  if (!str) return '';
  
  const { preserveAcronyms = true } = options;
  
  // Common words that should remain lowercase in titles
  const articles = new Set(['a', 'an', 'and', 'as', 'at', 'but', 'by', 'for', 'if', 'in', 'nor', 'of', 'on', 'or', 'so', 'the', 'to', 'up', 'yet']);
  
  return str
    .toLowerCase()
    .split(/\s+/)
    .map((word, index) => {
      // Always capitalize first and last word
      if (index === 0 || !articles.has(word)) {
        // Preserve acronyms if option is set
        if (preserveAcronyms && word.toUpperCase() === word && word.length <= 4) {
          return word.toUpperCase();
        }
        return word.charAt(0).toUpperCase() + word.slice(1);
      }
      return word;
    })
    .join(' ');
};

/**
 * Convert snake_case to Title Case
 */
export const snakeToTitleCase = (str: string): string => {
  if (!str) return '';
  
  return str
    .split('_')
    .map(word => word.charAt(0).toUpperCase() + word.slice(1).toLowerCase())
    .join(' ');
};

/**
 * Convert camelCase to kebab-case
 */
export const camelToKebab = (str: string): string => {
  if (!str) return '';
  
  return str
    .replace(/([a-z0-9]|(?=[A-Z]))([A-Z])/g, '$1-$2')
    .toLowerCase();
};

/**
 * Convert kebab-case to camelCase
 */
export const kebabToCamel = (str: string): string => {
  if (!str) return '';
  
  return str.replace(/-([a-z])/g, (_, letter) => letter.toUpperCase());
};

/**
 * Convert snake_case to camelCase
 */
export const snakeToCamel = (str: string): string => {
  if (!str) return '';
  
  return str.replace(/_([a-z])/g, (_, letter) => letter.toUpperCase());
};

/**
 * Convert camelCase to snake_case
 */
export const camelToSnake = (str: string): string => {
  if (!str) return '';
  
  return str.replace(/([A-Z])/g, '_$1').toLowerCase();
};

/**
 * Create URL-friendly slug from text
 */
export const createSlug = (
  text: string,
  options: {
    maxLength?: number;
    separator?: string;
    lowercase?: boolean;
  } = {}
): string => {
  const { maxLength = 50, separator = '-', lowercase = true } = options;
  
  if (!text) return '';
  
  let slug = text
    .trim()
    .replace(/[^\w\s-]/g, '') // Remove special characters
    .replace(/\s+/g, separator) // Replace spaces with separator
    .replace(new RegExp(`${separator}+`, 'g'), separator) // Replace multiple separators
    .replace(new RegExp(`^${separator}|${separator}$`, 'g'), ''); // Remove leading/trailing separators
  
  if (lowercase) {
    slug = slug.toLowerCase();
  }
  
  if (maxLength && slug.length > maxLength) {
    slug = slug.substring(0, maxLength).replace(new RegExp(`${separator}$`), '');
  }
  
  return slug;
};

/**
 * Truncate text with smart word boundaries
 */
export const truncateText = (
  text: string,
  maxLength: number,
  options: {
    suffix?: string;
    preserveWords?: boolean;
  } = {}
): string => {
  const { suffix = '...', preserveWords = true } = options;
  
  if (!text || text.length <= maxLength) return text;
  
  if (!preserveWords) {
    return text.substring(0, maxLength - suffix.length) + suffix;
  }
  
  const words = text.split(' ');
  let truncated = '';
  
  for (const word of words) {
    const nextText = truncated ? `${truncated} ${word}` : word;
    if (nextText.length > maxLength - suffix.length) {
      break;
    }
    truncated = nextText;
  }
  
  return truncated ? truncated + suffix : text.substring(0, maxLength - suffix.length) + suffix;
};

// =============================================================================
// CONTACT INFORMATION FORMATTERS
// =============================================================================

/**
 * Format user name with various display options
 */
export const formatUserName = (
  firstName: string,
  lastName: string,
  format: 'full' | 'lastFirst' | 'initials' | 'firstInitial' = 'full'
): string => {
  const first = firstName?.trim() || '';
  const last = lastName?.trim() || '';
  
  if (!first && !last) return '';
  
  switch (format) {
    case 'full':
      return `${first} ${last}`.trim();
    case 'lastFirst':
      return last ? `${last}, ${first}`.trim() : first;
    case 'initials':
      return `${first.charAt(0)}${last.charAt(0)}`.toUpperCase();
    case 'firstInitial':
      return `${first.charAt(0).toUpperCase()}. ${last}`.trim();
    default:
      return `${first} ${last}`.trim();
  }
};

/**
 * Format phone number with international support
 */
export const formatPhoneNumber = (
  phone: string,
  options: PhoneFormatOptions = {}
): string => {
  const { format = 'US' } = options;
  
  if (!phone) return '';
  
  const cleaned = phone.replace(/\D/g, '');
  
  switch (format) {
    case 'US':
      if (cleaned.length === 10) {
        return `(${cleaned.slice(0, 3)}) ${cleaned.slice(3, 6)}-${cleaned.slice(6)}`;
      }
      if (cleaned.length === 11 && cleaned.startsWith('1')) {
        return `+1 (${cleaned.slice(1, 4)}) ${cleaned.slice(4, 7)}-${cleaned.slice(7)}`;
      }
      break;
      
    case 'E164':
      if (cleaned.length === 10) {
        return `+1${cleaned}`;
      }
      if (cleaned.length === 11 && cleaned.startsWith('1')) {
        return `+${cleaned}`;
      }
      break;
      
    case 'international':
      // Basic international formatting - could be expanded
      if (cleaned.length >= 10) {
        return `+${cleaned}`;
      }
      break;
  }
  
  return phone; // Return original if can't format
};

/**
 * Format email address (basic validation and normalization)
 */
export const formatEmail = (email: string): string => {
  if (!email) return '';
  
  return email.trim().toLowerCase();
};

// =============================================================================
// DATE AND TIME FORMATTERS
// =============================================================================

/**
 * Format date with locale support
 */
type FormatDateOptions = Intl.DateTimeFormatOptions & {
  locale?: string;
  format?: 'short' | 'medium' | 'long' | 'full' | 'ddmmyyyy' | 'yyyy-mm-dd' | 'dd/mm/yyyy' | 'mm/dd/yyyy' | 'dd MMM yyyy' | 'dd-mm-yyyy';
};

const DATE_FORMATS: Record<
  'short' | 'medium' | 'long' | 'full',
  Intl.DateTimeFormatOptions
> = {
  short: { year: '2-digit', month: 'numeric', day: 'numeric' },
  medium: { year: 'numeric', month: 'short', day: 'numeric' },
  long: { year: 'numeric', month: 'long', day: 'numeric' },
  full: {
    weekday: 'long',
    year: 'numeric',
    month: 'long',
    day: 'numeric',
  },
};

export const formatDate = (
  date: Date | string | number,
  options: FormatDateOptions = {}
): string => {
  const {
    locale = 'en-US',
    format,
    ...intlOptions
  } = options;

  try {
    // Pre-validate string inputs before creating Date object
    if (typeof date === 'string') {
      const trimmed = date.trim();
      if (trimmed === '' || trimmed === 'null' || trimmed === 'undefined') {
        return 'No Date';
      }
    }

    const dateObj = new Date(date);
    
    // Check for invalid dates (NaN) or suspicious Unix epoch dates
    if (isNaN(dateObj.getTime()) || isSuspiciousUnixEpoch(date, dateObj)) {
      return 'No Date';
    }

    // Handle custom string formats
    if (typeof format === 'string') {
      const day = dateObj.getDate().toString().padStart(2, '0');
      const month = (dateObj.getMonth() + 1).toString().padStart(2, '0');
      const year = dateObj.getFullYear().toString();
      const monthNames = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
      const monthName = monthNames[dateObj.getMonth()];

      switch (format) {
        case 'ddmmyyyy':
          return `${day}${month}${year}`;
        case 'yyyy-mm-dd':
          return `${year}-${month}-${day}`;
        case 'dd-mm-yyyy':
          return `${day}-${month}-${year}`;
        case 'dd/mm/yyyy':
          return `${day}/${month}/${year}`;
        case 'mm/dd/yyyy':
          return `${month}/${day}/${year}`;
        case 'dd MMM yyyy':
          return `${day} ${monthName} ${year}`;
        // Fall through to Intl formats below
      }
    }

    // Use Intl for short/medium/long/full/custom Intl options
    const mergedOptions = {
      ...(format && DATE_FORMATS[format as keyof typeof DATE_FORMATS]),
      ...intlOptions,
    };

    const formatter = getCachedFormatter('date', locale, mergedOptions);
    return formatter.format(dateObj);
  } catch {
    return 'No Date';
  }
};

/**
 * Detects if we got Unix epoch from invalid input that was coerced
 * This is very aggressive - assumes most Unix epoch dates are from invalid coercion
 */
function isSuspiciousUnixEpoch(originalInput: Date | string | number, dateObj: Date): boolean {
  const time = dateObj.getTime();
  const isUnixEpoch = time === 0; // January 1, 1970 00:00:00 UTC
  
  if (!isUnixEpoch) return false;
  
  // If input is a Date object that's already Unix epoch, it might be valid
  if (originalInput instanceof Date) {
    return false;
  }
  
  // If input is exactly the number 0, it's intentional
  if (originalInput === 0) {
    return false;
  }
  
  // For any other number, if it results in Unix epoch, it's suspicious
  if (typeof originalInput === 'number') {
    return true;
  }
  
  // For strings - be VERY strict. Most Unix epoch results from strings are invalid
  if (typeof originalInput === 'string') {
    const trimmed = originalInput.trim();
    
    // Only these exact strings are considered valid Unix epoch
    const validUnixEpochStrings = [
      '0',
      '1970-01-01',
      '01/01/1970',
      '1/1/1970', 
      '01-01-1970',
      '1970-01-01T00:00:00.000Z',
      '1970-01-01T00:00:00Z'
    ];
    
    // Exact match only - no partial matches
    const isExactMatch = validUnixEpochStrings.includes(trimmed) || 
                        validUnixEpochStrings.includes(trimmed.toLowerCase());
    
    // If it's not an exact match but resulted in Unix epoch, it's from invalid input
    return !isExactMatch;
  }
  
  // Default to suspicious for any other type
  return true;
}


/**
 * Format time range
 */
export const formatTimeRange = (
  startTime: Date | string,
  endTime: Date | string,
  options: Intl.DateTimeFormatOptions & { locale?: string } = {}
): string => {
  const { locale = 'en-US', ...intlOptions } = options;
  
  const formatOptions = {
    hour: 'numeric' as const,
    minute: '2-digit' as const,
    ...intlOptions
  };
  
  const start = formatDate(startTime, { locale, ...formatOptions });
  const end = formatDate(endTime, { locale, ...formatOptions });
  
  return `${start} - ${end}`;
};

/**
 * Format relative time (e.g., "2 hours ago")
 */
export const formatRelativeTime = (
  date: Date | string | number,
  locale: string = 'en-US'
): string => {
  try {
    const dateObj = new Date(date);
    const now = new Date();
    const diffMs = now.getTime() - dateObj.getTime();
    const diffSec = Math.floor(diffMs / 1000);
    const diffMin = Math.floor(diffSec / 60);
    const diffHour = Math.floor(diffMin / 60);
    const diffDay = Math.floor(diffHour / 24);
    
    if (diffSec < 60) return 'just now';
    if (diffMin < 60) return `${diffMin} minute${diffMin !== 1 ? 's' : ''} ago`;
    if (diffHour < 24) return `${diffHour} hour${diffHour !== 1 ? 's' : ''} ago`;
    if (diffDay < 30) return `${diffDay} day${diffDay !== 1 ? 's' : ''} ago`;
    
    // For older dates, return formatted date
    return formatDate(dateObj, { locale, dateStyle: 'medium' });
  } catch {
    return 'No Date';
  }
};

// =============================================================================
// LIST AND ARRAY FORMATTERS
// =============================================================================

/**
 * Format array as a grammatically correct list
 */
export const formatList = (
  items: (string | number)[],
  options: ListFormatOptions & { locale?: string } = {}
): string => {
  const { locale = 'en-US', conjunction = 'and', ...intlOptions } = options;
  
  if (!Array.isArray(items) || items.length === 0) return '';
  
  const stringItems = items.map(String).filter(Boolean);
  
  if (stringItems.length === 0) return '';
  if (stringItems.length === 1) return stringItems[0];
  
  try {
    const listFormatOptions: Intl.ListFormatOptions = {
      style: 'long',
      type: conjunction === 'or' ? 'disjunction' : 'conjunction',
      ...intlOptions
    };
    
    const formatter = getCachedFormatter('list', locale, listFormatOptions);
    
    return formatter.format(stringItems);
  } catch {
    // Fallback for older browsers
    if (stringItems.length === 2) {
      return `${stringItems[0]} ${conjunction} ${stringItems[1]}`;
    }
    
    const lastItem = stringItems[stringItems.length - 1];
    const otherItems = stringItems.slice(0, -1);
    return `${otherItems.join(', ')}, ${conjunction} ${lastItem}`;
  }
};

/**
 * Format array with truncation support
 */
export const formatArrayWithLimit = (
  items: (string | number)[],
  options: {
    maxItems?: number;
    moreText?: string;
    conjunction?: 'and' | 'or';
    locale?: string;
  } = {}
): string => {
  const { maxItems = 5, moreText = 'more', conjunction = 'and', locale = 'en-US' } = options;
  
  if (!Array.isArray(items) || items.length === 0) return '';
  
  const stringItems = items.map(String).filter(Boolean);
  
  if (stringItems.length <= maxItems) {
    return formatList(stringItems, { conjunction, locale });
  }
  
  const visibleItems = stringItems.slice(0, maxItems);
  const remainingCount = stringItems.length - maxItems;
  
  return `${formatList(visibleItems, { conjunction, locale })} and ${remainingCount} ${moreText}`;
};

// =============================================================================
// ERROR AND VALIDATION FORMATTERS
// =============================================================================

/**
 * Format error messages consistently
 */
export const formatErrorMessage = (error: unknown): string => {
  if (typeof error === 'string') return error;
  if (error instanceof Error) return error.message;
  if (error && typeof error === 'object') {
    if ('message' in error && typeof error.message === 'string') {
      return error.message;
    }
    if ('error' in error && typeof error.error === 'string') {
      return error.error;
    }
  }
  return 'An unexpected error occurred';
};

/**
 * Format validation errors with field names
 */
export const formatValidationErrors = (
  errors: ValidationError[] | Record<string, string>
): string[] => {
  if (Array.isArray(errors)) {
    return errors
      .filter(error => error.message?.trim())
      .map(error => `${toTitleCase(error.field.replace(/([A-Z])/g, ' $1'))}: ${error.message}`);
  }
  
  return Object.entries(errors)
    .filter(([, message]) => message?.trim())
    .map(([field, message]) => `${toTitleCase(field.replace(/([A-Z])/g, ' $1'))}: ${message}`);
};

// =============================================================================
// SEARCH AND UTILITY FORMATTERS
// =============================================================================

/**
 * Normalize search query
 */
export const normalizeSearchQuery = (query: string): string => {
  if (!query) return '';
  
  return query
    .trim()
    .replace(/\s+/g, ' ') // Replace multiple spaces with single space
    .toLowerCase();
};

/**
 * Highlight search terms in text
 */
export const highlightSearchTerms = (
  text: string,
  searchTerms: string | string[],
  options: {
    className?: string;
    caseSensitive?: boolean;
    wholeWords?: boolean;
  } = {}
): string => {
  const { className = 'highlight', caseSensitive = false, wholeWords = false } = options;
  
  if (!text || !searchTerms) return text;
  
  const terms = Array.isArray(searchTerms) ? searchTerms : [searchTerms];
  const flags = caseSensitive ? 'g' : 'gi';
  
  let result = text;
  
  terms.forEach(term => {
    if (!term.trim()) return;
    
    const escapedTerm = term.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
    const pattern = wholeWords ? `\\b${escapedTerm}\\b` : escapedTerm;
    const regex = new RegExp(pattern, flags);
    
    result = result.replace(regex, `<span class="${className}">$&</span>`);
  });
  
  return result;
};

// =============================================================================
// EXPORTS
// =============================================================================

const formatters = {
  // Numbers
  formatNumber,
  formatCurrency,
  formatPercentage,
  formatScore,
  formatFileSize,
  
  // Strings
  toTitleCase,
  snakeToTitleCase,
  camelToKebab,
  kebabToCamel,
  snakeToCamel,
  camelToSnake,
  createSlug,
  truncateText,
  
  // Contact
  formatUserName,
  formatPhoneNumber,
  formatEmail,
  
  // Dates
  formatDate,
  formatTimeRange,
  formatRelativeTime,
  
  // Lists
  formatList,
  formatArrayWithLimit,
  
  // Errors
  formatErrorMessage,
  formatValidationErrors,
  
  // Search
  normalizeSearchQuery,
  highlightSearchTerms,
};

export default formatters;
```

<!-- path: utils/imageOptimization.ts -->
```typescript
// utils/imageOptimization.ts
"use client";

import Uppy from "@uppy/core";
import ImageEditor from "@uppy/image-editor";
import { useRef, useEffect } from "react";

// Types for better type safety
interface CompressionOptions {
  maxWidth?: number;
  maxHeight?: number;
  quality?: number;
}

interface OptimizedUppyOptions {
  folderId: string | null;
  maxFileSize?: number;
  maxNumberOfFiles?: number;
}

// 1. Improved ImageEditor configuration with better compression
export const enhancedImageEditorConfig = {
  quality: 0.85,
  cropperOptions: {
    viewMode: 1 as 0 | 1 | 2 | 3,
    background: false,
    autoCropArea: 1,
    responsive: true,
    checkOrientation: false,
    guides: true,
    highlight: false,
    dragMode: "crop" as const,
  },
  actions: {
    revert: true,
    rotate: true,
    granularRotate: true,
    flip: true,
    zoomIn: true,
    zoomOut: true,
    cropSquare: true,
    cropWidescreen: true,
    cropWidescreenVertical: true,
  },
};

// 2. Enhanced image compression utility function
export const compressImage = (
  file: File,
  options: CompressionOptions = {},
): Promise<File> => {
  const { maxWidth = 1920, maxHeight = 1080, quality = 0.8 } = options;

  return new Promise((resolve) => {
    // Check if it's actually an image
    if (!file.type.startsWith("image/")) {
      resolve(file);
      return;
    }

    const canvas = document.createElement("canvas");
    const ctx = canvas.getContext("2d");

    if (!ctx) {
      console.warn("Could not get canvas context");
      resolve(file);
      return;
    }

    const img = new Image();

    img.onload = () => {
      try {
        // Calculate new dimensions while maintaining aspect ratio
        let { width, height } = img;

        if (width > maxWidth || height > maxHeight) {
          const aspectRatio = width / height;

          if (width > height) {
            width = Math.min(width, maxWidth);
            height = width / aspectRatio;
          } else {
            height = Math.min(height, maxHeight);
            width = height * aspectRatio;
          }
        }

        canvas.width = width;
        canvas.height = height;

        // Clear canvas and draw image
        ctx.clearRect(0, 0, width, height);
        ctx.drawImage(img, 0, 0, width, height);

        canvas.toBlob(
          (blob) => {
            if (blob && blob.size > 0) {
              try {
                const compressedFile = new File([blob], file.name, {
                  type: file.type,
                  lastModified: Date.now(),
                });
                resolve(compressedFile);
              } catch (error) {
                console.warn("Error creating compressed file:", error);
                resolve(file);
              }
            } else {
              console.warn("Canvas toBlob produced empty result");
              resolve(file);
            }
          },
          file.type,
          quality,
        );
      } catch (error) {
        console.warn("Error compressing image:", error);
        resolve(file);
      }
    };

    img.onerror = () => {
      console.warn("Error loading image for compression");
      resolve(file);
    };

    img.src = URL.createObjectURL(file);
  });
};

// 3. Enhanced Uppy configuration with compression
export const createOptimizedUppy = (options: OptimizedUppyOptions) => {
  const {
    folderId,
    maxFileSize = 50 * 1024 * 1024, // 50MB
    maxNumberOfFiles = 20,
  } = options;

  const uppy = new Uppy({
    id: "file-uploader",
    autoProceed: false,
    allowMultipleUploads: true,
    restrictions: {
      maxFileSize,
      maxNumberOfFiles,
      allowedFileTypes: [
        "image/*",
        "application/pdf",
        ".doc",
        ".docx",
        ".txt",
        ".rtf",
        "video/*",
        "audio/*",
      ],
    },
    meta: {
      folderId: folderId,
    },
    onBeforeFileAdded: (currentFile, files) => {
      // Additional validation
      if (currentFile.size === 0) {
        uppy.log(`Skipping file ${currentFile.name} - file is empty`);
        return false;
      }

      // Check for duplicate files
      const existingFile = Object.values(files).find(
        (file) =>
          file.name === currentFile.name && file.size === currentFile.size,
      );

      if (existingFile) {
        uppy.log(`Skipping file ${currentFile.name} - duplicate file`);
        return false;
      }

      return true;
    },
  });

  // Add ImageEditor plugin with error handling
  try {
    uppy.use(ImageEditor, enhancedImageEditorConfig);
  } catch (error) {
    console.warn("Failed to add ImageEditor plugin:", error);
  }

  return uppy;
};

// 4. WebP conversion utility (for modern browsers)
export const convertToWebP = (file: File, quality = 0.8): Promise<File> => {
  return new Promise((resolve) => {
    if (!file.type.startsWith("image/") || file.type === "image/webp") {
      resolve(file);
      return;
    }

    // Check if browser supports WebP
    const canvas = document.createElement("canvas");
    const testBlob = canvas.toDataURL("image/webp");

    if (!testBlob.startsWith("data:image/webp")) {
      resolve(file);
      return;
    }

    const ctx = canvas.getContext("2d");
    if (!ctx) {
      resolve(file);
      return;
    }

    const img = new Image();

    img.onload = () => {
      try {
        canvas.width = img.width;
        canvas.height = img.height;
        ctx.drawImage(img, 0, 0);

        canvas.toBlob(
          (blob) => {
            if (blob && blob.size > 0 && blob.size < file.size) {
              const webpFile = new File(
                [blob],
                file.name.replace(/\.[^/.]+$/, ".webp"),
                {
                  type: "image/webp",
                  lastModified: Date.now(),
                },
              );
              resolve(webpFile);
            } else {
              resolve(file);
            }
          },
          "image/webp",
          quality,
        );
      } catch (error) {
        console.warn("Error converting to WebP:", error);
        resolve(file);
      }
    };

    img.onerror = () => resolve(file);
    img.src = URL.createObjectURL(file);
  });
};

// 5. Progressive JPEG utility
export const createProgressiveJPEG = (file: File): Promise<File> => {
  return new Promise((resolve) => {
    if (file.type !== "image/jpeg") {
      resolve(file);
      return;
    }

    const canvas = document.createElement("canvas");
    const ctx = canvas.getContext("2d");

    if (!ctx) {
      resolve(file);
      return;
    }

    const img = new Image();

    img.onload = () => {
      try {
        canvas.width = img.width;
        canvas.height = img.height;
        ctx.drawImage(img, 0, 0);

        canvas.toBlob(
          (blob) => {
            if (blob && blob.size > 0) {
              const progressiveFile = new File([blob], file.name, {
                type: "image/jpeg",
                lastModified: Date.now(),
              });
              resolve(progressiveFile);
            } else {
              resolve(file);
            }
          },
          "image/jpeg",
          0.85,
        );
      } catch (error) {
        console.warn("Error creating progressive JPEG:", error);
        resolve(file);
      }
    };

    img.onerror = () => resolve(file);
    img.src = URL.createObjectURL(file);
  });
};

// 6. FIXED Smart compression based on image content
export const smartCompress = async (file: File): Promise<File> => {
  if (!file.type.startsWith("image/")) {
    return file;
  }

  return new Promise((resolve) => {
    const img = new Image();
    const canvas = document.createElement("canvas");
    const ctx = canvas.getContext("2d");

    if (!ctx) {
      console.warn("Could not get canvas context for smart compression");
      resolve(file);
      return;
    }

    img.onload = () => {
      try {
        // Get optimal settings based on file size
        const { quality, maxWidth, maxHeight } = getOptimalImageSettings(file);

        // Calculate new dimensions while maintaining aspect ratio
        let { width, height } = img;

        if (width > maxWidth || height > maxHeight) {
          const aspectRatio = width / height;

          if (width > height) {
            width = Math.min(width, maxWidth);
            height = width / aspectRatio;
          } else {
            height = Math.min(height, maxHeight);
            width = height * aspectRatio;
          }
        }

        canvas.width = width;
        canvas.height = height;

        // Clear canvas and draw image
        ctx.clearRect(0, 0, width, height);
        ctx.drawImage(img, 0, 0, width, height);

        canvas.toBlob(
          (blob) => {
            if (blob && blob.size > 0) {
              try {
                const optimizedFile = new File([blob], file.name, {
                  type: file.type,
                  lastModified: Date.now(),
                });

                console.log(`Smart compression result: ${file.name}`, {
                  original: (file.size / 1024 / 1024).toFixed(2) + "MB",
                  compressed:
                    (optimizedFile.size / 1024 / 1024).toFixed(2) + "MB",
                  reduction:
                    (
                      ((file.size - optimizedFile.size) / file.size) *
                      100
                    ).toFixed(1) + "%",
                });

                resolve(optimizedFile);
              } catch (error) {
                console.warn("Error creating optimized file:", error);
                resolve(file);
              }
            } else {
              console.warn(
                "Smart compression produced empty result, using original file",
              );
              resolve(file);
            }
          },
          file.type,
          quality,
        );
      } catch (error) {
        console.warn("Error in smart compression:", error);
        resolve(file);
      }
    };

    img.onerror = (error) => {
      console.warn("Error loading image for smart compression:", error);
      resolve(file);
    };

    img.src = URL.createObjectURL(file);
  });
};

// 7. Custom hook for optimized file uploader
export const useOptimizedFileUploader = (
  folderId: string | null,
): Uppy<{ folderId: string | null }, Record<string, never>> | null => {
  const uppyRef = useRef<Uppy<
    { folderId: string | null },
    Record<string, never>
  > | null>(null);

  useEffect(() => {
    // Clean up previous instance
    if (uppyRef.current) {
      uppyRef.current.destroy();
    }

    const uppy = createOptimizedUppy({ folderId });

    // Add comprehensive image optimization preprocessor
    uppy.addPreProcessor(async (fileIDs) => {
      const optimizationPromises = fileIDs.map(async (fileID) => {
        const file = uppy.getFile(fileID);

        if (file && file.type && file.type.startsWith("image/")) {
          try {
            let optimizedFile = file.data as File;

            // Validate original file
            if (optimizedFile.size === 0) {
              console.warn(
                `Skipping optimization for ${file.name} - empty file`,
              );
              return;
            }

            // Apply smart compression with fallback
            try {
              const compressedFile = await smartCompress(optimizedFile);
              if (
                compressedFile.size > 0 &&
                compressedFile.size < optimizedFile.size
              ) {
                optimizedFile = compressedFile;
              }
            } catch (compressionError) {
              console.warn(
                `Compression failed for ${file.name}:`,
                compressionError,
              );
            }

            // Convert to WebP if beneficial (with validation)
            try {
              const webpFile = await convertToWebP(optimizedFile);
              if (webpFile.size > 0 && webpFile.size < optimizedFile.size) {
                optimizedFile = webpFile;
              }
            } catch (webpError) {
              console.warn(
                `WebP conversion failed for ${file.name}:`,
                webpError,
              );
            }

            // For JPEGs, make them progressive (with validation)
            try {
              if (optimizedFile.type === "image/jpeg") {
                const progressiveFile =
                  await createProgressiveJPEG(optimizedFile);
                if (progressiveFile.size > 0) {
                  optimizedFile = progressiveFile;
                }
              }
            } catch (progressiveError) {
              console.warn(
                `Progressive JPEG creation failed for ${file.name}:`,
                progressiveError,
              );
            }

            // Final validation before updating Uppy
            if (optimizedFile.size === 0) {
              console.error(
                `Optimization resulted in empty file for ${file.name}, using original`,
              );
              return; // Don't update Uppy, keep original
            }

            // Update the file in Uppy
            uppy.setFileState(fileID, {
              data: optimizedFile,
              size: optimizedFile.size,
            });

            const originalSizeMB = ((file.size ?? 0) / 1024 / 1024).toFixed(2);
            const optimizedSizeMB = (optimizedFile.size / 1024 / 1024).toFixed(
              2,
            );
            const compressionRatio = (
              (((file.size ?? 0) - optimizedFile.size) / (file.size ?? 1)) *
              100
            ).toFixed(1);

            console.log(
              `Optimized ${file.name}: ${originalSizeMB}MB  ${optimizedSizeMB}MB (${compressionRatio}% reduction)`,
            );
          } catch (error) {
            console.warn(`Failed to optimize ${file.name}:`, error);
            // Keep original file in case of any error
          }
        }
      });

      await Promise.all(optimizationPromises);
    });

    uppyRef.current = uppy;

    return () => {
      if (uppyRef.current) {
        uppyRef.current.destroy();
        uppyRef.current = null;
      }
    };
  }, [folderId]);

  return uppyRef.current;
};

// 8. Utility function to get optimal image settings
export const getOptimalImageSettings = (file: File) => {
  const sizeInMB = file.size / (1024 * 1024);

  if (sizeInMB > 10) {
    return { quality: 0.6, maxWidth: 1600, maxHeight: 1200 };
  } else if (sizeInMB > 5) {
    return { quality: 0.7, maxWidth: 1800, maxHeight: 1350 };
  } else if (sizeInMB > 2) {
    return { quality: 0.75, maxWidth: 1920, maxHeight: 1440 };
  } else {
    return { quality: 0.85, maxWidth: 1920, maxHeight: 1440 };
  }
};

// 9. Batch optimization function
export const optimizeFilesBatch = async (files: File[]): Promise<File[]> => {
  const optimizationPromises = files.map(async (file) => {
    console.log(
      "Original file:",
      file.name,
      "Size:",
      file.size,
      "Type:",
      file.type,
    );

    if (file.type.startsWith("image/") && file.size > 0) {
      try {
        const optimized = await smartCompress(file);
        return optimized.size > 0 ? optimized : file; // Fallback to original if compression fails
      } catch (error) {
        console.warn(`Batch optimization failed for ${file.name}:`, error);
        return file; // Return original on error
      }
    }

    return file;
  });

  return Promise.all(optimizationPromises);
};

```

<!-- path: utils/zod-validation.config.ts -->
```typescript
// Configuration for smart Zod validation rules
export interface ValidationConfig {
  stringRules: StringValidationRule[];
  numberRules: NumberValidationRule[];
  customRules: CustomValidationRule[];
}

export interface StringValidationRule {
  fieldPatterns: string[]; // Field names that match this rule (supports regex)
  validation: string; // Zod validation string
  description?: string;
}

export interface NumberValidationRule {
  fieldPatterns: string[];
  validation: string;
  description?: string;
}

export interface CustomValidationRule {
  fieldName: string; // Exact field name
  tableName?: string; // Supports partial matching (e.g., "user" matches "user_profiles")
  validation: string;
  description?: string;
}

export const defaultValidationConfig: ValidationConfig = {
  stringRules: [
    {
      fieldPatterns: ['email'],
      validation: 'z.email()',
      description: 'Email format validation',
    },
    {
      fieldPatterns: ['password', 'pwd'],
      validation: `z.string()
        .min(6, "Password must be at least 6 characters long")
        .max(50, "Password must not exceed 50 characters")
        .regex(
          /^(?=.*[a-z])(?=.*[A-Z])(?=.*\\d)(?=.*[@$!%*?&])[A-Za-z\\d@$!%*?&]/,
          "Password must contain at least one uppercase letter, one lowercase letter, one number and one special character"
        )`,
      description: 'Basic password strength',
    },
    {
      fieldPatterns: ['encrypted_password'],
      validation: 'z.string().min(1, "Encrypted password cannot be empty")',
      description: 'Already encrypted passwords just need presence check',
    },
    {
      fieldPatterns: ['^id$', '.*_id$', '.*uuid.*'],
      validation: 'z.uuid()',
      description: 'UUID format validation',
    },
    {
      fieldPatterns: ['url', 'website', 'link'],
      validation: 'z.url()',
      description: 'URL format validation',
    },
    {
      fieldPatterns: ['phone', 'mobile', 'tel'],
      validation:
        'z.string().regex(/^[+]?[1-9]?[0-9]{7,15}$/, "Invalid phone number")',
      description: 'International phone number format',
    },
    {
      fieldPatterns: ['.*_at$', '.*date.*', '.*time.*'],
      validation: 'z.iso.datetime()',
      description: 'ISO datetime string validation',
    },
    {
      fieldPatterns: ['.*dob.*', '.*doj.*'],
      validation: 'z.iso.date()',
      description: 'ISO date string validation (e.g., YYYY-MM-DD)',
    },
    {
      fieldPatterns: ['token', 'jwt'],
      validation: 'z.jwt()',
      description: 'Token presence validation',
    },
    {
      fieldPatterns: ['slug'],
      validation:
        'z.string().regex(/^[a-z0-9]+(?:-[a-z0-9]+)*$/, "Invalid slug format")',
      description: 'URL-friendly slug format',
    },
    {
      fieldPatterns: ['username', 'user_name'],
      validation:
        'z.string().min(3).max(50).regex(/^[a-zA-Z0-9_]+$/, "Username can only contain letters, numbers and underscores")',
      description: 'Username format validation',
    },
    {
      fieldPatterns: ['.*name$', 'title'],
      validation:
        'z.string().min(1, "Name cannot be empty").max(255, "Name is too long")',
      description: 'Name fields validation',
    },
    {
      fieldPatterns: ['description', 'content', 'text', 'message'],
      validation: 'z.string().max(10000, "Text is too long")',
      description: 'Long text fields validation',
    },
    {
      fieldPatterns: ['.*address.*', '.*addr.*'],
      validation:
        'z.string().min(5, "Address must be at least 5 characters").max(500)',
      description: 'Address fields validation',
    },
    {
      fieldPatterns: ['ip.*', '.*ip_address.*'],
      validation: 'z.ipv4()',
      description: 'IP address format validation',
    },
    {
      fieldPatterns: ['status'],
      validation: 'z.string().min(1, "Status cannot be empty")',
      description: 'Status fields validation',
    },
  ],

  numberRules: [
    {
      fieldPatterns: ['age'],
      validation: 'z.number().int().min(0).max(150)',
      description: 'Age validation',
    },
    {
      fieldPatterns: ['count', 'quantity', 'qty'],
      validation: 'z.number().int().min(0)',
      description: 'Count/quantity validation',
    },
    {
      fieldPatterns: ['price', 'amount', 'cost', 'fee'],
      validation: 'z.number().min(0)',
      description: 'Monetary amount validation',
    },
    {
      fieldPatterns: ['rating', 'score'],
      validation: 'z.number().min(0).max(10)',
      description: 'Rating/score validation',
    },
    {
      fieldPatterns: ['percent.*', '.*_rate$'],
      validation: 'z.number().min(0).max(100)',
      description: 'Percentage validation',
    },
    {
      fieldPatterns: ['^id$', '.*_id$'],
      validation: 'z.number().int().positive()',
      description: 'Numeric ID validation',
    },
  ],

  customRules: [
    {
      fieldName: 'aud',
      tableName: 'user', // Will match "user_profiles", "users", etc.
      validation: 'z.string().min(1)',
      description: 'Supabase auth audience field',
    },
    {
      fieldName: 'role',
      tableName: 'user', // Will match "user_profiles", "users", etc.
      validation: 'z.enum(UserRole)',
      description: 'User role field using native enum',
    },
  ],
};

export function loadValidationConfig(): ValidationConfig {
  // You can load from file, environment, or database
  return defaultValidationConfig;
}

```

<!-- path: utils/distance.ts -->
```typescript
// utils/distance.ts

// Straight-Line Distance (Haversine Formula)
export function haversineDistance(
    lat1: number,
    lon1: number,
    lat2: number,
    lon2: number
  ): number {
    const R = 6371; // Radius of the Earth in km
    const dLat = (lat2 - lat1) * (Math.PI / 180);
    const dLon = (lon2 - lon1) * (Math.PI / 180);
  
    const a =
      Math.sin(dLat / 2) * Math.sin(dLat / 2) +
      Math.cos(lat1 * (Math.PI / 180)) *
        Math.cos(lat2 * (Math.PI / 180)) *
        Math.sin(dLon / 2) *
        Math.sin(dLon / 2);
  
    const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
    return R * c; // in kilometers
  }
// // Usage
// const minDist = haversineDistance(22.5726, 88.3639, 28.7041, 77.1025);
// console.log(`Distance: ${minDist.toFixed(2)} km`);

```

<!-- path: utils/renderKeyValueCell.tsx -->
```typescript
import React, { JSX } from "react";

export function renderKeyValueCell(value: unknown): JSX.Element {
  let elements: JSX.Element[] = [];

  if (value) {
    try {
      const parsedValue = typeof value === "string" ? JSON.parse(value) : value;

      if (typeof parsedValue === "object" && parsedValue !== null) {
        elements = Object.entries(parsedValue)
          .filter(([_, val]) => val !== null && val !== undefined && val !== "")
          .map(([key, val]) => (
            <div key={key} className='flex text-sm text-gray-500'>
              <span className='font-medium mr-1'>{key}:</span>
              <span>{String(val)}</span>
            </div>
          ));
      } else {
        elements = [
          <div key='single' className='text-sm text-gray-500'>
            {String(parsedValue)}
          </div>,
        ];
      }
    } catch (error) {
      elements = [
        <div key='error' className='text-sm text-gray-500'>
          {String(value)}
        </div>,
      ];
    }
  }

  return elements.length > 0 ? <div className='text-sm text-gray-500'>{elements}</div> : <div className='text-sm text-gray-500'>N/A</div>;
}

```

<!-- path: utils/index.ts -->
```typescript
// Core utilities
export { cn } from './classNames';
export { default as formatters } from './formatters';
export { default as validation } from './validationUtils';
export * from './caseConverter';

// Supabase
export { createClient } from './supabase/server';
export { createClient as createBrowserClient } from './supabase/client';

```

<!-- path: utils/supabase/admin.ts -->
```typescript
import { createClient as createAdminClient } from '@supabase/supabase-js';

// This is a server-side only client that uses the service role key
// It should only be used in API routes or server components

export function createAdmin() {
  // These environment variables should be set in your deployment environment
  const supabaseUrl = process.env.NEXT_PUBLIC_SUPABASE_URL;
  const supabaseServiceRoleKey = process.env.SUPABASE_SERVICE_ROLE_KEY;

  console.log('URL:', process.env.NEXT_PUBLIC_SUPABASE_URL);
  console.log('Service key:', process.env.SUPABASE_SERVICE_ROLE_KEY ? 'exists' : 'missing');

  if (!supabaseUrl || !supabaseServiceRoleKey) {
    throw new Error(
      'Missing required environment variables: NEXT_PUBLIC_SUPABASE_URL and SUPABASE_SERVICE_ROLE_KEY must be set'
    );
  }

  return createAdminClient(supabaseUrl, supabaseServiceRoleKey, {
    auth: {
      autoRefreshToken: false,
      persistSession: false,
      detectSessionInUrl: false,
    },
  });
}

```

<!-- path: utils/supabase/client.ts -->
```typescript
// utils/supabase/client.ts

import { createBrowserClient } from '@supabase/ssr'

export function createClient() {
  return createBrowserClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!
  )
}
```

<!-- path: utils/supabase/server.ts -->
```typescript
 
import { createServerClient } from '@supabase/ssr'
import { cookies } from 'next/headers'
 
export async function createClient() {
  const cookieStore = await cookies()
 
  // Create a server's supabase client with newly configured cookie,
  // which could be used to maintain user's session
  return createServerClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,
    {
      cookies: {
        getAll() {
          return cookieStore.getAll()
        },
        setAll(cookiesToSet) {
          try {
            cookiesToSet.forEach(({ name, value, options }) =>
              cookieStore.set(name, value, options)
            )
          } catch {
            // The `setAll` method was called from a Server Component.
            // This can be ignored if you have middleware refreshing
            // user sessions.
          }
        },
      },
    }
  )
}
```

<!-- path: utils/supabase/middleware.ts -->
```typescript
 
import { createServerClient } from '@supabase/ssr'
import { NextResponse, type NextRequest } from 'next/server'
 
export async function updateSession(request: NextRequest) {
  let supabaseResponse = NextResponse.next({
    request,
  })
 
  const supabase = createServerClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,
    {
      cookies: {
        getAll() {
          return request.cookies.getAll()
        },
        setAll(cookiesToSet) {
          // eslint-disable-next-line @typescript-eslint/no-unused-vars
          cookiesToSet.forEach(({ name, value, options }) => request.cookies.set(name, value))
          supabaseResponse = NextResponse.next({
            request,
          })
          cookiesToSet.forEach(({ name, value, options }) =>
            supabaseResponse.cookies.set(name, value, options)
          )
        },
      },
    }
  )
 
  // refreshing the auth token
  await supabase.auth.getUser()
 
  return supabaseResponse
}
```

<!-- path: next-env.d.ts -->
```typescript
/// <reference types="next" />
/// <reference types="next/image-types/global" />
/// <reference path="./.next/types/routes.d.ts" />

// NOTE: This file should not be edited
// see https://nextjs.org/docs/app/api-reference/config/typescript for more information.

```

<!-- path: public/sw.js -->
```javascript
self.addEventListener('push', function (event) {
  if (event.data) {
    const data = event.data.json()
    const options = {
      body: data.body,
      icon: data.icon || '/icon.png',
      badge: '/badge.png',
      vibrate: [100, 50, 100],
      data: {
        dateOfArrival: Date.now(),
        primaryKey: '2',
      },
    }
    event.waitUntil(self.registration.showNotification(data.title, options))
  }
})
 
self.addEventListener('notificationclick', function (event) {
  // console.log('Notification click received.')
  event.notification.close()
  event.waitUntil(clients.openWindow('<https://hnvtx.vercel.app>'))
})
```

<!-- path: components/lookup/lookup-hooks.ts -->
```typescript
import { useRouter, useSearchParams } from "next/navigation";
import { useCallback, useState } from "react";
import { toast } from "sonner";
import { createClient } from "@/utils/supabase/client";
import { useDeduplicated, useTableDelete, useTableQuery, useToggleStatus } from "@/hooks/database";
import { Lookup_typesUpdateSchema } from "@/schemas/zod-schemas";

export function useLookupTypes(initialCategory = "") {
  const router = useRouter();
  const searchParams = useSearchParams();
  const [selectedCategory, setSelectedCategory] = useState(initialCategory || searchParams.get("category") || "");
  const [isLookupModalOpen, setIsLookupModalOpen] = useState(false);
  const [searchTerm, setSearchTerm] = useState("");
  const [editingLookup, setEditingLookup] = useState<Lookup_typesUpdateSchema | null>(null);

  const supabase = createClient();

  // Database hooks
  const {
    data: categories = [],
    isLoading: categoriesLoading,
    error: categoriesError,
    refetch: refetchCategories
  } = useDeduplicated(supabase, "lookup_types", {
    columns: ["category"],
    orderBy: [{ column: "created_at", ascending: true }],
  });

  const {
    data: lookupTypes = [],
    isLoading: lookupLoading,
    error: lookupError,
    refetch: refetchLookups
  } = useTableQuery(supabase, "lookup_types", {
    orderBy: [{ column: "name", ascending: true }],
    filters: {
      name: { operator: "neq", value: "DEFAULT" },
      ...(selectedCategory && { 
        category: { operator: "eq", value: selectedCategory } 
      })
    }
  });

  const { mutate: toggleStatus } = useToggleStatus(supabase, "lookup_types");
  const { mutate: deleteRowsById } = useTableDelete(supabase, "lookup_types");

  // Derived state
  const hasCategories = categories.length > 0;
  const hasSelectedCategory = !!selectedCategory;
  const isLoading = categoriesLoading || lookupLoading;
  
  const filteredLookups = lookupTypes
    .filter(lookup => 
      lookup.name.toLowerCase().includes(searchTerm.toLowerCase()) ||
      lookup.code?.toLowerCase().includes(searchTerm.toLowerCase()) ||
      lookup.description?.toLowerCase().includes(searchTerm.toLowerCase())
    );

  // Handlers
  const handleCategoryChange = useCallback((category: string) => {
    setSelectedCategory(category);
    setSearchTerm("");
    router.push(`/dashboard/lookup${category ? `?category=${category}` : ''}`);
  }, [router]);

  const handleRefresh = useCallback(async () => {
    try {
      await Promise.all([refetchCategories(), refetchLookups()]);
      toast.success("Data refreshed successfully");
    } catch (error) {
      console.log(error);
      toast.error("Failed to refresh data");
    }
  }, [refetchCategories, refetchLookups]);

  const handleAddNew = useCallback(() => {
    if (!hasSelectedCategory) {
      toast.error("Please select a category first");
      return;
    }
    setEditingLookup(null);
    setIsLookupModalOpen(true);
  }, [hasSelectedCategory]);

  const handleEdit = useCallback((lookup: Lookup_typesUpdateSchema) => {
    setEditingLookup(lookup);
    setIsLookupModalOpen(true);
  }, []);

  const handleDelete = useCallback((id: string) => {
    deleteRowsById([id], {
      onSuccess: () => {
        toast.success("Lookup type deleted successfully");
        refetchLookups();
      },
      onError: (error: Error) => {
        toast.error(`Failed to delete lookup type: ${error.message}`);
      }
    });
  }, [deleteRowsById, refetchLookups]);

  const handleToggleStatus = useCallback((id: string, currentStatus: boolean) => {
    toggleStatus({ id, status: !currentStatus }, {
      onSuccess: () => {
        toast.success(`Lookup type ${currentStatus ? 'deactivated' : 'activated'} successfully`);
        refetchLookups();
      },
      onError: (error: Error) => {
        toast.error(`Failed to toggle status: ${error.message}`);
      }
    });
  }, [toggleStatus, refetchLookups]);

  const handleModalClose = useCallback(() => {
    setIsLookupModalOpen(false);
    setEditingLookup(null);
  }, []);

  const handleLookupCreated = useCallback(() => {
    toast.success("Lookup type created successfully");
    refetchLookups();
    handleModalClose();
  }, [refetchLookups, handleModalClose]);

  const handleLookupUpdated = useCallback(() => {
    toast.success("Lookup type updated successfully");
    refetchLookups();
    handleModalClose();
  }, [refetchLookups, handleModalClose]);

  return {
    state: {
      selectedCategory,
      isLookupModalOpen,
      searchTerm,
      editingLookup,
      categories,
      lookupTypes: filteredLookups,
      isLoading,
      hasCategories,
      hasSelectedCategory,
      categoriesError,
      lookupError
    },
    handlers: {
      setSearchTerm,
      handleCategoryChange,
      handleRefresh,
      handleAddNew,
      handleEdit,
      handleDelete,
      handleToggleStatus,
      handleModalClose,
      handleLookupCreated,
      handleLookupUpdated
    }
  };
}
```

<!-- path: components/lookup/lookup-types.ts -->
```typescript
// export interface LookupType {
//     id: string;
//     category: string;
//     name: string;
//     code: string | null;
//     description: string | null;
//     sort_order: number | null;
//     status: boolean | null;
//     is_system_default: boolean | null;
//     created_at: string | null;
//     updated_at: string | null;
//   }
  
  export interface LookupTypesPageProps {
    initialCategory?: string;
  }
```

<!-- path: components/lookup/LookupModal.tsx -->
```typescript
"use client";

import { Button } from "@/components/common/ui/Button";
import { Input } from "@/components/common/ui/Input";
import { Modal } from "@/components/common/ui/Modal";
import { useTableInsert, useTableUpdate } from "@/hooks/database";
import { lookup_typesInsertSchema, Lookup_typesInsertSchema, Lookup_typesRowSchema, Lookup_typesUpdateSchema } from "@/schemas/zod-schemas";
import { snakeToTitleCase } from "@/utils/formatters";
import { createClient } from "@/utils/supabase/client";
import { zodResolver } from "@hookform/resolvers/zod";
import { useCallback, useEffect } from "react";
import { useForm } from "react-hook-form";
import { toast } from "sonner";
import z from "zod";

interface LookupModalProps {
  isOpen: boolean;
  onClose: () => void;
  onLookupCreated?: (lookupData: Lookup_typesInsertSchema) => void;
  onLookupUpdated?: (lookupData: Lookup_typesUpdateSchema) => void;
  editingLookup?: Lookup_typesUpdateSchema | null;
  category?: string;
  categories?: Lookup_typesRowSchema[];
}

// Add this function to extract unique categories
const getUniqueCategories = (data?: Lookup_typesRowSchema[]) => {
  if (!data) return [];

  const categoriesSet = new Set<string>();
  data.forEach(item => {
    if (item.category) {
      categoriesSet.add(item.category);
    }
  });

  return Array.from(categoriesSet).sort();
};

export function LookupModal({
  isOpen,
  onClose,
  onLookupCreated,
  onLookupUpdated,
  editingLookup,
  category,
  categories,
}: LookupModalProps) {
  // Database hooks
  const supabase = createClient();
  const { mutate: createLookup } = useTableInsert(supabase, "lookup_types");
  const { mutate: updateLookup } = useTableUpdate(supabase, "lookup_types");

  // console.log("categories", categories);

  const isEditMode = Boolean(editingLookup);

  // Extract unique categories
  const uniqueCategories = getUniqueCategories(categories);
  // console.log("uniqueCategories", uniqueCategories);

  // Create a form-specific schema
  const lookupTypeFormSchema = lookup_typesInsertSchema.pick({
    category: true,
    code: true,
    description: true,
    name: true,
    sort_order: true,
    is_system_default: true,
    status: true,
  });
  type LookupTypeFormData = z.infer<typeof lookupTypeFormSchema>;

  // react-hook-form setup with better default values
  const {
    register,
    handleSubmit,
    formState: { errors, isSubmitting },
    reset,
    watch,
    setValue,
  } = useForm<LookupTypeFormData>({
    resolver: zodResolver(lookupTypeFormSchema),
    defaultValues: {
      category: "",
      code: "",
      description: "",
      name: "",
      sort_order: 0,
      is_system_default: false,
      status: true,
    },
  });

  // Reset form when modal opens/closes or editing changes
  useEffect(() => {
    if (isOpen) {
      const resetData: LookupTypeFormData = {
        category: editingLookup?.category || category || "",
        code: editingLookup?.code || "",
        description: editingLookup?.description || "",
        name: editingLookup?.name || "",
        sort_order: editingLookup?.sort_order || 0,
        is_system_default: editingLookup?.is_system_default || false,
        status: editingLookup?.status !== false,
      };

      reset(resetData);
    }
  }, [isOpen, editingLookup, category, reset]); // Ensure setValue is not in this array if you have it

  const onValidSubmit = useCallback(
    async (data: LookupTypeFormData) => {
      try {
        const submissionData: LookupTypeFormData = {
          ...data,
          code: data.code?.trim() || null,
          description: data.description?.trim() || null,
          name: data.name?.trim(),
          category: data.category?.trim(),
        };

        if (isEditMode && editingLookup?.id) {
          // Update existing lookup
          updateLookup(
            {
              id: editingLookup.id,
              data: submissionData,
            },
            {
              onSuccess: (updatedData) => {
                onLookupUpdated?.(updatedData as Lookup_typesUpdateSchema);
                onClose();
              },
              onError: (error) => {
                console.error("Error updating lookup type:", error);
                toast.error("Failed to update lookup type");
              },
            }
          );
        } else {
          // Create new lookup
          createLookup(submissionData, {
            onSuccess: (createdData) => {
              onLookupCreated?.(createdData as unknown as Lookup_typesInsertSchema);
              onClose();
            },
            onError: (error) => {
              console.error("Error creating lookup type:", error);
              toast.error("Failed to create lookup type");
            },
          });
        }
      } catch (error) {
        console.error("Error submitting lookup type:", error);
        toast.error("Failed to submit lookup type");
      }
    },
    [
      isEditMode,
      editingLookup,
      updateLookup,
      createLookup,
      onLookupUpdated,
      onLookupCreated,
      onClose,
    ]
  );

  const modalTitle = isEditMode ? "Edit Lookup Type" : "Add Lookup Type";
  const submitButtonText = isEditMode
    ? isSubmitting
      ? "Updating..."
      : "Update Lookup Type"
    : isSubmitting
    ? "Creating..."
    : "Create Lookup Type";

  const canSubmit = Boolean(
    watch("category")?.trim() && watch("name")?.trim() && !isSubmitting
  );

  // Watch values for debugging
  const watchedCategory = watch("category");
  const watchedName = watch("name");
  const watchedCode = watch("code");

  // console.log("category prop:", category);
  // console.log("editingLookup:", editingLookup);

  return (
    <Modal isOpen={isOpen} onClose={onClose} title={modalTitle} visible={false}
      className="h-screen w-screen transparent bg-gray-700 rounded-2xl">
      <form onSubmit={handleSubmit(onValidSubmit)} className="space-y-4">
        <div className="grid grid-cols-1 gap-4 md:grid-cols-2">
          <div className="md:col-span-2">
            <label htmlFor="category" className="mb-2 block text-sm font-medium text-gray-700 dark:text-gray-300">
              Category <span className="text-red-500 dark:text-red-400">*</span>
            </label>

            {isEditMode || category ? (
              // Read-only category in edit mode or when category is provided
              <div className="space-y-1">
                <Input
                  type="text"
                  {...register("category")}
                  readOnly
                  className="bg-gray-50 dark:bg-gray-700 text-gray-900 dark:text-gray-100 border-gray-300 dark:border-gray-600"
                  value={watchedCategory || ""}
                />
                {errors.category && (
                  <p className="text-xs text-red-500 dark:text-red-400 mt-1">
                    {errors.category.message}
                  </p>
                )}
                <p className="text-xs text-gray-500 dark:text-gray-400">
                  {isEditMode
                    ? "Category cannot be changed when editing"
                    : "Category is set from parent"}
                </p>
              </div>
            ) : (
              // Category selection for create mode
              <div className="space-y-2">
                <select
                  {...register("category")}
                  className={`w-full rounded-md border px-3 py-2 bg-white dark:bg-gray-800 text-gray-900 dark:text-gray-100 focus:ring-2 focus:ring-blue-500 focus:outline-none ${
                    errors.category
                      ? "border-red-300 dark:border-red-600"
                      : "border-gray-300 dark:border-gray-600"
                  }`}
                  disabled={isSubmitting}
                  value={watchedCategory || ""}
                  onChange={(e) => setValue("category", e.target.value)}
                >
                  <option value="">Select category...</option>
                  {uniqueCategories.map((cat) => (
                    <option key={cat} value={cat}>
                      {snakeToTitleCase(cat)}
                    </option>
                  ))}
                </select>

                {errors.category && (
                  <p className="text-xs text-red-500 dark:text-red-400 mt-1">
                    {errors.category.message}
                  </p>
                )}
              </div>
            )}
          </div>

          {/* Name Field */}
          <div className="md:col-span-2">
            <label htmlFor="name" className="mb-2 block text-sm font-medium text-gray-700 dark:text-gray-300">
              Name <span className="text-red-500 dark:text-red-400">*</span>
            </label>
            <Input
              type="text"
              {...register("name")}
              placeholder="Enter lookup name"
              disabled={isSubmitting}
              value={watchedName || ""}
              onChange={(e) => setValue("name", e.target.value)}
              className={`${
                errors.name ? "border-red-300 dark:border-red-600" : ""
              } dark:bg-gray-800 dark:border-gray-600 dark:text-white dark:placeholder-gray-400`}
            />
            {errors.name && (
              <p className="text-xs text-red-500 dark:text-red-400 mt-1">
                {errors.name.message}
              </p>
            )}
          </div>

          {/* Code Field */}
          <div>
            <label htmlFor="code" className="mb-2 block text-sm font-medium text-gray-700 dark:text-gray-300">
              Code
            </label>
            <Input
              type="text"
              id="code"
              {...register("code")}
              placeholder="Enter code (optional)"
              value={watchedCode || ""}
              disabled={isSubmitting}
              onChange={(e) => setValue("code", e.target.value)}
              className={`${
                errors.code ? "border-red-300 dark:border-red-600" : ""
              } dark:bg-gray-800 dark:border-gray-600 dark:text-white dark:placeholder-gray-400`}
            />
            {errors.code && (
              <p className="text-xs text-red-500 dark:text-red-400 mt-1">
                {errors.code.message}
              </p>
            )}
          </div>

          {/* Sort Order Field */}
          <div>
            <label htmlFor="sort_order" className="mb-2 block text-sm font-medium text-gray-700 dark:text-gray-300">
              Sort Order
            </label>
            <Input
              type="number"
              id="sort_order"
              {...register("sort_order", { valueAsNumber: true })}
              placeholder="0"
              disabled={isSubmitting}
              min="0"
              className={`${
                errors.sort_order ? "border-red-300 dark:border-red-600" : ""
              } dark:bg-gray-800 dark:border-gray-600 dark:text-white`}
            />
            {errors.sort_order && (
              <p className="text-xs text-red-500 dark:text-red-400 mt-1">
                {errors.sort_order.message}
              </p>
            )}
          </div>

          {/* Description Field */}
          <div className="md:col-span-2">
            <label htmlFor="description" className="mb-2 block text-sm font-medium text-gray-700 dark:text-gray-300">
              Description
            </label>
            <textarea
              className="w-full rounded-md border border-gray-300 dark:border-gray-600 bg-white dark:bg-gray-800 text-gray-900 dark:text-gray-100 px-3 py-2 text-sm focus:border-blue-500 focus:outline-none focus:ring-1 focus:ring-blue-500 dark:focus:border-blue-400 dark:focus:ring-blue-400"
              rows={3}
              {...register("description")}
              placeholder="Enter description (optional)"
              disabled={isSubmitting}
            />
            {errors.description && (
              <p className="text-xs text-red-500 dark:text-red-400 mt-1">
                {errors.description.message}
              </p>
            )}
          </div>

          {/* Checkboxes */}
          <div className="md:col-span-2 space-y-3">
            <div className="flex items-center">
              <input
                type="checkbox"
                id="is_system_default"
                {...register("is_system_default")}
                disabled={
                  isSubmitting ||
                  (isEditMode && !!editingLookup?.is_system_default)
                }
                className="h-4 w-4 rounded border-gray-300 dark:border-gray-600 bg-white dark:bg-gray-800 text-blue-600 focus:ring-blue-500 dark:focus:ring-blue-400 dark:ring-offset-gray-800"
              />
              <label
                htmlFor="is_system_default"
                className="ml-2 text-sm text-gray-700 dark:text-gray-300"
              >
                System Default
                {isEditMode && editingLookup?.is_system_default && (
                  <span className="ml-1 text-xs text-gray-500 dark:text-gray-400">
                    (cannot be changed)
                  </span>
                )}
              </label>
            </div>

            <div className="flex items-center">
              <input
                type="checkbox"
                id="status"
                {...register("status")}
                disabled={isSubmitting}
                className="h-4 w-4 rounded border-gray-300 dark:border-gray-600 bg-white dark:bg-gray-800 text-blue-600 focus:ring-blue-500 dark:focus:ring-blue-400 dark:ring-offset-gray-800"
              />
              <label
                htmlFor="status"
                className="ml-2 text-sm text-gray-700 dark:text-gray-300"
              >
                Active Status
              </label>
            </div>
          </div>
        </div>

        {/* Information Cards */}
        {isEditMode ? (
          <div className="rounded-md border border-amber-200 dark:border-amber-800 bg-amber-50 dark:bg-amber-900/20 p-3">
            <h4 className="mb-1 text-sm font-medium text-amber-900 dark:text-amber-200">
              Edit Mode Notes:
            </h4>
            <ul className="space-y-1 text-xs text-amber-800 dark:text-amber-200/80">
              <li> Category field cannot be changed after creation</li>
              <li> System default status cannot be removed once set</li>
              <li> Updated timestamp will be set automatically</li>
            </ul>
          </div>
        ) : (
          <div className="rounded-md border border-blue-200 dark:border-blue-800 bg-blue-50 dark:bg-blue-900/20 p-3">
            <h4 className="mb-1 text-sm font-medium text-blue-900 dark:text-blue-200">
              {category ? "Adding to Lookup" : "Creating New Lookup Type"}
            </h4>
            <ul className="space-y-1 text-xs text-blue-800 dark:text-blue-200/80">
              <li> Timestamps will be set automatically</li>
              <li> ID will be generated automatically</li>
              {!category && (
                <li> Select an existing category or create a new one</li>
              )}
            </ul>
          </div>
        )}

        {/* Form Actions */}
        <div className="flex justify-end gap-2 pt-4">
          <Button
            type="button"
            variant="outline"
            onClick={onClose}
            disabled={isSubmitting}
            className="dark:border-gray-600 dark:hover:bg-gray-700"
          >
            Cancel
          </Button>
          <Button type="submit" disabled={!canSubmit}>
            {submitButtonText}
          </Button>
        </div>
      </form>
    </Modal>
  );
}

```

<!-- path: components/lookup/LookupTypesEmptyStates.tsx -->
```typescript
"use client";

import { Card } from "@/components/common/ui/card";
import { Button } from "@/components/common/ui/Button";
import { FiPlus } from "react-icons/fi";
import { useRouter } from "next/navigation";
import { LoadingSpinner } from "@/components/common/ui/LoadingSpinner";

export function NoCategoriesState({ error, isLoading }: { error?: Error; isLoading: boolean }) {
  const router = useRouter();
  
  return (
    <Card className="p-8 text-center">
      <p className="mb-4 text-gray-500 dark:text-gray-400">
        {isLoading ? "Loading categories..." : "No categories found."}
      </p>
      {error && (
        <p className="mb-4 text-red-500 dark:text-red-400">
          Error: {error.message}
        </p>
      )}
      <Button onClick={() => router.push('/dashboard/categories')}>
        <FiPlus className="mr-2 h-4 w-4" />
        Manage Categories
      </Button>
    </Card>
  );
}

export function SelectCategoryPrompt() {
  return (
    <Card className="p-8 text-center dark:bg-gray-800">
      <p className="text-gray-500 dark:text-gray-400">
        Please select a category to view lookup types.
      </p>
    </Card>
  );
}

export function LoadingState({ selectedCategory }: { selectedCategory: string }) {
  return (
    <div className="flex justify-center py-8">
      <LoadingSpinner />
      <span className="ml-2 text-gray-600 dark:text-gray-400">
        Loading lookup types for {`"${selectedCategory}"`}...
      </span>
    </div>
  );
}

export function ErrorState({ error, onRetry }: { error: Error; onRetry: () => void }) {
  return (
    <Card className="border-red-200 dark:border-red-800 bg-red-50 dark:bg-red-900/20 p-4">
      <p className="text-red-600 dark:text-red-400">
        Error loading lookup types: {error.message}
      </p>
      <Button
        onClick={onRetry}
        variant="outline"
        className="mt-2"
      >
        Retry
      </Button>
    </Card>
  );
}
```

<!-- path: components/lookup/LookupTypesTable.tsx -->
```typescript
"use client";

import { Button } from "@/components/common/ui/Button";
import { FiEdit2, FiTrash2, FiChevronUp, FiChevronDown } from "react-icons/fi";
import { useMemo } from "react";
import { SortDirection } from "@/hooks/useSorting";
import { Lookup_typesRowSchema } from "@/schemas/zod-schemas";

interface LookupTypesTableProps {
  lookups: Lookup_typesRowSchema[];
  onEdit: (lookup: Lookup_typesRowSchema) => void;
  onDelete: (id: string) => void;
  onToggleStatus: (id: string, currentStatus: boolean) => void;
  selectedCategory: string;
  searchTerm: string;
  onSort?: (key: string) => void;
  getSortDirection?: (key: string) => SortDirection;
}

interface SortableHeaderProps {
  children: React.ReactNode;
  sortKey: string;
  onSort?: (key: string) => void;
  getSortDirection?: (key: string) => SortDirection;
  className?: string;
}

function SortableHeader({ 
  children, 
  sortKey, 
  onSort, 
  getSortDirection, 
  className = "" 
}: SortableHeaderProps) {
  const sortDirection = getSortDirection?.(sortKey);
  const isSortable = onSort && getSortDirection;

  const handleClick = () => {
    if (onSort) {
      onSort(sortKey);
    }
  };

  if (!isSortable) {
    return (
      <th className={`px-6 py-3 text-left text-xs font-medium tracking-wider text-gray-500 dark:text-gray-400 uppercase ${className}`}>
        {children}
      </th>
    );
  }

  return (
    <th 
      className={`px-6 py-3 text-left text-xs font-medium tracking-wider text-gray-500 dark:text-gray-400 uppercase cursor-pointer hover:bg-gray-100 dark:hover:bg-gray-700 transition-colors select-none ${className}`}
      onClick={handleClick}
      role="button"
      tabIndex={0}
      onKeyDown={(e) => {
        if (e.key === 'Enter' || e.key === ' ') {
          e.preventDefault();
          handleClick();
        }
      }}
      title={`Sort by ${String(children).toLowerCase()}`}
    >
      <div className="flex items-center justify-between group">
        <span>{children}</span>
        <div className="flex flex-col ml-1">
          {sortDirection === 'asc' ? (
            <FiChevronUp className="h-3 w-3 text-blue-500" />
          ) : sortDirection === 'desc' ? (
            <FiChevronDown className="h-3 w-3 text-blue-500" />
          ) : (
            <div className="opacity-0 group-hover:opacity-50 transition-opacity">
              <FiChevronUp className="h-3 w-3" />
            </div>
          )}
        </div>
      </div>
    </th>
  );
}

export function LookupTypesTable({
  lookups,
  onEdit,
  onDelete,
  onToggleStatus,
  selectedCategory,
  searchTerm,
  onSort,
  getSortDirection
}: LookupTypesTableProps) {

  // Filter lookups based on search term (if not already filtered externally)
  const filteredLookups = useMemo(() => {
    if (!searchTerm.trim()) return lookups;
    
    const lowerSearchTerm = searchTerm.toLowerCase();
    return lookups.filter(lookup => 
      lookup.name?.toLowerCase().includes(lowerSearchTerm) ||
      lookup.code?.toLowerCase().includes(lowerSearchTerm) ||
      lookup.description?.toLowerCase().includes(lowerSearchTerm)
    );
  }, [lookups, searchTerm]);

  const displayedLookups = searchTerm ? filteredLookups : lookups;

  return (
    <div className="overflow-x-auto">
      <table className="w-full">
        <thead className="bg-gray-50 dark:bg-gray-800">
          <tr>
            <SortableHeader 
              sortKey="name" 
              onSort={onSort} 
              getSortDirection={getSortDirection}
            >
              Name
            </SortableHeader>
            <SortableHeader 
              sortKey="code" 
              onSort={onSort} 
              getSortDirection={getSortDirection}
            >
              Short Code
            </SortableHeader>
            <SortableHeader 
              sortKey="description" 
              onSort={onSort} 
              getSortDirection={getSortDirection}
            >
              Description
            </SortableHeader>
            <SortableHeader 
              sortKey="status" 
              onSort={onSort} 
              getSortDirection={getSortDirection}
            >
              Status
            </SortableHeader>
            <th className="px-6 py-3 text-left text-xs font-medium tracking-wider text-gray-500 dark:text-gray-400 uppercase">
              Actions
            </th>
          </tr>
        </thead>
        <tbody className="divide-y divide-gray-200 dark:divide-gray-700 bg-white dark:bg-gray-900">
          {displayedLookups.map((lookup) => (
            <tr key={lookup.id} className="hover:bg-gray-50 dark:hover:bg-gray-800">
              <td className="px-6 py-4 text-sm font-medium text-gray-900 dark:text-gray-100 max-w-[150px] break-words">
                {lookup.name ?? "-"}
              </td>
              <td className="px-6 py-4 text-sm whitespace-nowrap text-gray-500 dark:text-gray-400">
                {lookup.code || "-"}
              </td>
              <td className="px-6 py-4 text-sm text-gray-500 dark:text-gray-400 max-w-xs break-words">
                {lookup.description || "-"}
              </td>
              <td className="px-6 py-4 whitespace-nowrap">
                <Button
                  variant="ghost"
                  onClick={() => onToggleStatus(lookup.id!, !!lookup.status)}
                  className={`inline-flex rounded-full px-2 py-1 text-xs font-semibold ${
                    lookup.status
                      ? "bg-green-100 dark:bg-green-900/30 text-green-800 dark:text-green-300 hover:bg-green-200 dark:hover:bg-green-900/50"
                      : "bg-red-100 dark:bg-red-900/30 text-red-800 dark:text-red-300 hover:bg-red-200 dark:hover:bg-red-900/50"
                  }`}
                  disabled={!!lookup.is_system_default}
                >
                  {lookup.status ? "Active" : "Inactive"}
                </Button>
              </td>
              <td className="px-6 py-4 text-sm font-medium whitespace-nowrap">
                <div className="flex items-center gap-2">
                  <Button
                    size="sm"
                    variant="outline"
                    disabled={!!lookup.is_system_default}
                    onClick={() => onEdit(lookup)}
                    title={
                      lookup.is_system_default
                        ? "Cannot edit system default"
                        : "Edit"
                    }
                    className="hover:text-blue-600 dark:hover:text-blue-400"
                  >
                    <FiEdit2 className="h-4 w-4" />
                  </Button>
                  <Button
                    size="sm"
                    variant="outline"
                    onClick={() => {
                      if (confirm(`Are you sure you want to delete "${lookup.name}"?`)) {
                        onDelete(lookup.id!);
                      }
                    }}
                    className="text-red-600 dark:text-red-400 hover:text-red-800 dark:hover:text-red-300"
                    disabled={!!lookup.is_system_default}
                    title={
                      lookup.is_system_default
                        ? "Cannot delete system default"
                        : "Delete"
                    }
                  >
                    <FiTrash2 className="h-4 w-4" />
                  </Button>
                </div>
              </td>
            </tr>
          ))}
        </tbody>
      </table>

      {displayedLookups.length === 0 && (
        <div className="py-8 text-center text-gray-500 dark:text-gray-400">
          {searchTerm
            ? `No lookup types found matching "${searchTerm}" in category "${selectedCategory}".`
            : `No lookup types found for category "${selectedCategory}".`}
        </div>
      )}

      {/* Optional: Show sorting/filtering info */}
      {(searchTerm || (getSortDirection && Object.values(['name', 'code', 'description', 'status']).some(key => getSortDirection(key)))) && (
        <div className="px-6 py-2 text-xs text-gray-500 dark:text-gray-400 bg-gray-50 dark:bg-gray-800 border-t border-gray-200 dark:border-gray-700">
          {searchTerm && (
            <span>Filtered by: &quot;{searchTerm}&quot;  </span>
          )}
          {getSortDirection && (() => {
            const sortedColumn = ['name', 'code', 'description', 'status'].find(key => getSortDirection(key));
            const sortDirection = sortedColumn ? getSortDirection(sortedColumn) : null;
            return sortedColumn && sortDirection ? (
              <span>Sorted by: {sortedColumn} ({sortDirection})</span>
            ) : null;
          })()}
        </div>
      )}
    </div>
  );
}
```

<!-- path: components/lookup/index.tsx -->
```typescript
export * from "./lookup-types";
export * from "./lookup-hooks";
export * from "./LookupModal";
export * from "./LookupTypesEmptyStates";
export * from "./LookupTypesFilters";

```

<!-- path: components/lookup/LookupTypesFilters.tsx -->
```typescript
"use client";

import { Input } from "@/components/common/ui/Input";
import { FiSearch } from "react-icons/fi";
import { snakeToTitleCase } from "@/utils/formatters";

interface LookupTypesFiltersProps {
  categories: Array<{ id: string; category: string }>;
  selectedCategory: string;
  onCategoryChange: (category: string) => void;
  searchTerm: string;
  onSearchTermChange: (term: string) => void;
  hasSelectedCategory: boolean;
}

export function LookupTypesFilters({
  categories,
  selectedCategory,
  onCategoryChange,
  searchTerm,
  onSearchTermChange,
  hasSelectedCategory
}: LookupTypesFiltersProps) {
  return (
    <div className="flex flex-col gap-4 sm:flex-row">
      <div className="flex-1">
        <label className="mb-2 block text-sm font-medium text-gray-700 dark:text-gray-300">
          Select Category
        </label>
        <select
          value={selectedCategory}
          onChange={(e) => onCategoryChange(e.target.value)}
          className="w-full rounded-md border border-gray-300 dark:border-gray-600 bg-white dark:bg-gray-800 px-3 py-2 text-gray-900 dark:text-gray-100 focus:ring-2 focus:ring-blue-500 focus:outline-none"
        >
          <option value="">Select a category</option>
          {categories.map((category) => (
            <option key={category.id} value={category.category}>
              {snakeToTitleCase(category.category)} ({category.category})
            </option>
          ))}
        </select>
      </div>

      <div className="flex-1">
        <label className="mb-2 block text-sm font-medium text-gray-700 dark:text-gray-300">
          Search
        </label>
        <div className="relative">
          <FiSearch className="absolute top-1/2 left-3 h-4 w-4 -translate-y-1/2 transform text-gray-400 dark:text-gray-500" />
          <Input
            type="text"
            placeholder="Search lookup types..."
            value={searchTerm}
            onChange={(e) => onSearchTermChange(e.target.value)}
            className="pl-10 dark:bg-gray-800 dark:text-gray-100"
            disabled={!hasSelectedCategory}
          />
        </div>
      </div>
    </div>
  );
}
```

<!-- path: components/navigation/sidebar.tsx -->
```typescript
"use client";

import { AnimatePresence, motion } from "framer-motion";
import { usePathname } from "next/navigation";
import { memo, useState, useCallback, useEffect } from "react";
import useIsMobile from "@/hooks/useIsMobile";

import { NavItem } from "@/components/navigation/sidebar-components/NavItem";
import { QuickActions } from "@/components/navigation/sidebar-components/QuickActions";
import { HoverMenu } from "@/components/navigation/sidebar-components/HoverMenu";
import { MobileSidebar } from "@/components/navigation/sidebar-components/MobileSidebar";
import { SidebarProps, NavItem as NavItemType, sidebarVariants, contentVariants } from "@/components/navigation/sidebar-components/sidebar-types";
import NavItems from "./sidebar-components/NavItems";
import { FiMenu, FiX } from "react-icons/fi";

const Sidebar = memo(({ isCollapsed, setIsCollapsed, showMenuFeatures }: SidebarProps) => {
  const pathname = usePathname();
  const [expandedItems, setExpandedItems] = useState<string[]>([]);
  const [hoveredItem, setHoveredItem] = useState<NavItemType | null>(null);
  const isMobile = useIsMobile();

  // Close mobile sidebar on route changes
  useEffect(() => {
    if (isMobile) {
      setIsCollapsed(true);
    }
  }, [pathname, isMobile, setIsCollapsed]);

  // Close hover menu when sidebar expands
  useEffect(() => {
    if (!isCollapsed) {
      setHoveredItem(null);
    }
  }, [isCollapsed]);

  

  const toggleExpanded = useCallback((id: string) => {
    setExpandedItems((prev) => (prev.includes(id) ? prev.filter((item) => item !== id) : [...prev, id]));
  }, []);


  if (isMobile) {
    return (
      <MobileSidebar
        isCollapsed={isCollapsed}
        setIsCollapsed={setIsCollapsed}
        navItems={NavItems()}
        expandedItems={expandedItems}
        toggleExpanded={toggleExpanded}
        setHoveredItem={setHoveredItem}
        pathname={pathname}
      />
    );
  }

  return (
    <motion.aside
      initial={false}
      animate={isCollapsed ? "collapsed" : "expanded"}
      variants={sidebarVariants}
      transition={{ duration: 0.3, ease: "easeInOut" }}
      className='fixed top-0 left-0 z-50 flex h-full flex-col border-r border-gray-200 bg-white shadow-lg dark:border-gray-800 dark:bg-gray-900 dark:text-white'>
      <div className='flex h-16 items-center justify-between border-b border-gray-200 px-4 dark:border-gray-800'>
        <AnimatePresence mode='wait'>
          {!isCollapsed && (
            <motion.h2 initial='hidden' animate='visible' exit='exit' variants={contentVariants} transition={{ duration: 0.2 }} className='text-lg font-semibold text-gray-900 dark:text-gray-100'>
              Navigation
            </motion.h2>
          )}
        </AnimatePresence>

        <button onClick={() => setIsCollapsed(!isCollapsed)} className='rounded-lg p-2 transition-colors hover:bg-gray-100 dark:hover:bg-gray-800' aria-label={isCollapsed ? "Expand sidebar" : "Collapse sidebar"}>
          <motion.div animate={{ rotate: isCollapsed ? 180 : 0 }} transition={{ duration: 0.2 }}>
            {isCollapsed ? <FiMenu className='h-5 w-5' /> : <FiX className='h-5 w-5' />}
          </motion.div>
        </button>
      </div>

      <div className='flex-1 overflow-y-auto py-4'>
        <nav className='space-y-1' role='navigation'>
          {NavItems().map((item) => (
            <NavItem key={item.id} item={item} isCollapsed={isCollapsed} expandedItems={expandedItems} toggleExpanded={toggleExpanded} setHoveredItem={setHoveredItem} />
          ))}
        </nav>
        {showMenuFeatures && <QuickActions isCollapsed={isCollapsed} pathname={pathname} />}
      </div>

      <HoverMenu hoveredItem={hoveredItem} setHoveredItem={setHoveredItem} />
    </motion.aside>
  );
});

Sidebar.displayName = "Sidebar";
export default Sidebar;

```

<!-- path: components/navigation/sidebar-components/NavItem.tsx -->
```typescript
"use client";

import { motion, AnimatePresence } from "framer-motion";
import { usePathname, useRouter } from "next/navigation";
import { FiChevronDown } from "react-icons/fi";
import { NavItem as NavItemType, submenuVariants } from "./sidebar-types";
import { useUserPermissions } from "@/hooks/useRoleFunctions";
import { toast } from "sonner";
import { UserRole } from "@/types/user-roles";
import { ButtonSpinner } from "@/components/common/ui/LoadingSpinner";
import { useState, useEffect } from "react";

interface NavItemProps {
  item: NavItemType;
  isCollapsed: boolean;
  depth?: number;
  expandedItems: string[];
  toggleExpanded: (id: string) => void;
  setHoveredItem: (item: NavItemType | null) => void;
}

export const NavItem = ({
  item,
  isCollapsed,
  depth = 0,
  expandedItems,
  toggleExpanded,
  setHoveredItem,
}: NavItemProps) => {
  const router = useRouter();
  const pathname = usePathname();
  const { isSuperAdmin, role } = useUserPermissions();
  const [isLoading, setIsLoading] = useState(false);
  const [navigatingTo, setNavigatingTo] = useState<string | null>(null);

  const hasPermission = (roles: UserRole[]) => {
    if (isSuperAdmin) return true;
    if (!roles || roles.length === 0) return false;
    return roles.includes(role as UserRole);
  };

  const isActive = () => {
    if (!item.href) return false;
    if (item.href === "/dashboard") {
      return pathname === "/dashboard";
    }
    return pathname.startsWith(item.href);
  };

  const handleItemClick = async (e: React.MouseEvent) => {
    if (!hasPermission(item.roles)) {
      e.preventDefault();
      toast.error("You are not authorized to access this section.");
      return;
    }
    
    if (item.children && item.children.length > 0) {
      e.preventDefault();
      toggleExpanded(item.id);
      return;
    }
    
    if (item.href) {
      try {
        setNavigatingTo(item.href);
        setIsLoading(true);
        if (item.external) {
          window.open(item.href, "_blank", "noopener,noreferrer");
          setIsLoading(false);
        } else {
          await router.push(item.href);
          // The loading state will be cleared by the effect below
        }
      } catch (error) {
        console.error("Navigation error:", error);
        toast.error("Failed to navigate. Please try again.");
        setIsLoading(false);
        setNavigatingTo(null);
      }
    }
  };

  // Clear loading state when the route changes
  useEffect(() => {
    if (pathname === navigatingTo) {
      setIsLoading(false);
      setNavigatingTo(null);
    }
  }, [pathname, navigatingTo]);

  if (!hasPermission(item.roles)) return null;

  const active = isActive();
  const hasChildren = item.children && item.children.length > 0;
  const isExpanded = expandedItems.includes(item.id);

  return (
    <div 
      key={item.id} 
      className="relative" 
      onMouseEnter={() => isCollapsed && hasChildren && setHoveredItem(item)} 
      onMouseLeave={() => isCollapsed && hasChildren && setHoveredItem(null)}
    >
      <div
        onClick={handleItemClick}
        className={`
          flex cursor-pointer items-center justify-between py-3 text-sm font-medium 
          transition-all duration-200 rounded-lg mx-2 mb-1
          ${active 
            ? "bg-blue-100 text-blue-800 dark:bg-blue-900/30 dark:text-blue-300 shadow-sm" 
            : "text-gray-700 hover:bg-gray-50 dark:text-gray-300 dark:hover:bg-gray-800 hover:shadow-sm"
          } 
          ${isCollapsed ? "justify-center px-4" : `pr-4 ${depth > 0 ? "pl-8" : "pl-4"}`}
        `}
        role="button"
        tabIndex={0}
        onKeyDown={(e) => {
          if (e.key === "Enter" || e.key === " ") {
            e.preventDefault();
            handleItemClick(e as unknown as React.MouseEvent);
          }
        }}
      >
        <div className="flex items-center space-x-3">
          <span className="flex-shrink-0">
            {isLoading && pathname !== item.href ? <ButtonSpinner size="xs" /> : item.icon}
          </span>
          {!isCollapsed && (
            <span className="truncate">
              {isLoading && pathname !== item.href ? 'Loading...' : item.label}
            </span>
          )}
        </div>
        {!isCollapsed && hasChildren && (
          <button
            onClick={(e) => {
              e.stopPropagation();
              toggleExpanded(item.id);
            }}
            className="p-1 rounded-md transition-colors hover:bg-gray-200 dark:hover:bg-gray-700"
            aria-label={isExpanded ? "Collapse" : "Expand"}
          >
            <motion.div 
              animate={{ rotate: isExpanded ? 0 : -90 }} 
              transition={{ duration: 0.2 }}
            >
              <FiChevronDown className="w-4 h-4" />
            </motion.div>
          </button>
        )}
      </div>
      
      {!isCollapsed && hasChildren && (
        <AnimatePresence initial={false}>
          {isExpanded && (
            <motion.div 
              initial="hidden"
              animate="visible"
              exit="hidden"
              variants={submenuVariants}
              transition={{ duration: 0.2 }}
              className="overflow-hidden"
            >
              <div className="ml-6 border-l-2 border-gray-200 dark:border-gray-700 pl-2">
                {item.children?.map((child) => (
                  <NavItem
                    key={child.id}
                    item={child}
                    isCollapsed={isCollapsed}
                    depth={depth + 1}
                    expandedItems={expandedItems}
                    toggleExpanded={toggleExpanded}
                    setHoveredItem={setHoveredItem}
                  />
                ))}
              </div>
            </motion.div>
          )}
        </AnimatePresence>
      )}
    </div>
  );
};
```

<!-- path: components/navigation/sidebar-components/sidebar-types.ts -->
```typescript
import { Database } from "@/types/supabase-types";
import { UserRole } from "@/types/user-roles";
import { ReactNode } from "react";

export type TableName = keyof Database["public"]["Tables"];

export interface SidebarProps {
  isCollapsed: boolean;
  setIsCollapsed: (collapsed: boolean) => void;
  showMenuFeatures: boolean;
}

export interface NavItem {
  id: string;
  label: string;
  icon: ReactNode;
  href?: string;
  children?: NavItem[];
  roles: UserRole[];
  external?: boolean;
}

// Animation variants
export const sidebarVariants = {
  expanded: { width: 260 },
  collapsed: { width: 64 }
};

export const mobileOverlayVariants = {
  hidden: { opacity: 0 },
  visible: { opacity: 1 }
};

export const mobileSidebarVariants = {
  hidden: { x: -260 },
  visible: { x: 0 }
};

export const contentVariants = {
  hidden: { opacity: 0, x: -10 },
  visible: { opacity: 1, x: 0 },
  exit: { opacity: 0, x: -10 }
};

export const submenuVariants = {
  hidden: { height: 0, opacity: 0 },
  visible: { height: "auto", opacity: 1 }
};
```

<!-- path: components/navigation/sidebar-components/HoverMenu.tsx -->
```typescript
"use client";

import { motion, AnimatePresence } from "framer-motion";
import { NavItem as NavItemType } from "./sidebar-types";
import { useUserPermissions } from "@/hooks/useRoleFunctions";
import { useRouter } from "next/navigation";
import { toast } from "sonner";
import { UserRole } from "@/types/user-roles";

interface HoverMenuProps {
  hoveredItem: NavItemType | null;
  setHoveredItem: (item: NavItemType | null) => void;
}

export const HoverMenu = ({ hoveredItem, setHoveredItem }: HoverMenuProps) => {
  const router = useRouter();
  const { isSuperAdmin, role } = useUserPermissions();

  const hasPermission = (roles: UserRole[]) => {
    if (isSuperAdmin) return true;
    if (!roles || roles.length === 0) return false;
    return roles.includes(role as UserRole);
  };

  const handleChildClick = (e: React.MouseEvent, child: NavItemType) => {
    e.stopPropagation();
    if (!hasPermission(child.roles)) {
      toast.error("You are not authorized to access this section.");
      return;
    }
    if (child.href) {
      router.push(child.href);
      setHoveredItem(null);
    }
  };

  return (
    <AnimatePresence>
      {hoveredItem?.children && (
        <motion.div
          initial={{ opacity: 0, x: 10, scale: 0.95 }}
          animate={{ opacity: 1, x: 0, scale: 1 }}
          exit={{ opacity: 0, x: 10, scale: 0.95 }}
          transition={{ duration: 0.15 }}
          className="fixed left-16 z-[60] min-w-48 overflow-hidden rounded-lg bg-white shadow-xl ring-1 ring-black/5 dark:bg-gray-800 dark:ring-white/10"
          style={{
            top: `${Math.max(80, Math.min(window.innerHeight - 200, 160))}px`,
          }}
          onMouseEnter={() => setHoveredItem(hoveredItem)}
          onMouseLeave={() => setHoveredItem(null)}
        >
          <div className="py-2">
            {hoveredItem.children.map((child) => (
              <button
                key={child.id}
                onClick={(e) => handleChildClick(e, child)}
                disabled={!hasPermission(child.roles)}
                className={`
                  flex w-full items-center space-x-3 px-4 py-2 text-left text-sm transition-colors
                  ${hasPermission(child.roles) 
                    ? "text-gray-700 hover:bg-gray-100 dark:text-gray-300 dark:hover:bg-gray-700" 
                    : "text-gray-400 cursor-not-allowed dark:text-gray-600"
                  }
                `}
              >
                <span className="flex-shrink-0">{child.icon}</span>
                <span className="truncate">{child.label}</span>
              </button>
            ))}
          </div>
        </motion.div>
      )}
    </AnimatePresence>
  );
};
```

<!-- path: components/navigation/sidebar-components/NavItems.tsx -->
```typescript
import { UserRole } from '@/types/user-roles';
import { NavItem as NavItemType } from '@/components/navigation/sidebar-components/sidebar-types';
import { useMemo } from 'react';
import {
  FiDatabase,
  FiHome,
  FiMap,
  FiUsers,
  FiServer,
  FiLayers,
  FiCpu,
  FiMapPin,
  FiList,
} from 'react-icons/fi';
import { FaDiagramNext } from 'react-icons/fa6';
import { BsPeople } from 'react-icons/bs';
import { ImUserTie } from 'react-icons/im';
import { GiElectric, GiLinkedRings, GiWireCoil } from 'react-icons/gi';
import { AiFillMerge } from 'react-icons/ai';
import { FaNetworkWired, FaRoute } from 'react-icons/fa';
import { MdLan } from 'react-icons/md';

function NavItems() {
  const items: NavItemType[] = useMemo(
    () => [
      {
        id: 'home',
        label: 'Home',
        icon: <FiHome className="h-5 w-5" />,
        href: '/dashboard',
        roles: [
          UserRole.ADMIN,
          UserRole.VIEWER,
          UserRole.AUTHENTICATED,
          UserRole.CPANADMIN,
          UserRole.MAANADMIN,
          UserRole.SDHADMIN,
          UserRole.VMUXADMIN,
        ],
      },
      {
        id: 'user-management',
        label: 'User Management',
        icon: <FiUsers className="h-5 w-5" />,
        href: '/dashboard/users',
        roles: [],
      },
      {
        id: 'employees',
        label: 'Employees',
        icon: <BsPeople className="h-5 w-5" />,
        href: '/dashboard/employees',
        roles: [UserRole.ADMIN],
      },
      {
        id: 'base-menu',
        label: 'Base Structure',
        icon: <FiServer className="h-5 w-5" />,
        roles: [
          UserRole.ADMIN,
          UserRole.VIEWER,
          UserRole.AUTHENTICATED,
          UserRole.CPANADMIN,
          UserRole.MAANADMIN,
          UserRole.SDHADMIN,
          UserRole.VMUXADMIN,
        ],
        children: [
          {
            id: 'designations',
            label: 'Designations',
            icon: <ImUserTie className="h-5 w-5" />,
            href: '/dashboard/designations',
            roles: [],
          },
          {
            id: 'categories',
            label: 'Categories',
            icon: <FiLayers className="h-5 w-5" />,
            href: '/dashboard/categories',
            roles: [UserRole.ADMIN],
          },
          {
            id: 'lookups',
            label: 'Lookups',
            icon: <FiList className="h-5 w-5" />,
            href: '/dashboard/lookup',
            roles: [UserRole.ADMIN],
          },
          {
            id: 'maintenance-areas',
            label: 'Maintenance Areas',
            icon: <FiMapPin className="h-5 w-5" />,
            href: '/dashboard/maintenance-areas',
            roles: [UserRole.ADMIN],
          },
          {
            id: 'rings',
            label: 'Rings',
            icon: <GiLinkedRings className="h-5 w-5" />,
            href: '/dashboard/rings',
            roles: [UserRole.ADMIN],
          },
          {
            id: 'nodes',
            label: 'Nodes',
            icon: <FiCpu className="h-5 w-5" />,
            href: '/dashboard/nodes',
            roles: [UserRole.ADMIN],
          },
        ],
      },
      {
        id: 'ofc-menu',
        label: 'Ofc & Routes',
        icon: <GiElectric className="h-5 w-5" />,
        roles: [
          UserRole.ADMIN,
          UserRole.VIEWER,
          UserRole.AUTHENTICATED,
          UserRole.CPANADMIN,
          UserRole.MAANADMIN,
          UserRole.SDHADMIN,
          UserRole.VMUXADMIN,
        ],
        children: [
          {
            id: 'ofc-menu',
            label: 'Optical Fiber Cable',
            href: '/dashboard/ofc',
            icon: <AiFillMerge className="h-5 w-5" />, // replaced non-existent TbCableData with a valid icon
            roles: [UserRole.ADMIN],
          },
          {
            id: 'route-manager',
            label: 'RouteManager',
            icon: <FaRoute className="h-5 w-5" />,
            href: '/dashboard/route-manager',
            roles: [UserRole.ADMIN],
          },
        ],
      },
      {
        id: 'systems',
        label: 'Systems',
        icon: <FiDatabase className="h-5 w-5" />,
        href: '/dashboard/systems',
        roles: [UserRole.ADMIN],
      },
      {
        id: 'diagrams',
        label: 'Diagrams',
        icon: <FaDiagramNext className="h-5 w-5" />,
        href: '/dashboard/diagrams',
        roles: [UserRole.ADMIN],
      },
      {
        id: 'map',
        label: 'BTS Map',
        icon: <FiMap className="h-5 w-5" />,
        href: 'https://www.google.com/maps/d/u/0/embed?mid=1dpO2c3Qt2EmLFxovZ14rcqkjrN6uqlvP&ehbc=2E312F&ll=22.485295672038035%2C88.3701163022461&z=14',
        roles: [
          UserRole.ADMIN,
          UserRole.VIEWER,
          UserRole.MAANADMIN,
          UserRole.SDHADMIN,
          UserRole.VMUXADMIN,
        ],
        external: true,
      },
    ],
    []
  );
  return items;
}

export default NavItems;

```

<!-- path: components/navigation/sidebar-components/QuickActions.tsx -->
```typescript
"use client";

import { motion, AnimatePresence } from "framer-motion";
import { FiChevronDown, FiSettings, FiUpload } from "react-icons/fi";
import { Input } from "@/components/common/ui/Input";
import { useRef, useState } from "react";
import { submenuVariants } from "./sidebar-types";
import { createClient } from "@/utils/supabase/client";
import { useUploadConfigStore } from "@/stores/useUploadConfigStore";
import { useExcelUpload } from "@/hooks/database/excel-queries";
import { toast } from "sonner";
import { TableName } from "@/hooks/database/queries-type-helpers";
import { useCurrentTableName } from "@/hooks/useCurrentTableName";

interface QuickActionsProps {
  isCollapsed: boolean;
  pathname: string;
}

export const QuickActions = ({ isCollapsed, pathname }: QuickActionsProps) => {
  const [showMenuSection, setShowMenuSection] = useState(true);
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  const [file, setFile] = useState<File | null>(null);
  const currentTableName = useCurrentTableName();

  // Don't show on dashboard or when collapsed
  const shouldHideFeatures =
    pathname === "/dashboard" || isCollapsed || !currentTableName;

  // Zustand integration
  const supabase = createClient();
  const fileInputRef = useRef<HTMLInputElement>(null);
  // const pageKey = currentTableName as string;

  // Get the config for this specific context from the store.
  const { configs } = useUploadConfigStore();
  const storeConfig = configs[currentTableName as string];
  // console.log("storeConfig", storeConfig);

  // Initialize the upload hook. Note that we don't know the table name here yet.
  const { mutate, isPending } = useExcelUpload(
    supabase,
    currentTableName as TableName,
    {
      onSuccess: (result) => {
        // ... success handler
        console.log("result", result);
        return result.successCount > 0
          ? toast.success(
              `Successfully uploaded ${result.successCount} of ${result.totalRows} records.`
            )
          : toast.error(`Failed to upload ${result.totalRows} records.`);
      },
      onError: (error) => {
        // ... error handler
        console.log(error);
      },
    }
  );

  const handleFileChange = (event: React.ChangeEvent<HTMLInputElement>) => {
    const selectedFile = event.target.files?.[0];

    if (!selectedFile) {
      alert("Please select a file first!");
      return;
    }

    setFile(selectedFile);

    if (!storeConfig) {
      toast.error("Upload configuration is missing. Cannot proceed.");
      return;
    }

    mutate({
      file: selectedFile,
      columns: storeConfig.columnMapping,
      uploadType: storeConfig.uploadType,
      conflictColumn: storeConfig.conflictColumn,
    });

    if (fileInputRef.current) {
      fileInputRef.current.value = "";
    }
  };

  // Don't show on dashboard or when collapsed
  if (shouldHideFeatures) return null;

  return (
    <div className="mt-4 border-t border-gray-200 pt-4 dark:border-gray-700">
      <div
        onClick={() => setShowMenuSection(!showMenuSection)}
        className="flex cursor-pointer items-center justify-between py-2 px-4 mx-2 rounded-lg text-sm font-medium text-gray-700 transition-colors duration-200 hover:bg-gray-50 dark:text-gray-300 dark:hover:bg-gray-800"
      >
        <div className="flex items-center space-x-3">
          <FiSettings className="h-5 w-5 flex-shrink-0" />
          <span>Quick Actions</span>
        </div>
        <motion.div
          animate={{ rotate: showMenuSection ? 0 : -90 }}
          transition={{ duration: 0.2 }}
        >
          <FiChevronDown className="h-4 w-4" />
        </motion.div>
      </div>

      <AnimatePresence initial={false}>
        {showMenuSection && storeConfig?.isUploadEnabled && (
          <motion.div
            initial="hidden"
            animate="visible"
            exit="hidden"
            variants={submenuVariants}
            transition={{ duration: 0.2 }}
            className="overflow-hidden"
          >
            <div className="space-y-3 px-4 py-3">
              <div className="space-y-2">
                <h4 className="px-2 text-xs font-medium uppercase tracking-wide text-gray-500 dark:text-gray-400">
                  Upload data for:
                  <div className="flex">
                    <div className="font-bold ml-1 lowercase px-2 ">
                      {currentTableName}{" "}
                    </div>
                    <div className="uppercase">table</div>
                  </div>
                </h4>

                {/* Upload Excel Button */}
                <>
                  <Input
                    type="file"
                    accept=".xlsx, .xls"
                    ref={fileInputRef}
                    onChange={handleFileChange}
                    className="hidden"
                  />
                  <button
                    onClick={() => fileInputRef.current?.click()}
                    disabled={isPending || !currentTableName}
                    className="flex w-full items-center gap-2 rounded-md border border-gray-300 p-2 text-left text-xs transition-colors hover:bg-gray-50 disabled:cursor-not-allowed disabled:opacity-50 dark:border-gray-600 dark:hover:bg-gray-800"
                  >
                    <FiUpload className="h-3 w-3" />
                    <span>{isPending ? "Uploading..." : "Upload Excel"}</span>
                  </button>
                </>
              </div>
            </div>
          </motion.div>
        )}
      </AnimatePresence>
    </div>
  );
};

```

<!-- path: components/navigation/sidebar-components/MobileSidebar.tsx -->
```typescript
"use client";

import { motion } from "framer-motion";
import { FiX } from "react-icons/fi";
import { NavItem } from "./NavItem";
import { QuickActions } from "./QuickActions";
import { mobileOverlayVariants, mobileSidebarVariants } from "./sidebar-types";
import { NavItem as NavItemType } from "./sidebar-types";

interface MobileSidebarProps {
  isCollapsed: boolean;
  setIsCollapsed: (collapsed: boolean) => void;
  navItems: NavItemType[];
  expandedItems: string[];
  toggleExpanded: (id: string) => void;
  setHoveredItem: (item: NavItemType | null) => void;
  pathname: string;
}

export const MobileSidebar = ({
  isCollapsed,
  setIsCollapsed,
  navItems,
  expandedItems,
  toggleExpanded,
  setHoveredItem,
  pathname,
}: MobileSidebarProps) => {
  const handleBackdropClick = () => {
    setIsCollapsed(true);
  };

  if (isCollapsed) return null;

  return (
    <>
      <motion.div 
        initial="hidden"
        animate="visible"
        exit="hidden"
        variants={mobileOverlayVariants}
        className="fixed inset-0 z-40 bg-black/50 backdrop-blur-sm" 
        aria-label="Sidebar backdrop" 
        onClick={handleBackdropClick}
      />
      <motion.aside
        initial="hidden"
        animate="visible"
        exit="hidden"
        variants={mobileSidebarVariants}
        transition={{ type: "spring", damping: 30, stiffness: 300 }}
        className="fixed top-0 left-0 z-50 flex h-full w-64 flex-col border-r border-gray-200 bg-white shadow-xl dark:border-gray-800 dark:bg-gray-900 dark:text-white"
      >
        <div className="flex h-16 items-center justify-between border-b border-gray-200 px-4 dark:border-gray-800">
          <h2 className="text-lg font-semibold text-gray-900 dark:text-gray-100">
            Navigation
          </h2>
          <button 
            onClick={() => setIsCollapsed(true)} 
            className="rounded-lg p-2 transition-colors hover:bg-gray-100 dark:hover:bg-gray-800" 
            aria-label="Close sidebar"
          >
            <FiX className="h-5 w-5" />
          </button>
        </div>
        
        <div className="flex-1 overflow-y-auto py-4">
          <nav className="space-y-1" role="navigation">
            {navItems.map((item) => (
              <NavItem
                key={item.id}
                item={item}
                isCollapsed={false}
                expandedItems={expandedItems}
                toggleExpanded={toggleExpanded}
                setHoveredItem={setHoveredItem}
              />
            ))}
          </nav>
          <QuickActions
            isCollapsed={false}
            pathname={pathname}
          />
        </div>
      </motion.aside>
    </>
  );
};
```

<!-- path: components/ofc-details/OfcConnectionsFormModal.tsx -->
```typescript
"use client";

import React, { useCallback, useEffect, useMemo } from "react";
import { Modal } from "@/components/common/ui/Modal";
import { createClient } from "@/utils/supabase/client";
import { Database, TablesInsert } from "@/types/supabase-types";
import {
  useTableInsert,
  useTableUpdate,
} from "@/hooks/database";
import { ofcConnectionFormSchema, type OfcConnectionFormData } from "@/schemas";
import { useForm } from "react-hook-form";
import { zodResolver } from "@hookform/resolvers/zod";
import { FormCard } from "@/components/common/form/FormCard";
import {
  FormInput,
  FormTextarea,
  FormSwitch,
} from "@/components/common/form/FormControls";

export type OfcConnectionsRow = Database["public"]["Tables"]["ofc_connections"]["Row"];
export type OfcConnectionsInsert = TablesInsert<"ofc_connections">;



interface OfcConnectionsFormModalProps {
  isOpen: boolean;
  onClose: () => void;
  editingOfcConnections?: OfcConnectionsRow | null;
  onCreated?: (ofcConnections: OfcConnectionsRow) => void;
  onUpdated?: (ofcConnections: OfcConnectionsRow) => void;
}

export function OfcConnectionsFormModal({
  isOpen,
  onClose,
  editingOfcConnections,
  onCreated,
  onUpdated,
}: OfcConnectionsFormModalProps) {

  console.log("editingOfcConnections", editingOfcConnections);
  
  const {
    register,
    handleSubmit,
    formState: { errors, isSubmitting },
    reset,
    control,
    setValue,
    watch,
  } = useForm<OfcConnectionFormData>({
    resolver: zodResolver(ofcConnectionFormSchema),
    defaultValues: {
      ofc_id: "",
      logical_path_id: null,
      system_id: null,
      fiber_role: "",
      fiber_no_sn: 1,
      fiber_no_en: 1,
      path_segment_order: null,
      connection_category: "",
      connection_type: "",
      source_port: null,
      destination_port: null,
      sn_dom: undefined,
      otdr_distance_sn_km: null,
      sn_power_dbm: null,
      en_dom: undefined,
      otdr_distance_en_km: null,
      en_power_dbm: null,
      route_loss_db: undefined,
      status: true,
      remark: null,
    },
  });

  const supabase = createClient();
  const { mutate: insertOfcConnections, isPending: creating } = useTableInsert(
    supabase,
    "ofc_connections"
  );
  const { mutate: updateOfcConnections, isPending: updating } = useTableUpdate(
    supabase,
    "ofc_connections"
  );

  const isEdit = useMemo(() => Boolean(editingOfcConnections), [editingOfcConnections]);

  // Connection types and categories (you might want to fetch these from lookup tables)
  const connectionTypes = [
    { value: "SPLICE", label: "Splice" },
    { value: "CONNECTOR", label: "Connector" },
    { value: "TERMINATION", label: "Termination" },
  ];

  const connectionCategories = [
    { value: "FIBER", label: "Fiber" },
    { value: "CABLE", label: "Cable" },
    { value: "PATH", label: "Path" },
  ];

  const fiberRoles = [
    { value: "WORKING", label: "Working" },
    { value: "PROTECTION", label: "Protection" },
  ];

  useEffect(() => {
    if (!isOpen) return;
    if (editingOfcConnections) {
      reset({
        ...editingOfcConnections,
        sn_dom: editingOfcConnections.sn_dom ? new Date(editingOfcConnections.sn_dom) : undefined,
        en_dom: editingOfcConnections.en_dom ? new Date(editingOfcConnections.en_dom) : undefined,
        en_power_dbm: editingOfcConnections.en_power_dbm ?? null,
        sn_power_dbm: editingOfcConnections.sn_power_dbm ?? null,
        otdr_distance_sn_km: editingOfcConnections.otdr_distance_sn_km ?? null,
        otdr_distance_en_km: editingOfcConnections.otdr_distance_en_km ?? null,
        route_loss_db: editingOfcConnections.route_loss_db ?? null,
      });
    } else {
      reset({
        ofc_id: "",
      logical_path_id: null,
      system_id: null,
      fiber_role: "",
      fiber_no_sn: 1,
      fiber_no_en: 1,
      path_segment_order: null,
      connection_category: "",
      connection_type: "",
      source_port: null,
      destination_port: null,
      sn_dom: undefined,
      otdr_distance_sn_km: null,
      sn_power_dbm: null,
      en_dom: undefined,
      otdr_distance_en_km: null,
      en_power_dbm: null,
      route_loss_db: undefined,
      status: true,
      remark: null,
      });
    }
  }, [isOpen, editingOfcConnections, reset]);

  const handleClose = useCallback(() => {
    if (creating || updating) return;
    onClose();
  }, [creating, updating, onClose]);

  const onValidSubmit = useCallback(
    (formData: OfcConnectionFormData) => {
      if (isEdit && editingOfcConnections) {
        updateOfcConnections(
          { id: editingOfcConnections.id, data: formData as Partial<OfcConnectionsInsert> },
          {
            onSuccess: (data: unknown) => {
              onUpdated?.(Array.isArray(data) ? data[0] : data);
              onClose();
            },
          }
        );
      } else {
        insertOfcConnections(formData as OfcConnectionsInsert, {
          onSuccess: (data: unknown) => {
            onCreated?.(Array.isArray(data) ? data[0] : data);
            onClose();
          },
        });
      }
    },
    [isEdit, editingOfcConnections, updateOfcConnections, insertOfcConnections, onUpdated, onCreated, onClose]
  );

  const submitting = creating || updating || isSubmitting;

  return (
    <Modal
      isOpen={isOpen}
      onClose={handleClose}
      title={isEdit ? "Edit OFC Connection" : "Add OFC Connection"}
      size="full"
      visible={false}
      className="h-screen w-screen transparent bg-gray-700 rounded-2xl"
    >
      <FormCard
        title={isEdit ? "Edit OFC Connection" : "Add OFC Connection"}
        onSubmit={handleSubmit(onValidSubmit)}
        onCancel={handleClose}
        standalone
      >

        {/* Fiber Role */}
        {/* <FormSearchableSelect
          name="fiber_role"
          label="Fiber Role"
          control={control}
          options={fiberRoles}
          error={errors.fiber_role}
          disabled={submitting}
          
        /> */}

        {/* Fiber Numbers */}
        <FormInput
          name="fiber_no_sn"
          label="Start Node Fiber No. *"
          register={register}
          error={errors.fiber_no_sn}
          disabled={true}
          
        />

        <FormInput
          name="fiber_no_en"
          label="End Node Fiber No."
          register={register}
          error={errors.fiber_no_en}
          disabled={true}
          
        />

        {/* Path Segment Order */}
        <FormInput
          name="path_segment_order"
          label="Path Segment Order"
          register={register}
          error={errors.path_segment_order}
          disabled={submitting}
          
        />

        {/* Connection Category (Required) */}
        {/* <FormSearchableSelect
          name="connection_category"
          label="Connection Category *"
          control={control}
          options={connectionCategories}
          error={errors.connection_category}
          disabled={submitting}
          
        /> */}

        {/* Connection Type (Required) */}
        {/* <FormSearchableSelect
          name="connection_type"
          label="Connection Type *"
          control={control}
          options={connectionTypes}
          error={errors.connection_type}
          disabled={submitting}
          
        /> */}

        <FormInput
          name="otdr_distance_sn_km"
          label="OTDR Distance SN (km)"
          register={register}
          step="0.001"
          error={errors.otdr_distance_sn_km}
          disabled={submitting}
          
        />

        <FormInput
          name="sn_power_dbm"
          label="SN Power (dBm)"
          register={register}
          step="0.01"
          error={errors.sn_power_dbm}
          disabled={submitting}
          
        />

        <FormInput
          name="otdr_distance_en_km"
          label="OTDR Distance EN (km)"
          register={register}
          step="0.001"
          error={errors.otdr_distance_en_km}
          disabled={submitting}
          
        />

        <FormInput
          name="en_power_dbm"
          label="EN Power (dBm)"
          register={register}
          step="0.01"
          error={errors.en_power_dbm}
          disabled={submitting}
          
        />

        {/* Overall Measurements */}
        <FormInput
          name="route_loss_db"
          label="Route Loss (dB)"
          register={register}
          step="0.01"
          error={errors.route_loss_db}
          disabled={submitting}
          
        />

        {/* Status */}
        <div className="flex items-center">
          <FormSwitch
            name="status"
            label="Active"
            control={control}
            error={errors.status}
            disabled={submitting}
            className="my-2"
          />
        </div>

        {/* Remark */}
        <FormTextarea
          name="remark"
          label="Remark"
          control={control}
          error={errors.remark}
          disabled={submitting}
          
        />
      </FormCard>
    </Modal>
  );
}
```

<!-- path: components/ofc-details/FiberTraceDiagram.tsx -->
```typescript
// path: components/ofc-details/FiberTraceDiagram.tsx
'use client';

import { FiberTraceNode } from '@/components/route-manager/types';
import { Box, Network, GitBranch } from 'lucide-react';

interface TraceNodeProps {
  node: FiberTraceNode;
}

const TraceNode: React.FC<TraceNodeProps> = ({ node }) => {
    return (
        <div className="flex items-center">
            <div className="flex flex-col items-center flex-shrink-0">
                <div className={`w-12 h-12 rounded-full flex items-center justify-center text-white shadow-md ${node.type === 'NODE' ? 'bg-blue-600' : 'bg-green-500'}`}>
                    {node.type === 'NODE' ? <Network size={24} /> : <Box size={24} />}
                </div>
                <p className="mt-2 text-xs font-semibold text-center w-20 truncate" title={node.name}>{node.name}</p>
            </div>
            {node.children.length > 0 && (
                <div className="flex items-start ml-2">
                    <div className="w-4 h-1 mt-6 bg-gray-300 dark:bg-gray-600"></div>
                    <div className="flex flex-col">
                        {node.children.map((child, index) => (
                            <div key={`${child.cable.id}-${child.cable.fiber_no}-${index}`} className="flex items-center">
                                <div className="flex flex-col items-center">
                                    <div className="text-xs font-mono font-bold text-blue-600 dark:text-blue-400">F{child.cable.fiber_no}</div>
                                    <div className="w-24 h-1 bg-blue-500"></div>
                                    <div className="text-xs text-gray-500 mt-1" title={child.cable.is_otdr ? 'OTDR Measured' : 'Segment Length'}>
                                        {child.cable.distance_km?.toFixed(2)} km
                                    </div>
                                </div>
                                {child.downstreamNode ? (
                                    <TraceNode node={child.downstreamNode} />
                                ) : (
                                    <div className="flex flex-col items-center flex-shrink-0 ml-2">
                                        <div className="w-10 h-10 rounded-full bg-yellow-500 flex items-center justify-center text-white shadow-md">
                                            <GitBranch size={20} className="transform -rotate-90" />
                                        </div>
                                        <p className="mt-2 text-xs font-semibold text-center w-20 truncate">Terminated</p>
                                    </div>
                                )}
                            </div>
                        ))}
                    </div>
                </div>
            )}
        </div>
    );
};

interface FiberTraceDiagramProps {
  startNode: FiberTraceNode;
}

export const FiberTraceDiagram: React.FC<FiberTraceDiagramProps> = ({ startNode }) => {
  return (
    <div className="p-4 font-sans">
      <div className="flex items-center space-x-2 overflow-x-auto pb-4">
        <TraceNode node={startNode} />
      </div>
    </div>
  );
};
```

<!-- path: components/ofc-details/CableNotFound.tsx -->
```typescript
import { ButtonSpinner } from '@/components/common/ui';
import { motion } from 'framer-motion';

// Define animation variants outside for better portability and to resolve TypeScript inference issues

const containerVariants = {
  hidden: { opacity: 0, y: -20 },
  visible: {
    opacity: 1,
    y: 0,
    transition: {
      duration: 0.5,
      staggerChildren: 0.1, // for seamless animation orchestration.
    },
  },
} as const; // Add 'as const' to enforce literal types and resolve TS errors, as variants are objects of arbitrary string keys

const bannerVariants = {
  hidden: { x: -100, opacity: 0 },
  visible: {
    x: 0,
    opacity: 1,
    transition: {
      duration: 0.6,
      delay: 0.2,
      type: 'spring', // Specify as string literal; TypeScript may infer 'string' without 'as const', but 'spring' with stiffness/damping ensures proper typing.
      stiffness: 300,
      damping: 30,
    },
  },
} as const;

const textVariants = {
  hidden: { opacity: 0 },
  visible: {
    opacity: 1,
    transition: { duration: 0.8, delay: 0.4 },
  },
} as const;

const buttonVariants = {
  hidden: { scale: 0.8, opacity: 0 },
  visible: {
    scale: 1,
    opacity: 1,
    transition: {
      duration: 0.5,
      delay: 0.6,
      type: 'spring',
      stiffness: 400,
      damping: 25,
    },
  },
  hover: {
    scale: 1.05,
    transition: { duration: 0.2 },
  },
  tap: {
    scale: 0.95,
    transition: { duration: 0.1 },
  },
} as const;

const CableNotFound = ({
  id,
  handleBackToOfcList,
  isBackClicked,
}: {
  id: string;
  handleBackToOfcList: () => void;
  isBackClicked: boolean;
}) => {
  return (
    <motion.div
      className="p-6"
      variants={containerVariants}
      initial="hidden"
      animate="visible"
    >
      <motion.div
        className="bg-gradient-to-r from-red-50 to-red-100 border-l-4 border-red-400 p-4 rounded-lg shadow-lg"
        variants={bannerVariants}
        initial="hidden"
        animate="visible"
      >
        <div className="flex">
          <div className="flex-shrink-0">
            <motion.svg
              className="h-5 w-5 text-red-400"
              viewBox="0 0 20 20"
              fill="currentColor"
              variants={bannerVariants}
              whileHover={{
                scale: 1.1,
                rotate: 5,
              }}
              whileTap={{ scale: 0.9 }}
            >
              <path
                fillRule="evenodd"
                d="M10 18a8 8 0 100-16 8 8 0 000 16zM8.28 7.22a.75.75 0 00-1.06 1.06L8.94 10l-1.72 1.72a.75.75 0 101.06 1.06L10 11.06l1.72 1.72a.75.75 0 101.06-1.06L11.06 10l1.72-1.72a.75.75 0 00-1.06-1.06L10 8.94 8.28 7.22z"
                clipRule="evenodd"
              />
            </motion.svg>
          </div>
          <div className="ml-3">
            <motion.p
              className="text-sm text-red-700 font-semibold"
              variants={textVariants}
              initial="hidden"
              animate="visible"
            >
              OFC cable with ID {id} not found.
            </motion.p>
            <motion.button
              onClick={handleBackToOfcList}
              className="mt-2 text-sm text-blue-600 hover:text-blue-800 transition-colors duration-200 flex items-center gap-2"
              variants={buttonVariants}
              initial="hidden"
              animate="visible"
              whileHover="hover"
              whileTap="tap"
            >
              {isBackClicked ? <ButtonSpinner /> : ' Back to OFC List'}
            </motion.button>
          </div>
        </div>
      </motion.div>
    </motion.div>
  );
};

export default CableNotFound;

```

<!-- path: components/ofc-details/FiberTraceModal.tsx -->
```typescript
// path: components/ofc-details/FiberTraceModal.tsx
'use client';

import { Modal, PageSpinner } from '@/components/common/ui';
import { OfcForSelection, RouteDetailsPayload, FiberTraceNode } from '@/components/route-manager/types';
import { FiberTraceDiagram } from './FiberTraceDiagram';
import { useFiberTrace } from '@/hooks/database/path-queries'; // Import our new hook

interface FiberTraceModalProps {
  isOpen: boolean;
  onClose: () => void;
  cableId: string | null;
  fiberNo: number | null;
  allCables: OfcForSelection[] | undefined; // Keep this for getting the start cable name
}

export const FiberTraceModal: React.FC<FiberTraceModalProps> = ({ isOpen, onClose, cableId, fiberNo, allCables }) => {
  // Use the new hook to get the pre-built trace tree
  const { data: traceTree, isLoading, isError, error } = useFiberTrace(cableId, fiberNo);

  const startingCableName = allCables?.find(c => c.id === cableId)?.route_name || '';

  const renderContent = () => {
    if (isLoading) return <PageSpinner text="Tracing fiber path..." />;
    if (isError) return <div className="p-4 text-red-500">Error tracing path: {error.message}</div>;
    if (!traceTree) return <div className="p-4 text-gray-500">Path could not be traced. This fiber may be terminated or un-spliced.</div>;

    return (
      <FiberTraceDiagram
        startNode={traceTree}
      />
    );
  };

  return (
    <Modal
      isOpen={isOpen}
      onClose={onClose}
      title={`End-to-End Trace for Fiber #${fiberNo} on ${startingCableName}`}
      size="xl"
    >
      <div className="overflow-x-auto py-4">
        {renderContent()}
      </div>
    </Modal>
  );
};
```

<!-- path: components/ofc-details/OfcDetailsHeader.tsx -->
```typescript
import React from 'react';
import { motion, Variants } from 'framer-motion';
import { Cable, Calendar, MapPin, Settings, Hash, Route, LucideIcon } from 'lucide-react';
import { StatusBadge } from '@/components/common/ui/badges/StatusBadge';
import { Row } from '@/hooks/database';

interface OfcDetailsHeaderProps {
    cable: Row<'v_ofc_cables_complete'>;
}
  
  const OfcDetailsHeader: React.FC<OfcDetailsHeaderProps> = ({ cable }) => {
    const containerVariants: Variants = {
      hidden: { opacity: 0 },
      visible: {
        opacity: 1,
        transition: {
          staggerChildren: 0.1,
          delayChildren: 0.2
        }
      }
    };
  
    const cardVariants: Variants = {
      hidden: { 
        opacity: 0, 
        y: 20,
        scale: 0.95
      },
      visible: { 
        opacity: 1, 
        y: 0,
        scale: 1,
        transition: {
          type: "spring" as const,
          stiffness: 100,
          damping: 15
        }
      }
    };
  
    const itemVariants: Variants = {
      hidden: { opacity: 0, x: -10 },
      visible: { 
        opacity: 1, 
        x: 0,
        transition: {
          type: "spring" as const,
          stiffness: 150,
          damping: 20
        }
      }
    };
  
    interface InfoItemProps {
      icon: LucideIcon;
      label: string;
      value: string;
      delay?: number;
    }
  
    const InfoItem: React.FC<InfoItemProps> = ({ icon: Icon, label, value }) => (
      <motion.div 
        variants={itemVariants}
        className="flex items-center justify-between py-3 px-1 rounded-lg hover:bg-gray-50 dark:hover:bg-gray-800/50 transition-colors duration-200"
      >
        <div className="flex items-center gap-3">
          <div className="p-1.5 rounded-lg bg-blue-50 dark:bg-blue-900/20 text-blue-600 dark:text-blue-400">
            <Icon size={16} />
          </div>
          <span className="text-gray-600 dark:text-gray-400 font-medium text-sm">
            {label}
          </span>
        </div>
        <span className="font-semibold text-gray-900 dark:text-gray-100 text-sm max-w-[60%] text-right truncate">
          {value}
        </span>
      </motion.div>
    );
  
    return (
      <motion.div 
        variants={containerVariants}
        initial="hidden"
        animate="visible"
        className="grid grid-cols-1 lg:grid-cols-2 gap-6 mb-8"
      >
        {/* Summary Card */}
        <motion.div 
          variants={cardVariants}
          whileHover={{ 
            y: -2,
            boxShadow: "0 10px 25px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05)"
          }}
          className="group relative overflow-hidden rounded-xl border border-gray-200 dark:border-gray-700 bg-white dark:bg-gray-800 shadow-sm hover:shadow-lg transition-all duration-300"
        >
          {/* Gradient Background */}
          <div className="absolute inset-0 bg-gradient-to-br from-blue-50/50 via-transparent to-indigo-50/30 dark:from-blue-900/10 dark:via-transparent dark:to-indigo-900/10" />
          
          {/* Decorative Element */}
          <div className="absolute top-0 right-0 w-32 h-32 bg-gradient-to-bl from-blue-100/20 to-transparent dark:from-blue-800/10 rounded-bl-full" />
          
          <div className="relative p-6">
            <motion.div 
              className="flex items-center gap-3 mb-6"
              initial={{ opacity: 0, y: -10 }}
              animate={{ opacity: 1, y: 0 }}
              transition={{ delay: 0.3 }}
            >
              <div className="p-2.5 rounded-xl bg-gradient-to-r from-blue-500 to-indigo-600 text-white shadow-lg">
                <Cable size={20} />
              </div>
              <h2 className="text-xl font-bold bg-gradient-to-r from-gray-900 to-gray-700 dark:from-gray-100 dark:to-gray-300 bg-clip-text text-transparent">
                Summary
              </h2>
            </motion.div>
            
            <motion.div 
              variants={containerVariants}
              className="space-y-1"
            >
              <InfoItem 
                icon={Hash}
                label="Asset No."
                value={String(cable.asset_no ?? '-')}
              />
              <InfoItem 
                icon={Route}
                label="Route Name"
                value={String(cable.route_name ?? '-')}
              />
              <motion.div 
                variants={itemVariants}
                className="flex items-center justify-between py-3 px-1 rounded-lg hover:bg-gray-50 dark:hover:bg-gray-800/50 transition-colors duration-200"
              >
                <div className="flex items-center gap-3">
                  <div className="p-1.5 rounded-lg bg-blue-50 dark:bg-blue-900/20 text-blue-600 dark:text-blue-400">
                    <Settings size={16} />
                  </div>
                  <span className="text-gray-600 dark:text-gray-400 font-medium text-sm">
                    Status
                  </span>
                </div>
                <StatusBadge status={cable.status || 'Unknown'} />
              </motion.div>
            </motion.div>
          </div>
        </motion.div>
  
        {/* Metadata Card */}
        <motion.div 
          variants={cardVariants}
          whileHover={{ 
            y: -2,
            boxShadow: "0 10px 25px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05)"
          }}
          className="group relative overflow-hidden rounded-xl border border-gray-200 dark:border-gray-700 bg-white dark:bg-gray-800 shadow-sm hover:shadow-lg transition-all duration-300"
        >
          {/* Gradient Background */}
          <div className="absolute inset-0 bg-gradient-to-br from-emerald-50/50 via-transparent to-teal-50/30 dark:from-emerald-900/10 dark:via-transparent dark:to-teal-900/10" />
          
          {/* Decorative Element */}
          <div className="absolute top-0 right-0 w-32 h-32 bg-gradient-to-bl from-emerald-100/20 to-transparent dark:from-emerald-800/10 rounded-bl-full" />
          
          <div className="relative p-6">
            <motion.div 
              className="flex items-center gap-3 mb-6"
              initial={{ opacity: 0, y: -10 }}
              animate={{ opacity: 1, y: 0 }}
              transition={{ delay: 0.4 }}
            >
              <div className="p-2.5 rounded-xl bg-gradient-to-r from-emerald-500 to-teal-600 text-white shadow-lg">
                <Settings size={20} />
              </div>
              <h2 className="text-xl font-bold bg-gradient-to-r from-gray-900 to-gray-700 dark:from-gray-100 dark:to-gray-300 bg-clip-text text-transparent">
                Metadata
              </h2>
            </motion.div>
            
            <motion.div 
              variants={containerVariants}
              className="space-y-1"
            >
              <InfoItem 
                icon={Cable}
                label="OFC Type"
                value={cable?.ofc_type_name || '-'}
              />
              <InfoItem 
                icon={MapPin}
                label="Maintenance Area"
                value={cable?.maintenance_area_name || '-'}
              />
              <InfoItem 
                icon={Calendar}
                label="Commissioned On"
                value={
                  cable.commissioned_on
                    ? new Date(String(cable.commissioned_on)).toLocaleDateString('en-US', {
                        year: 'numeric',
                        month: 'short',
                        day: 'numeric'
                      })
                    : '-'
                }
              />
            </motion.div>
          </div>
        </motion.div>
      </motion.div>
    );
  };
  
  export default OfcDetailsHeader;
```

<!-- path: components/home/HeroContent.tsx -->
```typescript
import {
  motion,
  MotionValue,
  TargetAndTransition,
  Variants,
} from "framer-motion";
import { useRouter } from "next/navigation";
import { useState } from "react";
import { LoadingSpinner } from "../common/ui/LoadingSpinner";

interface HeroContentProps {
  variants: {
    containerVariants: Variants;
    titleVariants: Variants;
    subtitleVariants: Variants;
    highlightVariants: Variants;
    ctaVariants: Variants;
  };
  floatingAnimation: TargetAndTransition;
  textY: MotionValue<number>;
}

export default function HeroContent({
  variants,
  floatingAnimation,
  textY,
}: HeroContentProps) {
  const [loading, setLoading] = useState(false);
  const router = useRouter();

  const handleGetStarted = (e: React.MouseEvent<HTMLButtonElement>) => {
    e.preventDefault();
    setLoading(true);
    router.push("/dashboard");
    // setTimeout(() => {
    //   router.push("/dashboard");
    // }, 1000); // Simulate loading for 1 second
  };
  return (
    <motion.div
      className="mx-auto flex max-w-6xl flex-col items-center justify-center px-4 text-center sm:px-6 overflow-hidden"
      style={{ y: textY }}
      variants={variants.containerVariants}
      initial="hidden"
      animate="visible"
    >
      {/* Floating badge */}
      <motion.div
        variants={variants.ctaVariants}
        animate={floatingAnimation}
        className="mb-6 rounded-full border border-red-400/40 bg-gradient-to-r from-red-500/20 to-purple-500/20 px-4 py-2 text-red-200 shadow-lg backdrop-blur-md sm:mb-8 sm:px-6 sm:py-3 dark:border-blue-400/40 dark:from-blue-500/20 dark:to-cyan-500/20 dark:text-blue-200"
      >
        <span className="text-xs font-semibold tracking-wide sm:text-sm">
           Advanced Database Management
        </span>
      </motion.div>

      {/* Title */}
      <motion.h1
        variants={variants.titleVariants}
        className="relative mb-4 text-3xl leading-tight font-black text-white sm:mb-6 sm:text-4xl md:text-5xl lg:text-6xl xl:text-7xl dark:text-gray-100"
      >
        <span className="mb-1 block text-2xl sm:mb-2 sm:text-3xl md:text-4xl lg:text-5xl xl:text-6xl">
          Welcome to
        </span>
        <span className="block bg-gradient-to-r from-red-400 via-red-500 to-orange-500 bg-clip-text text-3xl font-extrabold text-transparent sm:text-4xl md:text-5xl lg:text-6xl xl:text-7xl dark:from-blue-400 dark:via-purple-500 dark:to-cyan-400">
          Harinavi Transmission
        </span>
        <span className="mt-1 block text-2xl font-semibold text-gray-200 sm:mt-2 sm:text-3xl md:text-4xl lg:text-5xl xl:text-6xl dark:text-gray-300">
          Record Database
        </span>
      </motion.h1>

      {/* Subtitle */}
      <motion.p
        variants={variants.subtitleVariants}
        className="mb-6 max-w-xs px-2 text-base leading-relaxed text-gray-300 sm:mb-8 sm:max-w-2xl sm:px-0 sm:text-lg md:text-xl lg:max-w-3xl lg:text-2xl dark:text-gray-400"
      >
        Secure, reliable, and efficient database management for transmission
        records
      </motion.p>

      {/* CTA buttons */}
      <motion.div
        variants={variants.ctaVariants}
        className="mt-2 flex w-full max-w-xs flex-col gap-3 px-4 sm:mt-4 sm:max-w-md sm:flex-row sm:gap-4 sm:px-0"
      >
        <motion.button
          whileHover={{
            scale: 1.02,
            boxShadow: "0 10px 30px rgba(239, 68, 68, 0.3)",
          }}
          whileTap={{ scale: 0.98 }}
          className="flex w-full items-center justify-center gap-2 rounded-xl border border-red-400/30 bg-gradient-to-r from-red-500 to-red-600 px-6 py-3 text-base font-bold text-white shadow-xl transition-all hover:from-red-600 hover:to-red-700 sm:px-8 sm:py-4 sm:text-lg dark:from-red-600 dark:to-red-700 dark:hover:from-red-700 dark:hover:to-red-800"
          disabled={loading}
          onClick={handleGetStarted}
        >
          {loading ? (
            <LoadingSpinner size="sm" color="white" />
          ) : (
            "Get Started"
          )}
        </motion.button>
      </motion.div>
    </motion.div>
  );
}

```

<!-- path: components/home/ParticlesOverlay.tsx -->
```typescript
"use client"
import { motion } from "framer-motion";
import { useEffect, useState } from "react";

export default function ParticlesOverlay() {
  const [isDarkMode, setIsDarkMode] = useState(false);

  useEffect(() => {
    const mediaQuery = window.matchMedia('(prefers-color-scheme: dark)');
    setIsDarkMode(mediaQuery.matches);
    
    const handler = (e: MediaQueryListEvent) => setIsDarkMode(e.matches);
    mediaQuery.addEventListener('change', handler);
    
    return () => mediaQuery.removeEventListener('change', handler);
  }, []);

  // Colors that adapt to dark/light mode
  const colors = {
    red: isDarkMode 
      ? { gradient: 'rgba(239, 68, 68, 0.8)' } 
      : { gradient: 'rgba(220, 38, 38, 0.6)' },
    purple: isDarkMode 
      ? { gradient: 'rgba(168, 85, 247, 0.8)' } 
      : { gradient: 'rgba(147, 51, 234, 0.6)' },
    white: isDarkMode 
      ? { gradient: 'rgba(255, 255, 255, 0.4)' } 
      : { gradient: 'rgba(255, 255, 255, 0.2)' }
  };

  return (
    <div className="fixed inset-0 z-5 pointer-events-none">
      {/* Animated particles */}
      {[...Array(12)].map((_, i) => (
        <motion.div
          key={i}
          className="absolute rounded-full"
          style={{
            left: `${Math.random() * 100}%`,
            top: `${Math.random() * 100}%`,
            width: `${4 + Math.random() * 8}px`,
            height: `${4 + Math.random() * 8}px`,
            background: i % 3 === 0 
              ? `radial-gradient(circle, ${colors.red.gradient}, transparent 70%)`
              : i % 3 === 1
              ? `radial-gradient(circle, ${colors.purple.gradient}, transparent 70%)`
              : `radial-gradient(circle, ${colors.white.gradient}, transparent 70%)`,
            boxShadow: i % 3 === 0 
              ? `0 0 20px rgba(239, 68, 68, ${isDarkMode ? 0.6 : 0.4})`
              : i % 3 === 1
              ? `0 0 20px rgba(168, 85, 247, ${isDarkMode ? 0.6 : 0.4})`
              : `0 0 15px rgba(255, 255, 255, ${isDarkMode ? 0.5 : 0.3})`,
          }}
          animate={{
            scale: [1, 1.5, 1],
            opacity: [0.3, 0.8, 0.3],
            x: [0, Math.random() * 50 - 25, 0],
            y: [0, Math.random() * 50 - 25, 0],
          }}
          transition={{
            duration: 4 + Math.random() * 3,
            repeat: Infinity,
            delay: Math.random() * 2,
            ease: "easeInOut",
          }}
        />
      ))}
      
      {/* Floating geometric shapes */}
      {[...Array(6)].map((_, i) => (
        <motion.div
          key={`shape-${i}`}
          className="absolute"
          style={{
            left: `${20 + i * 12}%`,
            top: `${20 + (i % 3) * 20}%`,
            width: `${isDarkMode ? 3 : 2}px`,
            height: `${isDarkMode ? 3 : 2}px`,
          }}
          animate={{
            rotate: [0, 360],
            scale: [1, 1.5, 1],
            opacity: [0.2, 0.6, 0.2],
          }}
          transition={{
            duration: 8 + i,
            repeat: Infinity,
            delay: i * 0.5,
          }}
        >
          <div 
            className="w-full h-full rounded-full"
            style={{
              background: `radial-gradient(circle, ${colors.white.gradient}, transparent 70%)`,
              boxShadow: `0 0 ${isDarkMode ? 15 : 10}px ${colors.white.gradient}`
            }}
          />
        </motion.div>
      ))}
    </div>
  );
}
```

<!-- path: components/home/ScrollIndicator.tsx -->
```typescript
"use client";
import { motion } from "framer-motion";
import { useEffect, useState } from "react";

export default function ScrollIndicator() {
  const [isDarkMode, setIsDarkMode] = useState(false);

  useEffect(() => {
    const mediaQuery = window.matchMedia('(prefers-color-scheme: dark)');
    setIsDarkMode(mediaQuery.matches);
    
    const handler = (e: MediaQueryListEvent) => setIsDarkMode(e.matches);
    mediaQuery.addEventListener('change', handler);
    
    return () => mediaQuery.removeEventListener('change', handler);
  }, []);

  return (
    <motion.div
      initial={{ opacity: 0, y: 20 }}
      animate={{ opacity: 1, y: 0 }}
      transition={{ delay: 3.5, duration: 1 }}
      className="fixed bottom-4 left-1/2 z-30 hidden -translate-x-1/2 transform sm:bottom-8 md:block"
    >
      <motion.div
        animate={{ y: [0, 8, 0] }}
        transition={{
          duration: 2,
          repeat: Infinity,
          ease: "easeInOut",
        }}
        className="flex flex-col items-center space-y-2"
      >
        {/* Mouse indicator */}
        <div className={`
          relative flex justify-center rounded-full border-2 shadow-lg backdrop-blur-sm
          h-8 w-5 sm:h-10 sm:w-6
          ${isDarkMode 
            ? "border-gray-300/70 bg-gray-800/30" 
            : "border-white/70 bg-white/20"}
        `}>
          <motion.div
            animate={{ 
              y: [2, 10, 2], 
              opacity: [1, 0.3, 1] 
            }}
            transition={{
              duration: 2,
              repeat: Infinity,
              ease: "easeInOut",
            }}
            className={`
              mt-1 rounded-full shadow-sm
              h-2 w-0.5 sm:h-3 sm:w-1
              ${isDarkMode ? "bg-gray-300" : "bg-white"}
            `}
          />
        </div>
        
        {/* Scroll text */}
        <motion.span
          initial={{ opacity: 0 }}
          animate={{ opacity: 1 }}
          transition={{ delay: 4.5 }}
          className={`text-xs font-medium tracking-wider ${
            isDarkMode ? "text-gray-300/80" : "text-white/80"
          }`}
        >
          <small>Harinavi Transmission</small>
        </motion.span>
      </motion.div>
    </motion.div>
  );
}
```

<!-- path: components/home/StatsHighlights.tsx -->
```typescript
"use client"
import { motion } from "framer-motion";

export default function StatsHighlights() {
  const stats = [
    { number: "99.9%", label: "Uptime Guarantee", icon: "" },
    { number: "256-bit", label: "AES Encryption", icon: "" },
    { number: "Real-Time", label: "Data Insights", icon: "" }
  ];

  return (
    <motion.div
      initial={{ opacity: 0, y: 40 }}
      animate={{ opacity: 1, y: 0 }}
      transition={{ duration: 0.8, delay: 2.2 }}
      className="mt-8 sm:mt-16 grid grid-cols-1 sm:grid-cols-3 gap-4 sm:gap-6 max-w-xs sm:max-w-4xl w-full px-4"
    >
      {stats.map((stat, index) => (
        <motion.div
          key={index}
          initial={{ opacity: 0, y: 20, scale: 0.9 }}
          animate={{ opacity: 1, y: 0, scale: 1 }}
          transition={{ 
            duration: 0.6, 
            delay: 2.5 + index * 0.15,
            type: "spring",
            stiffness: 100
          }}
          whileHover={{ 
            scale: 1.05, 
            y: -5,
            transition: { duration: 0.2 }
          }}
          className="group relative p-4 sm:p-6 rounded-2xl backdrop-blur-lg border bg-gradient-to-br from-white/10 to-white/5 dark:from-gray-800/40 dark:to-gray-900/20 border-white/20 dark:border-gray-600/30 shadow-xl hover:shadow-2xl transition-all duration-300"
        >
          {/* Background glow effect */}
          <div className="absolute inset-0 rounded-2xl bg-gradient-to-r from-red-500/10 to-purple-500/10 dark:from-blue-500/10 dark:to-cyan-500/10 opacity-0 group-hover:opacity-100 transition-opacity duration-300" />
          
          <div className="relative z-10 text-center">
            {/* Icon */}
            <motion.div
              initial={{ scale: 0, rotate: -180 }}
              animate={{ scale: 1, rotate: 0 }}
              transition={{ 
                duration: 0.6, 
                delay: 2.7 + index * 0.1,
                type: "spring",
                stiffness: 200
              }}
              className="text-2xl sm:text-3xl mb-2 sm:mb-3"
            >
              {stat.icon}
            </motion.div>
            
            {/* Number */}
            <motion.div
              initial={{ scale: 0 }}
              animate={{ scale: 1 }}
              transition={{ 
                duration: 0.5, 
                delay: 2.8 + index * 0.1, 
                type: "spring", 
                stiffness: 200 
              }}
              className="text-2xl sm:text-3xl md:text-4xl font-black bg-gradient-to-r from-red-400 to-orange-500 dark:from-blue-400 dark:to-cyan-400 bg-clip-text text-transparent mb-1 sm:mb-2"
            >
              {stat.number}
            </motion.div>
            
            {/* Label */}
            <div className="text-xs sm:text-sm font-semibold text-gray-200 dark:text-gray-300 tracking-wide">
              {stat.label}
            </div>
          </div>
        </motion.div>
      ))}
    </motion.div>
  );
}
```

<!-- path: components/home/variants.ts -->
```typescript
import { TargetAndTransition, Variants } from "framer-motion";

export const containerVariants: Variants = {
  hidden: { opacity: 0 },
  visible: {
    opacity: 1,
    transition: {
      duration: 0.8,
      staggerChildren: 0.3,
      ease: "easeOut"
    },
  },
};

export const titleVariants: Variants = {
  hidden: { 
    opacity: 0, 
    y: 60, 
    scale: 0.8 
  },
  visible: {
    opacity: 1,
    y: 0,
    scale: 1,
    transition: { 
      duration: 1.2,
      type: "spring",
      stiffness: 100,
      damping: 12
    },
  },
};

export const subtitleVariants: Variants = {
  hidden: { 
    opacity: 0, 
    y: 40 
  },
  visible: {
    opacity: 1,
    y: 0,
    transition: {
      duration: 0.8,
      delay: 0.2,
      ease: [0.25, 0.1, 0.25, 1] as [number, number, number, number],
    },
  },
};

export const highlightVariants: Variants = {
  hidden: { 
    opacity: 0,
    scaleX: 0,
    transformOrigin: "left"
  },
  visible: {
    opacity: 1,
    scaleX: 1,
    transition: {
      duration: 1.2,
      delay: 1.5,
      ease: [0.25, 0.1, 0.25, 1] as [number, number, number, number],
    },
  },
};

export const ctaVariants: Variants = {
  hidden: { 
    opacity: 0, 
    y: 30, 
    scale: 0.9 
  },
  visible: {
    opacity: 1,
    y: 0,
    scale: 1,
    transition: { 
      duration: 0.8, 
      delay: 0.5,
      type: "spring",
      stiffness: 120,
      damping: 10
    },
  },
};

export const floatingAnimation: TargetAndTransition = {
  y: [-8, 8, -8],
  rotate: [-1, 1, -1],
  transition: {
    duration: 6,
    repeat: Infinity,
    ease: "easeInOut",
  },
};
```

<!-- path: components/home/AnimatedBackground.tsx -->
```typescript
"use client"
import Image from "next/image";
import { motion, useScroll, useTransform } from "framer-motion";
import { useState, useEffect } from "react";
import HnvImg from "@/public/hnv.webp";
import HnvImgMobile from "@/public/hnvmobile.webp";
import useIsMobile from "@/hooks/useIsMobile";

export default function AnimatedBackground() {
  const { scrollY } = useScroll();
  const backgroundY = useTransform(scrollY, [0, 500], [0, 150]);
  const isMobile = useIsMobile();
  const [isDarkMode, setIsDarkMode] = useState(false);

  useEffect(() => {
    // Check for dark mode preference
    const mediaQuery = window.matchMedia('(prefers-color-scheme: dark)');
    setIsDarkMode(mediaQuery.matches);
    
    const handler = (e: MediaQueryListEvent) => setIsDarkMode(e.matches);
    mediaQuery.addEventListener('change', handler);
    
    return () => mediaQuery.removeEventListener('change', handler);
  }, []);

  return (
    <>
      {/* Dynamic gradient overlay that adjusts for dark mode */}
      <div className={`fixed inset-0 z-0 transition-opacity duration-500 ${
        isDarkMode 
          ? "bg-gradient-to-b from-black/70 via-black/40 to-black/70" 
          : "bg-gradient-to-b from-black/40 via-transparent to-black/40"
      }`} />
      
      <motion.div 
        className="fixed inset-0 -z-10" 
        style={{ y: backgroundY }}
      >
        <Image
          src={isMobile ? HnvImgMobile : HnvImg}
          alt="Harinavi Transmission Background"
          fill
          className={`transition-all duration-700 object-cover ${
            isDarkMode ? "opacity-50" : "opacity-80"
          }`}
          priority
          quality={90}
          sizes="100vw"
          placeholder="blur"
          blurDataURL="data:image/jpeg;base64,/9j/4AAQSkZJRgABAQAAAQABAAD/2wBDAAYEBQYFBAYGBQYHBwYIChAKCgkJChQODwwQFxQYGBcUFhYaHSUfGhsjHBYWICwgIyYnKSopGR8tMC0oMCUoKSj/2wBDAQcHBwoIChMKChMoGhYaKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCj/wAARCAABAAEDASIAAhEBAxEB/8QAFQABAQAAAAAAAAAAAAAAAAAAAAv/xAAhEAACAQMDBQAAAAAAAAAAAAABAgMABAUGIWGRkqGx0f/EABUBAQEAAAAAAAAAAAAAAAAAAAMF/8QAGhEAAgIDAAAAAAAAAAAAAAAAAAECEgMRkf/aAAwDAQACEQMRAD8AltJagyeH0AthI5xdrLcNM91BF5pX2HaH9bcfaSXWGaRmknyJckliyjqTzSlT54b6bk+h0R//2Q=="
        />
      </motion.div>
    </>
  );
}
```

<!-- path: components/route-manager/schemas.ts -->
```typescript
// components/route-manager/schemas.ts
// Lightweight runtime validators (type guards) to avoid extra deps.

import { RouteDetailsPayload, EvolutionCommitPayload, Equipment, CableSegment, FiberSplice, Site } from './types';

function isSite(x: any): x is Site {
  return x && typeof x.id === 'string' && typeof x.name === 'string';
}

function isEquipment(x: any): x is Equipment {
  return (
    x && typeof x.id === 'string' && typeof x.name === 'string' &&
    x.equipment_type === 'junction_closure' &&
    typeof x.latitude === 'number' && typeof x.longitude === 'number' &&
    (x.status === 'existing' || x.status === 'planned') &&
    x.attributes &&
    (x.attributes.jc_type === 'inline' || x.attributes.jc_type === 'branching' || x.attributes.jc_type === 'terminal') &&
    typeof x.attributes.capacity === 'number' &&
    typeof x.attributes.position_on_route === 'number'
  );
}

export function isRouteDetailsPayload(x: any): x is RouteDetailsPayload {
  return (
    x && x.route && typeof x.route.id === 'string' && typeof x.route.name === 'string' &&
    isSite(x.route.start_site) && isSite(x.route.end_site) &&
    typeof x.route.capacity === 'number' && typeof x.route.distance_km === 'number' &&
    (x.route.evolution_status === 'simple' || x.route.evolution_status === 'with_jcs' || x.route.evolution_status === 'fully_segmented') &&
    Array.isArray(x.equipment) && x.equipment.every(isEquipment)
  );
}

export function isCableSegment(x: any): x is CableSegment {
  return (
    x && typeof x.segment_order === 'number' &&
    typeof x.start_point_id === 'string' && typeof x.end_point_id === 'string' &&
    (x.start_point_type === 'site' || x.start_point_type === 'equipment') &&
    (x.end_point_type === 'site' || x.end_point_type === 'equipment') &&
    typeof x.fiber_count === 'number' && typeof x.distance_km === 'number'
  );
}

export function isFiberSplice(x: any): x is FiberSplice {
  return (
    x && typeof x.equipment_id === 'string' && typeof x.incoming_segment_id === 'string' &&
    typeof x.incoming_fiber_number === 'number' && typeof x.outgoing_segment_id === 'string' &&
    typeof x.outgoing_fiber_number === 'number' &&
    (x.splice_type === 'through' || x.splice_type === 'tap' || x.splice_type === 'split') &&
    (x.status === 'active' || x.status === 'spare' || x.status === 'faulty')
  );
}

export function isEvolutionCommitPayload(x: any): x is EvolutionCommitPayload {
  const ok = (
    x && Array.isArray(x.plannedEquipment) &&
    Array.isArray(x.plannedSegments) &&
    Array.isArray(x.plannedSplices)
  );
  if (!ok) return false;

  // We validate shapes of elements loosely as they are Omit<...>
  const equipOk = x.plannedEquipment.every((e: any) => (
    e && typeof e.name === 'string' && e.equipment_type === 'junction_closure' &&
    typeof e.latitude === 'number' && typeof e.longitude === 'number' &&
    e.attributes && (e.attributes.jc_type === 'inline' || e.attributes.jc_type === 'branching' || e.attributes.jc_type === 'terminal') &&
    typeof e.attributes.capacity === 'number' && typeof e.attributes.position_on_route === 'number'
  ));

  const segOk = x.plannedSegments.every((s: any) => isCableSegment({ ...s, id: 'x' }));
  const spOk = x.plannedSplices.every((sp: any) => isFiberSplice({ ...sp, id: 'x' }));

  return equipOk && segOk && spOk;
}

```

<!-- path: components/route-manager/JcFormModal.tsx -->
```typescript
// path: components/route-manager/JcFormModal.tsx
'use client';

import { useEffect, useMemo } from 'react';
import { z } from 'zod';
import { useForm } from 'react-hook-form';
import { zodResolver } from '@hookform/resolvers/zod';
import { Modal } from '@/components/common/ui';
import { FormCard, FormInput, FormSearchableSelect } from '@/components/common/form';
import { createClient } from '@/utils/supabase/client';
import { Equipment } from './types';
import { toast } from 'sonner';
import { Junction_closuresInsertSchema, junction_closuresInsertSchema } from '@/schemas/zod-schemas';
import { Filters, useTableQuery } from '@/hooks/database';
import { Option } from '@/components/common/ui/select/SearchableSelect';


interface JcFormModalProps {
  isOpen: boolean;
  onClose: () => void;
  onSave: () => void; // Callback to trigger a refetch
  routeId: string | null;
  editingJc: Equipment | null;
  rkm: number | null;
}

export const JcFormModal: React.FC<JcFormModalProps> = ({ isOpen, onClose, onSave, routeId, editingJc, rkm }) => {
  const supabase = createClient();
  const isEditMode = !!editingJc;

  // Get the JC Lists
  const serverFilters = useMemo(() => {
      const f: Filters = {
        // Filter to download only categories with name not equal to "DEFAULT" and NODE_TYPES equal to "Joint / Splice Point"
        node_type_code: { operator: 'eq', value: 'BJC' },
        name: { operator: 'neq', value: 'DEFAULT' },
      };
      return f;
    }, []);
  const { data: jcLists } = useTableQuery(supabase, 'v_nodes_complete', { filters: serverFilters, columns: 'id, name, latitude, longitude' });

  // Local form schema: only validate the fields this form actually collects
  const junction_closuresFormSchema = junction_closuresInsertSchema.pick({
    node_id: true,
    position_km: true,
  });
  type JcFormValues = z.infer<typeof junction_closuresFormSchema>;

  const {
    register,
    handleSubmit,
    reset,
    control,
    watch,
    formState: { errors, isSubmitting },
  } = useForm<JcFormValues>({
    resolver: zodResolver(junction_closuresFormSchema),
    defaultValues: {
      node_id: '',
      position_km: null,
    },
  });

  useEffect(() => {
    if (isOpen) {
      if (editingJc) {
        // For planned equipment, we need to map the fields appropriately
        // Since Equipment doesn't have node_id, we'll need to handle this differently
        reset({
          node_id: '', // Planned equipment doesn't have a node_id yet
          position_km: editingJc.attributes.position_on_route
            ? (editingJc.attributes.position_on_route / 100) * (rkm || 0)
            : null,
        });
      } else {
        // Start with no selection for node; leave node_id undefined
        reset({
          node_id: '',
          position_km: null,
        });
      }
    }
  }, [isOpen, editingJc, reset, jcLists, rkm]);

  const jcOptions: Option[] = (jcLists || [])
  .filter(d => d.id != null && d.name != null)
  .map((d) => ({
    value: d.id as string,    // We've filtered out nulls, so it's safe to assert
    label: d.name as string,
  }));

  // Watch selected JC (node) id
  const selectedNodeId = watch("node_id");

  // If needed, you can derive latitude/longitude from selectedNodeId for display purposes
  // but they are not part of the form schema, so we do not set them in form state.
  useEffect(() => {
    if (!selectedNodeId) return;
    // Placeholder for any side effects when node changes
  }, [selectedNodeId]);

  const handleValidSubmit = async (formData: JcFormValues) => {
    if (!routeId) {
      toast.error("No route selected to add the JC to.");
      return;
    }

    if (formData.position_km && rkm && Number(formData.position_km) > Number(rkm)) {
      toast.error("Position on route (km) cannot be greater than Cable length.");
      return;
    }

    console.log('=== JC FORM SUBMIT DEBUG ===');
    console.log('routeId:', routeId);
    console.log('formData:', formData);
    console.log('isEditMode:', isEditMode);

    const payload = {
      ...formData,
      ofc_cable_id: routeId,
    };

    try {
      let jcData, insertError;

      if (isEditMode && editingJc) {
        // UPDATE existing junction closure
        console.log('Updating existing JC with ID:', editingJc.id);
        const { data, error } = await supabase
          .from('junction_closures')
          .update({
            node_id: payload.node_id,
            position_km: payload.position_km,
          })
          .eq('id', editingJc.id)
          .select();

        jcData = data;
        insertError = error;
      } else {
        // CREATE new junction closure using the RPC function
        console.log('Creating new JC');
        const result = await supabase
          .rpc('add_junction_closure', {
            p_node_id: payload.node_id,
            p_ofc_cable_id: payload.ofc_cable_id,
            p_position_km: payload.position_km
          });

        jcData = result.data;
        insertError = result.error;
      }

      console.log('Function result:', { jcData, insertError });

      if (insertError) {
        console.error('Database error:', insertError);
        toast.error(`Failed to ${isEditMode ? 'update' : 'create'} JC: ${insertError.message}`);
        return;
      }

      // If this is a new junction closure (not an edit), cable segments will be created automatically by database trigger
      if (!isEditMode && jcData) {
        // jcData is returned as an array from the database function
        const dataArray = Array.isArray(jcData) ? jcData : [jcData];
        if (dataArray && dataArray.length > 0) {
          const newJc = dataArray[0];
        } else {
          console.error('No JC data returned from database function');
        }
      }

      onSave(); // Trigger refetch on the parent page
      toast.success(`Junction Closure ${isEditMode ? 'updated' : 'created'} successfully!`);
      onClose();
    } catch (error) {
      console.error('Error in handleValidSubmit:', error);
    
      if (error instanceof Error) {
        toast.error(
          `Failed to ${isEditMode ? 'update' : 'create'} JC: ${error.message}`
        );
      } else {
        toast.error(
          `Failed to ${isEditMode ? 'update' : 'create'} JC: Unknown error`
        );
      }
    }
  };

  console.log('=== JcFormModal RENDERED ===');
  console.log('isOpen:', isOpen);
  console.log('routeId:', routeId);
  console.log('editingJc:', editingJc);

  return (
    <Modal isOpen={isOpen} onClose={onClose} title={isEditMode ? 'Edit Junction Closure' : 'Add Junction Closure'} >
      <FormCard
        title={isEditMode ? 'Edit Junction Closure' : 'Add Junction Closure'}
        onSubmit={handleSubmit(
          handleValidSubmit,
          () => toast.error('Please fix the highlighted fields')
        )}
        onCancel={onClose}
        isLoading={isSubmitting}
        heightClass="max-h-[80vh]"
        standalone
      >
        <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
          <FormSearchableSelect
            name="node_id"
            label="Junction Closure"
            control={control}
            options={jcOptions || []}
            error={errors.node_id}
            required
            placeholder="Select a Junction Closure"
          />
          <FormInput
            name="position_km"
            label="Position on Route (km)"
            type="number"
            step="0.01"
            register={register}
            error={errors.position_km}
            placeholder="e.g., 12.5"
          />
        </div>
      </FormCard>
    </Modal>
  );
};

```

<!-- path: components/route-manager/types.ts -->
```typescript
// path: components/route-manager/types.ts

import { Ofc_cablesRowSchema, V_junction_closures_completeRowSchema, V_ofc_cables_completeRowSchema } from "@/schemas/zod-schemas";

// The high-level route object, fetched for the selection dropdown
// export interface OfcForSelection {
//   id: string;
//   route_name: string;
//   capacity?: number; // FIXED: Added capacity as it's selected in the hook
// }

// Create a new schema with only the fields we want
export type OfcForSelection = Pick<Ofc_cablesRowSchema, 'id' | 'route_name' | 'capacity'>;

export type JunctionClosure = Pick<V_junction_closures_completeRowSchema, 'id' | 'node_id' | 'name' | 'ofc_cable_id' | 'latitude' | 'longitude' | 'position_km'>;

export type CableRoute = Pick<V_ofc_cables_completeRowSchema, 'id' | 'route_name' | 'capacity' | 'sn_id' | 'sn_name' | 'en_id' | 'en_name' | 'current_rkm'>;


// Detailed data for a selected route, fetched on the client
export interface RouteDetailsPayload {
  route: CableRoute;
  junction_closures: JunctionClosure[];
  equipment: Equipment[];
}

// Information for a single fiber within the Splice Matrix
export interface FiberInfo {
  fiber_no: number;
  status: 'available' | 'used_as_incoming' | 'used_as_outgoing' | 'terminated';
  splice_id: string | null;
  connected_to_cable: string | null;
  connected_to_fiber: number | null;
}

// Represents a cable column within the Splice Matrix
export interface CableInJc {
  cable_id: string;
  route_name: string;
  capacity: number;
  start_node: string;
  end_node: string;
  fibers: FiberInfo[];
}



// Represents a single row from the fiber_splices table
export interface SpliceConnection {
    splice_id: string;
    jc_id: string;
    jc_name: string;
    jc_position_km: number | null;
    incoming_cable_id: string;
    incoming_fiber_no: number;
    outgoing_cable_id: string | null;
    outgoing_fiber_no: number | null;
    otdr_length_km: number | null;
    loss_db: number | null;
}

// Represents the tree structure for the fiber trace visualization
export interface FiberTraceNode {
  type: 'NODE' | 'JC';
  id: string;
  name: string;
  children: {
    cable: {
      id: string;
      name: string;
      distance_km: number | null;
      is_otdr: boolean;
      fiber_no: number;
    };
    downstreamNode: FiberTraceNode | null;
  }[];
}

// NEW: Props for the SpliceMatrixModal component
export interface SpliceMatrixModalProps {
  jc: JunctionClosure | null;
  isOpen: boolean;
  onClose: () => void;
}

// NEW: Type for the return value of the auto-splice RPC
export interface AutoSpliceResult {
  splices_created: number;
}

// ========================================================================================================================


// The high-level route object, fetched on the server for initial selection
export interface RouteForSelection {
    id: string;
    route_name: string;
    evolution_status: 'simple' | 'with_jcs' | 'fully_segmented';
  }

  // Detailed data for a selected route, fetched on the client
  export interface Site {
    id: string;
    name: string;
  }

  export interface Equipment {
    id: string;
    name: string;
    equipment_type: 'junction_closure';
    latitude: number;
    longitude: number;
    status: 'existing' | 'planned'; // 'existing' from DB, 'planned' is new
    attributes: {
      jc_type: 'inline' | 'branching' | 'terminal';
      capacity: number;
      position_on_route: number; // 0-100%
    };
  }

  export interface CableSegment {
    id: string;
    segment_order: number;
    start_point_id: string;
    end_point_id: string;
    start_point_type: 'site' | 'equipment';
    end_point_type: 'site' | 'equipment';
    fiber_count: number;
    distance_km: number;
  }

  export interface FiberSplice {
    id: string;
    jc_id: string; // Junction closure ID
    incoming_cable_id: string; // Incoming cable ID
    incoming_fiber_no: number; // Incoming fiber number
    outgoing_cable_id: string | null; // Outgoing cable ID (nullable for termination)
    outgoing_fiber_no: number | null; // Outgoing fiber number (nullable for termination)
    splice_type: 'pass_through' | 'branch' | 'termination'; // Match SQL constraints
    status: 'active' | 'faulty' | 'reserved'; // Match SQL constraints
    logical_path_id?: string | null; // Optional logical path reference
    loss_db?: number | null; // Optional loss measurement
    otdr_length_km?: number | null; // Optional OTDR measurement
    created_at?: string; // Optional timestamps
    updated_at?: string;
  }

  // Payload for the POST request to commit changes
  export interface EvolutionCommitPayload {
    plannedEquipment: Omit<Equipment, 'status' | 'id'>[];
    plannedSegments: Omit<CableSegment, 'id'>[];
    plannedSplices: Omit<FiberSplice, 'id'>[];
  }
```

<!-- path: components/route-manager/CableSegmentationManager.tsx -->
```typescript
// components/ofc/CableSegmentationManager.tsx
'use client';

import { useState, useEffect, useCallback } from 'react';
import { Button } from '@/components/common/ui';
import { Card, CardHeader, CardBody } from '@/components/common/ui';
import { useCableSegmentation, JunctionClosure, CableSegment, SpliceConfiguration } from '@/hooks/ofc/useCableSegmentation';
import { createClient } from '@/utils/supabase/client';
import { toast } from 'sonner';
import { AlertCircle, Check, Info, Link, Loader2, MapPin, Plus, Settings, X } from 'lucide-react';

interface CableSegmentationManagerProps {
  cableId: string;
  cableName: string;
  onSegmentationComplete?: () => void;
}

export const CableSegmentationManager = ({
  cableId,
  cableName,
  onSegmentationComplete
}: CableSegmentationManagerProps) => {
  const [junctionClosures, setJunctionClosures] = useState<JunctionClosure[]>([]);
  const [cableSegments, setCableSegments] = useState<CableSegment[]>([]);
  const [showAddJCForm, setShowAddJCForm] = useState(false);
  const [newJCData, setNewJCData] = useState({
    name: '',
    position_km: 0,
  });

  const supabase = createClient();
  const {
    isLoading,
    error,
    addJunctionClosure,
    createCableSegments,
    createInitialFiberConnections,
    updateFiberConnections,
  } = useCableSegmentation();

  const loadExistingData = useCallback(async () => {
    // Don't load if no cable is selected
    if (!cableId || cableId === '') {
      setJunctionClosures([]);
      setCableSegments([]);
      return;
    }
  
    try {
      // Load junction closures
      const { data: jcData, error: jcError } = await supabase
        .from('junction_closures')
        .select('*')
        .eq('ofc_cable_id', cableId)
        .order('position_km');
  
      if (jcError) throw jcError;
      setJunctionClosures(jcData || []);
  
      // Load cable segments
      const { data: segmentData, error: segmentError } = await supabase
        .from('cable_segments')
        .select('*')
        .eq('original_cable_id', cableId)
        .order('segment_order');
  
      if (segmentError) throw segmentError;
      setCableSegments(segmentData || []);
    } catch (err) {
      if (err instanceof Error) {
        toast.error(`Failed to load data: ${err.message}`);
      } else {
        toast.error(`Failed to load data: Unknown error`);
      }
    }
  }, [cableId, supabase]);



  // Load existing junction closures and segments
  useEffect(() => {
    loadExistingData();
  }, [cableId, loadExistingData]);



  const handleAddJunctionClosure = async () => {
    if (!newJCData.name || newJCData.position_km <= 0) {
      toast.error('Please provide valid JC name and position');
      return;
    }

    console.log('=== CABLE SEGMENTATION JC ADD DEBUG ===');
    console.log('cableId:', cableId);
    console.log('newJCData:', newJCData);

    try {
      const jc = await addJunctionClosure(cableId, newJCData.position_km, newJCData.name);
      if (jc) {
        console.log('JC created:', jc);

        // Create cable segments (this will recreate all segments for the cable)
        const segments = await createCableSegments(jc.id, cableId);
        console.log('Segments created:', segments);

        if (segments.length > 0) {
          // Create initial fiber connections for each segment
          for (const segment of segments) {
            await createInitialFiberConnections(segment.id);
          }

          await loadExistingData();
          setShowAddJCForm(false);
          setNewJCData({ name: '', position_km: 0 });
          onSegmentationComplete?.();
        } else {
          console.warn('No segments were created');
          toast.error('No cable segments were created. Please check the cable configuration.');
        }
      }
    } catch (error) {
      console.error('Error in handleAddJunctionClosure:', error);
      toast.error(`Failed to add junction closure: ${error}`);
    }
  };

  const handleApplySplices = async (segmentId: string, spliceConfig: SpliceConfiguration[]) => {
    // Find the junction closure between segments
    const segment = cableSegments.find(s => s.id === segmentId);
    if (!segment || segment.end_node_type !== 'jc') return;

    const nextSegment = cableSegments.find(s =>
      s.original_cable_id === segment.original_cable_id &&
      s.segment_order === segment.segment_order + 1
    );

    if (!nextSegment) return;

    await updateFiberConnections(
      segment.end_node_id,
      segmentId,
      nextSegment.id,
      spliceConfig
    );

    toast.success('Splice configuration applied successfully');
  };

    // Don't render if no cable is selected
    if (!cableId || cableId === '') {
      return (
        <div className="space-y-6">
          <Card>
            <CardHeader>
              <h2 className="text-lg font-semibold">Cable Segmentation Management</h2>
              <p className="text-sm text-gray-600 dark:text-gray-400">
                Please select a cable first
              </p>
            </CardHeader>
            <CardBody>
              <div className="text-center py-8">
                <p className="text-gray-500 dark:text-gray-400">
                  Select an OFC route above to manage its cable segmentation.
                </p>
              </div>
            </CardBody>
          </Card>
        </div>
      );
    }

  return (
    <div className="space-y-6">
  <Card className="bg-white dark:bg-gray-800 border border-gray-200 dark:border-gray-700 shadow-sm">
    <CardHeader className="pb-4">
      <h2 className="text-xl font-semibold text-gray-900 dark:text-white">Cable Segmentation Management</h2>
      <p className="text-sm text-gray-600 dark:text-gray-300">
        Cable: <span className="font-medium">{cableName}</span> (<span className="font-mono">{cableId}</span>)
      </p>
    </CardHeader>
    
    <CardBody className="pt-4">
      <div className="space-y-6">
        {/* Add JC Button */}
        <Button
          onClick={() => setShowAddJCForm(!showAddJCForm)}
          disabled={isLoading}
          className="w-full sm:w-auto bg-blue-600 hover:bg-blue-700 disabled:bg-gray-400 dark:disabled:bg-gray-600 text-white font-medium py-2.5 px-4 rounded-lg transition-colors duration-200"
        >
          {showAddJCForm ? (
            <span className="flex items-center justify-center">
              <X className="w-4 h-4 mr-2" />
              Cancel
            </span>
          ) : (
            <span className="flex items-center justify-center">
              <Plus className="w-4 h-4 mr-2" />
              Add Junction Closure
            </span>
          )}
        </Button>

        {/* Add JC Form */}
        {showAddJCForm && (
          <Card className="border-2 border-dashed border-gray-300 dark:border-gray-600 bg-gray-50 dark:bg-gray-900/50">
            <CardBody className="p-6">
              <div className="space-y-4">
                <div>
                  <label className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2">
                    Junction Closure Name
                  </label>
                  <input
                    type="text"
                    value={newJCData.name}
                    onChange={(e) => setNewJCData({ ...newJCData, name: e.target.value })}
                    placeholder="JC-001"
                    className="w-full p-3 border border-gray-300 dark:border-gray-600 rounded-lg bg-white dark:bg-gray-800 text-gray-900 dark:text-white placeholder-gray-500 dark:placeholder-gray-400 focus:ring-2 focus:ring-blue-500 focus:border-transparent transition-all duration-200"
                  />
                </div>
                <div>
                  <label className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2">
                    Position (km from start)
                  </label>
                  <input
                    type="number"
                    step="0.1"
                    min="0.1"
                    value={newJCData.position_km || ''}
                    onChange={(e) => setNewJCData({ ...newJCData, position_km: parseFloat(e.target.value) || 0 })}
                    placeholder="5.5"
                    className="w-full p-3 border border-gray-300 dark:border-gray-600 rounded-lg bg-white dark:bg-gray-800 text-gray-900 dark:text-white placeholder-gray-500 dark:placeholder-gray-400 focus:ring-2 focus:ring-blue-500 focus:border-transparent transition-all duration-200"
                  />
                </div>
                <Button
                  onClick={handleAddJunctionClosure}
                  disabled={isLoading || !newJCData.name || newJCData.position_km <= 0}
                  className="w-full bg-green-600 hover:bg-green-700 disabled:bg-gray-400 dark:disabled:bg-gray-600 text-white font-medium py-2.5 px-4 rounded-lg transition-colors duration-200"
                >
                  {isLoading ? (
                    <span className="flex items-center justify-center">
                      <Loader2 className="w-4 h-4 mr-2 animate-spin" />
                      Adding...
                    </span>
                  ) : (
                    <span className="flex items-center justify-center">
                      <Check className="w-4 h-4 mr-2" />
                      Add Junction Closure
                    </span>
                  )}
                </Button>
              </div>
            </CardBody>
          </Card>
        )}

        {/* Existing Junction Closures */}
        {junctionClosures.length > 0 && (
          <div>
            <h3 className="text-lg font-semibold text-gray-900 dark:text-white mb-4 flex items-center">
              <MapPin className="w-5 h-5 mr-2 text-blue-500" />
              Junction Closures ({junctionClosures.length})
            </h3>
            <div className="grid gap-3 sm:grid-cols-1 md:grid-cols-2 lg:grid-cols-1">
              {junctionClosures.map((jc) => (
                <Card key={jc.node_id} className="bg-white dark:bg-gray-800 border border-gray-200 dark:border-gray-700 hover:shadow-md transition-shadow duration-200">
                  <CardBody className="p-4">
                    <div className="flex flex-col sm:flex-row sm:justify-between sm:items-center gap-3">
                      <div className="flex-1">
                        <div className="flex items-center gap-2 mb-1">
                          <h4 className="font-medium text-gray-900 dark:text-white">{jc.name}</h4>
                          <span className="inline-flex items-center px-2 py-1 rounded-full text-xs font-medium bg-blue-100 dark:bg-blue-900 text-blue-800 dark:text-blue-200">
                            {jc.position_km} km
                          </span>
                        </div>
                        <p className="text-sm text-gray-600 dark:text-gray-400">
                          Created: {new Date(jc.created_at).toLocaleDateString()}
                        </p>
                      </div>
                      <div className="text-sm text-gray-500 dark:text-gray-400 bg-gray-50 dark:bg-gray-900 px-3 py-1 rounded-md">
                        ID: {jc.node_id.slice(0, 8)}...
                      </div>
                    </div>
                  </CardBody>
                </Card>
              ))}
            </div>
          </div>
        )}

        {/* Cable Segments */}
        {cableSegments.length > 0 && (
          <div>
            <h3 className="text-lg font-semibold text-gray-900 dark:text-white mb-4 flex items-center">
              <Link className="w-5 h-5 mr-2 text-green-500" />
              Cable Segments ({cableSegments.length})
            </h3>
            <div className="grid gap-3 sm:grid-cols-1 lg:grid-cols-2">
              {cableSegments.map((segment) => (
                <Card key={segment.id} className="bg-white dark:bg-gray-800 border border-gray-200 dark:border-gray-700 hover:shadow-md transition-shadow duration-200">
                  <CardBody className="p-4">
                    <div className="flex flex-col gap-3">
                      <div className="flex justify-between items-start">
                        <div>
                          <h4 className="font-medium text-gray-900 dark:text-white mb-1">
                            Segment #{segment.segment_order}
                          </h4>
                          <div className="flex items-center gap-2 text-sm text-gray-600 dark:text-gray-400 mb-2">
                            <span className="bg-gray-100 dark:bg-gray-700 px-2 py-1 rounded">
                              {segment.start_node_type === 'node' ? 'Node' : 'JC'}  {segment.end_node_type === 'node' ? 'Node' : 'JC'}
                            </span>
                          </div>
                          <div className="text-sm text-gray-600 dark:text-gray-400 space-y-1">
                            <p>Distance: <span className="font-medium">{segment.distance_km} km</span></p>
                            <p>Fibers: <span className="font-medium">{segment.fiber_count}</span></p>
                          </div>
                        </div>
                      </div>
                      <Button
                        size="sm"
                        onClick={() => handleApplySplices(segment.id, [])}
                        disabled={isLoading}
                        className="w-full sm:w-auto bg-gray-600 hover:bg-gray-700 disabled:bg-gray-400 dark:disabled:bg-gray-600 text-white font-medium py-2 px-4 rounded-lg transition-colors duration-200"
                      >
                        <Settings className="w-4 h-4 mr-2" />
                        Configure Splices
                      </Button>
                    </div>
                  </CardBody>
                </Card>
              ))}
            </div>
          </div>
        )}

        {/* Empty States */}
        {junctionClosures.length === 0 && cableSegments.length === 0 && !showAddJCForm && (
          <div className="text-center py-8">
            <div className="mx-auto w-16 h-16 bg-gray-100 dark:bg-gray-700 rounded-full flex items-center justify-center mb-4">
              <Info className="w-8 h-8 text-gray-400" />
            </div>
            <h3 className="text-lg font-medium text-gray-900 dark:text-white mb-2">No segments yet</h3>
            <p className="text-gray-600 dark:text-gray-400 max-w-md mx-auto">
              Start by adding a junction closure to create your first cable segment.
            </p>
          </div>
        )}

        {error && (
          <div className="bg-red-50 dark:bg-red-900/20 border border-red-200 dark:border-red-800 rounded-lg p-4">
            <div className="flex items-center">
              <AlertCircle className="w-5 h-5 text-red-500 mr-2" />
              <p className="text-red-800 dark:text-red-300 font-medium">Error</p>
            </div>
            <p className="text-red-700 dark:text-red-400 mt-1 text-sm">{error}</p>
          </div>
        )}
      </div>
    </CardBody>
  </Card>
</div>
  );
};

```

<!-- path: components/route-manager/ui/AddJcForm.tsx -->
```typescript
// components/route-manager/ui/AddJcForm.tsx
"use client";

import { useState } from 'react';
import { Equipment, RouteDetailsPayload } from '@/components/route-manager/types';

interface Props {
  route: RouteDetailsPayload['route'];
  onAddJc: (jc: Omit<Equipment, 'id' | 'status'>) => void;
}

// Define the initial state for the form
const getInitialState = () => ({
  name: '',
  latitude: 0,
  longitude: 0,
  jc_type: 'inline' as const,
  capacity: 48,
  position_on_route: 50,
});

export default function AddJcForm({ route, onAddJc }: Props) {
  const [newJC, setNewJC] = useState(getInitialState());

  const handleSubmit = () => {
    // Basic validation
    if (!newJC.name || newJC.latitude === 0 || newJC.longitude === 0) {
      alert('Please fill in JC Name, Latitude, and Longitude.');
      return;
    }

    // Call the parent component's handler with the structured data
    onAddJc({
      name: newJC.name,
      equipment_type: 'junction_closure',
      latitude: newJC.latitude,
      longitude: newJC.longitude,
      attributes: {
        jc_type: newJC.jc_type,
        capacity: newJC.capacity,
        position_on_route: newJC.position_on_route,
      },
    });

    // Reset the form for the next entry
    setNewJC(getInitialState());
  };

  return (
    <div className="bg-yellow-50 dark:bg-yellow-900/20 p-4 rounded-lg border border-yellow-200 dark:border-yellow-800">
      <h4 className="font-semibold text-gray-900 dark:text-white mb-3">Add New Junction Closure</h4>
      <div className="space-y-3">
        <div>
          <label className="block text-xs font-medium text-gray-700 dark:text-gray-300 mb-1">
            JC Name *
          </label>
          <input
            type="text"
            value={newJC.name}
            onChange={(e) => setNewJC({ ...newJC, name: e.target.value })}
            placeholder="JC-SITE-001"
            className="w-full p-2 text-sm border border-gray-300 dark:border-gray-600 rounded bg-white dark:bg-gray-700 text-gray-900 dark:text-white"
          />
        </div>

        <div className="grid grid-cols-2 gap-2">
          <div>
            <label className="block text-xs font-medium text-gray-700 dark:text-gray-300 mb-1">
              Latitude
            </label>
            <input
              type="number"
              step="0.000001"
              value={newJC.latitude || ''}
              onChange={(e) => setNewJC({ ...newJC, latitude: parseFloat(e.target.value) })}
              className="w-full p-2 text-sm border border-gray-300 dark:border-gray-600 rounded bg-white dark:bg-gray-700 text-gray-900 dark:text-white"
            />
          </div>
          <div>
            <label className="block text-xs font-medium text-gray-700 dark:text-gray-300 mb-1">
              Longitude
            </label>
            <input
              type="number"
              step="0.000001"
              value={newJC.longitude || ''}
              onChange={(e) => setNewJC({ ...newJC, longitude: parseFloat(e.target.value) })}
              className="w-full p-2 text-sm border border-gray-300 dark:border-gray-600 rounded bg-white dark:bg-gray-700 text-gray-900 dark:text-white"
            />
          </div>
        </div>

        <div>
          <label className="block text-xs font-medium text-gray-700 dark:text-gray-300 mb-1">
            Position on Route: {newJC.position_on_route}%
          </label>
          <input
            type="range"
            min="5"
            max="95"
            value={newJC.position_on_route}
            onChange={(e) => setNewJC({ ...newJC, position_on_route: Number(e.target.value) })}
            className="w-full"
          />
          <div className="text-xs text-gray-500 dark:text-gray-400 text-center">
            ~{(route.distance_km * newJC.position_on_route / 100).toFixed(1)} km from {route.start_site.name}
          </div>
        </div>

        <div className="grid grid-cols-2 gap-2">
          <div>
            <label className="block text-xs font-medium text-gray-700 dark:text-gray-300 mb-1">
              JC Type
            </label>
            <select
              value={newJC.jc_type}
              onChange={(e) => setNewJC({ ...newJC, jc_type: e.target.value as any })}
              className="w-full p-2 text-sm border border-gray-300 dark:border-gray-600 rounded bg-white dark:bg-gray-700 text-gray-900 dark:text-white"
            >
              <option value="inline">Inline</option>
              <option value="branching">Branching</option>
              <option value="terminal">Terminal</option>
            </select>
          </div>
          <div>
            <label className="block text-xs font-medium text-gray-700 dark:text-gray-300 mb-1">
              Splice Capacity
            </label>
            <select
              value={newJC.capacity}
              onChange={(e) => setNewJC({ ...newJC, capacity: Number(e.target.value) })}
              className="w-full p-2 text-sm border border-gray-300 dark:border-gray-600 rounded bg-white dark:bg-gray-700 text-gray-900 dark:text-white"
            >
              <option value={24}>24 Splice</option>
              <option value={48}>48 Splice</option>
              <option value={96}>96 Splice</option>
              <option value={144}>144 Splice</option>
            </select>
          </div>
        </div>

        <button
          onClick={handleSubmit}
          disabled={!newJC.name || newJC.latitude === 0 || newJC.longitude === 0}
          className="w-full p-2 bg-green-500 text-white rounded-md hover:bg-green-600 disabled:bg-gray-400 disabled:cursor-not-allowed text-sm font-semibold"
        >
          Add JC to Route
        </button>
      </div>
    </div>
  );
}
```

<!-- path: components/route-manager/ui/CommitView.tsx -->
```typescript
// components/route-manager/ui/CommitView.tsx
"use client";

import { Equipment, CableSegment, FiberSplice } from '@/components/route-manager/types';

interface Props {
  equipment: Equipment[];
  segments: CableSegment[];
  splices: FiberSplice[]; // Pass the calculated splices for a full summary
  onCommit: () => void;
  isCommitting: boolean;
}

export default function CommitView({ equipment, segments, splices, onCommit, isCommitting }: Props) {
  const plannedJCs = equipment.filter(eq => eq.status === 'planned');

  if (plannedJCs.length === 0) {
    return (
        <div className="bg-gray-50 dark:bg-gray-800 p-8 rounded-lg text-center">
            <h4 className="text-lg font-medium text-gray-900 dark:text-white mb-1">Nothing to Commit</h4>
            <p className="text-sm text-gray-500 dark:text-gray-400">
                Add one or more new Junction Closures to the route before committing.
            </p>
        </div>
    );
  }

  return (
    <div className="space-y-4">
      <div className="bg-blue-50 dark:bg-blue-900/20 p-4 rounded-lg border border-blue-200 dark:border-blue-800">
        <h4 className="font-semibold text-blue-800 dark:text-blue-200 mb-2">Review & Commit Changes</h4>
        <p className="text-sm text-blue-700 dark:text-blue-300">
          This will permanently update the route structure by adding {plannedJCs.length} new junction closure(s) and creating {segments.length} new cable segments.
        </p>
      </div>

      <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
        <div className="bg-white dark:bg-gray-800 p-4 rounded-lg border border-gray-200 dark:border-gray-700">
          <h4 className="font-semibold text-gray-900 dark:text-white mb-3">
            <span className="text-green-500 font-mono text-xs py-1 px-2 bg-green-100 dark:bg-green-900 rounded mr-2">ADD</span>
            New Junction Closures
          </h4>
          <ul className="space-y-2">
            {plannedJCs.map(jc => (
              <li key={jc.id} className="flex justify-between text-sm">
                <span className="font-medium text-gray-800 dark:text-gray-200">{jc.name}</span>
                <span className="text-gray-600 dark:text-gray-400">{jc.attributes.position_on_route}% on route</span>
              </li>
            ))}
          </ul>
        </div>

        <div className="bg-white dark:bg-gray-800 p-4 rounded-lg border border-gray-200 dark:border-gray-700">
          <h4 className="font-semibold text-gray-900 dark:text-white mb-3">
            <span className="text-green-500 font-mono text-xs py-1 px-2 bg-green-100 dark:bg-green-900 rounded mr-2">CREATE</span>
            New Cable Segments
          </h4>
          <ul className="space-y-2">
            {segments.map(segment => (
              <li key={segment.id} className="flex justify-between text-sm">
                <span className="text-gray-800 dark:text-gray-200">
                  Segment #{segment.segment_order}
                </span>
                <span className="text-gray-600 dark:text-gray-400">{segment.distance_km} km</span>
              </li>
            ))}
          </ul>
        </div>
      </div>

      {splices.length > 0 && (
        <div className="bg-white dark:bg-gray-800 p-4 rounded-lg border border-gray-200 dark:border-gray-700">
            <h4 className="font-semibold text-gray-900 dark:text-white mb-3">
                <span className="text-green-500 font-mono text-xs py-1 px-2 bg-green-100 dark:bg-green-900 rounded mr-2">CREATE</span>
                New Fiber Splices
            </h4>
            <div className="text-center text-sm text-gray-700 dark:text-gray-300">
                A total of <span className="font-bold text-lg">{splices.length}</span> default "through" splices will be created.
            </div>
        </div>
      )}

      <div className="flex justify-end mt-6">
        <button
          onClick={onCommit}
          disabled={isCommitting}
          className="px-8 py-2 bg-purple-600 text-white font-semibold rounded-md hover:bg-purple-700 disabled:bg-gray-500 disabled:cursor-wait"
        >
          {isCommitting ? 'Committing...' : 'Confirm & Commit Evolution'}
        </button>
      </div>
    </div>
  );
}
```

<!-- path: components/route-manager/ui/RouteVisualization.tsx -->
```typescript
// components/route-manager/ui/RouteVisualization.tsx
'use client';

import { useMemo } from 'react';
import { Equipment, RouteDetailsPayload } from '@/components/route-manager/types';
import { Button } from '@/components/common/ui';
import { FiEdit, FiTrash2 } from 'react-icons/fi';

interface Props {
  routeDetails: RouteDetailsPayload;
  onJcClick: (jc: Equipment) => void;
  onEditJc: (jc: Equipment) => void;
  onDeleteJc: (jc: Equipment) => void;
}

export default function RouteVisualization({ routeDetails, onJcClick, onEditJc, onDeleteJc }: Props) {
  const { route, equipment } = routeDetails;

  // Combine start node, sorted equipment (JCs), and end node into a single array of points
  const points = useMemo(() => [
    { type: 'node' as const, id: route.start_node.id, name: route.start_node.name, position: 0 },
    ...[...equipment].sort((a, b) => a.attributes.position_on_route - b.attributes.position_on_route)
                     .map(jc => ({ type: 'jc' as const, ...jc, position: jc.attributes.position_on_route })),
    { type: 'node' as const, id: route.end_node.id, name: route.end_node.name, position: route.distance_km },
  ], [route, equipment]);

  const totalDistance = route.distance_km || 1;

  // Helper to determine color based on JC type
  const getJcColor = (jcType: string) => {
    switch (jcType) {
      case 'branching': return 'bg-orange-500';
      case 'terminal': return 'bg-red-500';
      default: return 'bg-green-500';
    }
  };

  return (
    <div className="bg-gray-50 dark:bg-gray-800/50 p-6 rounded-lg border dark:border-gray-700">
      <h3 className="text-lg font-semibold text-gray-900 dark:text-white mb-12">
        Route Topology
      </h3>
      <div className="relative w-full h-1 bg-gray-300 dark:bg-gray-600 my-8">
          <div className="relative flex justify-between w-full h-full">
            {points.map((point, index) => {
              const leftPercentage = Math.min(100, Math.max(0, (point.position / totalDistance) * 100));
              return (
                <div
                  key={`${point.type}-${point.id}-${index}`}
                  className="absolute top-1/2 -translate-y-1/2 flex flex-col items-center group z-10"
                  style={{ left: `${leftPercentage}%`, transform: 'translateX(-50%)' }}
                >
                  <div
                    className={`w-10 h-10 rounded-full flex items-center justify-center border-4 ${point.type === 'node' ? 'bg-blue-600 border-white dark:border-gray-800' : `${getJcColor((point as Equipment).attributes.jc_type)} border-white dark:border-gray-800 cursor-pointer hover:scale-110 transition-transform`}`}
                    onClick={() => point.type === 'jc' && onJcClick(point as Equipment)}
                  >
                    <span className="text-white font-bold text-sm">{point.type === 'node' ? 'N' : 'JC'}</span>
                  </div>
                  <div className="absolute top-12 text-center w-28">
                    <p className="text-xs font-semibold text-gray-700 dark:text-gray-300 truncate" title={point.name}>{point.name}</p>
                    <p className="text-xs text-gray-500 dark:text-gray-400">{point.position} km</p>
                  </div>
                  {point.type === 'jc' && (
                    <div className="absolute -top-10 flex gap-1 opacity-0 group-hover:opacity-100 transition-opacity duration-200">
                        <Button size="xs" variant="outline" onClick={(e) => { e.stopPropagation(); onEditJc(point as Equipment)}} title="Edit JC"> <FiEdit className="h-3 w-3" /> </Button>
                        <Button size="xs" variant="danger" onClick={(e) => { e.stopPropagation(); onDeleteJc(point as Equipment)}} title="Delete JC"> <FiTrash2 className="h-3 w-3" /> </Button>
                    </div>
                  )}
                </div>
              );
            })}
        </div>
      </div>
    </div>
  );
}
```

<!-- path: components/route-manager/logic/project.ts -->
```typescript
// components/route-manager/logic/project.ts

import { CableSegment, Equipment, FiberSplice, RouteDetailsPayload } from '../types';

export type BranchConfig = {
  target_id: string; // site or equipment id
  target_type: 'site' | 'equipment';
  distance_km: number; // length of the branch cable
  tap_fibers: number; // number of fibers to tap towards branch
};
export type BranchConfigMap = Record<string, BranchConfig>; // key: jc.id

// Project cable segments between start -> JCs -> end, ordered by position_on_route
export function projectSegments(
  route: RouteDetailsPayload['route'],
  equipment: Equipment[],
  branchConfig?: BranchConfigMap
): CableSegment[] {
  const sorted = [...equipment].sort(
    (a, b) => a.attributes.position_on_route - b.attributes.position_on_route
  );

  const points = [
    { id: route.start_site.id, type: 'site' as const, position: 0 },
    ...sorted.map((jc) => ({ id: jc.id, type: 'equipment' as const, position: jc.attributes.position_on_route })),
    { id: route.end_site.id, type: 'site' as const, position: 100 },
  ];

  const segments: CableSegment[] = [];
  let order = 1;
  for (let i = 0; i < points.length - 1; i++) {
    const start = points[i];
    const end = points[i + 1];
    const pct = Math.max(0, end.position - start.position) / 100;
    const distance = Math.round(route.distance_km * pct * 1000) / 1000; // km with 3 decimals
    segments.push({
      id: `proj-seg-${route.id}-${order}`,
      segment_order: order,
      start_point_id: start.id,
      end_point_id: end.id,
      start_point_type: start.type,
      end_point_type: end.type,
      fiber_count: route.capacity,
      distance_km: distance,
    });
    order++;
  }

  // Create branch segments based on provided config, fallback to small placeholder if branching without config
  const BRANCH_DEFAULT_KM = Math.max(0.2, Math.min(2, route.distance_km * 0.1)); // between 0.2 and 2 km
  for (const jc of equipment) {
    if (jc.attributes.jc_type === 'branching') {
      const cfg = branchConfig?.[jc.id];
      const endPointId = cfg?.target_id ?? `branch-end-${jc.id}`;
      const endPointType = cfg?.target_type ?? 'site';
      const distance = Math.round((cfg?.distance_km ?? BRANCH_DEFAULT_KM) * 1000) / 1000;
      segments.push({
        id: `proj-branch-${route.id}-${jc.id}`,
        segment_order: order++,
        start_point_id: jc.id,
        end_point_id: endPointId,
        start_point_type: 'equipment',
        end_point_type: endPointType,
        fiber_count: route.capacity,
        distance_km: distance,
      });
    }
  }
  return segments;
}

// Create default "through" splices as a placeholder; can be refined later.
export function projectDefaultSplices(
  route: RouteDetailsPayload['route'],
  segments: CableSegment[],
  equipment: Equipment[],
  branchConfig?: BranchConfigMap
): FiberSplice[] {
  const splices: FiberSplice[] = [];
  const DEFAULT_TAP_FIBERS = 2; // fallback

  // Build index of segments by their connection to speed lookups
  const segsByStart: Record<string, CableSegment[]> = {};
  const segsByEnd: Record<string, CableSegment[]> = {};
  for (const s of segments) {
    (segsByStart[s.start_point_id] ||= []).push(s);
    (segsByEnd[s.end_point_id] ||= []).push(s);
  }

  for (const jc of equipment) {
    const incoming = (segsByEnd[jc.id] || []).find(s => s.end_point_id === jc.id);
    const mainOutgoing = (segsByStart[jc.id] || []).find(s => s.start_point_id === jc.id && !s.id.startsWith('proj-branch-'));
    const branchOutgoing = (segsByStart[jc.id] || []).find(s => s.id.startsWith('proj-branch-'));

    if (!incoming || !mainOutgoing) continue; // need both to splice

    const fiberCount = Math.min(incoming.fiber_count, mainOutgoing.fiber_count);

    if (jc.attributes.jc_type === 'branching' && branchOutgoing) {
      const cfgTap = branchConfig?.[jc.id]?.tap_fibers ?? DEFAULT_TAP_FIBERS;
      // Through most fibers on the main, tap a few to the branch
      for (let i = 1; i <= fiberCount; i++) {
        if (i <= cfgTap) {
          splices.push({
            id: `sp-tap-${jc.id}-${i}`,
            equipment_id: jc.id,
            incoming_segment_id: incoming.id,
            incoming_fiber_number: i,
            outgoing_segment_id: branchOutgoing.id,
            outgoing_fiber_number: i,
            splice_type: 'tap',
            status: 'active',
          });
        } else {
          splices.push({
            id: `sp-through-${jc.id}-${i}`,
            equipment_id: jc.id,
            incoming_segment_id: incoming.id,
            incoming_fiber_number: i,
            outgoing_segment_id: mainOutgoing.id,
            outgoing_fiber_number: i,
            splice_type: 'through',
            status: 'active',
          });
        }
      }
    } else {
      // Inline: through all fibers by default
      for (let i = 1; i <= fiberCount; i++) {
        splices.push({
          id: `sp-through-${jc.id}-${i}`,
          equipment_id: jc.id,
          incoming_segment_id: incoming.id,
          incoming_fiber_number: i,
          outgoing_segment_id: mainOutgoing.id,
          outgoing_fiber_number: i,
          splice_type: 'through',
          status: 'active',
        });
      }
    }
  }

  return splices;
}

```

<!-- path: components/route-manager/RouteManager.tsx -->
```typescript
import { useState, useMemo, useEffect } from 'react';
import { useQuery, useMutation, useQueryClient } from '@tanstack/react-query';
import { queryKeys } from '@/components/route-manager/queryKeys';
import {
  projectSegments,
  projectDefaultSplices,
} from '@/components/route-manager/logic/project';
import type { BranchConfigMap } from '@/components/route-manager/logic/project';
import { isRouteDetailsPayload } from '@/components/route-manager/schemas';
import {
  RouteForSelection,
  RouteDetailsPayload,
  Equipment,
  CableSegment,
  FiberSplice,
  EvolutionCommitPayload,
} from '@/components/route-manager/types';
import AddJcForm from '@/components/route-manager/ui/AddJcForm';
import RouteVisualization from '@/components/route-manager/ui/RouteVisualization';
import CommitView from '@/components/route-manager/ui/CommitView';
import { FiberSpliceManager } from '@/components/route-manager/FiberSpliceManager';
import { SearchableSelect } from '@/components/common/ui/select/SearchableSelect';
import { JcFormModal } from '@/components/route-manager/JcFormModal';
import {
  DataQueryHookParams,
  DataQueryHookReturn,
  useCrudManager,
} from '@/hooks/useCrudManager';
import { OfcConnectionRowsWithCount } from '@/types/view-row-types';
import { createClient } from '@/utils/supabase/client';
import { useParams } from 'next/navigation';
import { usePagedOfcConnectionsComplete } from '@/hooks/database';

// 1. ADAPTER HOOK: Makes `useOfcData` compatible with `useCrudManager`
const useOfcConnectionsData = (
  params: DataQueryHookParams
): DataQueryHookReturn<OfcConnectionRowsWithCount> => {
  const { currentPage, pageLimit, searchQuery } = params;
  const supabase = createClient();
  const { id } = useParams();
  const cableId = id as string;

  const { data, isLoading, error, refetch } = usePagedOfcConnectionsComplete(
    supabase,
    {
      filters: { ofc_id: cableId, ...(searchQuery ? { searchQuery } : {}) },
      limit: 300,
      offset: (currentPage - 1) * pageLimit,
    }
  );

  // Calculate counts from the full dataset
  const totalCount = data?.[0]?.total_count || 0;
  const activeCount = data?.[0]?.active_count || 0;
  const inactiveCount = data?.[0]?.inactive_count || 0;

  return {
    data: data || [],
    totalCount,
    activeCount,
    inactiveCount,
    isLoading,
    error,
    refetch,
  } as unknown as DataQueryHookReturn<OfcConnectionRowsWithCount>;
};

// --- Client-Side API Functions ---
const fetchRouteDetails = async (
  routeId: string
): Promise<RouteDetailsPayload> => {
  const res = await fetch(`/api/route/${routeId}`);
  if (!res.ok) throw new Error('Failed to fetch route details');
  const data = await res.json();
  if (!isRouteDetailsPayload(data)) {
    throw new Error('Invalid route details payload received from server');
  }
  return data;
};

const commitEvolution = async (vars: {
  routeId: string;
  payload: EvolutionCommitPayload;
}) => {
  const res = await fetch(`/api/route/${vars.routeId}`, {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify(vars.payload),
  });
  if (!res.ok) {
    const err = await res.json();
    throw new Error(err.message || 'Commit failed');
  }
  return res.json();
};

export default function RouteManager({
  initialRoutes,
  isRouteLoading,
}: {
  initialRoutes: { id: string; route_name: string }[];
  isRouteLoading: boolean;
}) {
  const [selectedRouteId, setSelectedRouteId] = useState<string | null>(null);
  const [selectedRoute, setSelectedRoute] = useState<string | null>(null);
  const [evolutionMode, setEvolutionMode] = useState<
    'view' | 'add_jc' | 'commit'
  >('view');

  console.log(initialRoutes);

  // 2. USE THE CRUD MANAGER with the adapter hook and both generic types
  const {
    data: cableConnectionsData,
    totalCount,
    activeCount,
    inactiveCount,
    isLoading: isRouteDetailsLoading,
    // isMutating,
    // error,
    refetch,
    pagination,
    // search,
    // filters: crudFilters,
    editModal,
    // viewModal,
    // bulkActions,
    deleteModal,
    actions: crudActions,
  } = useCrudManager<'ofc_connections', OfcConnectionRowsWithCount>({
    tableName: 'ofc_connections',
    dataQueryHook: useOfcConnectionsData,
  });

  // Local UI state for JCs the user is planning to add
  const [plannedJCs, setPlannedJCs] = useState<Equipment[]>([]);
  const [branchConfig, setBranchConfig] = useState<BranchConfigMap>({});
  const [selectedJcForSplice, setSelectedJcForSplice] = useState<Equipment | null>(null);
  const [showJcModal, setShowJcModal] = useState(false);
  const [editingJc, setEditingJc] = useState<Equipment | null>(null);
  const [activeTab, setActiveTab] = useState<'visualization' | 'fiber-splice' | 'commit'>('visualization');
  console.log('plannedJCs', plannedJCs);
  console.log('branchConfig', branchConfig);
  console.log('selectedRouteId', selectedRouteId);
  console.log('selectedRoute', selectedRoute);
  console.log('evolutionMode', evolutionMode);
  console.log('isRouteDetailsLoading', isRouteDetailsLoading);

  const queryClient = useQueryClient();

  // --- DATA FETCHING with React Query ---
  const {
    data: routeDetails,
    isLoading,
    isError,
    error,
  } = useQuery({
    queryKey: queryKeys.routeDetails(selectedRouteId),
    queryFn: () => fetchRouteDetails(selectedRouteId!),
    enabled: !!selectedRouteId, // Query only runs when a route is selected
  });

  // In v5, query callbacks like onSuccess were removed. Mirror that behavior here.
  useEffect(() => {
    if (selectedRouteId && routeDetails) {
      // Reset local state when a new route is successfully loaded
      setPlannedJCs([]);
      setBranchConfig({});
      setEvolutionMode('view');
    }
  }, [selectedRouteId, routeDetails]);

  // --- DATA MUTATION with React Query ---
  const { mutate: commitMutation, isPending: isCommitting } = useMutation({
    mutationFn: commitEvolution,
    onSuccess: (data) => {
      alert(data.message);
      // Invalidate queries to refetch fresh server state
      if (selectedRouteId) {
        queryClient.invalidateQueries({
          queryKey: queryKeys.routeDetails(selectedRouteId),
        });
      }
      // You might also want to refetch the initial list if statuses change
      queryClient.invalidateQueries({ queryKey: queryKeys.routes });
      setSelectedRouteId(null); // Deselect route
    },
    onError: (err) => alert(`Error: ${err.message}`),
  });

  // --- DERIVED STATE with useMemo ---
  // Combines existing equipment from the DB with locally planned JCs
  const allEquipmentOnRoute = useMemo(
    () => [...(routeDetails?.equipment || []), ...plannedJCs],
    [routeDetails, plannedJCs]
  );

  // Projects segments and splices based on the combined equipment list
  const projectedSegments = useMemo(() => {
    if (!routeDetails) return [] as CableSegment[];
    return projectSegments(
      routeDetails.route,
      allEquipmentOnRoute,
      branchConfig
    );
  }, [routeDetails, allEquipmentOnRoute, branchConfig]);

  const projectedSplices = useMemo(() => {
    if (!routeDetails) return [] as FiberSplice[];
    return projectDefaultSplices(
      routeDetails.route,
      projectedSegments,
      allEquipmentOnRoute,
      branchConfig
    );
  }, [routeDetails, projectedSegments, allEquipmentOnRoute, branchConfig]);

  const handleAddJc = (newJcData: Omit<Equipment, 'id' | 'status'>) => {
    const newJc: Equipment = {
      ...newJcData,
      id: `planned-${Date.now()}`, // Temporary client-side ID
      status: 'planned',
    };
    setPlannedJCs((prev) => [...prev, newJc]);
  };

  const handleRemoveJc = (jcId: string) => {
    setPlannedJCs((prev) => prev.filter((jc) => jc.id !== jcId));
    setBranchConfig((prev) => {
      const { [jcId]: _, ...rest } = prev;
      return rest;
    });
  };

  const setBranchForJc = (
    jcId: string,
    updater: (
      prev: BranchConfigMap[string] | undefined
    ) => BranchConfigMap[string]
  ) => {
    setBranchConfig((prev) => ({
      ...prev,
      [jcId]: updater(prev[jcId]),
    }));
  };

  const handleCommit = () => {
    if (!selectedRouteId || plannedJCs.length === 0) return;

    // Prepare payload for the API
    const payload: EvolutionCommitPayload = {
      plannedEquipment: plannedJCs.map(({ id, status, ...rest }) => rest), // Remove client-only fields
      plannedSegments: projectedSegments.map(({ id, ...rest }) => rest),
      plannedSplices: projectedSplices.map(({ id, ...rest }) => rest),
    };

    commitMutation({ routeId: selectedRouteId, payload });
  };

  const handleJcClick = (jc: Equipment) => {
    setSelectedJcForSplice(jc);
  };

  const handleEditJc = (jc: Equipment) => {
    setEditingJc(jc);
    setShowJcModal(true);
  };

  const handleDeleteJc = (jc: Equipment) => {
    handleRemoveJc(jc.id);
  };

  const handleCloseJcModal = () => {
    setShowJcModal(false);
    setEditingJc(null);
  };

  const handleSpliceComplete = () => {
    // Refresh data after splice configuration
    refetch();
  };

  const getStatusColor = (status: string) => {
    // ... your getEvolutionStatusColor logic
  };

  return (
    <>
      {isRouteLoading ? (
        <p>Loading routes...</p>
      ) : (
        <>
          {/* Route Selection */}
          <div className="grid grid-cols-1 gap-4 mb-8">
            <SearchableSelect
              className="w-full"
              clearable={true}
              options={initialRoutes.map((r) => ({
                value: r.id,
                label: r.route_name,
              }))}
              onChange={(val: string | null) => {
                setSelectedRouteId(val);

                const found = initialRoutes.find((r) => r.id === val);
                setSelectedRoute(found ? found.route_name : null);
              }}
              placeholder="Select a route..."
            />
          </div>

          {selectedRouteId && (
            <div
              onClick={() =>
                console.log('placeholder for fetching route connection')
              }
              className={`p-4 border-2 rounded-lg cursor-pointer transition-all border-gray-200 dark:border-gray-600 hover:border-blue-300`}
            >
              <div className="font-medium">{selectedRoute}</div>
              {/* <span className={`px-2 py-1 rounded text-xs mt-2 inline-block ${getStatusColor(route.evolution_status)}`}>
              {route.evolution_status.replace('_', ' ')}
            </span> */}
            </div>
          )}

          {isLoading && <p>Loading route details...</p>}
          {isError && <p className="text-red-500">Error: {error?.message}</p>}

          {routeDetails && (
            <div className="grid grid-cols-1 xl:grid-cols-3 gap-6">
              {/* Left Panel: Info and Forms */}
              <div className="space-y-6">
                <div className="bg-gray-50 dark:bg-gray-800 p-4 rounded-lg">
                  <h3 className="font-semibold mb-3">Route Details</h3>
                  {/* ... display details from `routeDetails.route` ... */}
                </div>

                <div className="bg-gray-50 dark:bg-gray-800 p-4 rounded-lg">
                  <h3 className="font-semibold mb-3">Evolution Actions</h3>
                  <div className="flex flex-wrap gap-2">
                    <button
                      onClick={() => setEvolutionMode('view')}
                      className={`px-3 py-1.5 rounded border text-sm ${
                        evolutionMode === 'view'
                          ? 'bg-blue-600 text-white border-blue-600'
                          : 'bg-transparent text-blue-600 border-blue-600'
                      }`}
                      disabled={!selectedRouteId}
                    >
                      View
                    </button>
                    <button
                      onClick={() => setEvolutionMode('add_jc')}
                      className={`px-3 py-1.5 rounded border text-sm ${
                        evolutionMode === 'add_jc'
                          ? 'bg-green-600 text-white border-green-600'
                          : 'bg-transparent text-green-600 border-green-600'
                      }`}
                      disabled={!selectedRouteId}
                    >
                      Add Junction Closure
                    </button>
                    <button
                      onClick={() => setEvolutionMode('commit')}
                      className={`px-3 py-1.5 rounded border text-sm ${
                        evolutionMode === 'commit'
                          ? 'bg-purple-600 text-white border-purple-600'
                          : 'bg-transparent text-purple-600 border-purple-600'
                      }`}
                      disabled={!selectedRouteId || plannedJCs.length === 0}
                      title={
                        plannedJCs.length === 0
                          ? 'Add at least one JC to commit'
                          : ''
                      }
                    >
                      Review & Commit
                    </button>
                  </div>
                </div>

                {evolutionMode === 'add_jc' && (
                  <AddJcForm route={routeDetails.route} onAddJc={handleAddJc} />
                )}

                {/* Branch Configuration for planned branching JCs */}
                {plannedJCs.some(
                  (j) => j.attributes.jc_type === 'branching'
                ) && (
                  <div className="bg-gray-50 dark:bg-gray-800 p-4 rounded-lg">
                    <h3 className="font-semibold mb-3">Branch Configuration</h3>
                    <div className="space-y-4">
                      {plannedJCs
                        .filter((j) => j.attributes.jc_type === 'branching')
                        .map((jc) => {
                          const cfg = branchConfig[jc.id];
                          return (
                            <div key={jc.id} className="border rounded p-3">
                              <div className="flex items-center justify-between">
                                <div className="font-medium">{jc.name}</div>
                                <span className="text-xs text-gray-500">
                                  @{' '}
                                  {(
                                    ((routeDetails.route.current_rkm || 0) *
                                      jc.attributes.position_on_route) /
                                    100
                                  ).toFixed(1)}{' '}
                                  km
                                </span>
                              </div>
                              <div className="mt-3 grid grid-cols-1 sm:grid-cols-3 gap-3">
                                <label className="text-sm">
                                  <span className="block mb-1 text-gray-600 dark:text-gray-300">
                                    Branch endpoint
                                  </span>
                                  <select
                                    className="w-full border rounded px-2 py-1 bg-white dark:bg-gray-900"
                                    value={
                                      cfg?.target_id ??
                                      (routeDetails.route.en_id || '')
                                    }
                                    onChange={(e) =>
                                      setBranchForJc(jc.id, (prev) => ({
                                        target_id: e.target.value,
                                        target_type:
                                          e.target.value ===
                                            (routeDetails.route.sn_id || '') ||
                                          e.target.value ===
                                            (routeDetails.route.en_id || '')
                                            ? 'site'
                                            : prev?.target_type ?? 'site',
                                        distance_km:
                                          prev?.distance_km ??
                                          Math.min(
                                            2,
                                            Math.max(
                                              0.2,
                                              (routeDetails.route.current_rkm || 0) *
                                                0.1
                                            )
                                          ),
                                        tap_fibers: prev?.tap_fibers ?? 2,
                                      }))
                                    }
                                  >
                                    <option
                                      value={routeDetails.route.sn_id || ''}
                                    >
                                      Start site:{' '}
                                      {routeDetails.route.sn_name || 'Unknown'}
                                    </option>
                                    <option
                                      value={routeDetails.route.en_id || ''}
                                    >
                                      End site:{' '}
                                      {routeDetails.route.en_name || 'Unknown'}
                                    </option>
                                  </select>
                                </label>
                                <label className="text-sm">
                                  <span className="block mb-1 text-gray-600 dark:text-gray-300">
                                    Branch length (km)
                                  </span>
                                  <input
                                    type="number"
                                    min={0.1}
                                    step={0.1}
                                    className="w-full border rounded px-2 py-1 bg-white dark:bg-gray-900"
                                    value={
                                      cfg?.distance_km ??
                                      Math.min(
                                        2,
                                        Math.max(
                                          0.2,
                                          (routeDetails.route.current_rkm || 0) * 0.1
                                        )
                                      )
                                    }
                                    onChange={(e) =>
                                      setBranchForJc(jc.id, (prev) => ({
                                        target_id:
                                          prev?.target_id ??
                                          (routeDetails.route.en_id || ''),
                                        target_type:
                                          prev?.target_type ?? 'site',
                                        distance_km: Math.max(
                                          0.1,
                                          Number(e.target.value || 0)
                                        ),
                                        tap_fibers: prev?.tap_fibers ?? 2,
                                      }))
                                    }
                                  />
                                </label>
                                <label className="text-sm">
                                  <span className="block mb-1 text-gray-600 dark:text-gray-300">
                                    Tap fibers
                                  </span>
                                  <input
                                    type="number"
                                    min={1}
                                    max={routeDetails.route.capacity || 100}
                                    className="w-full border rounded px-2 py-1 bg-white dark:bg-gray-900"
                                    value={cfg?.tap_fibers ?? 2}
                                    onChange={(e) =>
                                      setBranchForJc(jc.id, (prev) => ({
                                        target_id:
                                          prev?.target_id ??
                                          (routeDetails.route.en_id || ''),
                                        target_type:
                                          prev?.target_type ?? 'site',
                                        distance_km:
                                          prev?.distance_km ??
                                          Math.min(
                                            2,
                                            Math.max(
                                              0.2,
                                              (routeDetails.route.current_rkm || 0) *
                                                0.1
                                            )
                                          ),
                                        tap_fibers: Math.min(
                                          routeDetails.route.capacity || 100,
                                          Math.max(
                                            1,
                                            Number(e.target.value || 1)
                                          )
                                        ),
                                      }))
                                    }
                                  />
                                </label>
                              </div>
                            </div>
                          );
                        })}
                    </div>
                  </div>
                )}
              </div>

              {/* Middle and Right Panels */}
              <div className="xl:col-span-2 space-y-6">
                {/* Tab Navigation */}
                <div className="flex space-x-1 bg-gray-100 dark:bg-gray-800 p-1 rounded-lg">
                  <button
                    onClick={() => setActiveTab('visualization')}
                    className={`px-4 py-2 rounded-md text-sm font-medium transition-colors ${
                      activeTab === 'visualization'
                        ? 'bg-white dark:bg-gray-700 text-gray-900 dark:text-white shadow-sm'
                        : 'text-gray-600 dark:text-gray-400 hover:text-gray-900 dark:hover:text-white'
                    }`}
                  >
                    Route Visualization
                  </button>
                  <button
                    onClick={() => setActiveTab('fiber-splice')}
                    className={`px-4 py-2 rounded-md text-sm font-medium transition-colors ${
                      activeTab === 'fiber-splice'
                        ? 'bg-white dark:bg-gray-700 text-gray-900 dark:text-white shadow-sm'
                        : 'text-gray-600 dark:text-gray-400 hover:text-gray-900 dark:hover:text-white'
                    }`}
                    disabled={!selectedJcForSplice}
                  >
                    Fiber Splice Manager
                  </button>
                  <button
                    onClick={() => setActiveTab('commit')}
                    className={`px-4 py-2 rounded-md text-sm font-medium transition-colors ${
                      activeTab === 'commit'
                        ? 'bg-white dark:bg-gray-700 text-gray-900 dark:text-white shadow-sm'
                        : 'text-gray-600 dark:text-gray-400 hover:text-gray-900 dark:hover:text-white'
                    }`}
                    disabled={plannedJCs.length === 0}
                  >
                    Review & Commit
                  </button>
                </div>

                {/* Tab Content */}
                {activeTab === 'visualization' && routeDetails && (
                  <RouteVisualization
                    routeDetails={routeDetails}
                    onJcClick={handleJcClick}
                    onEditJc={handleEditJc}
                    onDeleteJc={handleDeleteJc}
                  />
                )}

                {activeTab === 'fiber-splice' && selectedJcForSplice && (
                  <FiberSpliceManager
                    junctionClosureId={selectedJcForSplice.id}
                    junctionClosureName={selectedJcForSplice.name}
                    onSpliceComplete={handleSpliceComplete}
                  />
                )}

                {activeTab === 'commit' && (
                  <CommitView
                    equipment={plannedJCs}
                    segments={projectedSegments}
                    splices={projectedSplices}
                    onCommit={handleCommit}
                    isCommitting={isCommitting}
                  />
                )}
              </div>
            </div>
          )}
        </>
      )}
      <JcFormModal
        isOpen={showJcModal}
        onClose={handleCloseJcModal}
        onSave={() => refetch()}
        routeId={selectedRouteId}
        editingJc={editingJc}
        rkm={routeDetails?.route.current_rkm ?? null}
      />
    </>
  );
}

```

<!-- path: components/route-manager/RouteVisualizer.tsx -->
```typescript
// =================================================================
// Sub-component for visualizing the route topology

import { Button } from "@/components/common/ui";
import { Equipment, JunctionClosure } from "@/components/route-manager/types";
import { useRouteDetails } from "@/hooks/database/route-manager-hooks";
import { FiEdit, FiTrash2 } from "react-icons/fi";

interface RouteVisualizerProps {
  routeDetails: NonNullable<ReturnType<typeof useRouteDetails>['data']>;
  onJcClick: (jc: Equipment) => void;
  onEditJc: (jc: Equipment) => void; // <--- ADDED for editing
  onDeleteJc: (jc: Equipment) => void; // <--- ADDED for deleting
}

interface Point {
  type: 'node' | 'jc';
  id: string;
  name: string | null;
  position: number;
  originalJc?: JunctionClosure;
  latitude?: number | null;
  longitude?: number | null;
  node_id?: string | null;
  ofc_cable_id?: string | null;
  position_km?: number | null;
  equipmentData?: Equipment;
}

export const RouteVisualizer: React.FC<RouteVisualizerProps> = ({ routeDetails, onJcClick, onEditJc, onDeleteJc }) => {
    // ... (The content of this component remains exactly the same, but now it receives onEditJc and onDeleteJc)
    const { route, junction_closures } = routeDetails;
    const sortedJCs = [...junction_closures].sort((a, b) => (a.position_km || 0) - (b.position_km || 0));

    const points: Point[] = [
      { type: 'node' as const, id: route.start_node.id || 'start-node', name: route.start_node.name, position: 0 },
      ...[...junction_closures]
        .sort((a, b) => (a.position_km || 0) - (b.position_km || 0))
        .map((jc, idx) => {
          // Convert JunctionClosure to Equipment for compatibility with handlers
          const equipmentJc: Equipment = {
            id: jc.id || `jc-${idx}`,
            name: jc.name || 'Unnamed JC',
            equipment_type: 'junction_closure',
            latitude: jc.latitude || 0,
            longitude: jc.longitude || 0,
            status: 'existing',
            attributes: {
              jc_type: 'inline', // Default type, could be determined from other data
              capacity: 48, // Default capacity, could be determined from other data
              position_on_route: ((jc.position_km || 0) / (route.current_rkm || 1)) * 100
            }
          };

          return {
            type: 'jc' as const,
            // Keep the original junction closure data intact for delete operations
            originalJc: jc,
            // Ensure an id exists for JC points for keys/segment ids
            id: jc.node_id ?? `${route.id}-${jc.position_km ?? idx}`,
            name: jc.name,
            position: jc.position_km || 0,
            latitude: jc.latitude,
            longitude: jc.longitude,
            node_id: jc.node_id,
            ofc_cable_id: jc.ofc_cable_id,
            position_km: jc.position_km,
            equipmentData: equipmentJc, // Store converted Equipment for handlers
          };
        }),
      { type: 'node' as const, id: route.end_node.id || 'end-node', name: route.end_node.name, position: route.current_rkm || 1 },
    ];
  
    // 2. Create segments between each consecutive point
    const segments = [];
    const totalDistance = route.current_rkm || 1; // Avoid division by zero
    for (let i = 0; i < points.length - 1; i++) {
      const startPoint = points[i];
      const endPoint = points[i + 1];
      
      segments.push({
        id: `seg-${startPoint.id}-${endPoint.id}`,
        startPercentage: (startPoint.position / totalDistance) * 100,
        endPercentage: (endPoint.position / totalDistance) * 100,
        length: endPoint.position - startPoint.position,
      });
    }

    return (
      <div className="bg-gray-50 dark:bg-gray-800/50 p-6 rounded-lg border dark:border-gray-700">
        <h3 className="text-lg font-semibold text-gray-900 dark:text-white mb-12">Route Topology</h3>
        <div className="relative flex items-center w-full h-16">
  
          {/* 3. Render each segment as a line */}
          {segments.map(seg => (
            <div
              key={seg.id}
              className="absolute top-1/2 -translate-y-1/2 h-1 bg-gray-300 dark:bg-gray-600 group cursor-pointer"
              style={{
                left: `${seg.startPercentage}%`,
                width: `${seg.endPercentage - seg.startPercentage}%`,
              }}
            >
              <div className="absolute inset-0 bg-blue-500 opacity-0 group-hover:opacity-100 transition-opacity duration-300" />
              {/* Tooltip for the segment */}
              <div className="absolute bottom-full left-1/2 -translate-x-1/2 mb-2 px-2 py-1 bg-gray-900 text-white text-xs rounded-md opacity-0 group-hover:opacity-100 transition-opacity whitespace-nowrap pointer-events-none">
                Capacity: {route.capacity}F<br/>
                Length: {seg.length.toFixed(2)} km
                <div className="absolute top-full left-1/2 -translate-x-1/2 w-0 h-0 border-l-4 border-r-4 border-t-4 border-transparent border-t-gray-900"></div>
              </div>
            </div>
          ))}
          
          {/* 4. Render each point (Node or JC) on top of the lines */}
          <div className="relative flex justify-between w-full">
              {points.map((point, index) => {
                const leftPercentage = Math.min(100, Math.max(0, (point.position / totalDistance) * 100));
                return (
                  <div
                    key={`${point.type}-${point.id}-${index}`}
                    className="relative flex flex-col items-center group z-10" // <-- Add z-10
                    style={{ position: 'absolute', left: `${leftPercentage}%`, transform: 'translateX(-50%)' }}
                  >
                    <div
                      className={`w-10 h-10 rounded-full flex items-center justify-center border-4
                        ${point.type === 'node'
                          ? 'bg-blue-600 border-white dark:border-gray-800'
                          : 'bg-green-500 border-white dark:border-gray-800 cursor-pointer hover:scale-110 transition-transform'
                        }`}
                      onClick={() => point.type === 'jc' && point.equipmentData && onJcClick(point.equipmentData)}
                    >
                      <span className="text-white font-bold text-sm">{point.type === 'node' ? 'N' : 'JC'}</span>
                    </div>
                    <div className="absolute top-12 text-center w-28">
                      <p className="text-xs font-semibold text-gray-700 dark:text-gray-300 truncate" title={point.name || ''}>{point.name}</p>
                      <p className="text-xs text-gray-500 dark:text-gray-400">{point.position} km</p>
                    </div>
                    {point.type === 'jc' && (
                      <div className="absolute -top-10 flex gap-1 opacity-0 group-hover:opacity-100 transition-opacity duration-200">
                          <Button size="xs" variant="outline" onClick={() => point.equipmentData && onEditJc(point.equipmentData)} title="Edit JC">
                              <FiEdit className="h-3 w-3" />
                          </Button>
                          <Button size="xs" variant="danger" onClick={() => point.equipmentData && onDeleteJc(point.equipmentData)} title="Delete JC">
                              <FiTrash2 className="h-3 w-3" />
                          </Button>
                      </div>
                    )}
                  </div>
                );
              })}
          </div>
        </div>
      </div>
    );
  };
  
```

<!-- path: components/route-manager/data.ts -->
```typescript
// components/route-manager/data.ts
import 'server-only';
import { RouteForSelection } from './types';

// In a real app, this would connect to your database (e.g., using Prisma)
export const getRoutesForSelection = async (): Promise<RouteForSelection[]> => {
  console.log("== EXECUTING ON SERVER: getRoutesForSelection ==");
  
  // Mocking a database call
  const mockRoutes: RouteForSelection[] = [
    { id: 'route-1', route_name: 'NodeA  NodeB _ 1', evolution_status: 'simple' },
    { id: 'route-2', route_name: 'NodeC  NodeD _ 1', evolution_status: 'with_jcs' },
    { id: 'route-3', route_name: 'NodeE  NodeF _ 1', evolution_status: 'fully_segmented' },
  ];
  return mockRoutes;
};
```

<!-- path: components/route-manager/queryKeys.ts -->
```typescript
// components/route-manager/queryKeys.ts

export const queryKeys = {
  routes: ['routes'] as const,
  routeDetails: (routeId: string | null) => ['routeDetails', routeId] as const,
};

```

<!-- path: components/route-manager/FiberSpliceManager.tsx -->
```typescript
// components/ofc/FiberSpliceManager.tsx
'use client';

import { useState, useEffect, useCallback } from 'react';
import { Button } from '@/components/common/ui';
import { Card, CardHeader, CardBody } from '@/components/common/ui';
import { createClient } from '@/utils/supabase/client';
import { toast } from 'sonner';
import { useCableSegmentation } from '@/hooks/ofc/useCableSegmentation';
import {
  AlertCircle,
  ArrowDownCircle,
  ArrowUpCircle,
  CheckCircle,
  Clock,
  Info,
  Loader2,
  RefreshCw,
  Settings,
  Split,
} from 'lucide-react';

interface FiberSplice {
  id: string;
  jc_id: string;
  incoming_cable_id: string;
  incoming_fiber_no: number;
  outgoing_cable_id: string | null;
  outgoing_fiber_no: number | null;
  splice_type: 'pass_through' | 'branch' | 'termination';
  status: 'active' | 'faulty' | 'reserved';
  logical_path_id?: string | null;
  loss_db?: number | null;
  otdr_length_km?: number | null;
  created_at?: string;
  updated_at?: string;
}

interface SpliceConfiguration {
  incoming_fiber_no: number;
  outgoing_fiber_no: number;
  splice_type: 'straight' | 'cross';
  outgoing_cable_id?: string | null;
}

interface FiberSpliceManagerProps {
  junctionClosureId: string;
  junctionClosureName: string;
  onSpliceComplete?: () => void;
  capacity?: number;
}

export const FiberSpliceManager = ({
  junctionClosureId,
  junctionClosureName,
  onSpliceComplete,
  capacity,
}: FiberSpliceManagerProps) => {
  const [fiberSplices, setFiberSplices] = useState<FiberSplice[]>([]);
  const [spliceConfigurations, setSpliceConfigurations] = useState<SpliceConfiguration[]>([]);
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const [cableOptions, setCableOptions] = useState<
    { id: string; label: string; capacity: number | null }[]
  >([]);
  const [incomingCableId, setIncomingCableId] = useState<string>('');

  const supabase = createClient();
  const { updateFiberConnections } = useCableSegmentation();

  // Segment-based selection
  interface SegmentOption {
    id: string;
    label: string;
    fiber_count: number;
    original_cable_id: string;
    segment_order: number;
  }
  const [segmentOptions, setSegmentOptions] = useState<SegmentOption[]>([]);
  const [incomingSegmentId, setIncomingSegmentId] = useState<string>('');
  const [outgoingSegmentId, setOutgoingSegmentId] = useState<string>('');

  const loadFiberSplices = useCallback(async () => {
    // Don't load if no junction closure is selected
    if (!junctionClosureId || junctionClosureId === '') {
      setFiberSplices([]);
      return;
    }

    try {
      // Step 1: Find the node_id of the selected JC
      const { data: jcRow, error: jcFetchError } = await supabase
        .from('junction_closures')
        .select('node_id')
        .eq('id', junctionClosureId)
        .maybeSingle();

      if (jcFetchError) throw jcFetchError;

      // If we cannot find the node_id, fallback to the original single-JC behavior
      if (!jcRow?.node_id) {
        const { data, error: spliceError } = await supabase
          .from('fiber_splices')
          .select('*')
          .eq('jc_id', junctionClosureId)
          .order('incoming_fiber_no');

        if (spliceError) throw spliceError;
        setFiberSplices(data || []);
        return;
      }
      // Step 2: Get all JC IDs that share this node_id (i.e., the same physical JC across cables)
      const { data: relatedJcs, error: relatedJcsError } = await supabase
        .from('junction_closures')
        .select('id, ofc_cable_id')
        .eq('node_id', jcRow.node_id);

      if (relatedJcsError) throw relatedJcsError;

      const jcIds = (relatedJcs || []).map((r) => r.id).filter(Boolean);
      const jcCableIds = Array.from(
        new Set((relatedJcs || []).map((r) => r.ofc_cable_id).filter(Boolean) as string[])
      );

      // Safety: if for some reason we didn't get a list, fallback to current JC only
      const targetJcIds = jcIds.length > 0 ? jcIds : [junctionClosureId];

      // Step 3: Fetch all fiber_splices for any of those JC IDs
      const { data, error: spliceError } = await supabase
        .from('fiber_splices')
        .select('*')
        .in('jc_id', targetJcIds)
        .order('incoming_fiber_no');

      if (spliceError) throw spliceError;
      setFiberSplices(data || []);
      // Discover connected segments via JC view (jc_id column is node_id)
      type SegRow = {
        id: string;
        original_cable_id: string;
        segment_order: number;
        fiber_count: number;
        jc_id: string;
      };
      const { data: segView, error: segViewErr } = await supabase
        .from('v_cable_segments_at_jc')
        .select('id, original_cable_id, segment_order, fiber_count, jc_id')
        .eq('jc_id', jcRow.node_id);
      if (segViewErr) throw segViewErr;
      const segs: SegRow[] = (segView as SegRow[] | null) || [];
      // Deduplicate segments that appear for multiple JC ids (e.g., both endpoints included)
      const segsUnique: SegRow[] = Array.from(new Map(segs.map((s) => [s.id, s])).values());
      const cableIds = Array.from(
        new Set(
          segsUnique.map((s) => s.original_cable_id).filter((id): id is string => Boolean(id))
        )
      );
      // Ensure we include cables directly on the JC rows as well
      for (const id of jcCableIds) {
        if (!cableIds.includes(id)) cableIds.push(id);
      }

      let options: { id: string; label: string; capacity: number | null }[] = cableIds.map(
        (id) => ({ id, label: id, capacity: null })
      );
      if (cableIds.length > 0) {
        const { data: cables, error: cablesErr } = await supabase
          .from('ofc_cables')
          .select('id, route_name, capacity')
          .in('id', cableIds);
        if (!cablesErr && cables) {
          const m = new Map(
            (cables as { id: string; route_name: string | null; capacity: number | null }[]).map(
              (c) => [c.id, { name: c.route_name || c.id, capacity: c.capacity ?? null }]
            )
          );
          options = cableIds.map((id) => {
            const info = m.get(id);
            const base = info?.name || id;
            const cap = info?.capacity ?? null;
            return { id, label: cap ? `${base} (${cap}F)` : base, capacity: cap };
          });
        }
      }
      setCableOptions(options);
      // Build segment options with cable label
      const labelMap = new Map(options.map((o) => [o.id, o.label]));
      const segOpts: SegmentOption[] = segsUnique.map((s) => ({
        id: s.id,
        label: `${labelMap.get(s.original_cable_id) || s.original_cable_id}  Seg ${
          s.segment_order
        }`,
        fiber_count: s.fiber_count || 0,
        original_cable_id: s.original_cable_id,
        segment_order: s.segment_order || 0,
      }));
      setSegmentOptions(segOpts);
      const existingIncoming = (data || []).find((s) => s.incoming_cable_id)?.incoming_cable_id as
        | string
        | undefined;
      setIncomingCableId(existingIncoming || options[0]?.id || '');
    } catch (err: unknown) {
      const message = err instanceof Error ? err.message : 'Unknown error';
      setError(message);
      toast.error(`Failed to load fiber splices: ${message}`);
    }
  }, [junctionClosureId, supabase]);

  // Set sensible defaults for segments after options load
  useEffect(() => {
    if (segmentOptions.length === 0) return;
    if (!incomingSegmentId && segmentOptions[0]?.id) {
      setIncomingSegmentId(segmentOptions[0].id);
    }
    if (!outgoingSegmentId && (segmentOptions[1]?.id || segmentOptions[0]?.id)) {
      setOutgoingSegmentId(segmentOptions[1]?.id || segmentOptions[0]!.id);
    }
  }, [segmentOptions, incomingSegmentId, outgoingSegmentId]);

  useEffect(() => {
    loadFiberSplices();
  }, [loadFiberSplices]);

  const handleSpliceTypeChange = (fiberNo: number, spliceType: 'straight' | 'cross') => {
    setSpliceConfigurations((prev) => {
      const existing = prev.find((s) => s.incoming_fiber_no === fiberNo);
      if (existing) {
        return prev.map((s) =>
          s.incoming_fiber_no === fiberNo ? { ...s, splice_type: spliceType } : s
        );
      } else {
        return [
          ...prev,
          {
            incoming_fiber_no: fiberNo,
            outgoing_fiber_no: spliceType === 'straight' ? fiberNo : fiberNo, // Will be updated by user
            splice_type: spliceType,
          },
        ];
      }
    });
  };

  const handleOutgoingCableChange = (fiberNo: number, outgoingCableId: string) => {
    setSpliceConfigurations((prev) => {
      const existing = prev.find((s) => s.incoming_fiber_no === fiberNo);
      if (existing) {
        return prev.map((s) =>
          s.incoming_fiber_no === fiberNo ? { ...s, outgoing_cable_id: outgoingCableId } : s
        );
      }
      return [
        ...prev,
        {
          incoming_fiber_no: fiberNo,
          outgoing_fiber_no: fiberNo,
          splice_type: 'straight',
          outgoing_cable_id: outgoingCableId,
        },
      ];
    });
  };

  const handleIndividualFiberConfig = async (fiberNo: number) => {
    if (isLoading) return;

    setIsLoading(true);
    setError(null);

    try {
      const config = spliceConfigurations.find(s => s.incoming_fiber_no === fiberNo);
      const splice = fiberSplices.find(s => s.incoming_fiber_no === fiberNo);

      // Use the current configuration or create a default one
      const fiberConfig = config || {
        incoming_fiber_no: fiberNo,
        outgoing_fiber_no: splice?.outgoing_fiber_no || fiberNo,
        splice_type: (splice?.splice_type === 'pass_through' ? 'straight' : 'cross') as 'straight' | 'cross',
        outgoing_cable_id: splice?.outgoing_cable_id || (segmentOptions.length === 0 ? incomingCableId : undefined)
      };

      // Apply configuration for just this single fiber
      const rpcPayload = [fiberConfig];

      if (incomingSegmentId && outgoingSegmentId) {
        await updateFiberConnections(
          junctionClosureId,
          incomingSegmentId,
          outgoingSegmentId,
          rpcPayload
        );
      } else {
        // Fallback to individual splice update
        const existingSplice = fiberSplices.find(s => s.incoming_fiber_no === fiberNo);
        if (existingSplice) {
          const { error: updateError } = await supabase
            .from('fiber_splices')
            .update({
              outgoing_fiber_no: fiberConfig.outgoing_fiber_no,
              splice_type: fiberConfig.splice_type === 'straight' ? 'pass_through' : 'branch',
              updated_at: new Date().toISOString(),
            })
            .eq('id', existingSplice.id);

          if (updateError) throw updateError;
        } else {
          const { error: insertError } = await supabase
            .from('fiber_splices')
            .insert({
              jc_id: junctionClosureId,
              incoming_cable_id: incomingCableId || fiberSplices[0]?.incoming_cable_id || '',
              incoming_fiber_no: fiberNo,
              outgoing_cable_id: fiberConfig.outgoing_cable_id || fiberSplices[0]?.outgoing_cable_id || null,
              outgoing_fiber_no: fiberConfig.outgoing_fiber_no,
              splice_type: fiberConfig.splice_type === 'straight' ? 'pass_through' : 'branch',
              status: 'active',
            });

          if (insertError) throw insertError;
        }
      }

      toast.success(`Fiber ${fiberNo} configuration applied successfully`);
      await loadFiberSplices();
      onSpliceComplete?.();
    } catch (err: any) {
      setError(err.message);
      toast.error(`Failed to configure fiber ${fiberNo}: ${err.message}`);
    } finally {
      setIsLoading(false);
    }
  };

  const handleOutgoingFiberChange = (
    fiberNo: number,
    outgoingFiberNo: number,
    currentOutgoingCableId: string
  ) => {
    // Determine if segment-based splicing is active (both segments selected)
    const selectedOutgoingSegment = segmentOptions.find((s) => s.id === outgoingSegmentId) || null;

    // Capacity clamp: prefer segment fiber_count if segment mode, else fall back to cable capacity
    let safeMax = maxFibers;
    if (selectedOutgoingSegment) {
      safeMax = Math.max(1, Number(selectedOutgoingSegment.fiber_count) || maxFibers);
    } else {
      const capMap = new Map(cableOptions.map((o) => [o.id, o.capacity]));
      const cap = capMap.get(currentOutgoingCableId) || null;
      safeMax = cap && cap > 0 ? cap : maxFibers;
    }
    const clamped = Math.max(1, Math.min(outgoingFiberNo, safeMax));

    // Uniqueness: if segment mode, only ensure uniqueness within the selected outgoing segment
    if (selectedOutgoingSegment) {
      const takenNumbers = new Set<number>(
        spliceConfigurations
          .filter((sc) => sc.incoming_fiber_no !== fiberNo && sc.outgoing_fiber_no != null)
          .map((sc) => Number(sc.outgoing_fiber_no))
      );
      if (takenNumbers.has(clamped)) {
        toast.error('This outgoing fiber number is already selected in the outgoing segment');
        return;
      }
    } else {
      // Legacy cable-based uniqueness check when not in segment mode
      const takenKeys = new Set([
        // Existing persisted splices at this JC (by outgoing cable id + fiber no)
        ...fiberSplices
          .filter((s) => s.outgoing_cable_id && s.outgoing_fiber_no != null)
          .map((s) => `${s.outgoing_cable_id}:${s.outgoing_fiber_no}`),
        // Also consider current, unsaved selections in this UI session
        ...spliceConfigurations
          .filter((sc) => sc.outgoing_fiber_no != null && Boolean(sc.outgoing_cable_id))
          .map((sc) => `${sc.outgoing_cable_id}:${sc.outgoing_fiber_no}`),
      ]);
      const candidateKey = `${currentOutgoingCableId}:${clamped}`;
      if (takenKeys.has(candidateKey)) {
        toast.error('This outgoing fiber is already mapped at this JC');
        return;
      }
    }

    setSpliceConfigurations((prev) =>
      prev.map((s) => (s.incoming_fiber_no === fiberNo ? { ...s, outgoing_fiber_no: clamped } : s))
    );
  };

  const applySpliceConfiguration = async () => {
    if (spliceConfigurations.length === 0) {
      toast.error('No splice configurations to apply');
      return;
    }

    setIsLoading(true);
    setError(null);

    try {
      if (incomingSegmentId && outgoingSegmentId) {
        const rpcPayload = spliceConfigurations.map((sc) => ({
          incoming_fiber_no: sc.incoming_fiber_no,
          outgoing_fiber_no: sc.outgoing_fiber_no,
          splice_type: sc.splice_type,
        }));
        await updateFiberConnections(
          junctionClosureId,
          incomingSegmentId,
          outgoingSegmentId,
          rpcPayload
        );
        toast.success('Splice configuration applied successfully');
        await loadFiberSplices();
        onSpliceComplete?.();
        return;
      }
      // Update fiber splices in database
      for (const config of spliceConfigurations) {
        const existingSplice = fiberSplices.find(
          (s) =>
            s.incoming_fiber_no === config.incoming_fiber_no &&
            (!incomingCableId || s.incoming_cable_id === incomingCableId)
        );

        if (existingSplice) {
          const { error: updateError } = await supabase
            .from('fiber_splices')
            .update({
              outgoing_fiber_no: config.outgoing_fiber_no,
              splice_type: config.splice_type === 'straight' ? 'pass_through' : 'branch',
              outgoing_cable_id: config.outgoing_cable_id ?? existingSplice.outgoing_cable_id,
              updated_at: new Date().toISOString(),
            })
            .eq('id', existingSplice.id);

          if (updateError) throw updateError;
        } else {
          // Create new splice if it doesn't exist
          const { error: insertError } = await supabase.from('fiber_splices').insert({
            jc_id: junctionClosureId,
            incoming_cable_id: incomingCableId || fiberSplices[0]?.incoming_cable_id || '',
            incoming_fiber_no: config.incoming_fiber_no,
            outgoing_cable_id:
              config.outgoing_cable_id ?? (fiberSplices[0]?.outgoing_cable_id || null),
            outgoing_fiber_no: config.outgoing_fiber_no,
            splice_type: config.splice_type === 'straight' ? 'pass_through' : 'branch',
            status: 'active',
          });

          if (insertError) throw insertError;
        }
      }

      toast.success('Splice configuration applied successfully');
      await loadFiberSplices();
      onSpliceComplete?.();
    } catch (err: unknown) {
      const message = err instanceof Error ? err.message : 'Unknown error';
      setError(message);
      toast.error(`Failed to apply splice configuration: ${message}`);
    } finally {
      setIsLoading(false);
    }
  };

  const getMaxFiberCount = () => {
    const maxIncoming = Math.max(...fiberSplices.map((s) => s.incoming_fiber_no), 0);
    const maxOutgoing = Math.max(...fiberSplices.map((s) => s.outgoing_fiber_no || 0), 0);
    return Math.max(maxIncoming, maxOutgoing, 2); // Minimum 2 fibers
  };

  const incomingSeg = segmentOptions.find((s) => s.id === incomingSegmentId);
  const outgoingSeg = segmentOptions.find((s) => s.id === outgoingSegmentId);
  const segmentBasedMax =
    incomingSeg && outgoingSeg ? Math.min(incomingSeg.fiber_count, outgoingSeg.fiber_count) : null;
  const maxFibers =
    segmentBasedMax && segmentBasedMax > 0
      ? segmentBasedMax
      : capacity && capacity > 0
      ? capacity
      : getMaxFiberCount();

  // Don't render if no junction closure is selected
  if (!junctionClosureId || junctionClosureId === '') {
    return (
      <div className="space-y-6">
        <Card>
          <CardHeader>
            <h2 className="text-lg font-semibold">Fiber Splice Configuration</h2>
            <p className="text-sm text-gray-600 dark:text-gray-400">
              Please select a junction closure first
            </p>
          </CardHeader>
          <CardBody>
            <div className="text-center py-8">
              <p className="text-gray-500 dark:text-gray-400">
                Click on a junction closure (JC) in the Route Visualizer tab to manage its fiber
                splices.
              </p>
            </div>
          </CardBody>
        </Card>
      </div>
    );
  }

  return (
    <div className="space-y-6">
      <Card className="bg-white dark:bg-gray-800 border border-gray-200 dark:border-gray-700 shadow-sm">
        <CardHeader className="pb-4">
          <h2 className="text-xl font-semibold text-gray-900 dark:text-white flex items-center gap-2">
            <Split className="w-5 h-5 text-blue-500" />
            Fiber Splice Configuration
          </h2>
          <p className="text-sm text-gray-600 dark:text-gray-300">
            Junction Closure:{' '}
            <span className="font-medium text-gray-900 dark:text-white">{junctionClosureName}</span>
          </p>
        </CardHeader>

        <CardBody className="pt-4">
          <div className="space-y-6">
            {/* Segment Info */}
            <div className="flex items-center justify-between">
              <span className="text-xs font-medium text-gray-500 dark:text-gray-400 bg-gray-100 dark:bg-gray-700 px-3 py-1 rounded-full">
                Segments at JC: {segmentOptions.length}
              </span>
            </div>

            {/* Segment Selection */}
            <div className="grid grid-cols-1 lg:grid-cols-2 gap-4 p-4 bg-gray-50 dark:bg-gray-900/50 rounded-lg border border-gray-200 dark:border-gray-600">
              <div className="space-y-2">
                <label className="text-sm font-medium text-gray-700 dark:text-gray-300 flex items-center gap-2">
                  <ArrowDownCircle className="w-4 h-4 text-green-500" />
                  Incoming Segment
                </label>
                <select
                  value={incomingSegmentId}
                  onChange={(e) => setIncomingSegmentId(e.target.value)}
                  disabled={segmentOptions.length === 0}
                  className="w-full p-3 border border-gray-300 dark:border-gray-600 rounded-lg bg-white dark:bg-gray-800 text-gray-900 dark:text-white text-sm focus:ring-2 focus:ring-blue-500 focus:border-transparent transition-all duration-200 disabled:opacity-50 disabled:cursor-not-allowed"
                >
                  <option value="" disabled className="text-gray-500">
                    {segmentOptions.length ? 'Select segment' : 'No segments found at this JC'}
                  </option>
                  {segmentOptions.map((opt) => (
                    <option key={opt.id} value={opt.id} className="text-gray-900 dark:text-white">
                      {opt.label}  {opt.fiber_count}F
                    </option>
                  ))}
                </select>
              </div>

              <div className="space-y-2">
                <label className="text-sm font-medium text-gray-700 dark:text-gray-300 flex items-center gap-2">
                  <ArrowUpCircle className="w-4 h-4 text-blue-500" />
                  Outgoing Segment
                </label>
                <select
                  value={outgoingSegmentId}
                  onChange={(e) => setOutgoingSegmentId(e.target.value)}
                  disabled={segmentOptions.length === 0}
                  className="w-full p-3 border border-gray-300 dark:border-gray-600 rounded-lg bg-white dark:bg-gray-800 text-gray-900 dark:text-white text-sm focus:ring-2 focus:ring-blue-500 focus:border-transparent transition-all duration-200 disabled:opacity-50 disabled:cursor-not-allowed"
                >
                  <option value="" disabled className="text-gray-500">
                    {segmentOptions.length ? 'Select segment' : 'No segments found at this JC'}
                  </option>
                  {segmentOptions.map((opt) => (
                    <option key={opt.id} value={opt.id} className="text-gray-900 dark:text-white">
                      {opt.label}  {opt.fiber_count}F
                    </option>
                  ))}
                </select>
              </div>
            </div>

            {/* Actions */}
            <div className="flex items-center justify-end">
              <Button
                onClick={() => loadFiberSplices()}
                disabled={isLoading}
                className="bg-gray-600 hover:bg-gray-700 disabled:bg-gray-400 dark:disabled:bg-gray-600 text-white font-medium py-2 px-4 rounded-lg transition-colors duration-200 flex items-center gap-2"
              >
                <RefreshCw className={`w-4 h-4 ${isLoading ? 'animate-spin' : ''}`} />
                {isLoading ? 'Reloading' : 'Reload Segments'}
              </Button>
            </div>

            {/* Cable Selection (Fallback) */}
            {segmentOptions.length === 0 && cableOptions.length > 0 && (
              <div className="p-4 bg-amber-50 dark:bg-amber-900/20 border border-amber-200 dark:border-amber-800 rounded-lg">
                <div className="space-y-2">
                  <label className="text-sm font-medium text-amber-800 dark:text-amber-300 flex items-center gap-2">
                    <Info className="w-4 h-4" />
                    Incoming Cable (Fallback)
                  </label>
                  <select
                    value={incomingCableId}
                    onChange={(e) => setIncomingCableId(e.target.value)}
                    className="w-full p-3 border border-amber-300 dark:border-amber-600 rounded-lg bg-white dark:bg-gray-800 text-gray-900 dark:text-white text-sm focus:ring-2 focus:ring-amber-500 focus:border-transparent transition-all duration-200"
                  >
                    {cableOptions.map((opt) => (
                      <option key={opt.id} value={opt.id} className="text-gray-900 dark:text-white">
                        {opt.label}
                      </option>
                    ))}
                  </select>
                </div>
              </div>
            )}

            {/* Splice Configuration Table */}
            <div className="border border-gray-200 dark:border-gray-700 rounded-lg overflow-hidden">
              <div className="overflow-x-auto">
                <table className="w-full">
                  <thead className="bg-gray-50 dark:bg-gray-900 border-b border-gray-200 dark:border-gray-700">
                    <tr>
                      <th className="px-6 py-4 text-left text-xs font-semibold text-gray-600 dark:text-gray-400 uppercase tracking-wider">
                        Fiber #
                      </th>
                      <th className="px-6 py-4 text-left text-xs font-semibold text-gray-600 dark:text-gray-400 uppercase tracking-wider">
                        Splice Type
                      </th>
                      {segmentOptions.length === 0 && (
                        <th className="px-6 py-4 text-left text-xs font-semibold text-gray-600 dark:text-gray-400 uppercase tracking-wider">
                          Outgoing Cable
                        </th>
                      )}
                      <th className="px-6 py-4 text-left text-xs font-semibold text-gray-600 dark:text-gray-400 uppercase tracking-wider">
                        Outgoing Fiber
                      </th>
                      <th className="px-6 py-4 text-left text-xs font-semibold text-gray-600 dark:text-gray-400 uppercase tracking-wider">
                        Individual Config
                      </th>
                      <th className="px-6 py-4 text-left text-xs font-semibold text-gray-600 dark:text-gray-400 uppercase tracking-wider">
                        Status
                      </th>
                    </tr>
                  </thead>
                  <tbody className="divide-y divide-gray-200 dark:divide-gray-700">
                    {Array.from({ length: maxFibers }, (_, i) => i + 1).map((fiberNo) => {
                      const splice = fiberSplices.find(
                        (s) =>
                          s.incoming_fiber_no === fiberNo &&
                          (!incomingCableId || s.incoming_cable_id === incomingCableId)
                      );
                      const config = spliceConfigurations.find(
                        (s) => s.incoming_fiber_no === fiberNo
                      );
                      const nonIncoming = cableOptions.filter((opt) => opt.id !== incomingCableId);
                      const outgoingOptions = nonIncoming.length > 0 ? nonIncoming : cableOptions;
                      const defaultOutgoingCable = outgoingOptions[0]?.id || incomingCableId || '';
                      const currentOutgoingCable = (config?.outgoing_cable_id ??
                        splice?.outgoing_cable_id ??
                        defaultOutgoingCable) as string;

                      return (
                        <tr
                          key={fiberNo}
                          className="hover:bg-gray-50 dark:hover:bg-gray-800/50 transition-colors duration-150"
                        >
                          <td className="px-6 py-4 whitespace-nowrap">
                            <span className="inline-flex items-center justify-center w-8 h-8 bg-blue-100 dark:bg-blue-900/30 text-blue-800 dark:text-blue-300 rounded-full text-sm font-medium">
                              {fiberNo}
                            </span>
                          </td>
                          <td className="px-6 py-4 whitespace-nowrap">
                            <select
                              value={
                                config?.splice_type ||
                                (splice?.splice_type === 'pass_through'
                                  ? 'straight'
                                  : splice?.splice_type === 'branch'
                                  ? 'cross'
                                  : 'straight')
                              }
                              onChange={(e) =>
                                handleSpliceTypeChange(
                                  fiberNo,
                                  e.target.value as 'straight' | 'cross'
                                )
                              }
                              className="border border-gray-300 dark:border-gray-600 rounded-md bg-white dark:bg-gray-800 text-gray-900 dark:text-white p-2 text-sm focus:ring-2 focus:ring-blue-500 focus:border-transparent transition-all duration-200"
                            >
                              <option value="straight" className="text-gray-900 dark:text-white">
                                Straight
                              </option>
                              <option value="cross" className="text-gray-900 dark:text-white">
                                Cross
                              </option>
                            </select>
                          </td>
                          {segmentOptions.length === 0 && (
                            <td className="px-6 py-4 whitespace-nowrap">
                              <select
                                value={currentOutgoingCable}
                                onChange={(e) => handleOutgoingCableChange(fiberNo, e.target.value)}
                                className="border border-gray-300 dark:border-gray-600 rounded-md bg-white dark:bg-gray-800 text-gray-900 dark:text-white p-2 text-sm focus:ring-2 focus:ring-blue-500 focus:border-transparent transition-all duration-200 min-w-[120px]"
                              >
                                {outgoingOptions.map((opt) => (
                                  <option
                                    key={opt.id}
                                    value={opt.id}
                                    className="text-gray-900 dark:text-white"
                                  >
                                    {opt.label}
                                  </option>
                                ))}
                              </select>
                            </td>
                          )}
                          <td className="px-6 py-4 whitespace-nowrap">
                            <input
                              type="number"
                              min="1"
                              max={maxFibers}
                              value={
                                config?.outgoing_fiber_no || splice?.outgoing_fiber_no || fiberNo
                              }
                              onChange={(e) =>
                                handleOutgoingFiberChange(
                                  fiberNo,
                                  parseInt(e.target.value) || fiberNo,
                                  currentOutgoingCable
                                )
                              }
                              className="w-20 border border-gray-300 dark:border-gray-600 rounded-md bg-white dark:bg-gray-800 text-gray-900 dark:text-white p-2 text-sm text-center focus:ring-2 focus:ring-blue-500 focus:border-transparent transition-all duration-200"
                            />
                          </td>
                          <td className="px-6 py-4 whitespace-nowrap">
                            <Button
                              size="sm"
                              onClick={() => handleIndividualFiberConfig(fiberNo)}
                              disabled={isLoading}
                              className="bg-blue-500 hover:bg-blue-600 disabled:bg-gray-400 dark:disabled:bg-gray-600 text-white font-medium py-1 px-3 rounded-md transition-colors duration-200 flex items-center gap-1"
                            >
                              <Settings className="w-3 h-3" />
                              Configure
                            </Button>
                          </td>
                          <td className="px-6 py-4 whitespace-nowrap">
                            <span
                              className={`inline-flex items-center px-3 py-1 rounded-full text-xs font-medium ${
                                splice?.status === 'active'
                                  ? 'bg-green-100 text-green-800 dark:bg-green-900/30 dark:text-green-300'
                                  : 'bg-gray-100 text-gray-800 dark:bg-gray-700 dark:text-gray-300'
                              }`}
                            >
                              {splice?.status === 'active' ? (
                                <CheckCircle className="w-3 h-3 mr-1" />
                              ) : (
                                <Clock className="w-3 h-3 mr-1" />
                              )}
                              {splice?.status || 'Not Set'}
                            </span>
                          </td>
                        </tr>
                      );
                    })}
                  </tbody>
                </table>
              </div>
            </div>

            {/* Apply Button */}
            <div className="flex justify-end pt-4">
              <Button
                onClick={applySpliceConfiguration}
                disabled={isLoading || spliceConfigurations.length === 0}
                className="bg-green-600 hover:bg-green-700 disabled:bg-gray-400 dark:disabled:bg-gray-600 text-white font-medium py-3 px-6 rounded-lg transition-colors duration-200 flex items-center gap-2"
              >
                {isLoading ? (
                  <Loader2 className="w-4 h-4 animate-spin" />
                ) : (
                  <CheckCircle className="w-4 h-4" />
                )}
                {isLoading ? 'Applying...' : 'Apply Splice Configuration'}
              </Button>
            </div>

            {error && (
              <div className="bg-red-50 dark:bg-red-900/20 border border-red-200 dark:border-red-800 rounded-lg p-4">
                <div className="flex items-center">
                  <AlertCircle className="w-5 h-5 text-red-500 mr-2" />
                  <p className="text-red-800 dark:text-red-300 font-medium">Error</p>
                </div>
                <p className="text-red-700 dark:text-red-400 mt-1 text-sm">{error}</p>
              </div>
            )}
          </div>
        </CardBody>
      </Card>
    </div>
  );
};

```

<!-- path: components/rings/RingModal.tsx -->
```typescript
"use client";

import React, { useCallback, useEffect, useMemo } from "react";
import { Modal } from "@/components/common/ui/Modal";
import { Option } from "@/components/common/ui/select/SearchableSelect";
import { createClient } from "@/utils/supabase/client";
import { useTableInsert, useTableUpdate } from "@/hooks/database";
import { useForm } from "react-hook-form";
import { zodResolver } from "@hookform/resolvers/zod";
import { FormCard } from "@/components/common/form/FormCard";
import {
  FormInput,
  FormSearchableSelect,
  FormSwitch,
  FormTextarea,
} from "@/components/common/form/FormControls";
import { ringsInsertSchema, RingsInsertSchema, RingsRowSchema, RingsUpdateSchema } from "@/schemas/zod-schemas";


interface RingModalProps {
  isOpen: boolean;
  onClose: () => void;
  editingRing?: RingsRowSchema | null;
  onCreated?: (ring: RingsRowSchema) => void;
  onUpdated?: (ring: RingsRowSchema) => void;
  ringTypes: Array<{ id: string; name: string; code: string | null }>;
  maintenanceAreas: Array<{ id: string; name: string; code: string | null }>;
}

export function RingModal({
  isOpen,
  onClose,
  editingRing,
  onCreated,
  onUpdated,
  ringTypes,
  maintenanceAreas,
}: RingModalProps) {
  const {
    register,
    handleSubmit,
    formState: { errors, isSubmitting },
    reset,
    control,
  } = useForm<RingsInsertSchema>({
    resolver: zodResolver(ringsInsertSchema),
    defaultValues: {
      name: "",
      description: null,
      ring_type_id: null,
      maintenance_terminal_id: null,
      status: true,
    },
  });

  const supabase = createClient();
  const { mutate: insertRing, isPending: creating } = useTableInsert(
    supabase,
    "rings"
  );
  const { mutate: updateRing, isPending: updating } = useTableUpdate(
    supabase,
    "rings"
  );

  const isEdit = useMemo(() => Boolean(editingRing), [editingRing]);

  // Memoized options for selects
  const ringTypeOptions: Option[] = useMemo(
    () =>
      (ringTypes || []).map(
        (rt) =>
          ({
            value: rt.id,
            label: `${rt.name}${rt.code ? ` (${rt.code})` : ""}`,
          } as Option)
      ),
    [ringTypes]
  );

  const maintenanceAreaOptions: Option[] = useMemo(
    () =>
      (maintenanceAreas || []).map(
        (a) =>
          ({
            value: a.id,
            label: `${a.name}${a.code ? ` (${a.code})` : ""}`,
          } as Option)
      ),
    [maintenanceAreas]
  );

  useEffect(() => {
    if (!isOpen) return;
    if (editingRing) {
      reset({
        name: editingRing.name ?? "",
        description: editingRing.description ?? null,
        status: editingRing.status ?? true,
        ring_type_id: editingRing.ring_type_id ?? null,
        maintenance_terminal_id: editingRing.maintenance_terminal_id ?? null,
      });
    } else {
      reset({
        name: "",
        description: null,
        status: true,
        ring_type_id: null,
        maintenance_terminal_id: null,
      });
    }
  }, [isOpen, editingRing, reset]);

  const handleClose = useCallback(() => {
    if (creating || updating) return;
    onClose();
  }, [creating, updating, onClose]);

  const onValidSubmit = useCallback(
    (formData: RingsInsertSchema) => {
      const submitData = {
        name: formData.name.trim(),
        description: formData.description,
        status: formData.status,
        ring_type_id: formData.ring_type_id,
        maintenance_terminal_id: formData.maintenance_terminal_id,
      };

      if (isEdit && editingRing) {
        updateRing(
          { id: editingRing.id, data: submitData as Partial<RingsUpdateSchema> },
          {
            onSuccess: (data: unknown) => {
              onUpdated?.(Array.isArray(data) ? data[0] : data);
              onClose();
            },
          }
        );
      } else {
        insertRing(submitData as RingsInsertSchema, {
          onSuccess: (data: unknown) => {
            onCreated?.(Array.isArray(data) ? data[0] : data);
            onClose();
          },
        });
      }
    },
    [isEdit, editingRing, updateRing, insertRing, onUpdated, onCreated, onClose]
  );

  const submitting = creating || updating || isSubmitting;

  return (
    <Modal
      isOpen={isOpen}
      onClose={handleClose}
      title={isEdit ? "Edit Ring" : "Add Ring"}
      visible={false}
      className="h-screen w-screen transparent bg-gray-700 rounded-2xl"
    >
      <FormCard
        onSubmit={handleSubmit(onValidSubmit)}
        heightClass="min-h-calc(90vh - 200px)"
        title={isEdit ? "Edit Ring" : "Add Ring"}
        onCancel={handleClose}
        standalone
      >
        <FormInput
          name="name"
          label="Name"
          register={register}
          error={errors.name}
          disabled={submitting}
          placeholder="Enter ring name"
        />
        <FormSearchableSelect
          name="ring_type_id"
          label="Ring Type"
          control={control}
          error={errors.ring_type_id}
          disabled={submitting}
          placeholder="Select ring type"
          options={ringTypeOptions}
        />

        <FormSearchableSelect
          name="maintenance_terminal_id"
          label="Maintenance Terminal"
          control={control}
          error={errors.maintenance_terminal_id}
          disabled={submitting}
          placeholder="Select maintenance terminal"
          options={maintenanceAreaOptions}
        />

        <FormTextarea
          name="description"
          label="Description"
          control={control}
          error={errors.description}
          disabled={submitting}
          placeholder="Optional description"
        />
        <FormSwitch
          name="status"
          label="Status"
          control={control}
          error={errors.status}
          className="my-2"
        />
      </FormCard>
    </Modal>
  );
}

```

<!-- path: components/rings/RingsFilters.tsx -->
```typescript
import { FiSearch } from "react-icons/fi";

interface RingsFiltersProps {
  searchQuery: string;
  onSearchChange: (value: string) => void;
}

export function RingsFilters({ searchQuery, onSearchChange }: RingsFiltersProps) {
  return (
    <div className="w-full">
      <div className="flex-1 sm:max-w-md lg:max-w-xl">
        <div className="relative">
          <FiSearch className="absolute left-3 top-1/2 -translate-y-1/2 text-gray-400 w-4 h-4 sm:w-5 sm:h-5" />
          <input
            type="text"
            placeholder="Search rings..."
            value={searchQuery}
            onChange={(e) => onSearchChange(e.target.value)}
            className="w-full pl-9 sm:pl-10 pr-4 py-2.5 sm:py-2 text-sm sm:text-base border border-gray-300 dark:border-gray-600 rounded-lg bg-white dark:bg-gray-700 text-gray-900 dark:text-white placeholder-gray-500 dark:placeholder-gray-400 focus:ring-2 focus:ring-blue-500 focus:border-blue-500 transition-colors"
          />
        </div>
      </div>
    </div>
  );
}

export default RingsFilters;

```

<!-- path: components/diagrams/hooks/useFileHandling.ts -->
```typescript
// hooks/useFileHandling.ts
import { useCallback, useRef } from 'react';
import Uppy from "@uppy/core";

export function useFileHandling(uppyRef: React.RefObject<Uppy | null>) {
  const fileInputRef = useRef<HTMLInputElement>(null);

  const handleFileInputChange = useCallback((event: React.ChangeEvent<HTMLInputElement>) => {
    const files = event.target.files;
    if (files && uppyRef.current) {
      Array.from(files).forEach((file) => {
        uppyRef.current?.addFile({
          name: file.name,
          type: file.type,
          data: file,
          source: "file-input",
          isRemote: false,
        });
      });
      event.target.value = '';
    }
  }, [uppyRef]);

  const triggerFileInput = useCallback(() => {
    fileInputRef.current?.click();
  }, []);

  const handleRemoveFile = useCallback((fileId: string) => {
    uppyRef.current?.removeFile(fileId);
  }, [uppyRef]);

  return {
    fileInputRef,
    handleFileInputChange,
    triggerFileInput,
    handleRemoveFile
  };
}
```

<!-- path: components/diagrams/hooks/useFolders.ts -->
```typescript
// hooks/useFolders.ts
"use client";

import { useState, useCallback } from 'react';
import { createClient } from "@/utils/supabase/client";
import { useMutation, useQuery, useQueryClient } from "@tanstack/react-query";

interface Folder {
  id: string;
  name: string;
  user_id: string;
  uploaded_at: string;
}

interface UseFoldersReturn {
  folders: Folder[];
  folderId: string | null;
  setFolderId: (id: string | null) => void;
  newFolderName: string;
  setNewFolderName: (name: string) => void;
  handleCreateFolder: () => void;
  refreshFolders: () => Promise<void>;
  isCreatingFolder: boolean;
  isLoading: boolean;
}

interface UseFoldersProps {
  onError?: (error: string) => void;
  onSuccess?: () => void;
}

export function useFolders({
  onError,
  onSuccess
}: UseFoldersProps = {}): UseFoldersReturn {
  const supabase = createClient();
  const [folderId, setFolderId] = useState<string | null>(null);
  const [newFolderName, setNewFolderName] = useState("");
  const queryClient = useQueryClient();

  // Fetch folders
  const { data: folders = [], isLoading } = useQuery<Folder[]>({
    queryKey: ['folders'],
    queryFn: async () => {
      const { data: { user }, error: authError } = await supabase.auth.getUser();
      if (authError || !user) return [];

      const { data, error } = await supabase
        .from("folders")
        .select("*");
        // .eq("user_id", user.id);

      if (error) {
        console.error("Fetch folders error:", error);
        onError?.("Failed to load folders");
        return [];
      }
      
      return data || [];
    }
  });

  // Create folder mutation
  const { mutate: createFolder, isPending: isCreating } = useMutation({
    mutationFn: async (name: string) => {
      const { data: { user }, error: authError } = await supabase.auth.getUser();
      if (authError || !user) throw new Error("Not authenticated");
      if (!name.trim()) throw new Error("Folder name cannot be empty");

      const { data, error } = await supabase
        .from("folders")
        .insert({
          user_id: user.id,
          name: name.trim(),
        })
        .select()
        .single();

      if (error) throw error;
      return data;
    },
    onSuccess: () => {
      setNewFolderName("");
      queryClient.invalidateQueries({ queryKey: ['folders'] });
      onSuccess?.();
    },
    onError: (error: Error) => {
      console.error("Create folder error:", error);
      onError?.(error.message);
    },
  });

  const handleCreateFolder = useCallback(() => {
    if (newFolderName.trim()) {
      createFolder(newFolderName);
    }
  }, [createFolder, newFolderName]);

  const refreshFolders = useCallback(async () => {
    await queryClient.invalidateQueries({ queryKey: ['folders'] });
  }, [queryClient]);

  return {
    folders,
    folderId,
    setFolderId,
    newFolderName,
    setNewFolderName,
    handleCreateFolder,
    refreshFolders,
    isCreatingFolder: isCreating,
    isLoading,
  };
}
```

<!-- path: components/diagrams/hooks/useUppyUploader.ts -->
```typescript
// hooks/useUppyUploader.ts
import { useRef, useState, useEffect } from 'react';
import Uppy from '@uppy/core';
import XHRUpload from '@uppy/xhr-upload';
import Webcam from '@uppy/webcam';
import { createClient } from "@/utils/supabase/client";
import { createOptimizedUppy } from "@/utils/imageOptimization";
import { smartCompress, convertToWebP, createProgressiveJPEG } from "@/utils/imageOptimization";
import { useUploadFile } from "@/hooks/database/file-queries";


interface UploadedFile {
  public_id: string;
  secure_url: string;
  // Add other properties as needed
}

interface SelectedFile {
  id: string;
  name: string;
  type: string;
  size: number;
}

interface UseUppyUploaderProps {
  folderId: string | null;
  // refresh: boolean;
  setRefresh: React.Dispatch<React.SetStateAction<boolean>>;
  // error?: string | null;
  setError: React.Dispatch<React.SetStateAction<string | null>>;
}

interface UseUppyUploaderReturn {
  uppyRef: React.RefObject<Uppy | null>;
  uploadedFiles: UploadedFile[];
  selectedFiles: SelectedFile[];
  isUploading: boolean;
  processedFiles: Set<string>;
  handleStartUpload: () => void;
  toggleCamera: () => void;
  toggleCameraActive: () => void;
  facingMode: 'user' | 'environment';
  isCameraActive: boolean;
  cameraError: string | null;
}

export function useUppyUploader({
  folderId,
  setRefresh,
  setError,
}: UseUppyUploaderProps): UseUppyUploaderReturn {
  const { mutate: uploadFile } = useUploadFile();
  const supabase = createClient();
  const uppyRef = useRef<Uppy<any, Record<string, never>> | null>(null);
  const [uploadedFiles, setUploadedFiles] = useState<any[]>([]);
  const [selectedFiles, setSelectedFiles] = useState<any[]>([]);
  const [isUploading, setIsUploading] = useState(false);
  const [facingMode, setFacingMode] = useState<'user' | 'environment'>(
    (localStorage.getItem("preferredCamera") as 'user' | 'environment') || 'environment'
  );
  const [isCameraActive, setIsCameraActive] = useState(false);
  const [cameraError, setCameraError] = useState<string | null>(null);
  const [processedFiles, setProcessedFiles] = useState<Set<string>>(new Set());


  // Initialize Uppy
  useEffect(() => {
    const uppy = createOptimizedUppy({ folderId });

    uppy.use(XHRUpload, {
      endpoint: "/api/upload",
      method: "POST",
      formData: true,
      fieldName: "file",
      bundle: false,
      headers: {
        "x-folder-id": folderId || "",
      },
      limit: 14,
    });

    // Configure Webcam
    const webcamPlugin = uppy.use(Webcam, {
      onBeforeSnapshot: () => Promise.resolve(),
      countdown: false,
      modes: ["video-audio", "video-only", "audio-only", "picture"],
      mirror: facingMode === "user",
      videoConstraints: {
        facingMode: facingMode,
        width: { min: 720, ideal: 1280, max: 1920 },
        height: { min: 480, ideal: 720, max: 1080 },
      },
      showVideoSourceDropdown: true,
    });

    if (webcamPlugin && typeof webcamPlugin.on === "function") {
      webcamPlugin.on("error", (error: any) => {
        const errorMsg = `Camera error: ${error.message}`;
        setCameraError(errorMsg);
       console.error("Webcam error:", error);
      });
    }

    // Add optimization preprocessor
    uppy.addPreProcessor(async (fileIDs) => {
      const optimizationPromises = fileIDs.map(async (fileID) => {
        const file = uppy.getFile(fileID);

        if (file?.type?.startsWith("image/")) {
          try {
            let optimizedFile = await smartCompress(file.data as File);
            if (!optimizedFile || optimizedFile.size === 0) {
              console.warn("Optimization failed for", file.name, "- using original");
              return;
            }

            const webpFile = await convertToWebP(optimizedFile);
            if (webpFile.size < optimizedFile.size) {
              optimizedFile = webpFile;
            }

            if (optimizedFile.type === "image/jpeg") {
              optimizedFile = await createProgressiveJPEG(optimizedFile);
            }

            if (optimizedFile.size > 0) {
              uppy.setFileState(fileID, {
                data: optimizedFile,
                size: optimizedFile.size,
              });

              console.log(
                `Optimized ${file.name}: ${((file.size ?? 0) / 1024 / 1024).toFixed(2)}MB  ${(optimizedFile.size / 1024 / 1024).toFixed(2)}MB`,
              );
            }
          } catch (error) {
            console.warn(`Failed to optimize ${file.name}:`, error);
            uppy.setFileState(fileID, {
              data: file.data,
              size: file.size,
            });
          }
        }
      });

      await Promise.all(optimizationPromises);
    });

    // Event handlers
    uppy.on("upload", () => {
      setIsUploading(true);
      setCameraError(null);
    });

    uppy.on("upload-success", async (file, response) => {
      try {
       if (!file || processedFiles.has(file.id)) return;
        setProcessedFiles((prev) => new Set([...prev, file.id]));

        const { data: userData, error: userError } = await supabase.auth.getUser();
        if (userError || !userData?.user) {
          throw new Error("User not authenticated");
        }

        if (!response.body?.public_id) {
          console.error("Missing public_id in response:", {
            file: file.name,
            response: response.body,
          });
          setError("Upload response is missing public_id.");
          return;
        }

        if (!file.name) {
          throw new Error("File name is required");
        }

        const fileData = {
          user_id: userData.user.id,
          file_name: file.name,
          file_type: file.type || 'application/octet-stream',
          file_size: file.size?.toString() || '0', // Convert to string
          file_route: response.body.public_id,
          file_url: response.body.secure_url || "",
          folder_id: folderId || null,
        };

        try {
          await uploadFile(fileData);
          setUploadedFiles((prev) => [...prev, response.body]);
          setRefresh((prev) => !prev);
        } catch (error) {
          console.error("Error saving file to database:", error);
          setError(`Database error: ${error instanceof Error ? error.message : 'Unknown error'}`);
          setProcessedFiles((prev) => {
            const newSet = new Set(prev);
            newSet.delete(file.id);
            return newSet;
          });
        }
      } catch (err: any) {
        console.error("Upload success handler error:", err);
        setError(err.message);
        if (file) {
          setProcessedFiles((prev) => {
            const newSet = new Set(prev);
            newSet.delete(file.id);
            return newSet;
          });
        }
      }
    });

    uppy.on("upload-error", (file, error) => {
     console.error("Upload error:", error);
      setError(`Upload failed: ${error.message}`);
      setIsUploading(false);
    });

   uppy.on("complete", (result) => {
      console.log("Upload complete:", result);
      setIsUploading(false);
      if ((result.successful ?? []).length > 0) {
        setError(null);
        setSelectedFiles([]);
        setTimeout(() => setProcessedFiles(new Set()), 1000);
      }
    });

    uppy.on("file-added", (file) => {
      uppy.setFileMeta(file.id, { folderId });
      setSelectedFiles(prev => [
        ...prev.filter(f => f.id !== file.id),
        {
          id: file.id,
          name: file.name,
          type: file.type,
          size: file.size,
        },
      ]);
    });

    uppy.on("file-removed", (file) => {
      setSelectedFiles((prev) => prev.filter((f) => f.id !== file.id));
    });

    uppyRef.current = uppy;

    return () => {
      uppy.destroy();
      uppyRef.current = null;
    };
  }, [folderId, supabase, facingMode, processedFiles]);



  const handleStartUpload = () => {
    if (!folderId) {
      setError("Please select a folder first.");
      return;
    }

    if (!selectedFiles.length) {
      setError("Please select files to upload first.");
      return;
    }

    uppyRef.current?.upload();
  };

  const toggleCamera = () => {
    const newMode = facingMode === "user" ? "environment" : "user";
    setFacingMode(newMode);
    localStorage.setItem("preferredCamera", newMode);

    if (uppyRef.current) {
      const webcamPlugin = uppyRef.current.getPlugin("Webcam");
      if (webcamPlugin) {
        webcamPlugin.setOptions({
          mirror: newMode === "user",
          facingMode: newMode,
        });
      }
    }
  };

  const toggleCameraActive = () => {
    setIsCameraActive(!isCameraActive);
  };

  return {
    uppyRef,
    uploadedFiles,
    selectedFiles,
    isUploading,
    processedFiles,
    handleStartUpload,
    toggleCamera,
    toggleCameraActive,
    facingMode,
    isCameraActive,
    cameraError
  };
}
```

<!-- path: components/diagrams/FileUploader.tsx -->
```typescript
// components/FileUploader.tsx
'use client';

import { useState, useCallback } from 'react';
import { FileTable } from './FileTable';
import { useUppyUploader } from './hooks/useUppyUploader';
import { useFolders } from './hooks/useFolders';
import { useFileHandling } from './hooks/useFileHandling';
import { Toaster } from 'sonner';
import { useQueryClient } from '@tanstack/react-query';

export default function FileUploader() {
  const queryClient = useQueryClient();
  const [error, setError] = useState<string | null>(null);
  const [showUploadSection, setShowUploadSection] = useState(false);
  const [showDashboard, setShowDashboard] = useState(false);

  const {
    folders,
    folderId,
    newFolderName,
    setFolderId,
    setNewFolderName,
    handleCreateFolder,
    isCreatingFolder,
    isLoading: isLoadingFolders,
  } = useFolders({
    onError: setError,
    onSuccess: () => queryClient.invalidateQueries({ queryKey: ['files'] }),
  });

  const handleUploadSuccess = useCallback(() => {
    queryClient.invalidateQueries({ queryKey: ['files'] });
  }, [queryClient]);

  const {
    uppyRef,
    uploadedFiles,
    selectedFiles,
    isUploading,
    handleStartUpload,
    toggleCamera,
    toggleCameraActive,
    facingMode,
    isCameraActive,
    cameraError,
  } = useUppyUploader({
    folderId: folderId || null,
    setRefresh: () => {
      queryClient.invalidateQueries({ queryKey: ['files'] });
    },
    setError: (error) => {
      setError(error);
    },
  });

  const {
    fileInputRef,
    handleFileInputChange,
    triggerFileInput,
    handleRemoveFile,
  } = useFileHandling(uppyRef);

  const handleFileDeleted = useCallback(() => {
    queryClient.invalidateQueries({ queryKey: ['files'] });
  }, [queryClient]);

  return (
    <div className="mx-auto max-w-4xl space-y-6 p-4">
      <Toaster position="top-right" duration={4000} />

      <button
        onClick={() => setShowUploadSection(!showUploadSection)}
        className="mb-4 px-4 py-2 bg-blue-500 text-white rounded hover:bg-blue-600 transition-colors"
      >
        {showUploadSection ? 'Hide Upload Section' : 'Show Upload Section'}
      </button>

      {showUploadSection && (
        <div className="space-y-4 p-4 border rounded-lg bg-white dark:bg-gray-800">
          {/* Folder Management */}
          <div className="space-y-2">
            <input
              type="text"
              value={newFolderName}
              onChange={(e) => setNewFolderName(e.target.value)}
              placeholder="New folder name"
              className="w-full p-2 border rounded"
              disabled={isCreatingFolder}
            />
            <button
              onClick={handleCreateFolder}
              disabled={!newFolderName.trim() || isCreatingFolder}
              className="px-4 py-2 bg-green-500 text-white rounded hover:bg-green-600 disabled:opacity-50"
            >
              {isCreatingFolder ? 'Creating...' : 'Create Folder'}
            </button>
          </div>

          {/* File Upload Area */}
          <div className="mt-4">
            <input
              type="file"
              ref={fileInputRef}
              onChange={handleFileInputChange}
              className="hidden"
              multiple
            />
            <button
              onClick={triggerFileInput}
              className="px-4 py-2 bg-blue-500 text-white rounded hover:bg-blue-600"
              disabled={isUploading}
            >
              {isUploading ? 'Uploading...' : 'Select Files'}
            </button>
            <button
              onClick={handleStartUpload}
              disabled={selectedFiles.length === 0 || isUploading}
              className="ml-2 px-4 py-2 bg-purple-500 text-white rounded hover:bg-purple-600 disabled:opacity-50"
            >
              {isUploading
                ? 'Uploading...'
                : `Upload ${selectedFiles.length} Files`}
            </button>
          </div>
        </div>
      )}

      {/* File Table */}
      <div className="mt-6">
        <FileTable
          folders={folders}
          onFileDelete={handleFileDeleted}
          folderId={folderId}
          onFolderSelect={setFolderId}
          isLoading={isLoadingFolders}
        />
      </div>
    </div>
  );
}

```

<!-- path: components/diagrams/FileTable.tsx -->
```typescript
"use client";

import { useState, useMemo, useEffect, useCallback } from "react";
import { Eye, Download, Trash2, Search, Filter, Grid, List, X } from "lucide-react";
import { useFiles, useDeleteFile } from "@/hooks/database/file-queries";
import "../../app/customuppy.css"; // Custom styles for Uppy

// Define file type for better type safety
interface FileType {
  id: string;
  file_name: string;
  file_type: string;
  file_url: string;
  uploaded_at: string;
  [key: string]: any;
}

interface FileTableProps {
  folders: Array<{ id: string; name: string }>;
  onFileDelete?: () => void;
  folderId?: string | null;
  onFolderSelect?: (id: string | null) => void;
  isLoading?: boolean;
}

export function FileTable({ folders, onFileDelete }: FileTableProps) {
  const [selectedFolder, setSelectedFolder] = useState<string | null>(null);
  const [folderSearchTerm, setFolderSearchTerm] = useState<string>("");
  const [fileSearchTerm, setFileSearchTerm] = useState<string>("");
  const [sortBy, setSortBy] = useState<"name" | "date" | "type">("date");
  const [sortOrder, setSortOrder] = useState<"asc" | "desc">("desc");
  const [fileTypeFilter, setFileTypeFilter] = useState<string>("all");
  const [viewMode, setViewMode] = useState<"grid" | "list">("list");
  const [deletingFile, setDeletingFile] = useState<string | null>(null);

  // Use React Query to fetch files
  const { data: files = [], isLoading, refetch } = useFiles(selectedFolder || undefined);
  const loading = isLoading; // Use loading state from React Query
  const { mutate: deleteFile } = useDeleteFile();

  // Filter folders based on folder search term and sort alphabetically in ascending order
  const filteredFolders = useMemo(() => 
    folders
      .filter(folder =>
        folder.name.toLowerCase().includes(folderSearchTerm.toLowerCase())
      )
      .sort((a, b) => a.name.toLowerCase().localeCompare(b.name.toLowerCase())),
    [folders, folderSearchTerm]
  );

  // Reset selected folder when it's not in filtered results
  useEffect(() => {
    if (selectedFolder && folderSearchTerm) {
      const isFolderVisible = filteredFolders.some(folder => folder.id === selectedFolder);
      if (!isFolderVisible) {
        setSelectedFolder(null);
      }
    }
  }, [selectedFolder, folderSearchTerm, filteredFolders]);


  // Sort and filter files based on user preferences
  const processedFiles = useMemo(() => {
    return (files as FileType[])
      .filter((file) => {
        const matchesSearch = file.file_name.toLowerCase().includes(fileSearchTerm.toLowerCase());
        const matchesType = fileTypeFilter === "all" || file.file_type?.includes(fileTypeFilter);
        return matchesSearch && matchesType;
      })
      .sort((a, b) => {
        let comparison = 0;
        
        if (sortBy === "name") {
          comparison = a.file_name.localeCompare(b.file_name);
        } else if (sortBy === "type") {
          comparison = (a.file_type || "").localeCompare(b.file_type || "");
        } else {
          // Sort by date
          const dateA = new Date(a.uploaded_at || 0).getTime();
          const dateB = new Date(b.uploaded_at || 0).getTime();
          comparison = dateA - dateB;
        }
        
        return sortOrder === "asc" ? comparison : -comparison;
      });
  }, [files, fileSearchTerm, fileTypeFilter, sortBy, sortOrder]);

  const handleView = (file: FileType) => {
    if (file.file_type === "application/pdf") {
      const googleViewerUrl = `https://docs.google.com/gview?url=${encodeURIComponent(file.file_url)}&embedded=true`;
      window.open(googleViewerUrl, '_blank');
    } else {
      window.open(file.file_url, '_blank');
    }
  };

  const handleDelete = (file: FileType) => {
    if (!confirm(`Are you sure you want to delete "${file.file_name}"?`)) {
      return;
    }

    setDeletingFile(file.id);
    deleteFile(
      { id: file.id, folderId: selectedFolder },
      {
        onSuccess: () => {
          onFileDelete?.();
          refetch();
        },
        onError: (error) => {
          console.error("Delete error:", error);
          alert("Failed to delete file");
        },
        onSettled: () => {
          setDeletingFile(null);
        }
      }
    );
  };

  const getDownloadUrl = (file: FileType) => {
    if (file.file_type === "application/pdf") {
      return file.file_url.replace("/upload/", "/upload/fl_attachment/");
    }
    return file.file_url;
  };

  const getFileIcon = (fileType: string = '') => {
    if (fileType.startsWith("image/")) return "";
    if (fileType === "application/pdf") return "";
    if (fileType.startsWith("video/")) return "";
    if (fileType.startsWith("audio/")) return "";
    if (fileType.includes("document") || fileType.includes("word")) return "";
    if (fileType.includes("spreadsheet") || fileType.includes("excel")) return "";
    if (fileType.includes("presentation") || fileType.includes("powerpoint")) return "";
    return "";
  };

  const formatDate = (dateString: string) => {
    return new Date(dateString).toLocaleDateString("en-US", {
      year: "numeric",
      month: "short",
      day: "numeric",
      hour: "2-digit",
      minute: "2-digit",
    });
  };

  // Helper function to truncate folder names with ellipsis
  const truncateFolderName = (name: string, maxLength: number = 20) => {
    if (name.length <= maxLength) return name;
    return name.substring(0, maxLength) + "...";
  };

  // Clear search functions
  const clearFolderSearch = useCallback(() => {
    setFolderSearchTerm("");
  }, []);

  const clearFileSearch = useCallback(() => {
    setFileSearchTerm("");
  }, []);

  // Filter and sort files
  const filteredAndSortedFiles = useMemo(() => {
    return (files as FileType[])
      .filter((file) => {
        const matchesSearch = file.file_name.toLowerCase().includes(fileSearchTerm.toLowerCase());
        const matchesType = fileTypeFilter === "all" || file.file_type.startsWith(fileTypeFilter);
        return matchesSearch && matchesType;
      })
      .sort((a, b) => {
        let aValue: string | Date;
        let bValue: string | Date;
        
        switch (sortBy) {
          case "name":
            aValue = a.file_name.toLowerCase();
            bValue = b.file_name.toLowerCase();
            break;
          case "type":
            aValue = a.file_type || '';
            bValue = b.file_type || '';
            break;
          case "date":
          default:
            aValue = new Date(a.uploaded_at || 0);
            bValue = new Date(b.uploaded_at || 0);
            break;
        }
        
        const comparison = aValue > bValue ? 1 : aValue < bValue ? -1 : 0;
        return sortOrder === "asc" ? comparison : -comparison;
      });
  }, [files, fileSearchTerm, fileTypeFilter, sortBy, sortOrder]);

  const getFileTypeOptions = () => {
    const types = [...new Set((files as FileType[]).map(file => file.file_type.split("/")[0]))];
    return types.map(type => ({
      value: type,
      label: type ? type.charAt(0).toUpperCase() + type.slice(1) : 'Unknown',
    }));
  };

  return (
    <div className="mt-8 space-y-6">
      <h2
        className={`text-xl font-semibold dark:text-white text-black`}
      >
        UPLOADED DIAGRAMS
      </h2>
      {/* Files Display */}
      {selectedFolder && (
        <div className="space-y-4">
          <div className="flex items-center justify-between">
            <h3 className={`text-lg font-medium dark:text-white text-black`}>
              Files ({filteredAndSortedFiles.length})
            </h3>
            {loading && (
              <div className="text-sm text-gray-500">Loading files...</div>
            )}
          </div>

          {/* File Search */}
          <div className="relative max-w-md">
            <Search className="absolute left-3 top-1/2 transform -translate-y-1/2 h-4 w-4 text-gray-400" />
            <input
              type="text"
              placeholder="Search files..."
              value={fileSearchTerm}
              onChange={(e) => setFileSearchTerm(e.target.value)}
              className={`w-full pl-10 pr-10 py-2 rounded border text-sm dark:border-gray-600 dark:bg-gray-700 dark:text-white dark:placeholder-gray-400 border-gray-300 bg-white text-black placeholder-gray-500 focus:outline-none focus:ring-2 focus:ring-blue-500`}
            />
            {fileSearchTerm && (
              <button
                onClick={clearFileSearch}
                className="absolute right-3 top-1/2 transform -translate-y-1/2 text-gray-400 hover:text-gray-600 transition-colors"
                title="Clear search"
              >
                <X className="h-4 w-4" />
              </button>
            )}
          </div>

          {loading ? (
            <div className="flex justify-center py-8">
              <div className="animate-spin rounded-full h-8 w-8 border-b-2 border-blue-500"></div>
            </div>
          ) : filteredAndSortedFiles.length > 0 ? (
            viewMode === "grid" ? (
              <div className="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 xl:grid-cols-4 gap-4">
                {filteredAndSortedFiles.map((file) => (
                  <div
                    key={file.id}
                    className={`group relative overflow-hidden rounded-lg border p-3 transition-all hover:shadow-lg dark:border-gray-600 dark:bg-gray-700 dark:hover:bg-gray-600 border-gray-200 bg-white hover:bg-gray-50`}
                  >
                    {/* File Preview */}
                    <div className="aspect-square mb-3 overflow-hidden rounded">
                      {file.file_type.includes("image") ? (
                        <img
                          src={file.file_url}
                          alt={file.file_name}
                          className="h-full w-full object-cover transition-transform group-hover:scale-105"
                        />
                      ) : (
                        <div className={`flex h-full w-full items-center justify-center dark:bg-gray-600 bg-gray-100`}>
                          <div className="text-center">
                            <div className="mb-2 text-3xl">{getFileIcon(file.file_type)}</div>
                            <p className="text-xs text-gray-500 uppercase">
                              {file.file_type.split("/")[1] || "FILE"}
                            </p>
                          </div>
                        </div>
                      )}
                    </div>

                    {/* File Info */}
                    <div className="space-y-1">
                      <p
                        className={`truncate text-sm font-medium dark:text-white text-black`}
                        title={file.file_name}
                      >
                        {file.file_name}
                      </p>
                      <p className="text-xs text-gray-500">
                        {formatDate(file.uploaded_at)}
                      </p>
                    </div>

                    {/* Action buttons */}
                    <div className="absolute top-2 right-2 flex gap-1 opacity-0 transition-opacity group-hover:opacity-100">
                      <button
                        onClick={() => handleView(file)}
                        title="View"
                        className="bg-opacity-80 hover:bg-opacity-100 rounded bg-black p-1.5 text-white transition-all"
                      >
                        <Eye className="h-3 w-3" />
                      </button>
                      <a
                        href={getDownloadUrl(file)}
                        download={file.file_name}
                        title="Download"
                        className="bg-opacity-80 hover:bg-opacity-100 rounded bg-black p-1.5 text-white transition-all"
                      >
                        <Download className="h-3 w-3" />
                      </a>
                      <button
                        onClick={() => handleDelete(file)}
                        disabled={deletingFile === file.id}
                        title="Delete"
                        className="bg-opacity-80 hover:bg-opacity-100 rounded bg-red-600 p-1.5 text-white transition-all disabled:opacity-50"
                      >
                        {deletingFile === file.id ? (
                          <div className="h-3 w-3 animate-spin rounded-full border border-white border-t-transparent"></div>
                        ) : (
                          <Trash2 className="h-3 w-3" />
                        )}
                      </button>
                    </div>
                  </div>
                ))}
              </div>
            ) : (
              <div className="overflow-hidden rounded-lg border">
                <div className={`dark:bg-gray-700 bg-gray-50 px-4 py-2 border-b`}>
                  <div className="grid grid-cols-12 gap-4 text-xs font-medium uppercase tracking-wide text-gray-500">
                    <div className="col-span-5">Name</div>
                    <div className="col-span-2">Type</div>
                    <div className="col-span-2">Date</div>
                    <div className="col-span-1">Actions</div>
                  </div>
                </div>
                <div className={`divide-y dark:divide-gray-600 divide-gray-200`}>
                  {filteredAndSortedFiles.map((file) => (
                    <div
                      key={file.id}
                      className={`group px-4 py-3 transition-colors hover:bg-gray-50`}
                    >
                      <div className="grid grid-cols-12 gap-4 items-center">
                        <div className="col-span-5 flex items-center gap-3">
                          <span className="text-lg">{getFileIcon(file.file_type)}</span>
                          <span
                            className={`truncate text-sm dark:text-white text-black`}
                            title={file.file_name}
                          >
                            {file.file_name}
                          </span>
                        </div>
                        <div className="col-span-2 text-xs text-gray-500 uppercase">
                          {file.file_type.split("/")[1] || "Unknown"}
                        </div>
                        <div className="col-span-2 text-xs text-gray-500">
                          {formatDate(file.uploaded_at)}
                        </div>
                        <div className="col-span-1 flex gap-1">
                          <button
                            onClick={() => handleView(file)}
                            title="View"
                            className={`p-1 text-gray-400 hover:text-blue-500 transition-colors`}
                          >
                            <Eye className="h-4 w-4" />
                          </button>
                          <a
                            href={getDownloadUrl(file)}
                            download={file.file_name}
                            title="Download"
                            className={`p-1 text-gray-400 hover:text-green-500 transition-colors`}
                          >
                            <Download className="h-4 w-4" />
                          </a>
                          <button
                            onClick={() => handleDelete(file)}
                            disabled={deletingFile === file.id}
                            title="Delete"
                            className={`p-1 text-gray-400 hover:text-red-500 transition-colors disabled:opacity-50`}
                          >
                            {deletingFile === file.id ? (
                              <div className="h-4 w-4 animate-spin rounded-full border border-gray-400 border-t-transparent"></div>
                            ) : (
                              <Trash2 className="h-4 w-4" />
                            )}
                          </button>
                        </div>
                      </div>
                    </div>
                  ))}
                </div>
              </div>
            )
          ) : (
            <div className={`text-center py-12 dark:text-gray-400 text-gray-500`}>
              <div className="text-4xl mb-4"></div>
              <p className="text-lg font-medium">No files found</p>
              <p className="text-sm">
                {fileSearchTerm || fileTypeFilter !== "all"
                  ? "Try adjusting your search or filter criteria."
                  : "Upload some files to get started."}
              </p>
            </div>
          )}
        </div>
      )}
      {/* Search and Filter Controls */}
      <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-4">
        {/* Folder Search */}
        <div className="relative">
          <Search className="absolute left-3 top-1/2 transform -translate-y-1/2 h-4 w-4 text-gray-400" />
          <input
            type="text"
            placeholder="Search folders..."
            value={folderSearchTerm}
            onChange={(e) => setFolderSearchTerm(e.target.value)}
            className={`w-full pl-10 pr-10 py-2 rounded border text-sm dark:border-gray-600 dark:bg-gray-700 dark:text-white dark:placeholder-gray-400 border-gray-300 bg-white text-black placeholder-gray-500 focus:outline-none focus:ring-2 focus:ring-blue-500`}
          />
          {folderSearchTerm && (
            <button
              onClick={clearFolderSearch}
              className="absolute right-3 top-1/2 transform -translate-y-1/2 text-gray-400 hover:text-gray-600 transition-colors"
              title="Clear search"
            >
              <X className="h-4 w-4" />
            </button>
          )}
        </div>

        {/* View Mode Toggle */}
        <div className="flex rounded border overflow-hidden">
          <button
            onClick={(e) => { e.stopPropagation(); setViewMode("grid"); }}
            className={`flex-1 px-3 py-2 text-sm transition-colors ${
              viewMode === "grid"
                ? "dark:bg-blue-700 dark:text-white bg-blue-600 text-white"
                : "dark:bg-gray-700 dark:text-gray-300 dark:hover:bg-gray-600 bg-gray-100 text-gray-700 hover:bg-gray-200"
            }`}
          >
            <Grid className="h-4 w-4 mx-auto" />
          </button>
          <button
            onClick={(e) => { e.stopPropagation(); setViewMode("list"); }}
            className={`flex-1 px-3 py-2 text-sm transition-colors ${
              viewMode === "list"
                ? "dark:bg-blue-700 dark:text-white bg-blue-600 text-white"
                : "dark:bg-gray-700 dark:text-gray-300 dark:hover:bg-gray-600 bg-gray-100 text-gray-700 hover:bg-gray-200"
            }`}
          >
            <List className="h-4 w-4 mx-auto" />
          </button>
        </div>
      </div>

      {/* File Type Filter */}
      {files.length > 0 && (
        <div className="flex gap-2 flex-wrap">
          <button
            onClick={() => setFileTypeFilter("all")}
            className={`px-3 py-1 rounded text-sm transition-colors ${
              fileTypeFilter === "all"
                ? "dark:bg-blue-700 dark:text-white bg-blue-600 text-white"
                : "dark:bg-gray-700 dark:text-gray-300 dark:hover:bg-gray-600 bg-gray-200 text-gray-700 hover:bg-gray-300"
            }`}
          >
            All Files ({files.length})
          </button>
          {getFileTypeOptions().map((option) => {
            const count = files.filter(file => file.file_type.startsWith(option.value)).length;
            // console.log(`File type: ${option.value}, Count: ${count}`, "label:", option.label);
            
            return (
              <button
                key={option.value}
                onClick={() => setFileTypeFilter(option.value)}
                className={`px-3 py-1 rounded text-sm transition-colors ${
                  fileTypeFilter === option.value
                    ? "dark:bg-blue-700 dark:text-white bg-blue-600 text-white"
                    : "dark:bg-gray-700 dark:text-gray-300 dark:hover:bg-gray-600 bg-gray-200 text-gray-700 hover:bg-gray-300"
                }`}
              >
                {option.label === "Application" ? "Pdf" : option.label} ({count})
              </button>
            );
          })}
        </div>
      )}

      {/* Folder Selection */}
      <div className="space-y-4">
        <h3 className={`text-lg font-medium dark:text-white text-black`}>
          Select Folder to View Files
        </h3>
        
        {filteredFolders.length > 0 ? (
          <div className="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 xl:grid-cols-4 2xl:grid-cols-5 gap-3">
            {filteredFolders.map((folder) => (
              <div key={folder.id} className="group relative">
                <button
                  className={`w-full p-4 rounded border text-left transition-all hover:shadow-md ${
                    selectedFolder === folder.id
                      ? "dark:border-blue-500 dark:bg-blue-900 shadow-lg"
                      : "dark:border-gray-600 dark:bg-gray-700 dark:hover:bg-gray-600 border-gray-200 bg-white hover:bg-gray-50"
                  } dark:text-white text-black`}
                  onClick={() => setSelectedFolder(folder.id)}
                  title={folder.name} // Show full name on hover
                >
                  <div className="flex items-center justify-between min-w-0">
                    <div className="flex items-center gap-2 min-w-0 flex-1">
                      <span className="text-lg flex-shrink-0"></span>
                      <span className="font-medium text-sm leading-tight break-words line-clamp-2 min-w-0">
                        {folder.name}
                      </span>
                    </div>
                    {selectedFolder === folder.id && (
                      <span className="text-xs bg-blue-500 text-white px-2 py-1 rounded flex-shrink-0 ml-2">
                        Selected
                      </span>
                    )}
                  </div>
                </button>
                
                {/* Tooltip for long folder names */}
                {folder.name.length > 25 && (
                  <div className="absolute bottom-full left-1/2 transform -translate-x-1/2 mb-2 px-3 py-2 bg-black text-white text-sm rounded opacity-0 group-hover:opacity-100 transition-opacity duration-200 pointer-events-none z-10 max-w-xs text-center">
                    {folder.name}
                    <div className="absolute top-full left-1/2 transform -translate-x-1/2 w-0 h-0 border-l-4 border-r-4 border-t-4 border-transparent border-t-black"></div>
                  </div>
                )}
              </div>
            ))}
          </div>
        ) : (
          <div className={`text-center py-8 dark:text-gray-400 text-gray-500`}>
            {folderSearchTerm ? "No folders found matching your search." : "No folders available."}
          </div>
        )}
      </div>


    </div>
  );
}
```

<!-- path: components/diagrams/types/storage.ts -->
```typescript
export interface StoredFile {
  name: string;
  size: number;
  type: string;
  url: string;
  path?: string;
  uploadedAt: string;
}

export interface UploadProgress {
  [key: number]: number;
}

export interface StorageManagerProps {
  bucketName?: string;
  maxFileSize?: number;
  allowedFileTypes?: string[];
  onUploadComplete?: (files: StoredFile[]) => void;
  onError?: (error: string) => void;
}

export interface SupabaseStorageError {
  error: string;
  message: string;
  statusCode?: string;
}


```

<!-- path: components/diagrams/uploader-components/ErrorDisplay.tsx -->
```typescript
// components/diagrams/uploader-components/ErrorDisplay.tsx
import React, { useEffect } from "react";
import { toast } from "sonner";

interface ErrorDisplayProps {
  error: string | null;
  cameraError: string | null;
}

const ErrorDisplay: React.FC<ErrorDisplayProps> = ({
  error,
  cameraError,
}) => {
  useEffect(() => {
    if (error) {
      toast.error(error, {
        position: "top-right",
        duration: 5000,
      });
    }
  }, [error]);

  useEffect(() => {
    if (cameraError) {
      toast.warning(`Camera Error: ${cameraError}`, {
        position: "top-right",
        duration: 5000,
      });
    }
  }, [cameraError]);

  return null; // Toasts are handled globally
};

export default ErrorDisplay;

```

<!-- path: components/diagrams/uploader-components/AdvancedUpload.tsx -->
```typescript


"use client";

import React, { useRef } from "react";
import { Dashboard } from "@uppy/react";
import { Camera, CameraOff, Camera as CameraIcon, SwitchCamera } from "lucide-react";
import Uppy from "@uppy/core";

interface AdvancedUploadProps {
  uppyRef: React.RefObject<Uppy | null>;
  isCameraActive: boolean;
  toggleCameraActive: () => void;
  facingMode: "user" | "environment";
  toggleCamera: () => void;
}

const AdvancedUpload: React.FC<AdvancedUploadProps> = ({
  uppyRef,
  isCameraActive,
  toggleCameraActive,
  facingMode,
  toggleCamera,
}) => {
  const fileInputRef = useRef<HTMLInputElement | null>(null);

  const handleFileChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    if (e.target.files && e.target.files[0] && uppyRef.current) {
      const file = e.target.files[0];
      uppyRef.current.addFile({
        name: file.name,
        type: file.type,
        data: file,
        source: "Camera",
      });
    }
  };

  const openNativeCamera = () => {
    fileInputRef.current?.click();
  };

  return (
    <div className={`uppy-dashboard-container rounded-lg dark:uppy-dark uppy-light`}>
      {/* Native camera file input (hidden) */}
      <input
        ref={fileInputRef}
        type="file"
        accept="image/*"
        capture={facingMode}
        onChange={handleFileChange}
        className="hidden"
      />

      {/* Action Buttons */}
      <div className="mb-2 flex flex-wrap gap-2 justify-between items-center">
        <div className="flex gap-2">
          {/* <button
            onClick={toggleCameraActive}
            className={`flex items-center gap-2 rounded px-3 py-1 text-sm ${
              isNightMode
                ? "bg-gray-600 text-white hover:bg-gray-500"
                : "bg-gray-200 text-black hover:bg-gray-300"
            }`}
          >
            {isCameraActive ? (
              <>
                <CameraOff size={16} /> Stop Camera
              </>
            ) : (
              <>
                <Camera size={16} /> Start Camera
              </>
            )}
          </button> */}

          <button
            onClick={toggleCamera}
            className={`flex items-center gap-2 rounded px-3 py-1 text-sm dark:bg-gray-600 dark:text-white dark:hover:bg-gray-500 bg-gray-200 text-black hover:bg-gray-300`}
          >
            <SwitchCamera size={16} />
            Switch ({facingMode === "user" ? "Front" : "Back"})
          </button>
        </div>

        <button
          onClick={openNativeCamera}
          className="flex items-center gap-2 rounded px-3 py-1 text-sm bg-blue-600 text-white hover:bg-blue-700"
        >
          <CameraIcon size={16} /> Open Camera
        </button>
      </div>

      {/* Uppy Dashboard */}
      {uppyRef.current && (
        <div className="relative overflow-hidden rounded-lg">
          <Dashboard
            uppy={uppyRef.current}
            plugins={isCameraActive ? ["Webcam"] : []}
            height={400}
            width="100%"
            hideProgressDetails={true}
            showSelectedFiles={true}
            showRemoveButtonAfterComplete={true}
            disableStatusBar={false}
            disableInformer={false}
            disableThumbnailGenerator={false}
            proudlyDisplayPoweredByUppy={false}
            note="Select files to upload or drag and drop them here"
            locale={{
              strings: {
                uploading: "Uploading...",
                complete: "Complete",
                uploadFailed: "Upload failed",
                paused: "Paused",
                retry: "Retry",
                cancel: "Cancel",
                pause: "Pause",
                resume: "Resume",
                done: "Done",
                filesUploadedOfTotal: {
                  0: "%{complete} of %{smart_count} file uploaded",
                  1: "%{complete} of %{smart_count} files uploaded",
                },
                dataUploadedOfTotal: "%{complete} of %{total}",
                dataUploadedOfUnknown: "%{complete} uploaded",
                xTimeLeft: "%{time} left",
                uploadXFiles: {
                  0: "Upload %{smart_count} file",
                  1: "Upload %{smart_count} files",
                },
                uploadXNewFiles: {
                  0: "Upload %{smart_count} new file",
                  1: "Upload %{smart_count} new files",
                },
                upload: "Upload",
                retryUpload: "Retry upload",
                xMoreFilesAdded: {
                  0: "%{numFiles} more file added",
                  1: "%{numFiles} more files added",
                },
                showErrorDetails: "Show error details",
              },
            }}
          />
        </div>
      )}
    </div>
  );
};

export default AdvancedUpload;

```

<!-- path: components/diagrams/uploader-components/SimpleUpload.tsx -->
```typescript
// components/diagrams/uploader-components/SimpleUpload.tsx
import React from "react";
import { Loader2 } from "lucide-react";

interface SimpleUploadProps {
  uppyRef: React.RefObject<any>;
  fileInputRef: React.RefObject<HTMLInputElement | null>;
  handleFileInputChange: (event: React.ChangeEvent<HTMLInputElement>) => void;
  triggerFileInput: () => void;
  selectedFiles: any[];
  handleRemoveFile: (fileId: string) => void;
  isUploading: boolean;
  handleStartUpload: () => void;
//   FileItemComponent?: ({ file }: { file: any }) => React.JSX.Element;
}

const formatFileSize = (bytes: number) => {
  if (bytes === 0) return "0 Bytes";
  const k = 1024;
  const sizes = ["Bytes", "KB", "MB", "GB"];
  const i = Math.floor(Math.log(bytes) / Math.log(k));
  return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + " " + sizes[i];
};

const SimpleUpload: React.FC<SimpleUploadProps> = ({
  uppyRef,
  fileInputRef,
  handleFileInputChange,
  triggerFileInput,
  selectedFiles,
  handleRemoveFile,
  isUploading,
  handleStartUpload,
}) => {
  return (
    <div className="space-y-4">
      <div
        id="uppy-drag-drop"
        onClick={triggerFileInput}
        className={`cursor-pointer rounded-lg border-2 border-dashed p-8 text-center transition-colors dark:border-gray-600 dark:bg-gray-750 dark:hover:border-gray-500`}
      >
        <input
          ref={fileInputRef}
          type="file"
          multiple
          accept="image/*,application/pdf,.doc,.docx,.txt,.rtf,video/*,audio/*"
          onChange={handleFileInputChange}
          className="hidden"
        />
        <div>
          <p className="text-lg font-medium">Drag files here or click to browse</p>
          <p className="mt-2 text-sm opacity-70">
            Supports images, PDFs, documents, audio, and video files
          </p>
        </div>
      </div>

      <div id="uppy-progress" className="w-full"></div>

      {selectedFiles.length > 0 && (
        <div
          className={`rounded-lg border p-4 dark:border-gray-600 dark:bg-gray-700`}
        >
          <h4
            className={`mb-3 text-sm font-medium dark:text-gray-200 text-gray-700`}
          >
            Selected Files ({selectedFiles.length})
          </h4>
          <div className="max-h-40 space-y-2 overflow-y-auto">
            {selectedFiles.map((file) => (
              <div
                key={file.id}
                className={`flex items-center justify-between rounded p-2 dark:hover:bg-gray-600 dark:bg-gray-650 border dark:border-gray-500`}
              >
                <div className="flex min-w-0 flex-1 items-center space-x-3">
                  <div className="flex-shrink-0">
                    {file.type?.startsWith("image/") ? (
                      <div className="flex h-8 w-8 items-center justify-center rounded bg-green-100">
                        <span className="text-xs text-green-600"></span>
                      </div>
                    ) : file.type?.includes("pdf") ? (
                      <div className="flex h-8 w-8 items-center justify-center rounded bg-red-100">
                        <span className="text-xs text-red-600"></span>
                      </div>
                    ) : file.type?.startsWith("video/") ? (
                      <div className="flex h-8 w-8 items-center justify-center rounded bg-blue-100">
                        <span className="text-xs text-blue-600"></span>
                      </div>
                    ) : file.type?.startsWith("audio/") ? (
                      <div className="flex h-8 w-8 items-center justify-center rounded bg-purple-100">
                        <span className="text-xs text-purple-600"></span>
                      </div>
                    ) : (
                      <div className="flex h-8 w-8 items-center justify-center rounded bg-gray-100">
                        <span className="text-xs text-gray-600"></span>
                      </div>
                    )}
                  </div>
                  <div className="min-w-0 flex-1">
                    <p
                      className={`truncate text-sm font-medium dark:text-white text-gray-900`}
                    >
                      {file.name}
                    </p>
                    <p
                      className={`text-xs dark:text-gray-400 text-gray-500`}
                    >
                      {formatFileSize(file.size)}
                    </p>
                  </div>
                </div>
                <button
                  onClick={() => handleRemoveFile(file.id)}
                  className={`ml-2 flex-shrink-0 rounded-full p-1 transition-colors dark:text-gray-400 dark:hover:bg-red-500 dark:hover:text-red-400 text-gray-500 hover:bg-red-500 hover:text-red`}
                  title="Remove file"
                >
                  <svg
                    className="h-4 w-4"
                    fill="none"
                    stroke="currentColor"
                    viewBox="0 0 24 24"
                  >
                    <path
                      strokeLinecap="round"
                      strokeLinejoin="round"
                      strokeWidth={2}
                      d="M6 18L18 6M6 6l12 12"
                    />
                  </svg>
                </button>
              </div>
            ))}
          </div>
        </div>
      )}

      <button
        onClick={handleStartUpload}
        disabled={selectedFiles.length === 0 || isUploading}
        className={`flex w-full items-center justify-center gap-2 rounded px-4 py-2 transition-colors disabled:cursor-not-allowed disabled:opacity-50 dark:bg-blue-700 dark:hover:bg-blue-800 dark:disabled:bg-gray-600 bg-blue-600 hover:bg-blue-700 disabled:bg-gray-400 text-white`}
      >
        {isUploading && <Loader2 className="h-4 w-4 animate-spin" />}
        {isUploading
          ? "Uploading..."
          : selectedFiles.length > 0
            ? `Upload ${selectedFiles.length} File${selectedFiles.length > 1 ? "s" : ""}`
            : "Start Upload"}
      </button>
    </div>
  );
};

export default SimpleUpload;
```

<!-- path: components/diagrams/uploader-components/UploadModeToggle.tsx -->
```typescript
// components/diagrams/uploader-components/UploadModeToggle.tsx
import React from "react";

interface UploadModeToggleProps {
  showDashboard: boolean;
  setShowDashboard: (value: boolean) => void;
  folderId: string | null;
}

const UploadModeToggle: React.FC<UploadModeToggleProps> = ({
  showDashboard,
  setShowDashboard,
  folderId,
}) => {
  return (
    <div className="flex gap-2">
      <button
        onClick={() => setShowDashboard(true)}
        disabled={!folderId}
        className={`flex-1 rounded px-4 py-2 font-medium transition-colors ${
          showDashboard
            ? "dark:bg-blue-700 bg-blue-600"
            : "dark:bg-gray-600 dark:hover:bg-gray-500 bg-gray-400 hover:bg-gray-500"
        } text-white disabled:cursor-not-allowed disabled:opacity-50`}
      >
        Advanced Upload
      </button>
      <button
        onClick={() => setShowDashboard(false)}
        className={`flex-1 rounded px-4 py-2 font-medium transition-colors ${
          !showDashboard
            ? "dark:bg-blue-700 bg-blue-600"
            : "dark:bg-gray-600 dark:hover:bg-gray-500 bg-gray-400 hover:bg-gray-500"
        } text-white`}
      >
        Simple Upload
      </button>
    </div>
  );
};

export default UploadModeToggle;
```

<!-- path: components/diagrams/uploader-components/FolderManagement.tsx -->
```typescript
// components/diagrams/uploader-components/FolderManagement.tsx
import React from "react";

interface FolderManagementProps {
  newFolderName: string;
  setNewFolderName: (value: string) => void;
  handleCreateFolder: () => void;
  folders: any[];
  folderId: string | null;
  setFolderId: (value: string | null) => void;
}

const FolderManagement: React.FC<FolderManagementProps> = ({
  newFolderName,
  setNewFolderName,
  handleCreateFolder,
  folders,
  folderId,
  setFolderId,
}) => {
  // Sort folders alphabetically by name
  const sortedFolders = [...folders].sort((a, b) => 
    a.name.localeCompare(b.name, undefined, { sensitivity: 'base' })
  );

  return (
    <>
      <div className="flex gap-2">
        <input
          type="text"
          placeholder="New folder name"
          value={newFolderName}
          onChange={(e) => setNewFolderName(e.target.value)}
          className={`flex-1 rounded border px-3 py-2 dark:border-gray-600 dark:bg-gray-700 dark:text-white dark:placeholder-gray-400`}
          onKeyPress={(e) => e.key === "Enter" && handleCreateFolder()}
        />
        <button
          onClick={handleCreateFolder}
          disabled={!newFolderName.trim()}
          className={`rounded px-4 py-2 font-medium transition-colors dark:bg-green-700 dark:hover:bg-green-600 dark:disabled:bg-gray-600 bg-green-600 hover:bg-green-500 disabled:bg-gray-400 text-white disabled:cursor-not-allowed`}
        >
          Create
        </button>
      </div>

      <div>
        <label
          className={`mb-2 block text-sm font-medium dark:text-gray-200 text-gray-700`}
        >
          Select Destination Folder
        </label>
        <select
          className={`w-full rounded border px-3 py-2 dark:border-gray-600 dark:bg-gray-700 dark:text-white`}
          value={folderId || ""}
          onChange={(e) => setFolderId(e.target.value || null)}
        >
          <option value="">Select Folder</option>
          {sortedFolders.map((folder) => (
            <option key={folder.id} value={folder.id}>
              {folder.name}
            </option>
          ))}
        </select>
      </div>
    </>
  );
};

export default FolderManagement;
```

<!-- path: components/diagrams/uploader-components/RecentlyUploaded.tsx -->
```typescript
// components/diagrams/uploader-components/RecentlyUploaded.tsx
import React from "react";
import Image from "next/image";
import { Eye, Download } from "lucide-react";

interface RecentlyUploadedProps {
  uploadedFiles: any[];
}

const RecentlyUploaded: React.FC<RecentlyUploadedProps> = ({
  uploadedFiles,
}) => {
  return (
    <div className="space-y-4">
      <h3
        className={`text-lg font-semibold dark:text-white text-black`}
      >
        Recently Uploaded
      </h3>
      <div className="grid grid-cols-2 gap-4 md:grid-cols-4">
        {uploadedFiles.slice(-4).map((file, index) => (
          <div
            key={index}
            className={`group relative overflow-hidden rounded border p-2 dark:border-gray-600 dark:bg-gray-700 dark:text-white`}
          >
            {file.secure_url &&
            file.secure_url.match(/\.(jpg|jpeg|png|gif|webp|bmp|svg)$/i) ? (
              <Image
                src={file.secure_url}
                alt="Uploaded file"
                className="h-24 w-full rounded object-cover"
                width={300}
                height={96}
                style={{ objectFit: "cover" }}
              />
            ) : (
              <div className="flex h-24 w-full items-center justify-center rounded bg-gray-100">
                <div className="text-center">
                  <div className="mb-1 text-xl"></div>
                  <p className="text-xs text-gray-600">
                    {file.format?.toUpperCase() || "FILE"}
                  </p>
                </div>
              </div>
            )}

            <div className="absolute top-2 right-2 flex gap-1 opacity-0 transition-opacity group-hover:opacity-100">
              <button
                onClick={() => window.open(file.secure_url, "_blank")}
                title="View"
                className="bg-opacity-60 hover:bg-opacity-80 rounded bg-black p-1 text-white transition-all"
              >
                <Eye className="h-3 w-3" />
              </button>
              <a
                href={file.secure_url}
                download
                title="Download"
                className="bg-opacity-60 hover:bg-opacity-80 rounded bg-black p-1 text-white transition-all"
              >
                <Download className="h-3 w-3" />
              </a>
            </div>
          </div>
        ))}
      </div>
    </div>
  );
};

export default RecentlyUploaded;
```

<!-- path: components/categories/EmptyState.tsx -->
```typescript
import { FiPlus } from "react-icons/fi";
import { Button } from "@/components/common/ui/Button";
import { Card } from "@/components/common/ui/card";

interface EmptyStateProps {
  onCreate: () => void;
}

export function EmptyState({ onCreate }: EmptyStateProps) {
  return (
    <Card className="p-8 text-center dark:border-gray-700 dark:bg-gray-800">
      <p className="mb-4 text-gray-500 dark:text-gray-400">
        No unique categories found.
      </p>
      <Button onClick={onCreate}>
        <FiPlus className="mr-2 h-4 w-4" />
        Create First Category
      </Button>
    </Card>
  );
}
```

<!-- path: components/categories/CategorySearch.tsx -->
```typescript
import { FiSearch } from "react-icons/fi";
import { Input } from "@/components/common/ui/Input";

interface CategorySearchProps {
  searchTerm: string;
  onSearchChange: (value: string) => void;
}

export function CategorySearch({
  searchTerm,
  onSearchChange,
}: CategorySearchProps) {
  return (
    <div className="max-w-md">
      <label className="mb-2 block text-sm font-medium text-gray-700 dark:text-gray-300">
        Search Categories
      </label>
      <div className="relative">
        <FiSearch className="absolute top-1/2 left-3 h-4 w-4 -translate-y-1/2 transform text-gray-400" />
        <Input
          type="text"
          placeholder="Search unique categories..."
          value={searchTerm}
          onChange={(e) => onSearchChange(e.target.value)}
          className="pl-10 dark:bg-gray-800 dark:border-gray-700 dark:text-white dark:placeholder-gray-400"
        />
      </div>
    </div>
  );
}

```

<!-- path: components/categories/CategoriesTable.tsx -->
```typescript
import Link from "next/link";
import { FiEdit2, FiInfo } from "react-icons/fi";
import { Button } from "@/components/common/ui/Button";
import { Card } from "@/components/common/ui/card";
import { formatCategoryName } from "@/components/categories/utils";
import { Categories, CategoryInfo } from "./categories-types";
import { useIsSuperAdmin } from "@/hooks/useAdminUsers";

interface CategoriesTableProps {
  categories: Categories[];
  categoryLookupCounts: Record<string, CategoryInfo>;
  totalCategories: number;
  onEdit: (categoryName: string) => void;
  onDelete: (categoryName: string) => void;
  isDeleting: boolean;
  searchTerm?: string;
}

export function CategoriesTable({
  categories,
  categoryLookupCounts,
  totalCategories,
  onEdit,
  onDelete,
  isDeleting,
  searchTerm,
}: CategoriesTableProps) {

  const {data: isSuperAdmin} = useIsSuperAdmin();
  return (
    <Card className="overflow-hidden dark:border-gray-700 dark:bg-gray-800">
      <div className="border-b bg-gray-50 p-4 dark:border-gray-700 dark:bg-gray-700/50">
        <p className="text-sm text-gray-600 dark:text-gray-400">
          Showing {categories.length} of {totalCategories} unique categories
        </p>
      </div>

      {categories.length > 0 ? (
        <div className="overflow-x-auto">
          <table className="w-full">
            <thead className="bg-gray-50 dark:bg-gray-700/50">
              <tr>
                <th className="px-6 py-3 text-left text-xs font-medium tracking-wider text-gray-500 uppercase dark:text-gray-400">
                  Category Name
                </th>
                <th className="px-6 py-3 text-left text-xs font-medium tracking-wider text-gray-500 uppercase dark:text-gray-400">
                  Raw Value
                </th>
                <th className="px-6 py-3 text-left text-xs font-medium tracking-wider text-gray-500 uppercase dark:text-gray-400">
                  Lookup Types Count
                </th>
                <th className="px-6 py-3 text-left text-xs font-medium tracking-wider text-gray-500 uppercase dark:text-gray-400">
                  System Defaults
                </th>
                <th className="px-6 py-3 text-left text-xs font-medium tracking-wider text-gray-500 uppercase dark:text-gray-400">
                  Actions
                </th>
              </tr>
            </thead>
            <tbody className="divide-y divide-gray-200 bg-white dark:divide-gray-700 dark:bg-gray-800">
              {categories.map((category) => {
                const categoryInfo = categoryLookupCounts[category.category];
                return (
                  <tr
                    key={category.id}
                    className="hover:bg-gray-50 dark:hover:bg-gray-700/50"
                  >
                    <td className="px-6 py-4 text-sm font-medium whitespace-nowrap text-gray-900 dark:text-white">
                      {formatCategoryName(category)}
                    </td>
                    <td className="px-6 py-4 font-mono text-sm whitespace-nowrap text-gray-500 dark:text-gray-400">
                      {category.category}
                    </td>
                    <td className="px-6 py-4 text-sm whitespace-nowrap text-gray-500 dark:text-gray-400">
                      <Link
                        href={`/dashboard/lookup?category=${category.category}`}
                      >
                        <span className="inline-flex items-center gap-1 hover:text-blue-600 dark:hover:text-blue-400">
                          {categoryInfo?.lookupCount ?? 0}
                          {categoryInfo?.lookupCount > 0 && (
                            <FiInfo
                              className="h-3 w-3 text-blue-500 dark:text-blue-400"
                              title="Click to view lookup types"
                            />
                          )}
                        </span>
                      </Link>
                    </td>
                    <td className="px-6 py-4 whitespace-nowrap">
                      <span
                        className={`inline-flex rounded-full px-2 py-1 text-xs font-semibold ${
                          categoryInfo?.hasSystemDefaults
                            ? "bg-blue-100 text-blue-800 dark:bg-blue-900/50 dark:text-blue-300"
                            : "bg-gray-100 text-gray-800 dark:bg-gray-700 dark:text-gray-300"
                        }`}
                      >
                        {categoryInfo?.hasSystemDefaults ? "Yes" : "No"}
                      </span>
                    </td>
                    <td className="px-6 py-4 text-sm font-medium whitespace-nowrap">
                      <div className="flex items-center gap-2">
                        <Button
                          size="sm"
                          variant="outline"
                          onClick={() => onEdit(category.category)}
                          className="dark:border-gray-600 dark:hover:bg-gray-700"
                        >
                          <FiEdit2 className="h-4 w-4" />
                        </Button>
                        <Button
                          size="sm"
                          variant="outline"
                          onClick={() => onDelete(category.category)}
                          className="text-red-600 hover:text-red-800 dark:text-red-500 dark:hover:text-red-400 dark:border-gray-600 dark:hover:bg-gray-700"
                          disabled={!isSuperAdmin && (isDeleting || categoryInfo?.hasSystemDefaults)}
                          title={
                            isDeleting
                              ? "Deleting..."
                              : `Delete All "${category.category}" Categories`
                          }
                        >
                          {isDeleting
                            ? "Deleting..."
                            : `Delete All "${category.category}" Categories`}
                        </Button>
                      </div>
                    </td>
                  </tr>
                );
              })}
            </tbody>
          </table>
        </div>
      ) : (
        <div className="py-8 text-center text-gray-500 dark:text-gray-400">
          {searchTerm
            ? `No unique categories found matching "${searchTerm}".`
            : "No unique categories found."}
        </div>
      )}
    </Card>
  );
}
```

<!-- path: components/categories/CategoryModal.tsx -->
```typescript
"use client";

import { GroupedLookupsByCategory } from "@/components/categories/categories-types";
import { Button } from "@/components/common/ui/Button";
import { Input } from "@/components/common/ui/Input";
import { Modal } from "@/components/common/ui/Modal";
import { useTableInsert, useTableUpdate } from "@/hooks/database";
import { Lookup_typesInsertSchema, lookup_typesRowSchema, Lookup_typesRowSchema } from "@/schemas/zod-schemas";
import { snakeToTitleCase } from "@/utils/formatters";
import { createClient } from "@/utils/supabase/client";
import { zodResolver } from "@hookform/resolvers/zod";
import { PostgrestError } from "@supabase/supabase-js";
import { useCallback, useEffect, useRef } from "react";
import { useForm } from "react-hook-form";
import { toast } from "sonner";
import z from "zod";



interface CategoryModalProps {
  isOpen: boolean;
  onClose: () => void;
  onCategoryCreated?: (categoryData: Lookup_typesInsertSchema) => void;
  editingCategory?: string;
  categories?: Lookup_typesRowSchema[];
  lookupsByCategory?: GroupedLookupsByCategory;
}



export function CategoryModal({
  isOpen,
  onClose,
  onCategoryCreated,
  editingCategory,
  categories,
  lookupsByCategory,
}: CategoryModalProps) {

  const categoryFormSchema = lookup_typesRowSchema.pick({
  category: true,
  code: true,
  description: true,
  name: true,
  sort_order: true,
  is_system_default: true,
  status: true,
});
type CategoryForm = z.infer<typeof categoryFormSchema>;

  const {
    register,
    handleSubmit,
    formState: { errors, isSubmitting },
    reset,
    watch,
  } = useForm<CategoryForm>({
    resolver: zodResolver(categoryFormSchema),
    defaultValues: {
      category: "",
      code: "default",
      description: "",
      name: "DEFAULT",
      sort_order: 0,
      is_system_default: true,
      status: true,
    },
  });

  const supabase = createClient();
  const submissionInProgress = useRef(false);
  const abortControllerRef = useRef<AbortController | null>(null);

  const { mutate: createCategory } = useTableInsert(supabase, "lookup_types");
  const { mutate: updateCategory } = useTableUpdate(supabase, "lookup_types");

// Only reset when editingCategory changes or when opening for creation
useEffect(() => {
  if (isOpen) {
    if (editingCategory) {
      const categoryLookups = lookupsByCategory?.[editingCategory] || [];
      if (categoryLookups.length > 0) {
        const template = categoryLookups[0];
        reset({
          category: template.category,
          code: template.code || "default",
          description: template.description || "",
          name: template.name || "DEFAULT",
          sort_order: template.sort_order || 0,
          is_system_default: template.is_system_default ?? true,
          status: template.status ?? true,
        });
      }
    } else {
      // New category: reset to defaults
      reset({
        category: "",
        code: "default",
        description: "",
        name: "DEFAULT",
        sort_order: 0,
        is_system_default: true,
        status: true,
      });
    }
  }
  // Do not reset on close, only on open
}, [isOpen, editingCategory, lookupsByCategory, reset]);

  const handleUpdateError = useCallback((error: unknown) => {
    const postgrestError = error as PostgrestError;
    if (
      postgrestError?.message?.includes("already exists") ||
      postgrestError?.code === "23505" ||
      postgrestError?.message?.includes("violates unique constraint")
    ) {
      toast.error("Category already exists");
    } else {
      toast.error(`Failed to update category: ${postgrestError?.message || "Unknown error"}`);
    }
  }, []);

  const handleCreateError = useCallback((error: unknown) => {
    const postgrestError = error as PostgrestError;
    if (
      postgrestError?.message?.includes("already exists") ||
      postgrestError?.code === "23505" ||
      postgrestError?.message?.includes("violates unique constraint")
    ) {
      toast.error("Category already exists");
    } else {
      toast.error(`Failed to create category: ${postgrestError?.message || "Unknown error"}`);
    }
  }, []);

  const onValidSubmit = useCallback(
    async (data: CategoryForm) => {
      const id = categories?.find((cat) => cat.category === editingCategory)?.id;
      if (submissionInProgress.current) return;

      if (!data.category.trim()) {
        toast.error("Category is required");
        return;
      }

      submissionInProgress.current = true;
      abortControllerRef.current = new AbortController();

      try {
        const formattedCategory = data.category
          .trim()
          .toUpperCase()
          .replace(/\s+/g, "_")
          .replace(/[^A-Z0-9_]/g, "");

        if (!formattedCategory) {
          toast.error("Please enter a valid category name");
          return;
        }

        const commonData = {
          ...data,
          category: formattedCategory,
          description: `Default entry for ${snakeToTitleCase(formattedCategory)} category`,
        };

        if (editingCategory) {
          updateCategory(
            { id: id!, data: commonData },
            {
              onSuccess: () => {
                if (abortControllerRef.current?.signal.aborted) return;
                toast.success(`Category renamed to "${formattedCategory}"`);
                onCategoryCreated?.(commonData);
                onClose();
              },
              onError: handleUpdateError,
              onSettled: () => {
                submissionInProgress.current = false;
              },
            }
          );
        } else {
          if (categories?.some((cat) => cat.category === formattedCategory)) {
            toast.error("Category already exists");
            submissionInProgress.current = false;
            return;
          }
          createCategory(commonData, {
            onSuccess: () => {
              if (abortControllerRef.current?.signal.aborted) return;
              onCategoryCreated?.(commonData);
              onClose();
            },
            onError: handleCreateError,
            onSettled: () => {
              submissionInProgress.current = false;
            },
          });
        }
      } catch (error) {
        console.error("Error saving category:", error);
        toast.error(`Failed to ${editingCategory ? "update" : "create"} category`);
        submissionInProgress.current = false;
      }
    },
    [categories, editingCategory, createCategory, updateCategory, onCategoryCreated, onClose, handleUpdateError, handleCreateError]
  );

  const handleClose = useCallback(() => {
    if (!isSubmitting && !submissionInProgress.current) {
      onClose();
    }
  }, [isSubmitting, onClose]);

  const categoryValue = watch("category") || "";
  const formattedPreview = categoryValue
    .trim()
    .toUpperCase()
    .replace(/\s+/g, "_")
    .replace(/[^A-Z0-9_]/g, "");

  const isEditing = !!editingCategory;

  return (
    <Modal isOpen={isOpen} onClose={handleClose} title={isEditing ? "Edit Category" : "Create New Category"} visible={false}
      className="h-screen w-screen transparent bg-gray-700 rounded-2xl">
      <form onSubmit={handleSubmit(onValidSubmit)} className="space-y-4">
        <div className="grid grid-cols-1 gap-4 md:grid-cols-2">
          <div className="md:col-span-2">
            <label className="mb-2 block text-sm font-medium text-gray-700 dark:text-gray-300">
              Category {isEditing ? "Name" : ""} <span className="text-red-500">*</span>
            </label>
            <Input
              type="text"
              {...register("category")}
              placeholder="Enter category (e.g., Node Type, System Type)"
              required
              disabled={isSubmitting || submissionInProgress.current}
              className="dark:bg-gray-800 dark:border-gray-700 dark:text-white dark:placeholder-gray-400"
            />
            {formattedPreview && (
              <p className="mt-1 text-xs text-gray-500 dark:text-gray-400">
                Will be saved as:{" "}
                <code className="rounded bg-gray-100 px-1 py-0.5 dark:bg-gray-700 dark:text-gray-200">
                  {formattedPreview}
                </code>
              </p>
            )}
            {errors.category && (
              <p className="mt-1 text-xs text-red-500 dark:text-red-400">{errors.category.message}</p>
            )}
          </div>
        </div>

        <div
          className={`rounded-md border p-3 ${
            isEditing
              ? "border-yellow-200 bg-yellow-50 dark:border-yellow-800/50 dark:bg-yellow-900/20"
              : "border-blue-200 bg-blue-50 dark:border-blue-800/50 dark:bg-blue-900/20"
          }`}
        >
          <h4
            className={`mb-1 text-sm font-medium ${
              isEditing ? "text-yellow-900 dark:text-yellow-200" : "text-blue-900 dark:text-blue-200"
            }`}
          >
            {isEditing ? "Edit Category Notes:" : "Category Creation Notes:"}
          </h4>
          <ul
            className={`space-y-1 text-xs ${
              isEditing ? "text-yellow-800 dark:text-yellow-200/80" : "text-blue-800 dark:text-blue-200/80"
            }`}
          >
            {isEditing ? (
              <>
                <li> This will update the category name for ALL lookup types in this category</li>
                <li> Category name will be converted to uppercase with underscores</li>
                <li> Special characters will be removed except letters, numbers, and underscores</li>
              </>
            ) : (
              <>
                <li> Category field will be converted to uppercase with underscores</li>
                <li> Special characters will be removed except letters, numbers, and underscores</li>
                <li> Created and updated timestamps will be set automatically</li>
                <li> ID will be generated automatically</li>
              </>
            )}
          </ul>
        </div>

        <div className="flex justify-end gap-2 pt-4">
          <Button
            type="button"
            variant="outline"
            onClick={handleClose}
            disabled={isSubmitting || submissionInProgress.current}
            className="dark:border-gray-700 dark:hover:bg-gray-800"
          >
            Cancel
          </Button>
          <Button
            type="submit"
            disabled={isSubmitting || submissionInProgress.current || !categoryValue.trim()}
          >
            {isSubmitting || submissionInProgress.current
              ? isEditing
                ? "Updating..."
                : "Creating..."
              : isEditing
              ? "Update Category"
              : "Create Category"}
          </Button>
        </div>
      </form>
    </Modal>
  );
}

```

<!-- path: components/categories/categories-types.ts -->
```typescript
import { Database } from "@/types/supabase-types";

export type Categories = Database["public"]["Tables"]["lookup_types"]["Row"];
export type GroupedLookupsByCategory = Record<string, Categories[]>;

export interface CategoryInfo {
    name: string;
    lookupCount: number;
    hasSystemDefaults: boolean;
  }
```

<!-- path: components/categories/utils.ts -->
```typescript
import { Categories } from "@/components/categories/categories-types";

export function formatCategoryName(category: Categories): string {
  return category.category
    .split("_")
    .map((word) => word.charAt(0).toUpperCase() + word.slice(1))
    .join(" ");
}
```

<!-- path: components/categories/LoadingState.tsx -->
```typescript
import { LoadingSpinner } from "@/components/common/ui/LoadingSpinner";

export function LoadingState() {
  return (
    <div className="flex justify-center py-8">
      <LoadingSpinner />
      <span className="ml-2 dark:text-gray-400">Loading data...</span>
    </div>
  );
}
```

<!-- path: components/auth/terms.tsx -->
```typescript
import React from "react";

const Terms = () => {
  return (
    <div className='bg-gray-100 dark:bg-gray-900 min-h-screen'>
      <div className='container mx-auto px-4 py-8'>
        <h1 className='text-4xl font-bold text-center text-gray-800 dark:text-white mb-8'>Terms of Service</h1>
        <div className='bg-white dark:bg-gray-800 rounded-lg shadow-md p-8'>
          <p className='mb-4 text-gray-700 dark:text-gray-300'>Welcome to Harinavi Transmission Maintenance. These terms and conditions outline the rules and regulations for the use of our website.</p>
          <p className='mb-4 text-gray-700 dark:text-gray-300'>
            By accessing this website, we assume you accept these terms and conditions. Do not continue to use Harinavi Transmission Maintenance if you do not agree to all of the terms and conditions stated on this page.
          </p>

          <h2 className='text-2xl font-bold text-gray-800 dark:text-white mt-6 mb-4'>Intellectual Property Rights</h2>
          <p className='mb-4 text-gray-700 dark:text-gray-300'>
            Other than the content you own, under these Terms, Harinavi Transmission Maintenance and/or its licensors own all the intellectual property rights and materials contained in this Website.
          </p>

          <h2 className='text-2xl font-bold text-gray-800 dark:text-white mt-6 mb-4'>Restrictions</h2>
          <p className='mb-4 text-gray-700 dark:text-gray-300'>You are specifically restricted from all of the following:</p>
          <ul className='list-disc list-inside mb-4 text-gray-700 dark:text-gray-300'>
            <li>Publishing any Website material in any other media.</li>
            <li>Selling, sublicensing and/or otherwise commercializing any Website material.</li>
            <li>Publicly performing and/or showing any Website material.</li>
            <li>Using this Website in any way that is or may be damaging to this Website.</li>
          </ul>

          <h2 className='text-2xl font-bold text-gray-800 dark:text-white mt-6 mb-4'>No Warranties</h2>
          <p className='mb-4 text-gray-700 dark:text-gray-300'>
            This Website is provided "as is," with all faults, and Harinavi Transmission Maintenance expresses no representations or warranties, of any kind related to this Website or the materials contained on this Website.
          </p>

          <h2 className='text-2xl font-bold text-gray-800 dark:text-white mt-6 mb-4'>Limitation of Liability</h2>
          <p className='mb-4 text-gray-700 dark:text-gray-300'>
            In no event shall Harinavi Transmission Maintenance, nor any of its officers, directors and employees, be held liable for anything arising out of or in any way connected with your use of this Website.
          </p>

          <h2 className='text-2xl font-bold text-gray-800 dark:text-white mt-6 mb-4'>Contact Us</h2>
          <p className='text-gray-700 dark:text-gray-300'>If you have any questions about these Terms, please contact us at support@harinavi.com.</p>
        </div>
      </div>
    </div>
  );
};

export default Terms;

```

<!-- path: components/auth/ForgotPasswordForm.tsx -->
```typescript
// components/auth/ForgotPasswordForm.tsx
"use client";

import { useState } from "react";
import { motion } from "framer-motion";
import { toast } from "sonner";
import { FiMail, FiArrowLeft, FiLoader, FiCheck } from "react-icons/fi";
import Link from "next/link";
import { useAuth } from "@/hooks/useAuth";
import { isValidEmail } from "@/utils/validationUtils";
import { ButtonSpinner } from "../common/ui/LoadingSpinner";
import { useRouter } from "next/navigation";

export default function ForgotPasswordForm() {
  const [email, setEmail] = useState("");
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState("");
  const { forgotPassword } = useAuth();
  const router = useRouter();

  const validateEmail = isValidEmail(email);

  // Check if reset email was already sent
  const resetEmail = localStorage.getItem("reset_email_sent");
  const isResetEmailSent = () => {
    return !!resetEmail;
  };

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    setError("");

    if (!email) {
      setError("Email is required");
      return;
    }
    if (!validateEmail) {
      setError("Invalid email format");
      return;
    }

    setIsLoading(true);

    try {
      const response = await forgotPassword(email);

      if (response.error) {
        console.error("Password reset failed:", response.error);
        setError(response.error || "Failed to send reset email");
        toast.error(response.error || "Failed to send reset email");
      } else {
        localStorage.setItem("reset_email_sent", email);
        isResetEmailSent() ? toast.success("Password reset email sent again!") : toast.success("Password reset email sent!");
        setEmail("");
        setError("");
      }
    } catch (err) {
      const errorMessage = err instanceof Error ? err.message : "An error occurred";
      setError(errorMessage);
      toast.error(errorMessage);
    } finally {
      setIsLoading(false);
    }
  };

  const handleResendEmail = async () => {
    setIsLoading(true);
    setError("");
    try {
      const response = await forgotPassword(localStorage.getItem("reset_email_sent") || "");

      if (response.error) {
        setError(response.error || "Failed to resend email");
        toast.error(response.error || "Failed to resend email");
      } else {
        localStorage.setItem("reset_email_sent", localStorage.getItem("reset_email_sent") || "");
        toast.success("Reset email sent again!");
      }
    } catch (err) {
      const errorMessage = err instanceof Error ? err.message : "An error occurred";
      setError(errorMessage);
      toast.error(errorMessage);
    } finally {
      setIsLoading(false);
    }
  };

  const clearResetState = () => {
    localStorage.removeItem("reset_email_sent");
  };

  if (isResetEmailSent()) {
    return (
      <motion.div initial={{ opacity: 0, y: 20 }} animate={{ opacity: 1, y: 0 }} transition={{ duration: 0.5 }} className='w-full max-w-md mx-auto'>
        <div className='bg-white dark:bg-gray-800 rounded-lg shadow-lg p-8'>
          <div className='text-center'>
            <motion.div initial={{ scale: 0 }} animate={{ scale: 1 }} transition={{ delay: 0.2, type: "spring", stiffness: 200 }} className='w-16 h-16 bg-green-100 dark:bg-green-900/20 rounded-full flex items-center justify-center mx-auto mb-4'>
              <FiCheck className='w-8 h-8 text-green-600 dark:text-green-400' />
            </motion.div>

            <h2 className='text-2xl font-bold text-gray-900 dark:text-white mb-2'>Check Your Email</h2>

            <p className='text-gray-600 dark:text-gray-400 mb-6'>
              We&apos;ve sent a password reset link to your email address.
            </p>

            <div className='space-y-4'>
              <p className='text-sm text-gray-500 dark:text-gray-400'>Didn&apos;t receive the email? Check your spam folder or click below to resend.</p>

              <motion.button
                whileHover={{ scale: 1.02 }}
                whileTap={{ scale: 0.98 }}
                onClick={handleResendEmail}
                disabled={isLoading}
                className='w-full bg-gray-100 dark:bg-gray-700 hover:bg-gray-200 dark:hover:bg-gray-600 text-gray-700 dark:text-gray-300 font-medium py-3 px-4 rounded-lg transition-colors disabled:opacity-50 disabled:cursor-not-allowed'>
                {isLoading ? (
                  <div className='flex items-center justify-center'>
                    <FiLoader className='animate-spin mr-2' />
                    Resending...
                  </div>
                ) : (
                  "Resend Email"
                )}
              </motion.button>

              <motion.button
                whileHover={{ scale: 1.02 }}
                whileTap={{ scale: 0.98 }}
                onClick={()=>{setEmail(""); clearResetState(); router.push("/forgot-password")}}
                disabled={isLoading}
                className='w-full bg-gray-100 dark:bg-gray-700 hover:bg-gray-200 dark:hover:bg-gray-600 text-gray-700 dark:text-gray-300 font-medium py-3 px-4 rounded-lg transition-colors disabled:opacity-50 disabled:cursor-not-allowed'>
                {isLoading ? (
                  <div className='flex items-center justify-center'>
                    <FiLoader className='animate-spin mr-2' />
                    Clearing...
                  </div>
                ) : (
                  "Send Reset to anotherEmail"
                )}
              </motion.button>

              <Link 
                href='/login' 
                className='inline-flex items-center justify-center w-full text-blue-600 dark:text-blue-400 hover:text-blue-500 dark:hover:text-blue-300 font-medium transition-colors'
                onClick={clearResetState}
              >
                <FiArrowLeft className='mr-2' />
                Back to Login
              </Link>
            </div>
          </div>

          {error && (
            <motion.div initial={{ opacity: 0, scale: 0.95 }} animate={{ opacity: 1, scale: 1 }} className='mt-4 p-3 bg-red-50 dark:bg-red-900/20 border border-red-200 dark:border-red-800 rounded-md'>
              <p className='text-red-600 dark:text-red-400 text-sm'>{error}</p>
            </motion.div>
          )}
        </div>
      </motion.div>
    );
  }

  return (
    <motion.div initial={{ opacity: 0, y: 20 }} animate={{ opacity: 1, y: 0 }} transition={{ duration: 0.5 }} className='w-full max-w-md mx-auto'>
      <div className='bg-white dark:bg-gray-800 rounded-lg shadow-lg p-8'>
        <div className='text-center mb-8'>
          <h2 className='text-3xl font-bold text-gray-900 dark:text-white'>Forgot Password?</h2>
          <p className='text-gray-600 dark:text-gray-400 mt-2'>Enter your email address and we&apos;ll send you a link to reset your password.</p>
        </div>

        {error && (
          <motion.div initial={{ opacity: 0, scale: 0.95 }} animate={{ opacity: 1, scale: 1 }} className='mb-4 p-3 bg-red-50 dark:bg-red-900/20 border border-red-200 dark:border-red-800 rounded-md'>
            <p className='text-red-600 dark:text-red-400 text-sm'>{error}</p>
          </motion.div>
        )}

        <form onSubmit={handleSubmit} className='space-y-6'>
          <div>
            <label htmlFor='email' className='block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2'>
              Email Address
            </label>
            <div className='relative'>
              <FiMail className='absolute left-3 top-1/2 transform -translate-y-1/2 text-gray-400 dark:text-gray-500' />
              <input
                id='email'
                name='email'
                type='email'
                autoComplete='email'
                required
                value={email}
                onChange={(e) => setEmail(e.target.value)}
                className='w-full pl-10 pr-4 py-3 border border-gray-300 dark:border-gray-600 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-transparent transition-all bg-white dark:bg-gray-700 text-gray-900 dark:text-white placeholder-gray-500 dark:placeholder-gray-400'
                placeholder='Enter your email address'
              />
            </div>
          </div>

          <motion.button
            whileHover={{ scale: 1.02 }}
            whileTap={{ scale: 0.98 }}
            type='submit'
            disabled={isLoading}
            className='w-full bg-blue-600 hover:bg-blue-700 disabled:bg-blue-400 text-white font-medium py-3 px-4 rounded-lg transition-colors focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-offset-2 dark:focus:ring-offset-gray-800 disabled:cursor-not-allowed'>
            {isLoading ? (
              <ButtonSpinner />
            ) : (
              "Send Reset Email"
            )}
          </motion.button>
        </form>

        <div className='mt-8 text-center'>
          <Link 
            href='/login' 
            className='inline-flex items-center text-blue-600 dark:text-blue-400 hover:text-blue-500 dark:hover:text-blue-300 font-medium transition-colors'
            onClick={clearResetState}
          >
            <FiArrowLeft className='mr-2' />
            Back to Login
          </Link>
        </div>
      </div>
    </motion.div>
  );
}

```

<!-- path: components/auth/UnauthorizedModal.tsx -->
```typescript
// components/auth/UnauthorizedModal.tsx
"use client"

import { useState, useEffect } from "react";
import { useRouter } from "next/navigation";
import { UserRole } from "@/types/user-roles";

interface UnauthorizedModalProps {
  allowedRoles: UserRole[];
  currentRole?: string | null;
}

export const UnauthorizedModal: React.FC<UnauthorizedModalProps> = ({ 
  allowedRoles, 
  currentRole 
}) => {
  const [isOpen, setIsOpen] = useState(true);
  const router = useRouter();

  // Auto-close modal and redirect after 5 seconds
  useEffect(() => {
    const timer = setTimeout(() => {
      handleClose();
    }, 5000);

    return () => clearTimeout(timer);
  // eslint-disable-next-line react-hooks/exhaustive-deps
  }, []);

  const handleClose = () => {
    setIsOpen(false);
    // Redirect to dashboard or home page
    router.push("/dashboard");
  };

  const handleGoBack = () => {
    router.back();
    setIsOpen(false);
  };

  if (!isOpen) return null;

  const formatRole = (role: UserRole) => {
    return role.replace(/_/g, " ").replace(/\b\w/g, l => l.toUpperCase());
  };

  return (
    <div className="fixed inset-0 z-50 flex items-center justify-center">
      {/* Backdrop */}
      <div 
        className="absolute inset-0 bg-black bg-opacity-50 transition-opacity"
        onClick={handleClose}
      />
      
      {/* Modal */}
      <div className="relative bg-white rounded-lg shadow-xl max-w-md mx-4 p-6 z-10">
        {/* Icon */}
        <div className="flex items-center justify-center w-16 h-16 mx-auto mb-4 bg-red-100 rounded-full">
          <svg 
            className="w-8 h-8 text-red-600" 
            fill="none" 
            stroke="currentColor" 
            viewBox="0 0 24 24"
          >
            <path 
              strokeLinecap="round" 
              strokeLinejoin="round" 
              strokeWidth={2} 
              d="M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-2.5L13.732 4c-.77-.833-1.964-.833-2.732 0L4.082 15.5c-.77.833.192 2.5 1.732 2.5z" 
            />
          </svg>
        </div>

        {/* Title */}
        <h3 className="text-lg font-semibold text-gray-900 text-center mb-2">
          Access Denied
        </h3>

        {/* Message */}
        <div className="text-sm text-gray-600 text-center mb-6">
          <p className="mb-3">
            You don&apos;t have permission to access this page.
          </p>
          <div className="bg-gray-50 rounded-md p-3">
            <p className="font-medium text-gray-700 mb-1">Required roles:</p>
            <p className="text-gray-600">
              {allowedRoles.map(formatRole).join(", ")}
            </p>
            {currentRole && (
              <>
                <p className="font-medium text-gray-700 mt-2 mb-1">Your current role:</p>
                <p className="text-gray-600">{currentRole}</p>
              </>
            )}
          </div>
        </div>

        {/* Actions */}
        <div className="flex flex-col sm:flex-row gap-3">
          <button
            onClick={handleGoBack}
            className="flex-1 px-4 py-2 text-sm font-medium text-gray-700 bg-gray-100 border border-gray-300 rounded-md hover:bg-gray-200 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-gray-500 transition-colors"
          >
            Go Back
          </button>
          <button
            onClick={handleClose}
            className="flex-1 px-4 py-2 text-sm font-medium text-white bg-blue-600 border border-transparent rounded-md hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-blue-500 transition-colors"
          >
            Go to Dashboard
          </button>
        </div>

        {/* Auto-close notice */}
        <p className="text-xs text-gray-500 text-center mt-4">
          This modal will auto-close in 5 seconds
        </p>
      </div>
    </div>
  );
};
```

<!-- path: components/auth/OAuthProviders.tsx -->
```typescript
// components/auth/OAuthProviders.tsx
'use client';

import { OAuthButton } from '@/components/auth/OAuthButton';

interface OAuthProvidersProps {
  variant?: 'login' | 'signup';
  redirectTo?: string;
  providers?: string[];
  className?: string;
  showDivider?: boolean;
  dividerText?: string;
}

const defaultProviders: string[] = ['google'];

export default function OAuthProviders({
  variant = 'login',
  providers = defaultProviders,
  className = '',
  showDivider = true,
  dividerText,
}: OAuthProvidersProps) {
  const defaultDividerText = variant === 'signup' 
    ? 'Or sign up with email' 
    : 'Or continue with email';

  return (
    <div className={`space-y-4 ${className}`}>
      <div className="space-y-3">
        {providers.map((provider) => (
          <OAuthButton
            key={provider}
            provider={provider}
            variant={variant}
          />
        ))}
      </div>

      {showDivider && (
        <div className="relative">
          <div className="absolute inset-0 flex items-center">
            <div className="w-full border-t border-gray-300" />
          </div>
          <div className="relative flex justify-center text-sm">
            <span className="px-2 bg-white text-gray-500">
              {dividerText || defaultDividerText}
            </span>
          </div>
        </div>
      )}
    </div>
  );
}
```

<!-- path: components/auth/OAuthButton.tsx -->
```typescript
// components/auth/OAuthButton.tsx
"use client";

import { useState, useEffect, useCallback } from "react";
import { useAuth } from "@/hooks/useAuth";
import { FaGoogle } from "react-icons/fa";
import { LoadingSpinner } from "../common/ui/LoadingSpinner/LoadingSpinner";

// Debug helper
const debug = (...args: unknown[]) => {
  if (process.env.NODE_ENV === "development") {
    console.log("[OAuthButton]", ...args);
  }
};

interface OAuthButtonProps {
  provider: string;
  variant?: "login" | "signup";
  className?: string;
  disabled?: boolean;
}

const providerConfig = {
  google: {
    name: "Google",
    icon: FaGoogle,
    bgColor: "bg-white hover:bg-gray-50",
    textColor: "text-gray-800",
  },
} as const;

export function OAuthButton({
  provider,
  variant = "login",
  className = "",
  disabled = false,
}: OAuthButtonProps) {
  const { signInWithGoogle, authState } = useAuth();
  const [isLocalLoading, setIsLocalLoading] = useState(false);
  const [isOAuthInProgress, setIsOAuthInProgress] = useState(false);

  // Handle OAuth sign-in
  const handleGoogleSignIn = useCallback(async () => {
    debug("handleGoogleSignIn called");

    // Prevent multiple clicks during loading
    if (isLocalLoading || authState === "loading") {
      debug("Already loading, ignoring click");
      return;
    }

    try {
      debug("Setting loading state");
      setIsLocalLoading(true);
      setIsOAuthInProgress(true);
      sessionStorage.setItem("oauth_in_progress", "true");

      // Force a re-render to show loading state
      await new Promise((resolve) => setTimeout(resolve, 0));

      debug("Calling signInWithGoogle");
      await signInWithGoogle();
      debug("signInWithGoogle completed");
    } catch (error) {
      debug("OAuth error:", error);
      sessionStorage.removeItem("oauth_in_progress");
      setIsOAuthInProgress(false);
      throw error;
    } finally {
      debug("Cleaning up");
      setIsLocalLoading(false);
      sessionStorage.removeItem("oauth_in_progress");
    }
  }, [isLocalLoading, authState, signInWithGoogle]);

  // Check for OAuth in progress on mount
  useEffect(() => {
    const checkOAuthStatus = () => {
      const inProgress = sessionStorage.getItem("oauth_in_progress") === "true";
      setIsOAuthInProgress(inProgress);
    };

    // Check immediately
    checkOAuthStatus();

    // Set up storage event listener for cross-tab sync
    const handleStorageChange = (e: StorageEvent) => {
      if (e.key === "oauth_in_progress") {
        checkOAuthStatus();
      }
    };

    window.addEventListener("storage", handleStorageChange);
    return () => window.removeEventListener("storage", handleStorageChange);
  }, []);

  // Combine all loading states
  const isLoading =
    isLocalLoading || authState === "loading" || isOAuthInProgress;
  const isButtonDisabled = disabled || isLoading;
  const config = providerConfig[provider as keyof typeof providerConfig];

  debug("Rendering with state:", {
    isLocalLoading,
    authState,
    isOAuthInProgress,
    isLoading,
  });

  return (
    <button
      onClick={handleGoogleSignIn}
      disabled={isButtonDisabled}
      data-loading={isLoading}
      className={[
        // Base layout and spacing
        "relative flex items-center justify-center gap-3 w-full px-6 py-3 rounded-xl",
        "font-semibold text-sm tracking-wide overflow-hidden",

        // Enhanced transitions and animations
        "transition-all duration-300 ease-out transform-gpu",

        // Background with gradient and glassmorphism effect
        config.bgColor || "bg-white border-2 border-gray-200/50",

        // Text styling
        config.textColor || "text-gray-700",

        // Interactive states with improved feedback
        isButtonDisabled
          ? "opacity-60 cursor-not-allowed scale-100"
          : [
              "hover:shadow-2xl hover:shadow-blue-500/20",
              "hover:-translate-y-1 hover:scale-[1.02]",
              "active:translate-y-0 active:scale-[0.98]",
              "focus:outline-none focus:ring-4 focus:ring-blue-500/20 focus:ring-offset-2",
              "hover:border-blue-300/60",
            ].join(" "),

        // Loading state animation
        isLoading && "animate-pulse",

        className,
      ]
        .filter(Boolean)
        .join(" ")
        .trim()}
      style={{
        transition: "all 300ms cubic-bezier(0.4, 0, 0.2, 1)",
        transform: "translateZ(0)",
        backfaceVisibility: "hidden",
        WebkitFontSmoothing: "antialiased",
        // Subtle gradient overlay
        background: isButtonDisabled
          ? undefined
          : `linear-gradient(135deg, ${
              config.bgColor || "rgba(255, 255, 255, 0.95)"
            }, ${config.bgColor || "rgba(249, 250, 251, 0.95)"})`,
        // Subtle inset shadow for depth
        boxShadow: isButtonDisabled
          ? undefined
          : "inset 0 1px 0 rgba(255, 255, 255, 0.1), 0 1px 3px rgba(0, 0, 0, 0.1), 0 4px 6px rgba(0, 0, 0, 0.05)",
      }}
    >
      {/* Shimmer effect overlay for loading state */}
      {isLoading && (
        <div
          className="absolute inset-0 bg-gradient-to-r from-transparent via-white/20 to-transparent animate-shimmer"
          style={{
            animation: "shimmer 1.5s infinite",
            background:
              "linear-gradient(90deg, transparent, rgba(255,255,255,0.4), transparent)",
            backgroundSize: "200% 100%",
          }}
        />
      )}

      {/* Icon container with enhanced styling */}
      <div
        className={[
          "flex items-center justify-center min-w-[24px] h-6 relative z-10",
          "transition-transform duration-300 ease-out",
          isLoading ? "animate-spin" : "group-hover:scale-110",
        ].join(" ")}
      >
        {isLoading ? (
          <div className="relative">
            <LoadingSpinner
              size="sm"
              className="h-5 w-5 text-current opacity-80"
            />
            <div className="absolute inset-0 animate-ping">
              <div className="h-5 w-5 rounded-full bg-current opacity-20" />
            </div>
          </div>
        ) : (
          <config.icon className="h-5 w-5 transition-all duration-300 filter drop-shadow-sm" />
        )}
      </div>

      {/* Text with enhanced typography */}
      <span
        className={[
          "relative z-10 whitespace-nowrap select-none",
          "transition-all duration-300 ease-out",
          isLoading ? "tracking-wider" : "group-hover:tracking-wide",
        ].join(" ")}
      >
        {isLoading ? (
          <span className="flex items-center gap-2">
            Connecting
            <span className="flex gap-1">
              <span
                className="w-1 h-1 bg-current rounded-full animate-bounce"
                style={{ animationDelay: "0ms" }}
              />
              <span
                className="w-1 h-1 bg-current rounded-full animate-bounce"
                style={{ animationDelay: "150ms" }}
              />
              <span
                className="w-1 h-1 bg-current rounded-full animate-bounce"
                style={{ animationDelay: "300ms" }}
              />
            </span>
          </span>
        ) : (
          `${variant === "signup" ? "Sign up" : "Continue"} with ${config.name}`
        )}
      </span>

      {/* Subtle highlight effect */}
      {!isButtonDisabled && !isLoading && (
        <div className="absolute inset-0 rounded-xl bg-gradient-to-r from-transparent via-white/5 to-transparent opacity-0 group-hover:opacity-100 transition-opacity duration-300" />
      )}
    </button>
  );
}
<style jsx>{`
  @keyframes shimmer {
    0% {
      background-position: -200% 0;
    }
    100% {
      background-position: 200% 0;
    }
  }

  @keyframes bounce {
    0%,
    80%,
    100% {
      transform: translateY(0);
    }
    40% {
      transform: translateY(-4px);
    }
  }
`}</style>;

```

<!-- path: components/auth/privacy.tsx -->
```typescript
import React from "react";

const Privacy = () => {
  return (
    <div className='bg-gray-100 dark:bg-gray-900 min-h-screen'>
      <div className='container mx-auto px-4 py-8'>
        <h1 className='text-4xl font-bold text-center text-gray-800 dark:text-white mb-8'>Privacy Policy</h1>
        <div className='bg-white dark:bg-gray-800 rounded-lg shadow-md p-8'>
          <p className='mb-4 text-gray-700 dark:text-gray-300'>Your privacy is important to us. It is Harinavi Transmission Maintenance's policy to respect your privacy regarding any information we may collect from you across our website.</p>
          <p className='mb-4 text-gray-700 dark:text-gray-300'>
            We only ask for personal information when we truly need it to provide a service to you. We collect it by fair and lawful means, with your knowledge and consent. We also let you know why were collecting it and how it will be used.
          </p>

          <h2 className='text-2xl font-bold text-gray-800 dark:text-white mt-6 mb-4'>Information We Collect</h2>
          <p className='mb-4 text-gray-700 dark:text-gray-300'>
            We may collect personal identification information from Users in a variety of ways, including, but not limited to, when Users visit our site, register on the site, and in connection with other activities, services, features or resources
            we make available on our Site.
          </p>

          <h2 className='text-2xl font-bold text-gray-800 dark:text-white mt-6 mb-4'>How We Use Your Information</h2>
          <p className='mb-4 text-gray-700 dark:text-gray-300'>We may use the information we collect for various purposes, including to:</p>
          <ul className='list-disc list-inside mb-4 text-gray-700 dark:text-gray-300'>
            <li>Provide, operate, and maintain our website</li>
            <li>Improve, personalize, and expand our website</li>
            <li>Understand and analyze how you use our website</li>
            <li>Develop new products, services, features, and functionality</li>
          </ul>

          <h2 className='text-2xl font-bold text-gray-800 dark:text-white mt-6 mb-4'>Security</h2>
          <p className='mb-4 text-gray-700 dark:text-gray-300'>The security of your personal information is important to us, but remember that no method of transmission over the Internet, or method of electronic storage, is 100% secure.</p>

          <h2 className='text-2xl font-bold text-gray-800 dark:text-white mt-6 mb-4'>Contact Us</h2>
          <p className='text-gray-700 dark:text-gray-300'>If you have any questions about this Privacy Policy, please contact us at support@harinavi.com.</p>
        </div>
      </div>
    </div>
  );
};

export default Privacy;

```

<!-- path: components/auth/Protected.tsx -->
```typescript
"use client";

import { useState, useEffect, useRef } from "react";
import { useRouter } from "next/navigation";
import { PageSpinner } from "../common/ui/LoadingSpinner";
import { useUserPermissionsExtended } from "@/hooks/useRoleFunctions";
import { UserRole } from "@/types/user-roles";
import { UnauthorizedModal } from "./UnauthorizedModal";
import { useAuthStore } from "@/stores/authStore";

interface ProtectedProps {
  children: React.ReactNode;
  allowedRoles?: UserRole[];
  redirectTo?: string;
  fallbackComponent?: React.ReactNode;
}

type AuthState = "loading" | "authenticated" | "unauthenticated" | "unauthorized";

export const Protected: React.FC<ProtectedProps> = ({ children, allowedRoles, redirectTo = "/login", fallbackComponent }) => {
  const { role, isSuperAdmin, isLoading: isLoadingRole, canAccess } = useUserPermissionsExtended();
  const authState = useAuthStore((state) => state.authState);
  const user = useAuthStore((state) => state.user);
  const setAuthState = useAuthStore((state) => state.setAuthState);
  const router = useRouter();
  
  const [authStateExtended, setAuthStateExtended] = useState<AuthState>("loading");
  const hasRedirected = useRef(false);
  const [loadingStartTime] = useState(Date.now());
  const isOAuthFlow = useRef(false);
  const recheckTimeout = useRef<NodeJS.Timeout | null>(null);

  // Clean up timeouts on unmount
  useEffect(() => {
    return () => {
      if (recheckTimeout.current) {
        clearTimeout(recheckTimeout.current);
      }
    };
  }, []);

  // Detect OAuth callback flow (runs only once)
  useEffect(() => {
    const urlParams = new URLSearchParams(window.location.search);
    const pathname = window.location.pathname;
    const hasOAuthCode = urlParams.has('code');
    const isCallbackPath = pathname.includes('/auth/callback');
    const hasOAuthState = urlParams.has('state');
    isOAuthFlow.current = hasOAuthCode || isCallbackPath || hasOAuthState;
  }, []);

  const handleUnauthenticated = () => {
    if (authState === "unauthenticated" && !hasRedirected.current) {
      // console.log("handleUnauthenticated redirecting");
      // check non blocking way after 2 seconds
      setTimeout(() => {
        // Get current auth state from store instead of closure
        const currentAuthState = useAuthStore.getState().authState;
        if (currentAuthState === "unauthenticated" && !hasRedirected.current) {
          hasRedirected.current = true;
          router.replace(redirectTo);
        }
      }, 1000)
    }
  };

  useEffect(() => {
    // console.log(" Protection Logic Debug:", {
    //   authState,
    //   user,
    //   isLoadingRole,
    //   allowedRoles,
    //   hasRedirected: hasRedirected.current,
    //   isOAuthFlow: isOAuthFlow.current,
    //   "user === null": user === null,
    //   "authState === 'loading'": authState === "loading",
    //   "timeElapsed": Date.now() - loadingStartTime
    // });

    // Clear any pending timeout
    if (recheckTimeout.current) {
      clearTimeout(recheckTimeout.current);
      recheckTimeout.current = null;
    }

    // If auth is explicitly unauthenticated, handle it
    if (authState === "unauthenticated") {
      // Only update state if it's not already unauthenticated to prevent unnecessary re-renders
      if (authStateExtended !== "unauthenticated") {
        setAuthStateExtended("unauthenticated");
      }
      // Don't call handleUnauthenticated here - we'll handle the redirect in the render phase
      return;
    }

    // Enhanced timeout for loading state
    const timeElapsed = Date.now() - loadingStartTime;
    const maxTimeout = isOAuthFlow.current ? 4000 : 2000;

    if (authState === "loading" && user === null && timeElapsed > maxTimeout) {
      // console.log(" TIMEOUT: Force setting unauthenticated after", maxTimeout, "ms");
      setAuthState("unauthenticated");
      return;
    }

    // Only wait for role loading if we have role restrictions AND auth is complete
    const shouldWaitForRole = allowedRoles && allowedRoles.length > 0 && isLoadingRole;
    
    if (authState === "loading" || shouldWaitForRole) {
      setAuthStateExtended("loading");
      return;
    }

    // If we reach here, auth should be resolved
    if (authState === "authenticated" && user) {
      // Reset hasRedirected when we successfully authenticate
      hasRedirected.current = false;
      
      // Check role-based permissions if roles are specified
      if (allowedRoles && allowedRoles.length > 0) {
        if (canAccess(allowedRoles) || isSuperAdmin) {
          setAuthStateExtended("authenticated");
        } else {
          setAuthStateExtended("unauthorized");
        }
      } else {
        // No role restrictions, just authenticated
        setAuthStateExtended("authenticated");
      }
    }
  }, [authState, allowedRoles, canAccess, user, setAuthState, router, redirectTo, isLoadingRole, loadingStartTime]);

  // Don't render anything until we've determined the auth state
  if (authStateExtended === "loading") {
    return null; // Or <PageSpinner /> if you prefer
  }

  // Handle unauthenticated state
  if (authStateExtended === "unauthenticated") {
    // Use a timeout to prevent flash of content
    const handleRedirect = () => {
      if (!hasRedirected.current) {
        hasRedirected.current = true;
        router.replace(redirectTo);
      }
    };
    
    // Queue the redirect to the next tick to ensure we don't block rendering
    setTimeout(handleRedirect, 0);
    return null; // Or <PageSpinner /> if you prefer
  }

  // Handle unauthorized state
  if (authStateExtended === "unauthorized") {
    return fallbackComponent || <UnauthorizedModal allowedRoles={allowedRoles || []} currentRole={role} />;
  }

  // If we get here, user is authenticated and authorized
  return <>{children}</>;
};
```

<!-- path: components/auth/authButton.tsx -->
```typescript
// components/auth/authButton.tsx
'use client'
 
import Link from 'next/link'
import { useAuth } from '@/hooks/useAuth'
import { useAuthStore } from '@/stores/authStore'
import { BiLogOut, BiUser } from 'react-icons/bi'
import { CiSettings } from 'react-icons/ci'
import Image from 'next/image'
 
export default function AuthButton() {
  const { logout } = useAuth()
  const user = useAuthStore((state) => state.user)
 
  if (!user) {
    return (
      <div className="h-9 w-24 bg-gray-100 dark:bg-gray-800 animate-pulse rounded-lg border border-gray-200 dark:border-gray-700"></div>
    )
  }
 
  if (user) {
    return (
      <div className="bg-white dark:bg-gray-900 border border-gray-200 dark:border-gray-700 rounded-lg shadow-sm min-w-[220px]">
        {/* User Info Header */}
        <div className="px-4 py-3 border-b border-gray-100 dark:border-gray-800">
          <div className="flex items-center space-x-3">
            <div className="flex-shrink-0">
              {user.user_metadata?.avatar_url ? (
                <Image
                  src={user.user_metadata.avatar_url}
                  alt="Avatar"
                  className="h-8 w-8 rounded-full ring-2 ring-gray-100 dark:ring-gray-800"
                  width={32}
                  height={32}
                />
              ) : (
                <div className="h-8 w-8 rounded-full bg-gradient-to-br from-blue-500 to-indigo-600 flex items-center justify-center">
                  <BiUser className="h-4 w-4 text-white" />
                </div>
              )}
            </div>
            <div className="flex-1 min-w-0">
              <p className="text-sm font-semibold text-gray-900 dark:text-gray-100 truncate">
                {user.user_metadata?.name || user.email?.split('@')[0] || 'User'}
              </p>
              <p className="text-xs text-gray-500 dark:text-gray-400 truncate">
                {user.email}
              </p>
            </div>
          </div>
        </div>

        {/* Menu Items */}
        <div className="py-2">
          <Link
            href="/onboarding"
            className="flex items-center px-4 py-2.5 text-sm text-gray-700 dark:text-gray-300 hover:bg-gray-50 dark:hover:bg-gray-800 transition-colors group"
          >
            <CiSettings className="h-4 w-4 mr-3 text-gray-400 group-hover:text-gray-600 dark:group-hover:text-gray-300" />
            <span className="font-medium">Update Profile</span>
          </Link>
          
          <button
            onClick={logout}
            className="w-full flex items-center px-4 py-2.5 text-sm text-red-600 dark:text-red-400 hover:bg-red-50 dark:hover:bg-red-900/20 transition-colors group"
          >
            <BiLogOut className="h-4 w-4 mr-3 text-red-500 group-hover:text-red-600 dark:group-hover:text-red-400" />
            <span className="font-medium">Sign Out</span>
          </button>
        </div>
      </div>
    )
  }
 
  return (
    <div className="flex items-center space-x-3 bg-white dark:bg-gray-900 border border-gray-200 dark:border-gray-700 rounded-lg px-4 py-2 shadow-sm">
      <Link
        href="/login"
        className="text-sm font-medium text-gray-600 dark:text-gray-400 hover:text-gray-900 dark:hover:text-gray-100 transition-colors"
      >
        Sign In
      </Link>
      <div className="h-4 w-px bg-gray-300 dark:bg-gray-600"></div>
      <Link
        href="/signup"
        className="inline-flex items-center px-3 py-1.5 bg-gradient-to-r from-blue-600 to-indigo-600 hover:from-blue-700 hover:to-indigo-700 text-white text-sm font-medium rounded-md transition-all duration-200 shadow-sm hover:shadow-md"
      >
        Get Started
      </Link>
    </div>
  )
}
```

<!-- path: components/maintenance-areas/AreaFormModal.tsx -->
```typescript
// components/AreaFormModal.tsx
"use client";

import { useEffect, useMemo, useState } from "react";
import { MaintenanceArea, AreaFormModalProps } from "@/config/areas";
import { zodResolver } from "@hookform/resolvers/zod";
import { FormCard } from "../common/form/FormCard";
import { FormInput, FormSearchableSelect, FormSwitch, FormTextarea } from "@/components/common/form/FormControls";
import { useForm } from "react-hook-form";
import { maintenance_areasInsertSchema, Maintenance_areasInsertSchema } from "@/schemas/zod-schemas";

export function AreaFormModal({
  isOpen,
  onClose,
  onSubmit,
  area,
  allAreas,
  areaTypes,
  isLoading
}: AreaFormModalProps) {

  const {
    register,
    handleSubmit,
    formState: { errors },
    reset,
    control,
  } = useForm<Maintenance_areasInsertSchema>({
    resolver: zodResolver(maintenance_areasInsertSchema),
    defaultValues: {
      name: "",
      code: "",
      area_type_id: null,
      parent_id: null,
      contact_person: null,
      contact_number: null,
      email: null,
      address: null,
      latitude: null,
      longitude: null,
      status: true
    },
  });

  const [isInitialized, setIsInitialized] = useState(false);

  // Initialize form data when modal opens or area changes
  useEffect(() => {
    if (isOpen && !isInitialized) {
      if (area) {
        reset({
          name: area.name,
          code: area.code,
          area_type_id: area.area_type_id,
          parent_id: area.parent_id,
          contact_person: area.contact_person,
          contact_number: area.contact_number,
          email: area.email,
          address: area.address,
          latitude: area.latitude,
          longitude: area.longitude,
          status: area.status ?? true
        });
      } else {
        reset({
          name: "",
          code: "",
          area_type_id: null,
          parent_id: null,
          contact_person: null,
          contact_number: null,
          email: null,
          address: null,
          latitude: null,
          longitude: null,
          status: true
        });
      }
      setIsInitialized(true);
    }
  }, [area, isOpen, isInitialized, reset]);

  // Reset initialization when modal closes
  useEffect(() => {
    if (!isOpen) {
      setIsInitialized(false);
    }
  }, [isOpen]);

  const availableParents = useMemo(() => {
    if (!area) return allAreas;
    
    const getDescendantIds = (areaId: string, areas: MaintenanceArea[]): Set<string> => {
      const descendants = new Set<string>([areaId]);
      const children = areas.filter(a => a.parent_id === areaId);
      children.forEach(child => {
        const childDescendants = getDescendantIds(child.id, areas);
        childDescendants.forEach(id => descendants.add(id));
      });
      return descendants;
    };
    
    const excludeIds = getDescendantIds(area.id, allAreas);
    return allAreas.filter(a => !excludeIds.has(a.id));
  }, [area, allAreas]);

  const onValidSubmit = (data: Maintenance_areasInsertSchema) => {
    onSubmit(data);
  };

  if (!isOpen) return null;

  return (
    <div className="fixed inset-0 z-50 flex items-center justify-center bg-black bg-opacity-50">
      <div className="max-h-[90vh] w-full overflow-y-auto rounded-lg bg-white p-6 dark:bg-gray-800">
        <div className="mb-4 flex items-center justify-between">
          <h2 className="text-lg font-semibold text-gray-900 dark:text-white">
            {area ? "Edit Area" : "Add New Area"}
          </h2>
          <button 
            onClick={onClose} 
            className="text-gray-400 hover:text-gray-600 dark:hover:text-gray-300"
            disabled={isLoading}
            aria-label="Close modal"
          >
            
          </button>
        </div>
        
        <FormCard 
          onSubmit={handleSubmit(onValidSubmit)} 
          title={area ? "Edit Area" : "Add New Area"} 
          onCancel={onClose}
          isLoading={isLoading}
          heightClass="max-h-[calc(90vh-140px)]"
        >
          {/* Name Field */}
          <FormInput
            name="name"
            label="Area Name"
            register={register}
            error={errors.name}
            required
            disabled={isLoading}
          />
          
          {/* Code Field */}
          <FormInput
            name="code"
            label="Area Code"
            register={register}
            error={errors.code}
            disabled={isLoading}
          />
          
          {/* Area Type Field */}
          <FormSearchableSelect
            name="area_type_id"
            label="Area Type"
            control={control}
            error={errors.area_type_id}
            disabled={isLoading}
            options={areaTypes
              .filter(type => type.name !== "DEFAULT")
              .map(type => ({ value: type.id, label: type.name }))
            }
          />
          
          {/* Parent Area Field */}
          <FormSearchableSelect
            name="parent_id"
            label="Parent Area"
            control={control}
            error={errors.parent_id}
            disabled={isLoading}
            options={availableParents.map(a => ({ value: a.id, label: a.name }))}
          />
          
          {/* Contact Person Field */}
          <FormInput
            name="contact_person"
            label="Contact Person"
            register={register}
            error={errors.contact_person}
            disabled={isLoading}
          />
          
          {/* Contact Number Field */}
          <FormInput
            name="contact_number"
            label="Contact Number"
            register={register}
            error={errors.contact_number}
            disabled={isLoading}
          />
          
          {/* Email Field */}
          <FormInput
            name="email"
            label="Email Address"
            register={register}
            error={errors.email}
            disabled={isLoading}
          />
          
          {/* Address Field */}
          <FormTextarea
            name="address"
            label="Address"
            control={control}
            error={errors.address}
            disabled={isLoading}
          />
          
          {/* Coordinates Fields */}
          <FormInput
            name="latitude"
            label="Latitude"
            register={register}
            error={errors.latitude}
            disabled={isLoading}
          />
          <FormInput
            name="longitude"
            label="Longitude"
            register={register}
            error={errors.longitude}
            disabled={isLoading}
          />
          
          {/* Status Field */}
          <FormSwitch
            name="status"
            label="Active"
            control={control}
            error={errors.status}
            className="mt-2"
          />
        </FormCard>
      </div>
    </div>
  );
}
```

<!-- path: components/maintenance-areas/useMaintenanceAreasMutations.ts -->
```typescript
// components/maintenance-areas/useMaintenanceAreasMutations.ts
import { createClient } from "@/utils/supabase/client";
import { useTableInsert, useTableUpdate, useToggleStatus } from "@/hooks/database";
import { Maintenance_areasInsertSchema, Maintenance_areasUpdateSchema } from "@/schemas/zod-schemas";

export function useMaintenanceAreasMutations(
  supabase: ReturnType<typeof createClient>,
  onSuccess: () => void
) {
  const createAreaMutation = useTableInsert(supabase, "maintenance_areas", { onSuccess });
  const updateAreaMutation = useTableUpdate(supabase, "maintenance_areas", { onSuccess });
  const toggleStatusMutation = useToggleStatus(supabase, "maintenance_areas", { onSuccess });

  const handleFormSubmit = (
    data: Maintenance_areasInsertSchema,
    editingArea?: { id: string } | null
  ) => {
    if (editingArea?.id) {
      updateAreaMutation.mutate({ id: editingArea.id, data: data as Maintenance_areasUpdateSchema });
    } else {
      createAreaMutation.mutate(data);
    }
  };

  return {
    createAreaMutation,
    updateAreaMutation,
    toggleStatusMutation,
    handleFormSubmit: (data: Maintenance_areasInsertSchema, editingArea?: { id: string } | null) => handleFormSubmit(data, editingArea)
  };
}
```

<!-- path: components/maintenance-areas/index.ts -->
```typescript
export * from "./AreaFormModal";
export * from "./useMaintenanceAreasMutations";


```

<!-- path: components/designations/DesignationFormModal.tsx -->
```typescript
import { useEffect, useMemo } from "react";
import { useForm } from "react-hook-form";
import { zodResolver } from "@hookform/resolvers/zod";
import { z } from "zod";
import { FormCard } from "@/components/common/form/FormCard";
import { FormInput, FormSearchableSelect, FormSwitch } from "@/components/common/form/FormControls";
import { employee_designationsInsertSchema, Employee_designationsInsertSchema, Employee_designationsRowSchema } from "@/schemas/zod-schemas";
import { DesignationWithRelations } from "@/app/dashboard/designations/page";



interface DesignationFormModalProps {
  isOpen: boolean;
  onClose: () => void;
  onSubmit: (data: Employee_designationsInsertSchema) => void;
  designation: DesignationWithRelations | null;
  allDesignations: Employee_designationsRowSchema[];
  isLoading: boolean;
}

export function DesignationFormModal({ isOpen, onClose, onSubmit, designation, allDesignations, isLoading }: DesignationFormModalProps) {
  // === React Hook Form Setup ===
  // Create a form-specific schema that excludes timestamp fields to avoid Date vs string/null mismatches
  const designationFormSchema = employee_designationsInsertSchema.pick({ id: true, name: true, parent_id: true, status: true });
  type DesignationForm = z.infer<typeof designationFormSchema>;

  const {
    register,
    handleSubmit,
    formState: { errors },
    reset,
    control,
  } = useForm<DesignationForm>({
    resolver: zodResolver(designationFormSchema),
    defaultValues: {
      name: "",
      parent_id: null,
      status: true,
    },
  });

  const availableParents = useMemo(() => {
    if (!designation || !designation.id) return allDesignations;

    const getDescendantIds = (designationId: string, designations: Employee_designationsInsertSchema[]): Set<string> => {
      const descendants = new Set<string>([designationId]);
      const children = designations.filter((d) => d.parent_id === designationId);
      children.forEach((child) => {
        if (!child.id) return;
        const childDescendants = getDescendantIds(child.id, designations);
        childDescendants.forEach((id) => descendants.add(id));
      });
      return descendants;
    };

    const excludeIds = getDescendantIds(designation.id, allDesignations);
    return allDesignations.filter((d) => !d.id || !excludeIds.has(d.id));
  }, [designation, allDesignations]);

  // Reset form when designation changes (to pre-fill the form when editing)
  useEffect(() => {
    if (designation) {
      reset({
        id: designation.id,
        name: designation.name,
        parent_id: designation.parent_id ?? null,
        status: designation.status ?? true,
      });
    }
  }, [designation, reset]);

  const onValidSubmit = (data: DesignationForm) => {
    // Forward only the fields we collect; backend/consumer can add timestamps as needed
    const parsedData = {
      ...data,
    };
    onSubmit(parsedData);
  };

  if (!isOpen) return null;

  return (
    <div className='fixed inset-0 z-50 flex items-center justify-center bg-black bg-opacity-50'>
      <div className='max-h-[90vh] w-full overflow-y-auto rounded-lg bg-white p-6 dark:bg-gray-800'>
        <div className='mb-4 flex items-center justify-between'>
          <h2 className='text-lg font-semibold text-gray-900 dark:text-white'>{designation ? "Edit Designation" : "Add New Designation"}</h2>
          <button onClick={onClose} className='text-gray-400 hover:text-gray-600 dark:hover:text-gray-300'>
            
          </button>
        </div>
        <FormCard onSubmit={handleSubmit(onValidSubmit)} title={designation ? "Edit Designation" : "Add New Designation"} onCancel={onClose} heightClass="h-[calc(90vh-140px)]">
          <FormInput name='name' label='Designation Name' register={register} error={errors.name} required />
          <FormSearchableSelect name='parent_id' label='Parent Designation' control={control} error={errors.parent_id} required options={availableParents.map((d) => ({ value: d.id, label: d.name }))} />
          <FormSwitch name='status' label='Status' control={control} error={errors.status} className="mt-4" />
        </FormCard>
      </div>
    </div>
  );
}

```

<!-- path: components/polyfills/PolyfillLoader.tsx -->
```typescript
"use client";
 
import { useEffect } from "react";
 
export default function PolyfillLoader() {
  useEffect(() => {
    const needsPolyfills = !("fetch" in window) || !("IntersectionObserver" in window);
 
    if (needsPolyfills) {
      import("core-js/stable");
      import("regenerator-runtime/runtime");
      import("whatwg-fetch");
      import("intersection-observer");
      import("url-polyfill");
    }
  }, []);
 
  return null; // No UI needed
}
```

<!-- path: components/dashboard/MenuButton.tsx -->
```typescript
"use client";
import { FiMenu } from "react-icons/fi";

interface MenuButtonProps {
  onClick: () => void;
}

export default function MenuButton({ onClick }: MenuButtonProps) {
  return (
    <button
      onClick={onClick}
      className="block md:hidden p-2 rounded-lg text-gray-700 dark:text-gray-200 hover:bg-gray-100 dark:hover:bg-gray-800 focus:outline-none focus:ring-2 focus:ring-blue-500"
      aria-label="Open sidebar menu"
      type="button"
    >
      <FiMenu className="h-6 w-6" />
    </button>
  );
}

```

<!-- path: components/dashboard/ColumnManagementProvider.tsx -->
```typescript
"use client";

import { createContext, useContext, useState, useEffect, useMemo, ReactNode } from "react";
import { toast } from "sonner";

interface ColumnOption {
  label: string;
  value: string;
}

interface ColumnManagementContextType {
  visibleColumns: string[];
  setVisibleColumns: (columns: string[]) => void;
  isDeleteVisible: boolean;
  setIsDeleteVisible: (visible: boolean) => void;
  columnOptions: ColumnOption[];
  toggleDelete: () => void;
  resetColumnsToDefault: () => void;
}

const ColumnManagementContext =
  createContext<ColumnManagementContextType | null>(null);

export function useColumnManagement() {
  const context = useContext(ColumnManagementContext);
  if (!context) {
    throw new Error(
      "useColumnManagement must be used within a ColumnManagementProvider"
    );
  }
  return context;
}

interface ColumnManagementProviderProps {
  children: ReactNode;
  data: ReactNode | ReactNode[] | Record<string, unknown>[] | null; // The data to generate column options from
  excludeColumns?: string[];
}

export default function ColumnManagementProvider({
  children,
  data,
  excludeColumns = ["password_hash", "internal_id"],
}: ColumnManagementProviderProps) {
  const [visibleColumns, setVisibleColumns] = useState<string[]>([]);
  const [isDeleteVisible, setIsDeleteVisible] = useState(false);

  // Generate column options from data
  const columnOptions = useMemo(() => {
    if (!data || (data as Record<string, unknown>[]).length === 0) return [];

    // Get keys from first item in data array
    const firstItem = data as Record<string, unknown>[];
    if (!firstItem || typeof firstItem !== "object") return [];

    const keys = Object.keys(firstItem);

    return keys
      .filter((key) => !excludeColumns.includes(key))
      .map((key) => ({
        label: key.replace(/_/g, " ").replace(/\b\w/g, (l) => l.toUpperCase()),
        value: key,
      }));
  }, [data, excludeColumns]);

  // Initialize visible columns when column options change
  useEffect(() => {
    if (columnOptions.length > 0 && visibleColumns.length === 0) {
      setVisibleColumns(columnOptions.map((col) => col.value));
    }
  }, [columnOptions, visibleColumns.length]);

  // Toggle delete visibility
  const toggleDelete = () => {
    setIsDeleteVisible((prev) => {
      const newState = !prev;
      toast.info(newState ? "Delete options shown" : "Delete options hidden");
      return newState;
    });
  };

  // Reset columns to default
  const resetColumnsToDefault = () => {
    if (columnOptions.length > 0) {
      setVisibleColumns(columnOptions.map((col) => col.value));
      toast.success("Columns reset to default");
    } else {
      toast.warning("No columns available to reset");
    }
  };

  const contextValue: ColumnManagementContextType = {
    visibleColumns,
    setVisibleColumns,
    isDeleteVisible,
    setIsDeleteVisible,
    columnOptions,
    toggleDelete,
    resetColumnsToDefault,
  };

  return (
    <ColumnManagementContext.Provider value={contextValue}>
      {children}
    </ColumnManagementContext.Provider>
  );
}

```

<!-- path: components/dashboard/DashboardHeader.tsx -->
```typescript
"use client";

import AuthButton from "@/components/auth/authButton";
import Link from "next/link";
import MenuButton from "./MenuButton";
import { useAuthStore } from "@/stores/authStore";
import Image from "next/image";
import ThemeToggle from "../common/ui/theme/ThemeToggle";

interface DashboardHeaderProps {
  onMenuClick: () => void;
  title?: string;
}

export default function DashboardHeader({
  onMenuClick,
  title = "Dashboard",
}: DashboardHeaderProps) {
  const user = useAuthStore((state) => state.user);

  return (
    <header className="sticky top-0 z-40 border-b border-gray-200 bg-white shadow-sm dark:border-gray-700 dark:bg-gray-800">
      <div className="mx-auto max-w-full px-4 sm:px-6 lg:px-8">
        <div className="flex h-16 items-center justify-between">
          <div className="flex items-center">
            {/* Mobile menu button */}
            <MenuButton onClick={onMenuClick} />
            <h1 className="hidden text-2xl font-bold text-gray-900 md:block dark:text-white">
              {title}
            </h1>
          </div>

          <div className="space-x-4 relative flex items-center">
            {user && (
              <div className="group">
                <Link
                  href="/onboarding"
                  className="flex items-center space-x-2 transition-colors hover:opacity-80"
                >
                  {user.user_metadata?.avatar_url ? (
                    <Image
                      src={user.user_metadata?.avatar_url}
                      alt="User Avatar"
                      className="h-8 w-8 rounded-full"
                      width={32}
                      height={32}
                    />
                  ) : (
                    <div className="flex h-8 w-8 items-center justify-center rounded-full bg-blue-500">
                      <span className="text-sm font-medium text-white">
                        {user.user_metadata?.name?.[0] || "U"}
                      </span>
                    </div>
                  )}
                  <span className="text-sm font-medium text-gray-700 dark:text-gray-300">
                    {user.user_metadata?.name || "User"}
                  </span>
                </Link>

                {/* Dropdown AuthButton - Responsive positioning */}
                <div
                  className="absolute top-full right-0 mt-2 mr-4 opacity-0 invisible group-hover:opacity-100 group-hover:visible transition-all duration-200 z-50 
                    sm:left-0 sm:right-auto"
                >
                  <div
                    className="bg-white dark:bg-gray-800 rounded-lg shadow-lg border border-gray-200 dark:border-gray-700 p-2 
                      w-auto min-w-64 sm:w-auto"
                  >
                    <AuthButton />
                  </div>
                </div>
              </div>
            )}
            <ThemeToggle />
          </div>
        </div>
      </div>
    </header>
  );
}

```

<!-- path: components/dashboard/DashboardContent.tsx -->
```typescript
import { ReactNode } from "react";
import ColumnManagementProvider from "./ColumnManagementProvider";
import DashboardHeader from "./DashboardHeader";
import Sidebar from "../navigation/sidebar";


interface DashboardContentProps {
  children: ReactNode | ReactNode[] | Record<string, unknown>[] | null;
  isCollapsed: boolean;
  setIsCollapsed: (collapsed: boolean) => void;
  isMobile: boolean;
  showColumnManagement: boolean;
}

function DashboardContent({
  children,
  isCollapsed,
  setIsCollapsed,
  isMobile,
  showColumnManagement,
}: DashboardContentProps) {
  return (
      <ColumnManagementProvider
        data={children as Record<string, unknown>[] | null}
      >
        {/* Sidebar */}
        <Sidebar 
          isCollapsed={isCollapsed} 
          setIsCollapsed={setIsCollapsed}
          showMenuFeatures={showColumnManagement}
        />

        {/* Main Content Area */}
        <div
          className={`transition-all duration-300 min-h-screen${
            isMobile ? "" : isCollapsed ? " ml-16" : " ml-64"
            // isMobile ? "" : isCollapsed ? " " : " "
          }`}
        >
          {/* Header */}
          <DashboardHeader onMenuClick={() => setIsCollapsed(false)} />

          {/* Main Content */}
          <main className="p-6">
            <div className="mx-auto max-w-full">
              {children as ReactNode}
            </div>
          </main>
        </div>
      </ColumnManagementProvider>
  );
}

export default DashboardContent;

```

<!-- path: components/common/entity-management/EntityDetailsPanel.tsx -->
```typescript
import React from 'react';
import { FiEdit3, FiTrash2 } from 'react-icons/fi';
import { BaseEntity, EntityConfig } from '@/components/common/entity-management/types';
import { DetailItem } from '@/components/common/entity-management/DetailItem';

interface EntityDetailsPanelProps<T extends BaseEntity> {
  entity: T | null;
  config: EntityConfig<T>;
  onEdit: () => void;
  onDelete: (entity: { id: string; name: string }) => void;
}

export function EntityDetailsPanel<T extends BaseEntity>({
  entity,
  config,
  onEdit,
  onDelete,
}: EntityDetailsPanelProps<T>) {
  if (!entity) {
    const IconComponent = config.icon;
    return (
      <div className="p-8 text-center text-gray-500 dark:text-gray-400">
        <IconComponent className="mx-auto mb-3 h-12 w-12 text-gray-300 dark:text-gray-600" />
        <p>Select a {config.entityDisplayName.toLowerCase()} to view details</p>
      </div>
    );
  }

  return (
    <div className="p-4 space-y-4">
      <div className="mb-2 flex items-start justify-between">
        <h3 className="text-xl font-bold text-gray-900 dark:text-white">{entity.name}</h3>
        <span
          className={`rounded-full px-2 py-1 text-xs ${
            entity.status
              ? "bg-green-100 dark:bg-green-900/30 text-green-800 dark:text-green-200"
              : "bg-red-100 dark:bg-red-900/30 text-red-800 dark:text-red-200"
          }`}
        >
          {entity.status ? "Active" : "Inactive"}
        </span>
      </div>

      {config.detailFields.map((field) => (
        <DetailItem
          key={String(field.key)}
          label={field.label}
          value={entity[field.key]}
          type={field.type}
          entity={entity}
          render={field.render}
        />
      ))}

      <div className="border-t border-gray-200 dark:border-gray-700 pt-4">
        <div className="flex gap-2">
          <button
            onClick={onEdit}
            className="flex flex-1 items-center justify-center gap-2 rounded-lg bg-blue-600 px-4 py-2 text-white hover:bg-blue-700 dark:bg-blue-700 dark:hover:bg-blue-800"
          >
            <FiEdit3 className="h-4 w-4" /> Edit
          </button>
          <button
            onClick={() => onDelete({ id: entity.id, name: entity.name })}
            className="flex items-center justify-center gap-2 rounded-lg border border-red-300 dark:border-red-700 px-4 py-2 text-red-700 dark:text-red-400 hover:bg-red-50 dark:hover:bg-red-900/30"
          >
            <FiTrash2 className="h-4 w-4" /> Delete
          </button>
        </div>
      </div>
    </div>
  );
}
```

<!-- path: components/common/entity-management/EntityManagementComponent.tsx -->
```typescript
import { EntityDetailsPanel } from "@/components/common/entity-management/EntityDetailsPanel";
import { EntityListItem } from "@/components/common/entity-management/EntityListItem";
import { EntityTreeItem } from "@/components/common/entity-management/EntityTreeItem";
import { SearchAndFilters } from "@/components/common/entity-management/SearchAndFilters";
import { BaseEntity, EntityConfig } from "@/components/common/entity-management/types";
import { ViewModeToggle } from "@/components/common/entity-management/ViewModeToggle";
import { useEntityManagement } from "@/hooks/useEntityManagement";
import { FiInfo, FiPlus } from "react-icons/fi";


interface EntityManagementComponentProps<T extends BaseEntity> {
  config: EntityConfig<T>;
  entitiesQuery: any;
  toggleStatusMutation: any;
  onEdit: (entity: T) => void;
  onDelete: (entity: { id: string; name: string }) => void;
  onCreateNew: () => void;
}

export function EntityManagementComponent<T extends BaseEntity>({
  config,
  entitiesQuery,
  toggleStatusMutation,
  onEdit,
  onDelete,
  onCreateNew,
}: EntityManagementComponentProps<T>) {
  const {
    searchTerm,
    viewMode,
    showFilters,
    filters,
    showDetailsPanel,
    expandedEntities,
    filteredEntities,
    hierarchicalEntities,
    selectedEntity,
    setSearchTerm,
    setViewMode,
    setShowFilters,
    setFilters,
    setShowDetailsPanel,
    handleEntitySelect,
    toggleExpanded,
    handleOpenCreateForm,
    handleOpenEditForm,
    onToggleStatus, // This is the handler returned by the hook
  } = useEntityManagement({
    entitiesQuery,
    config,
    onEdit,
    onDelete,
    // It accepts both arguments but only uses the `entity` to trigger the mutation.
    onToggleStatus: (e, entity) => {
      toggleStatusMutation.mutate(entity);
    },
    onCreateNew,
  });

  const IconComponent = config.icon;

  return (
    <div className="h-screen flex flex-col bg-gray-50 dark:bg-gray-900">
      {/* Header */}
      <div className="bg-white dark:bg-gray-800 border-b border-gray-200 dark:border-gray-700 px-6 py-4">
        <div className="flex items-center justify-between">
          <div className="flex items-center space-x-3">
            <IconComponent className="h-6 w-6 text-gray-600 dark:text-gray-400" />
            <h1 className="text-2xl font-semibold text-gray-900 dark:text-white">
              {config.entityPluralName}
            </h1>
          </div>
          <button
            onClick={handleOpenCreateForm}
            className="inline-flex items-center px-4 py-2 text-sm font-medium text-white bg-blue-600 rounded-md hover:bg-blue-700 dark:bg-blue-700 dark:hover:bg-blue-800"
          >
            <FiPlus className="h-4 w-4 mr-2" />
            Add {config.entityDisplayName}
          </button>
        </div>
      </div>

      {/* Main Content */}
      <div className="flex flex-col lg:flex-row lg:h-[calc(100vh-80px)]">
        {/* Left Panel - List */}
        <div className={`flex-1 flex flex-col ${showDetailsPanel ? "hidden lg:flex" : "flex"} lg:border-r lg:border-gray-200 lg:dark:border-gray-700`}>
          <div className="bg-white dark:bg-gray-800 border-b border-gray-200 dark:border-gray-700">
            <SearchAndFilters
              searchTerm={searchTerm}
              onSearchChange={setSearchTerm}
              showFilters={showFilters}
              onToggleFilters={() => setShowFilters(p => !p)}
              filters={filters}
              onFilterChange={setFilters}
              onClearFilters={() => setFilters({})}
              config={config}
            />
            {config.isHierarchical && (
              <ViewModeToggle
                viewMode={viewMode}
                onChange={setViewMode}
              />
            )}
          </div>

          <div className="flex-1 overflow-y-auto bg-white dark:bg-gray-800">
            {entitiesQuery.isLoading ? (
              <div className="flex items-center justify-center py-12">
                <div className="text-center">
                  <div className="inline-block animate-spin rounded-full h-8 w-8 border-b-2 border-blue-600 mb-4"></div>
                  <p className="text-gray-600 dark:text-gray-400">
                    Loading {config.entityPluralName}...
                  </p>
                </div>
              </div>
            ) : entitiesQuery.isError ? (
              <div className="flex items-center justify-center py-12">
                <div className="text-center">
                  <div className="rounded-full bg-red-100 dark:bg-red-900/20 p-3 inline-block mb-4">
                    <svg className="h-6 w-6 text-red-600 dark:text-red-400" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                      <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M12 8v4m0 4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z" />
                    </svg>
                  </div>
                  <p className="text-red-600 dark:text-red-400">
                    Error loading {config.entityPluralName}
                  </p>
                </div>
              </div>
            ) : filteredEntities.length === 0 ? (
              <div className="flex items-center justify-center py-12">
                <div className="text-center">
                  <IconComponent className="h-12 w-12 text-gray-300 dark:text-gray-600 mx-auto mb-4" />
                  <p className="text-gray-500 dark:text-gray-400">
                    No {config.entityPluralName} found.
                  </p>
                  <button
                    onClick={handleOpenCreateForm}
                    className="mt-4 inline-flex items-center px-4 py-2 text-sm font-medium text-blue-600 bg-blue-50 rounded-md hover:bg-blue-100 dark:bg-blue-900/20 dark:text-blue-400 dark:hover:bg-blue-900/30"
                  >
                    <FiPlus className="h-4 w-4 mr-2" />
                    Add First {config.entityDisplayName}
                  </button>
                </div>
              </div>
            ) : config.isHierarchical && viewMode === "tree" ? (
              <div className="divide-y divide-gray-100 dark:divide-gray-700">
                {hierarchicalEntities.map((entity) => (
                  <EntityTreeItem
                    key={entity.id}
                    entity={entity}
                    config={config}
                    level={0}
                    selectedEntityId={selectedEntity?.id ?? null}
                    expandedEntities={expandedEntities}
                    onSelect={handleEntitySelect}
                    onToggleExpand={toggleExpanded}
                    onToggleStatus={onToggleStatus}
                    isLoading={toggleStatusMutation.isPending}
                  />
                ))}
              </div>
            ) : (
              <div className="divide-y divide-gray-100 dark:divide-gray-700">
                {filteredEntities.map((entity) => (
                  <EntityListItem
                    key={entity.id}
                    entity={entity}
                    config={config}
                    isSelected={entity.id === selectedEntity?.id}
                    onSelect={handleEntitySelect}
                    onToggleStatus={onToggleStatus}
                    isLoading={toggleStatusMutation.isPending}
                  />
                ))}
              </div>
            )}
          </div>
        </div>

        {/* Right Panel - Details */}
        <div className={`${showDetailsPanel ? "flex" : "hidden lg:flex"} flex-col w-full lg:w-96 xl:w-1/3 bg-white dark:bg-gray-800 border-t lg:border-t-0 border-gray-200 dark:border-gray-700`}>
          {/* Mobile Details Header */}
          <div className="sticky top-0 z-10 bg-white dark:bg-gray-800 border-b border-gray-200 dark:border-gray-700 px-4 py-3 lg:hidden">
            <div className="flex items-center justify-between">
              <h2 className="text-lg font-medium text-gray-900 dark:text-white">Details</h2>
              <button
                onClick={() => setShowDetailsPanel(false)}
                className="p-2 rounded-md text-gray-400 hover:text-gray-600 dark:hover:text-gray-300"
              >
                <svg className="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                  <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M6 18L18 6M6 6l12 12" />
                </svg>
              </button>
            </div>
          </div>

          {/* Desktop Details Header */}
          <div className="hidden lg:block border-b border-gray-200 dark:border-gray-700 px-4 py-3">
            <h2 className="text-lg font-medium text-gray-900 dark:text-white">
              {config.entityDisplayName} Details
            </h2>
          </div>

          <div className="flex-1 overflow-y-auto">
            {selectedEntity ? (
              <EntityDetailsPanel
                entity={selectedEntity}
                config={config}
                onEdit={handleOpenEditForm}
                onDelete={onDelete}
              />
            ) : (
              <div className="flex items-center justify-center h-full p-8">
                <div className="text-center">
                  <FiInfo className="h-12 w-12 text-gray-300 dark:text-gray-600 mx-auto mb-4" />
                  <p className="text-gray-500 dark:text-gray-400">
                    Select a {config.entityDisplayName.toLowerCase()} to view details
                  </p>
                </div>
              </div>
            )}
          </div>
        </div>
      </div>
    </div>
  );
}
```

<!-- path: components/common/entity-management/ViewModeToggle.tsx -->
```typescript
interface ViewModeToggleProps {
    viewMode: "tree" | "list";
    onChange: (mode: "tree" | "list") => void;
  }
  
  export function ViewModeToggle({ viewMode, onChange }: ViewModeToggleProps) {
    return (
      <div className="p-4 border-b border-gray-200 dark:border-gray-700">
        <div className="flex items-center gap-2">
          <button
            onClick={() => onChange("tree")}
            className={`px-3 py-2 rounded-lg text-sm font-medium ${
              viewMode === "tree"
                ? "bg-blue-100 text-blue-700 dark:bg-blue-900/30 dark:text-blue-300"
                : "text-gray-600 hover:bg-gray-100 dark:text-gray-400 dark:hover:bg-gray-700"
            }`}
          >
            Tree
          </button>
          <button
            onClick={() => onChange("list")}
            className={`px-3 py-2 rounded-lg text-sm font-medium ${
              viewMode === "list"
                ? "bg-blue-100 text-blue-700 dark:bg-blue-900/30 dark:text-blue-300"
                : "text-gray-600 hover:bg-gray-100 dark:text-gray-400 dark:hover:bg-gray-700"
            }`}
          >
            List
          </button>
        </div>
      </div>
    );
  }
```

<!-- path: components/common/entity-management/DetailItem.tsx -->
```typescript
import React from 'react';
import { BaseEntity } from '@/components/common/entity-management/types';

interface DetailItemProps<T extends BaseEntity> {
  label: string;
  value: any;
  type: 'text' | 'status' | 'parent' | 'date' | 'custom';
  entity: T;
  render?: (value: any, entity: T) => React.ReactNode;
}

export function DetailItem<T extends BaseEntity>({
  label,
  value,
  type,
  entity,
  render,
}: DetailItemProps<T>) {
  if (!value && type !== 'status') return null;

  const renderValue = () => {
    if (render) {
      return render(value, entity);
    }

    switch (type) {
      case 'status':
        return (
          <span
            className={`inline-flex rounded-full px-2 py-1 text-xs font-semibold ${
              value
                ? "bg-green-100 dark:bg-green-900/30 text-green-800 dark:text-green-200"
                : "bg-red-100 dark:bg-red-900/30 text-red-800 dark:text-red-200"
            }`}
          >
            {value ? "Active" : "Inactive"}
          </span>
        );
      case 'parent':
        return value?.name || 'No parent';
      case 'date':
        return value ? new Date(value).toLocaleDateString() : 'N/A';
      case 'text':
      default:
        return String(value);
    }
  };

  return (
    <div className="py-2">
      <dt className="text-sm font-medium text-gray-500 dark:text-gray-400">{label}</dt>
      <dd className="mt-1 text-sm text-gray-900 dark:text-gray-100">{renderValue()}</dd>
    </div>
  );
}
```

<!-- path: components/common/entity-management/types.ts -->
```typescript
// components/common/entity-management/types.ts
import { UseQueryResult } from '@tanstack/react-query';

export interface BaseEntity {
  id: string;
  name: string;
  status: boolean | null;
  created_at?: string | null;
  updated_at?: string | null;
}

export interface HierarchicalEntity extends BaseEntity {
  parent_id?: string | null;
  parent?: HierarchicalEntity | null;
}

// Utility type for entities with computed children
export type EntityWithChildren<T extends BaseEntity> = T & {
  children: EntityWithChildren<T>[];
};

// Type guard functions
export function isHierarchicalEntity<T extends BaseEntity>(
  entity: T
): entity is T & HierarchicalEntity {
  return 'parent_id' in entity || 'parent' in entity;
}

export interface EntityConfig<T extends BaseEntity> {
  entityName: string;
  entityDisplayName: string;
  entityPluralName: string;
  parentField?: keyof T;
  icon: React.ComponentType<{ className?: string }>;
  isHierarchical: boolean;
  searchFields: (keyof T)[];
  detailFields: Array<{
    key: keyof T;
    label: string;
    type: 'text' | 'status' | 'parent' | 'date' | 'custom';
    render?: (value: any, entity: T) => React.ReactNode;
  }>;
  filterOptions: Array<{
    key: string;
    label: string;
    type: 'select' | 'text' | 'date';
    options?: Array<{ value: string; label: string }>;
  }>;
}

// Interface for the hook props
export interface UseEntityManagementProps<T extends BaseEntity> {
  entitiesQuery: UseQueryResult<T[], Error>;
  config: EntityConfig<T>;
  onEdit: (entity: T) => void;
  onDelete: (entity: { id: string; name: string }) => void;
  onToggleStatus: (e: React.MouseEvent, entity: T) => void;
  onCreateNew: () => void;
}

// Updated component interfaces
export interface EntityTreeItemProps<T extends BaseEntity> {
    entity: EntityWithChildren<T>;
    config: EntityConfig<T>;
    level: number;
    selectedEntityId: string | null;
    expandedEntities: Set<string>;
    onSelect: (id: string) => void;
    onToggleExpand: (id: string) => void;
    onToggleStatus: (e: React.MouseEvent, entity: T) => void;
    isLoading: boolean;
  }


```

<!-- path: components/common/entity-management/EntityTreeItem.tsx -->
```typescript
import { BaseEntity, EntityTreeItemProps } from "@/components/common/entity-management/types";
import { FiChevronDown, FiChevronRight, FiToggleLeft, FiToggleRight } from "react-icons/fi";

export function EntityTreeItem<T extends BaseEntity>({
    entity,
    config,
    level,
    selectedEntityId,
    expandedEntities,
    onSelect,
    onToggleExpand,
    onToggleStatus,
    isLoading,
  }: EntityTreeItemProps<T>) {
    const IconComponent = config.icon;
    const hasChildren = entity.children.length > 0;
    const isSelected = entity.id === selectedEntityId;
    const isExpanded = expandedEntities.has(entity.id);
  
    return (
      <div className="border-b border-gray-100 dark:border-gray-700 last:border-b-0">
        <div
          className={`flex cursor-pointer items-center p-4 hover:bg-gray-50 dark:hover:bg-gray-800 ${
            isSelected
              ? "border-l-4 border-l-blue-500 bg-blue-50 dark:bg-gray-800"
              : "border-l-4 border-l-transparent"
          }`}
          style={{ paddingLeft: `${16 + level * 24}px` }}
          onClick={() => onSelect(entity.id)}
        >
          <div className="flex flex-1 items-center gap-2 truncate">
            {hasChildren ? (
              <button
                onClick={(e) => {
                  e.stopPropagation();
                  onToggleExpand(entity.id);
                }}
                className="rounded p-1 hover:bg-gray-200 dark:hover:bg-gray-700"
              >
                {isExpanded ? (
                  <FiChevronDown className="h-4 w-4 text-gray-400 dark:text-gray-500" />
                ) : (
                  <FiChevronRight className="h-4 w-4 text-gray-400 dark:text-gray-500" />
                )}
              </button>
            ) : (
              <div className="w-6" />
            )}
            <IconComponent className="h-5 w-5 flex-shrink-0 text-gray-400 dark:text-gray-500" />
            <div className="flex-1 truncate">
              <h3 className="font-medium text-gray-900 dark:text-gray-100 truncate">{entity.name}</h3>
            </div>
          </div>
          <button
            onClick={(e) => onToggleStatus(e, entity)}
            disabled={isLoading}
            className="ml-auto"
          >
            {entity.status ? (
              <FiToggleRight className="h-5 w-5 text-green-500 dark:text-green-400" />
            ) : (
              <FiToggleLeft className="h-5 w-5 text-gray-400 dark:text-gray-500" />
            )}
          </button>
        </div>
        {isExpanded && hasChildren && (
          <div>
            {entity.children.map((child) => (
              <EntityTreeItem
                key={child.id}
                entity={child}
                config={config}
                level={level + 1}
                selectedEntityId={selectedEntityId}
                expandedEntities={expandedEntities}
                onSelect={onSelect}
                onToggleExpand={onToggleExpand}
                onToggleStatus={onToggleStatus}
                isLoading={isLoading}
              />
            ))}
          </div>
        )}
      </div>
    );
  }
  
```

<!-- path: components/common/entity-management/SearchAndFilters.tsx -->
```typescript
import { MdFilterList as Filter, MdSearch as Search, MdClear as Clear } from 'react-icons/md';
import { BaseEntity, EntityConfig } from '@/components/common/entity-management/types';

interface SearchAndFiltersProps<T extends BaseEntity> {
  searchTerm: string;
  onSearchChange: (term: string) => void;
  showFilters: boolean;
  onToggleFilters: () => void;
  filters: Record<string, string>;
  onFilterChange: (filters: Record<string, string>) => void;
  onClearFilters: () => void;
  config: EntityConfig<T>;
}

export function SearchAndFilters<T extends BaseEntity>({
  searchTerm,
  onSearchChange,
  showFilters,
  onToggleFilters,
  filters,
  onFilterChange,
  onClearFilters,
  config,
}: SearchAndFiltersProps<T>) {
  return (
    <div className="border-b border-gray-200 dark:border-gray-700 p-4">
      <div className="mb-4 flex items-center gap-4">
        <div className="relative flex-1">
          <Search className="absolute top-1/2 left-3 h-4 w-4 -translate-y-1/2 transform text-gray-400 dark:text-gray-500" />
          <input
            type="text"
            placeholder={`Search ${config.entityPluralName.toLowerCase()}...`}
            value={searchTerm}
            onChange={(e) => onSearchChange(e.target.value)}
            className="w-full rounded-lg border border-gray-300 dark:border-gray-600 dark:bg-gray-700 dark:text-white py-2 pr-4 pl-10 focus:border-transparent focus:ring-2 focus:ring-blue-500 dark:focus:ring-blue-600"
          />
          {searchTerm && (
            <button
              onClick={() => onSearchChange("")}
              className="absolute right-3 top-1/2 -translate-y-1/2 text-gray-400 hover:text-gray-600"
            >
              <Clear className="h-4 w-4" />
            </button>
          )}
        </div>
        <button
          onClick={onToggleFilters}
          className="flex items-center gap-2 rounded-lg border border-gray-300 dark:border-gray-600 px-3 py-2 hover:bg-gray-50 dark:hover:bg-gray-700"
        >
          <Filter className="h-4 w-4" />
          Filters
        </button>
      </div>
      {showFilters && (
        <div className="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 gap-4 rounded-lg bg-gray-50 dark:bg-gray-700 p-4">
          {config.filterOptions.map((filterOption) => (
            <div key={filterOption.key}>
              <label className="mb-1 block text-sm font-medium text-gray-700 dark:text-gray-300">
                {filterOption.label}
              </label>
              {filterOption.type === 'select' ? (
                <select
                  value={filters[filterOption.key] || ''}
                  onChange={(e) => onFilterChange({ ...filters, [filterOption.key]: e.target.value })}
                  className="w-full rounded-lg border border-gray-300 px-3 py-2 focus:ring-2 focus:ring-blue-500 dark:border-gray-600 dark:bg-gray-700 dark:text-white dark:focus:ring-blue-600"
                >
                  {filterOption.options?.map((option) => (
                    <option key={option.value} value={option.value}>
                      {option.label}
                    </option>
                  ))}
                </select>
              ) : filterOption.type === 'text' ? (
                <input
                  type="text"
                  value={filters[filterOption.key] || ''}
                  onChange={(e) => onFilterChange({ ...filters, [filterOption.key]: e.target.value })}
                  className="w-full rounded-lg border border-gray-300 px-3 py-2 focus:ring-2 focus:ring-blue-500 dark:border-gray-600 dark:bg-gray-700 dark:text-white dark:focus:ring-blue-600"
                />
              ) : filterOption.type === 'date' ? (
                <input
                  type="date"
                  value={filters[filterOption.key] || ''}
                  onChange={(e) => onFilterChange({ ...filters, [filterOption.key]: e.target.value })}
                  className="w-full rounded-lg border border-gray-300 px-3 py-2 focus:ring-2 focus:ring-blue-500 dark:border-gray-600 dark:bg-gray-700 dark:text-white dark:focus:ring-blue-600"
                />
              ) : null}
            </div>
          ))}
          <div className="flex items-end">
            <button
              onClick={onClearFilters}
              className="px-4 py-2 text-gray-600 dark:text-gray-400 hover:text-gray-800 dark:hover:text-gray-200"
            >
              Clear Filters
            </button>
          </div>
        </div>
      )}
    </div>
  );
}
```

<!-- path: components/common/entity-management/EntityListItem.tsx -->
```typescript
import React from 'react';
import { BiToggleLeft, BiToggleRight } from 'react-icons/bi';
import { BaseEntity, EntityConfig, HierarchicalEntity, isHierarchicalEntity } from '@/components/common/entity-management/types';

interface EntityListItemProps<T extends BaseEntity> {
  entity: T;
  config: EntityConfig<T>;
  isSelected: boolean;
  onSelect: (id: string) => void;
  onToggleStatus: (e: React.MouseEvent, entity: T) => void;
  isLoading: boolean;
}

export function EntityListItem<T extends BaseEntity>({
  entity,
  config,
  isSelected,
  onSelect,
  onToggleStatus,
  isLoading,
}: EntityListItemProps<T>) {
  const IconComponent = config.icon;

  // Function to get parent name using the configured parent field
  const getParentName = (entity: T): string | null => {
    if (!config.isHierarchical || !config.parentField) return null;
    
    const parentObject = entity[config.parentField] as any;
    if (parentObject?.name) {
      return parentObject.name;
    }
    
    return null;
  };

  const parentName = getParentName(entity);

  return (
    <div
      className={`cursor-pointer border-b border-gray-100 dark:border-gray-700 p-4 hover:bg-gray-50 dark:hover:bg-gray-800 ${
        isSelected
          ? "border-l-4 border-l-blue-500 bg-blue-50 dark:bg-gray-800"
          : "border-l-4 border-l-transparent"
      }`}
      onClick={() => onSelect(entity.id)}
    >
      <div className="flex items-center justify-between">
        <div className="flex-1">
          <div className="mb-2 flex items-center gap-2">
            <IconComponent className="h-5 w-5 text-gray-400 dark:text-gray-500" />
            <h3 className="font-medium text-gray-900 dark:text-gray-100">{entity.name}</h3>
          </div>
          {config.isHierarchical && isHierarchicalEntity(entity) && parentName && (
            <span className="text-xs bg-blue-100 dark:bg-blue-900/30 text-blue-800 dark:text-blue-200 px-2 py-1 rounded">
              Child of: {parentName}
            </span>
          )}
        </div>
        <button
          onClick={(e) => {
            // IMPROVEMENT: Stop the click from bubbling up to the parent div.
            e.stopPropagation(); 
            onToggleStatus(e, entity);
          }}
          disabled={isLoading}
          className="ml-2"
        >
          {entity.status ? (
            <BiToggleRight className="h-5 w-5 text-green-500 dark:text-green-400" />
          ) : (
            <BiToggleLeft className="h-5 w-5 text-gray-400 dark:text-gray-500" />
          )}
        </button>
      </div>
    </div>
  );
}
```

<!-- path: components/common/PageHeader copy.tsx -->
```typescript
"use client";

import React, { ReactNode, useCallback, useMemo } from "react";
import { FiDownload, FiPlus, FiRefreshCw } from "react-icons/fi";
import { toast } from "sonner";
import { createClient } from "@/utils/supabase/client";
import { Filters, TableOrViewName, Row } from "@/hooks/database";
import { useDynamicColumnConfig } from "@/hooks/useColumnConfig";
import { Button, ButtonProps } from "@/components/common/ui/Button/Button";
import { useTableExcelDownload } from "@/hooks/database/excel-queries";
import { formatDate } from "@/utils/formatters";
import { cn } from "@/lib/utils";

// --- TYPE DEFINITIONS ---

interface ExportConfig<T extends TableOrViewName> {
  tableName: T;
  filters?: Filters;
  maxRows?: number;
  columns?: (keyof Row<T> & string)[]; // Allow specifying a subset of columns for export
  fileName?: string;
}

export interface ActionButton extends ButtonProps {
  label: string;
  hideOnMobile?: boolean;
  hideTextOnMobile?: boolean;
  priority?: 'high' | 'medium' | 'low'; // For mobile button ordering
}

interface StatProps {
  value: string | number;
  label: string;
  icon?: ReactNode;
  color?: 'primary' | 'success' | 'warning' | 'danger' | 'default';
}

export interface PageHeaderProps {
  title: string;
  description?: string;
  icon?: ReactNode;
  stats?: StatProps[];
  actions?: ActionButton[];
  isLoading?: boolean;
  className?: string;
}

// --- SUB-COMPONENTS ---

const StatCard: React.FC<StatProps> = ({ value, label, icon, color = 'default' }) => {
    const statColors = {
      primary: 'text-blue-600 dark:text-blue-400',
      success: 'text-green-600 dark:text-green-400',
      warning: 'text-yellow-600 dark:text-yellow-400',
      danger: 'text-red-600 dark:text-red-400',
      default: 'text-gray-900 dark:text-white',
    };
    return (
      <div className="rounded-lg border border-gray-200 bg-white p-4 dark:border-gray-700 dark:bg-gray-900 flex items-start gap-4">
        {icon && <div className={`flex-shrink-0 text-2xl ${statColors[color]}`}>{icon}</div>}
        <div>
          <div className={`text-2xl font-bold ${statColors[color]}`}>{value}</div>
          <div className="text-sm text-gray-600 dark:text-gray-400">{label}</div>
        </div>
      </div>
    );
};

// --- MAIN COMPONENT ---

export function PageHeader({
  title,
  description,
  icon,
  stats,
  actions = [],
  isLoading = false,
  className,
}: PageHeaderProps) {
  
  return (
    <div className={cn("space-y-4 sm:space-y-6", isLoading && "opacity-50",className)}>
      {/* Header Section */}
      <div className="flex flex-col space-y-4 lg:space-y-0 lg:flex-row lg:items-start lg:justify-between">
        <div className="flex-1 space-y-2 sm:space-y-3 min-w-0">
          <div className="flex flex-col space-y-2 sm:space-y-0 sm:flex-row sm:items-center sm:gap-3">
            {icon && <div className="text-2xl sm:text-3xl text-blue-600 dark:text-blue-400">{icon}</div>}
            <h1 className="text-2xl sm:text-3xl font-bold text-gray-900 dark:text-white leading-tight">
              {title}
            </h1>
          </div>
          {description && (
            <p className="text-gray-600 dark:text-gray-400 text-base sm:text-lg leading-relaxed">
              {description}
            </p>
          )}
        </div>
        
        {/* Desktop Action Buttons */}
        <div className="hidden lg:flex items-center gap-2 flex-shrink-0 ml-4">
          {actions.map((action, index) => (
            <Button
              key={`desktop-action-${index}`}
              {...action}
              disabled={action.disabled || isLoading}
            >
              {action.label}
            </Button>
          ))}
        </div>
      </div>

      {/* Stats and Mobile Actions Row */}
      <div className="flex flex-col space-y-4 sm:space-y-0 sm:flex-row sm:items-center sm:justify-between sm:gap-4">
        {/* Stats Grid */}
        <div className="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-4 gap-4 flex-grow">
          {isLoading ? (
            Array.from({ length: stats?.length || 2 }).map((_, i) => (
              <div key={`stat-skeleton-${i}`} className="rounded-lg border border-gray-200 bg-white p-4 dark:border-gray-700 dark:bg-gray-900 animate-pulse">
                <div className="h-8 w-1/2 rounded-md bg-gray-200 dark:bg-gray-700 mb-2"></div>
                <div className="h-4 w-3/4 rounded-md bg-gray-200 dark:bg-gray-700"></div>
              </div>
            ))
          ) : (
            stats?.map(stat => <StatCard key={stat.label} {...stat} />)
          )}
        </div>

        {/* Mobile/Tablet Action Buttons */}
        <div className="flex lg:hidden items-center gap-2 w-full sm:w-auto sm:flex-shrink-0">
          {actions.map((action, index) => (
            <Button
              key={`mobile-action-${index}`}
              {...action}
              className={`flex-1 sm:flex-none ${action.hideOnMobile ? 'hidden sm:flex' : ''}`}
              disabled={action.disabled || isLoading}
            >
              {action.hideTextOnMobile ? '' : action.label}
            </Button>
          ))}
        </div>
      </div>
    </div>
  );
}

// --- HOOK FOR CREATING STANDARD ACTIONS ---

interface StandardActionsConfig<T extends TableOrViewName> {
  onRefresh?: () => void;
  onAddNew?: () => void;
  exportConfig?: ExportConfig<T>;
  isLoading?: boolean;
  data?: Row<T>[];
}

export function useStandardHeaderActions<T extends TableOrViewName>({
  onRefresh,
  onAddNew,
  exportConfig,
  isLoading,
  data
}: StandardActionsConfig<T>): ActionButton[] {
  const supabase = useMemo(() => createClient(), []);
  const columns = useDynamicColumnConfig(exportConfig?.tableName as T,{data: data});

  const tableExcelDownload = useTableExcelDownload(
    supabase,
    exportConfig?.tableName as T,
    { onSuccess: () => toast.success("Export successful!"), onError: (err) => toast.error(`Export failed: ${err.message}`) },
  );

  const handleExport = useCallback(() => {
    if (!exportConfig?.tableName) {
      toast.error("Export failed: Table name not configured.");
      return;
    }
    tableExcelDownload.mutate({
      fileName: `${formatDate(new Date(), { format: "dd-mm-yyyy" })}-${exportConfig.fileName ? exportConfig.fileName : exportConfig.tableName}.xlsx`,
      sheetName: exportConfig.fileName ? exportConfig.fileName : exportConfig.tableName,
      filters: exportConfig.filters,
      columns: columns.filter(c => exportConfig.columns ? exportConfig.columns.includes(c.key as keyof Row<T> & string) : true),
      maxRows: exportConfig.maxRows
    });
  }, [exportConfig, columns, tableExcelDownload]);

  return useMemo(() => {
    const actions: ActionButton[] = [];

    if (onRefresh) {
      actions.push({
        label: "Refresh",
        onClick: onRefresh,
        variant: "outline",
        leftIcon: <FiRefreshCw className={isLoading ? "animate-spin" : ""} />,
        disabled: isLoading,
      });
    }

    if (exportConfig) {
      actions.push({
        label: tableExcelDownload.isPending ? 'Exporting...' : 'Export',
        onClick: handleExport,
        variant: "outline",
        leftIcon: <FiDownload />,
        disabled: isLoading || tableExcelDownload.isPending,
      });
    }

    if (onAddNew) {
      actions.push({
        label: "Add New",
        onClick: onAddNew,
        variant: "primary",
        leftIcon: <FiPlus />,
        disabled: isLoading,
      });
    }

    return actions;
  }, [onRefresh, onAddNew, exportConfig, isLoading, handleExport, tableExcelDownload.isPending]);
}
```

<!-- path: components/common/page-header/PageHeader.tsx -->
```typescript
'use client';

import React, { ReactNode } from 'react';
import { Button } from '@/components/common/ui/Button/Button';
import { cn } from '@/lib/utils';
import { CardSkeleton } from '@/components/common/ui/table/TableSkeleton';
import { StatCard, StatProps } from '@/components/common/page-header/StatCard';
import {
  ActionButton,
  DropdownButton,
} from '@/components/common/page-header/DropdownButton';

// --- TYPE DEFINITIONS ---

export interface PageHeaderProps {
  title: string;
  description?: string;
  icon?: ReactNode;
  stats?: StatProps[];
  actions?: ActionButton[];
  isLoading?: boolean;
  className?: string;
}

// --- SUB-COMPONENTS ---

// --- MAIN COMPONENT ---

export function PageHeader({
  title,
  description,
  icon,
  stats,
  actions = [],
  isLoading = false,
  className,
}: PageHeaderProps) {
  return (
    <>
      {isLoading ? (
        <CardSkeleton />
      ) : (
        <div
          className={cn(
            'space-y-4 sm:space-y-6',
            isLoading && 'opacity-50',
            className
          )}
        >
          {/* Header Section */}
          <div className="flex flex-col space-y-4 lg:space-y-0 lg:flex-row lg:items-start lg:justify-between">
            <div className="flex-1 space-y-2 sm:space-y-3 min-w-0">
              <div className="flex flex-col space-y-2 sm:space-y-0 sm:flex-row sm:items-center sm:gap-3">
                {icon && (
                  <div className="text-2xl sm:text-3xl text-blue-600 dark:text-blue-400">
                    {icon}
                  </div>
                )}
                <h1 className="text-2xl sm:text-3xl font-bold text-gray-900 dark:text-white leading-tight">
                  {title}
                </h1>
              </div>
              {description && (
                <p className="text-gray-600 dark:text-gray-400 text-base sm:text-lg leading-relaxed">
                  {description}
                </p>
              )}
            </div>

            {/* Desktop Action Buttons */}
            <div className="hidden lg:flex items-center gap-2 flex-shrink-0 ml-4">
              {actions.map((action, index) =>
                action['data-dropdown'] ? (
                  <div key={`desktop-dropdown-${index}`} data-dropdown="true">
                    <DropdownButton
                      {...action}
                      disabled={action.disabled || isLoading}
                    />
                  </div>
                ) : (
                  <Button
                    key={`desktop-action-${index}`}
                    {...action}
                    disabled={action.disabled || isLoading}
                  >
                    {action.label}
                  </Button>
                )
              )}
            </div>
          </div>

          {/* Stats and Mobile Actions Row */}
          <div className="flex flex-col space-y-4 sm:space-y-0 sm:flex-row sm:items-center sm:justify-between sm:gap-4">
            {/* Stats Grid */}
            <div className="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-4 gap-4 flex-grow">
              {isLoading
                ? Array.from({ length: stats?.length || 2 }).map((_, i) => (
                    <div
                      key={`stat-skeleton-${i}`}
                      className="rounded-lg border border-gray-200 bg-white p-4 dark:border-gray-700 dark:bg-gray-900 animate-pulse"
                    >
                      <div className="h-8 w-1/2 rounded-md bg-gray-200 dark:bg-gray-700 mb-2"></div>
                      <div className="h-4 w-3/4 rounded-md bg-gray-200 dark:bg-gray-700"></div>
                    </div>
                  ))
                : stats?.map((stat) => <StatCard key={stat.label} {...stat} />)}
            </div>

            {/* Mobile/Tablet Action Buttons */}
            <div className="flex lg:hidden items-center gap-2 w-full sm:w-auto sm:flex-shrink-0">
              {actions.map((action, index) =>
                action['data-dropdown'] ? (
                  <DropdownButton
                    key={`mobile-dropdown-${index}`}
                    {...action}
                    className={`flex-1 sm:flex-none ${
                      action.hideOnMobile ? 'hidden sm:flex' : ''
                    }`}
                    disabled={action.disabled || isLoading}
                  />
                ) : (
                  <Button
                    key={`mobile-action-${index}`}
                    {...action}
                    className={`flex-1 sm:flex-none ${
                      action.hideOnMobile ? 'hidden sm:flex' : ''
                    }`}
                    disabled={action.disabled || isLoading}
                  >
                    {action.hideTextOnMobile ? '' : action.label}
                  </Button>
                )
              )}
            </div>
          </div>
        </div>
      )}
    </>
  );
}

// --- HOOK FOR CREATING STANDARD ACTIONS ---

```

<!-- path: components/common/page-header/hooks/useStandardHeaderActions.tsx -->
```typescript
'use client';

import { useCallback } from 'react';
import { toast } from 'sonner';
import { createClient } from '@/utils/supabase/client';
import { useTableExcelDownload } from '@/hooks/database/excel-queries';
import { formatDate } from '@/utils/formatters';
import { useDynamicColumnConfig } from '@/hooks/useColumnConfig';

import { ActionButton } from '@/components/common/page-header/DropdownButton';
import { Filters, Row, TableOrViewName } from '@/hooks/database';
import { useMemo } from 'react';
import { FiDownload, FiPlus, FiRefreshCw } from 'react-icons/fi';

interface ExportFilterOption {
  label: string;
  filters?: Filters;
  fileName?: string;
}

interface ExportConfig<T extends TableOrViewName> {
  tableName: T;
  maxRows?: number;
  columns?: (keyof Row<T> & string)[]; // Allow specifying a subset of columns for export
  filterOptions?: ExportFilterOption[]; // New: array of filter options
  // Deprecated: keeping for backward compatibility
  filters?: Filters;
  fileName?: string;
}

interface StandardActionsConfig<T extends TableOrViewName> {
  onRefresh?: () => void;
  onAddNew?: () => void;
  exportConfig?: ExportConfig<T>;
  isLoading?: boolean;
  data?: Row<T>[];
}

export function useStandardHeaderActions<T extends TableOrViewName>({
  onRefresh,
  onAddNew,
  exportConfig,
  isLoading,
  data,
}: StandardActionsConfig<T>): ActionButton[] {
  const supabase = useMemo(() => createClient(), []);
  const columns = useDynamicColumnConfig(exportConfig?.tableName as T, {
    data: data,
  });

  const tableExcelDownload = useTableExcelDownload(
    supabase,
    exportConfig?.tableName as T,
    {
      onSuccess: () => toast.success('Export successful!'),
      onError: (err) => toast.error(`Export failed: ${err.message}`),
    }
  );

  const handleExport = useCallback(
    (filterOption?: ExportFilterOption) => {
      if (!exportConfig?.tableName) {
        toast.error('Export failed: Table name not configured.');
        return;
      }

      // Use filterOption filters if provided, otherwise fall back to exportConfig filters
      const filters = filterOption?.filters || exportConfig.filters;

      // Determine the file and sheet name
      let fileName: string;
      let sheetName: string;

      if (filterOption) {
        // If it's a filter option, use custom fileName or append label to table name
        if (filterOption.fileName) {
          fileName = filterOption.fileName;
          sheetName = filterOption.fileName;
        } else {
          // Append filter label to table name
          fileName = `${exportConfig.tableName}-${filterOption.label
            .toLowerCase()
            .replace(/\s+/g, '-')}`;
          sheetName = `${exportConfig.tableName}-${filterOption.label}`;
        }
      } else {
        // No filter option - use default table name or custom fileName
        fileName = exportConfig.fileName || exportConfig.tableName;
        sheetName = exportConfig.fileName || exportConfig.tableName;
      }

      tableExcelDownload.mutate({
        fileName: `${formatDate(new Date(), {
          format: 'dd-mm-yyyy',
        })}-${fileName}.xlsx`,
        sheetName: sheetName,
        filters: filters,
        columns: columns.filter((c) =>
          exportConfig.columns
            ? exportConfig.columns.includes(c.key as keyof Row<T> & string)
            : true
        ),
        maxRows: exportConfig.maxRows,
      });
    },
    [exportConfig, columns, tableExcelDownload]
  );

  return useMemo(() => {
    const actions: ActionButton[] = [];

    if (onRefresh) {
      actions.push({
        label: 'Refresh',
        onClick: onRefresh,
        variant: 'outline',
        leftIcon: <FiRefreshCw className={isLoading ? 'animate-spin' : ''} />,
        disabled: isLoading,
      });
    }

    if (exportConfig) {
      // Check if we have multiple filter options
      if (exportConfig.filterOptions && exportConfig.filterOptions.length > 0) {
        // Create dropdown with filter options
        const dropdownoptions = [
          {
            label: 'Export All (No Filters)',
            onClick: () =>
              handleExport({
                label: 'All',
                filters: undefined,
                fileName: undefined,
              }),
            disabled: tableExcelDownload.isPending,
          },
        ];
        exportConfig.filterOptions.forEach((option) => {
          dropdownoptions.push({
            label: `Export ${option.label}`,
            onClick: () => handleExport(option),
            disabled: tableExcelDownload.isPending,
          });
        });

        actions.push({
          label: 'Export',
          variant: 'outline',
          leftIcon: <FiDownload />,
          disabled: tableExcelDownload.isPending,
          'data-dropdown': true,
          dropdownoptions,
        });
      } else {
        // Single export button (backward compatibility)
        actions.push({
          label: tableExcelDownload.isPending ? 'Exporting...' : 'Export',
          onClick: () => handleExport(),
          variant: 'outline',
          leftIcon: <FiDownload />,
          disabled: isLoading || tableExcelDownload.isPending,
        });
      }
    }

    if (onAddNew) {
      actions.push({
        label: 'Add New',
        onClick: onAddNew,
        variant: 'primary',
        leftIcon: <FiPlus />,
        disabled: isLoading,
      });
    }

    return actions;
  }, [
    onRefresh,
    onAddNew,
    exportConfig,
    isLoading,
    handleExport,
    tableExcelDownload.isPending,
  ]);
}

```

<!-- path: components/common/page-header/DropdownButton.tsx -->
```typescript
'use client';
import { Button } from '@/components/common/ui';
import { FiChevronDown } from 'react-icons/fi';
import { cn } from '@/lib/utils';

import { ButtonProps } from '@/components/common/ui/Button/Button';
import { useState } from 'react';

export interface ActionButton extends Omit<ButtonProps, 'is_dropdown'> {
  label: string;
  hideOnMobile?: boolean;
  hideTextOnMobile?: boolean;
  priority?: 'high' | 'medium' | 'low'; // For mobile button ordering
  'data-dropdown'?: boolean; // Using data attribute instead of custom prop
  dropdownoptions?: Array<{
    label: string;
    onClick: () => void;
    disabled?: boolean;
  }>;
}

export const DropdownButton: React.FC<ActionButton> = ({
  label,
  dropdownoptions = [],
  disabled,
  variant = 'outline',
  leftIcon,
  className,
  ...props
}) => {
  const [isOpen, setIsOpen] = useState(false);

  return (
    <div className="relative" style={{ zIndex: 50 }}>
      <Button
        {...props}
        variant={variant}
        disabled={disabled}
        onClick={() => {
          setIsOpen(!isOpen);
        }}
        className={cn('flex items-center gap-2', className)}
        leftIcon={leftIcon}
        rightIcon={
          <FiChevronDown
            className={`transition-transform ${isOpen ? 'rotate-180' : ''}`}
          />
        }
      >
        {label}
      </Button>

      {isOpen && (
        <>
          {/* Backdrop */}
          <div
            className="fixed inset-0 z-40 bg-black/20 dark:bg-black/40"
            onClick={() => {
              setIsOpen(false);
            }}
            style={{
              position: 'fixed',
              inset: 0,
              zIndex: 40,
            }}
          />
          {/* Dropdown Menu */}
          <div className="absolute right-0 top-full z-50 mt-1 min-w-[200px] rounded-md border-2 border-gray-200 bg-white py-1 shadow-lg dark:border-gray-700 dark:bg-gray-800">
            {dropdownoptions.map((option, index) => (
              <button
                key={index}
                onClick={() => {
                  option.onClick();
                  setIsOpen(false);
                }}
                disabled={option.disabled}
                className="block w-full px-4 py-2 text-left text-sm text-gray-700 hover:bg-gray-100 disabled:cursor-not-allowed disabled:opacity-50 dark:text-gray-300 dark:hover:bg-gray-700"
              >
                {option.label}
              </button>
            ))}
          </div>
        </>
      )}
    </div>
  );
};

```

<!-- path: components/common/page-header/StatCard.tsx -->
```typescript
import { cn } from '@/lib/utils';
import { ReactNode } from 'react';

export interface StatProps {
  value: string | number;
  label: string;
  icon?: ReactNode;
  color?: 'primary' | 'success' | 'warning' | 'danger' | 'default';
}

export const StatCard: React.FC<StatProps> = ({
  value,
  label,
  icon,
  color = 'default',
}) => {
  const statColors = {
    primary: 'text-blue-600 dark:text-blue-400',
    success: 'text-green-600 dark:text-green-400',
    warning: 'text-yellow-600 dark:text-yellow-400',
    danger: 'text-red-600 dark:text-red-400',
    default: 'text-gray-900 dark:text-white',
  };

  const borderColors = {
    primary: 'border-blue-200 dark:border-blue-700',
    success: 'border-green-200 dark:border-green-700',
    warning: 'border-yellow-200 dark:border-yellow-700',
    danger: 'border-red-200 dark:border-red-700',
    default: 'border-gray-200 dark:border-gray-700',
  };

  const bgColors = {
    primary: 'bg-blue-50 dark:bg-blue-900/20',
    success: 'bg-green-50 dark:bg-green-900/20',
    warning: 'bg-yellow-50 dark:bg-yellow-900/20',
    danger: 'bg-red-50 dark:bg-red-900/20',
    default: 'bg-white dark:bg-gray-900',
  };

  return (
    <div
      className={cn(
        'rounded-lg border p-4 flex items-start gap-4',
        borderColors[color],
        bgColors[color]
      )}
    >
      {icon && (
        <div className={`flex-shrink-0 text-2xl ${statColors[color]}`}>
          {icon}
        </div>
      )}
      <div>
        <div className={`text-2xl font-bold ${statColors[color]}`}>{value}</div>
        <div className="text-sm text-gray-600 dark:text-gray-400">{label}</div>
      </div>
    </div>
  );
};

```

<!-- path: components/common/page-header/index.ts -->
```typescript
export * from './DropdownButton';
export * from './PageHeader';
export * from './StatCard';
export * from './hooks/useStandardHeaderActions';

```

<!-- path: components/common/DataListView.tsx -->
```typescript
import React, { useState } from 'react';
import { 
  FiSearch, 
  FiFilter, 
  FiGrid, 
  FiList, 
  FiInfo, 
  FiPlus, 
  FiX,
  FiAlertCircle 
} from 'react-icons/fi';
interface DataItem {
    id: string | number;  // Adjust the type based on your actual ID type
    name: string;
    description?: string;
    status?: boolean;
    title?: string;
    // Add other properties that your data items have
  }
interface DataListViewProps {
    data: DataItem[];
    isLoading: boolean;
    error: unknown;
    searchTerm: string;
    onSearchChange: (value: string) => void;
    searchPlaceholder: string;
    showFilters: boolean;
    onToggleFilters: () => void;
    filters: unknown;
    onFilterChange: (newFilters: unknown) => void;
    onClearFilters: () => void;
    viewMode: string;
    onViewModeChange: (mode: string) => void;
    showViewModeToggle: boolean;
    selectedItemId: string | null;
    showDetailsPanel: boolean;
    setShowDetailsPanel: (value: boolean) => void;
    detailsTitle: string;
    onCreateNew: () => void;
    createButtonText: string;
    createButtonIcon: React.ReactNode;
    onItemSelect: (item: DataItem) => void;
    renderListItem: (item: DataItem, isSelected: boolean, onSelect: () => void) => React.ReactNode;
    renderGridItem: (item: DataItem, isSelected: boolean, onSelect: () => void) => React.ReactNode;
    renderTreeItem: (item: DataItem, level: number, isSelected: boolean, isExpanded: boolean, onSelect: () => void, onToggleExpand: () => void) => React.ReactNode;
    renderDetailsPanel: (selectedItem: DataItem) => React.ReactNode;
    renderFilters: (filters: unknown, onFilterChange: (newFilters: unknown) => void, onClearFilters: () => void) => React.ReactNode;
    emptyStateIcon: React.ComponentType<{ className?: string }>;
    createIcon: React.ComponentType<{ className?: string }>;
    emptyStateTitle: string;
    emptyStateDescription: string;
    showCreateOnEmpty: boolean;
    loadingText: string;
    errorTitle: string;
    className: string;
    listClassName: string;
    detailsClassName: string;
}

/**
 * A reusable data list view component with search, filters, and details panel
 * @param {Object} props - Component props
 */
const DataListView = (props: DataListViewProps) => {
  // Destructure props with defaults
  const {
    data = [],
    isLoading = false,
    error = null,
    searchTerm = '',
    onSearchChange,
    searchPlaceholder = 'Search...',
    showFilters = false,
    onToggleFilters,
    filters = {},
    onFilterChange,
    onClearFilters,
    viewMode = 'list',
    onViewModeChange,
    showViewModeToggle = true,
    selectedItemId = null,
    onItemSelect,
    showDetailsPanel = false,
    setShowDetailsPanel,
    detailsTitle = 'Details',
    onCreateNew,
    createButtonText = 'Add New',
    renderListItem,
    renderTreeItem,
    renderGridItem,
    renderDetailsPanel,
    renderFilters,
    emptyStateIcon = FiInfo,
    emptyStateTitle = 'No items found',
    emptyStateDescription = 'No items match your criteria.',
    showCreateOnEmpty = true,
    loadingText = 'Loading...',
    errorTitle = 'Error loading data',
    className = '',
    listClassName = '',
    detailsClassName = '',
  } = props;

  const [internalShowDetailsPanel, setInternalShowDetailsPanel] = useState(false);
  
  // Use external state if provided, otherwise use internal state
  const detailsPanelVisible = showDetailsPanel !== undefined ? showDetailsPanel : internalShowDetailsPanel;
  const setDetailsPanelVisible = setShowDetailsPanel || setInternalShowDetailsPanel;

  const selectedItem = data.find((item) => (item as unknown as { id: string }).id === selectedItemId);

  const handleItemSelect = (item: DataItem) => {
    if (onItemSelect) {
      onItemSelect(item);
    }
    // Auto-show details panel on mobile when item is selected
    if (window.innerWidth < 1024) {
      setDetailsPanelVisible(true);
    }
  };

  const ViewModeToggle = () => {
    if (!showViewModeToggle) return null;
    
    return (
      <div className="flex items-center space-x-1 px-4 py-2 border-t border-gray-200 dark:border-gray-700">
        <button
          onClick={() => onViewModeChange && onViewModeChange('list')}
          className={`p-2 rounded-md ${
            viewMode === 'list'
              ? 'bg-blue-100 text-blue-600 dark:bg-blue-900/20 dark:text-blue-400'
              : 'text-gray-400 hover:text-gray-600 dark:hover:text-gray-300'
          }`}
        >
          <FiList className="h-4 w-4" />
        </button>
        <button
          onClick={() => onViewModeChange && onViewModeChange('grid')}
          className={`p-2 rounded-md ${
            viewMode === 'grid'
              ? 'bg-blue-100 text-blue-600 dark:bg-blue-900/20 dark:text-blue-400'
              : 'text-gray-400 hover:text-gray-600 dark:hover:text-gray-300'
          }`}
        >
          <FiGrid className="h-4 w-4" />
        </button>
      </div>
    );
  };

  const SearchAndFiltersSection = () => (
    <div className="bg-white dark:bg-gray-800 border-b border-gray-200 dark:border-gray-700">
      <div className="px-4 py-3">
        <div className="flex items-center space-x-3">
          <div className="flex-1 relative">
            <FiSearch className="absolute left-3 top-1/2 transform -translate-y-1/2 h-4 w-4 text-gray-400" />
            <input
              type="text"
              placeholder={searchPlaceholder}
              value={searchTerm}
              onChange={(e) => onSearchChange && onSearchChange(e.target.value)}
              className="w-full pl-10 pr-4 py-2 border border-gray-300 rounded-md focus:ring-blue-500 focus:border-blue-500 dark:bg-gray-700 dark:border-gray-600 dark:text-white"
            />
          </div>
          {onToggleFilters && (
            <button
              onClick={onToggleFilters}
              className={`p-2 rounded-md ${
                showFilters
                  ? 'bg-blue-100 text-blue-600 dark:bg-blue-900/20 dark:text-blue-400'
                  : 'text-gray-400 hover:text-gray-600 dark:hover:text-gray-300'
              }`}
            >
              <FiFilter className="h-4 w-4" />
            </button>
          )}
        </div>
      </div>
      
      {showFilters && renderFilters && (
        <div className="px-4 pb-3 border-t border-gray-200 dark:border-gray-700">
          {renderFilters(filters, onFilterChange, onClearFilters)}
        </div>
      )}
      
      <ViewModeToggle />
    </div>
  );

  const LoadingState = () => (
    <div className="flex items-center justify-center py-12">
      <div className="text-center">
        <div className="inline-block animate-spin rounded-full h-8 w-8 border-b-2 border-blue-600 mb-4"></div>
        <p className="text-gray-600 dark:text-gray-400">{loadingText}</p>
      </div>
    </div>
  );

  const ErrorState = () => {
    const ErrorIcon = FiAlertCircle;
    return (
      <div className="flex items-center justify-center py-12">
        <div className="text-center">
          <div className="rounded-full bg-red-100 dark:bg-red-900/20 p-3 inline-block mb-4">
            <ErrorIcon className="h-6 w-6 text-red-600 dark:text-red-400" />
          </div>
          <p className="text-red-600 dark:text-red-400">
            {errorTitle}: {(error as Error)?.message || String(error)}
          </p>
        </div>
      </div>
    );
  };

  const EmptyState = () => {
    
    return (
      <div className="flex items-center justify-center py-12">
        <div className="text-center">
          {React.createElement(emptyStateIcon, { 
            className: "h-12 w-12 text-gray-300 dark:text-gray-600 mx-auto mb-4" 
          })}
          <p className="text-gray-900 dark:text-white font-medium mb-2">
            {emptyStateTitle}
          </p>
          <p className="text-gray-500 dark:text-gray-400 mb-4">
            {emptyStateDescription}
          </p>
          {showCreateOnEmpty && onCreateNew && (
            <button
              onClick={onCreateNew}
              className="inline-flex items-center px-4 py-2 text-sm font-medium text-blue-600 bg-blue-50 rounded-md hover:bg-blue-100 dark:bg-blue-900/20 dark:text-blue-400 dark:hover:bg-blue-900/30"
            >
              <FiPlus className="h-4 w-4 mr-2" />
              {createButtonText}
            </button>
          )}
        </div>
      </div>
    );
  };

  const renderContent = () => {
    if (isLoading) return <LoadingState />;
    if (error) return <ErrorState />;
    if (data.length === 0) return <EmptyState />;

    const contentClass = viewMode === 'grid' 
      ? "grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4 p-4"
      : "divide-y divide-gray-100 dark:divide-gray-700";

    return (
      <div className={contentClass}>
        {data.map((item) => {
          const isSelected = selectedItemId === item.id;
          
          if (viewMode === 'grid' && renderGridItem) {
            return renderGridItem(item, isSelected, () => handleItemSelect(item));
          } else if (viewMode === 'tree' && renderTreeItem) {
            return renderTreeItem(item, 0, isSelected, false, () => handleItemSelect(item), () => {});
          } else if (renderListItem) {
            return renderListItem(item, isSelected, () => handleItemSelect(item));
          }
          
          // Fallback default rendering
          return (
            <div
              key={item.id}
              onClick={() => handleItemSelect(item)}
              className={`p-4 cursor-pointer hover:bg-gray-50 dark:hover:bg-gray-700 ${
                isSelected ? 'bg-blue-50 dark:bg-blue-900/20' : ''
              }`}
            >
              <div className="font-medium text-gray-900 dark:text-white">
                {item.name || item.title || item.id}
              </div>
              {item.description && (
                <div className="text-sm text-gray-500 dark:text-gray-400 mt-1">
                  {item.description}
                </div>
              )}
            </div>
          );
        })}
      </div>
    );
  };

  return (
    <div className={`flex flex-col lg:flex-row lg:h-[calc(100vh-80px)] ${className}`}>
      {/* Left Panel - List */}
      <div
        className={`flex-1 flex flex-col ${
          detailsPanelVisible ? "hidden lg:flex" : "flex"
        } lg:border-r lg:border-gray-200 lg:dark:border-gray-700 ${listClassName}`}
      >
        <SearchAndFiltersSection />
        
        <div className="flex-1 overflow-y-auto bg-white dark:bg-gray-800">
          {renderContent()}
        </div>
      </div>

      {/* Right Panel - Details */}
      <div
        className={`${
          detailsPanelVisible ? "flex" : "hidden lg:flex"
        } flex-col w-full lg:w-96 xl:w-1/3 bg-white dark:bg-gray-800 border-t lg:border-t-0 border-gray-200 dark:border-gray-700 ${detailsClassName}`}
      >
        {/* Mobile Details Header */}
        <div className="sticky top-0 z-10 bg-white dark:bg-gray-800 border-b border-gray-200 dark:border-gray-700 px-4 py-3 lg:hidden">
          <div className="flex items-center justify-between">
            <h2 className="text-lg font-medium text-gray-900 dark:text-white">
              {detailsTitle}
            </h2>
            <button
              onClick={() => setDetailsPanelVisible(false)}
              className="p-2 rounded-md text-gray-400 hover:text-gray-600 dark:hover:text-gray-300"
            >
              <FiX className="h-5 w-5" />
            </button>
          </div>
        </div>

        {/* Desktop Details Header */}
        <div className="hidden lg:block border-b border-gray-200 dark:border-gray-700 px-4 py-3">
          <h2 className="text-lg font-medium text-gray-900 dark:text-white">
            {detailsTitle}
          </h2>
        </div>

        <div className="flex-1 overflow-y-auto">
          {selectedItem && renderDetailsPanel ? (
            renderDetailsPanel(selectedItem)
          ) : (
            <div className="flex items-center justify-center h-full p-8">
              <div className="text-center">
                <FiInfo className="h-12 w-12 text-gray-300 dark:text-gray-600 mx-auto mb-4" />
                <p className="text-gray-500 dark:text-gray-400">
                  Select an item to view details
                </p>
              </div>
            </div>
          )}
        </div>
      </div>
    </div>
  );
};

export default DataListView;


// // Example usage component
// const ExampleUsage = () => {
//   const [searchTerm, setSearchTerm] = useState('');
//   const [selectedId, setSelectedId] = useState(null);
//   const [viewMode, setViewMode] = useState('list');
//   const [showFilters, setShowFilters] = useState(false);
//   const [filters, setFilters] = useState({});

//   // Mock data
//   const sampleData = [
//     { id: '1', name: 'Software Engineer', description: 'Develops applications', department: 'Engineering', status: 'active' },
//     { id: '2', name: 'Product Manager', description: 'Manages product roadmap', department: 'Product', status: 'active' },
//     { id: '3', name: 'UX Designer', description: 'Designs user experiences', department: 'Design', status: 'inactive' },
//     { id: '4', name: 'Data Analyst', description: 'Analyzes business data', department: 'Analytics', status: 'active' },
//   ];

//   const filteredData = sampleData.filter((item) => {
//     const matchesSearch = item.name.toLowerCase().includes(searchTerm.toLowerCase());
//     const matchesStatus = !filters.status || item.status === filters.status;
//     const matchesDepartment = !filters.department || item.department === filters.department;
//     return matchesSearch && matchesStatus && matchesDepartment;
//   });

//   const handleFilterChange = (newFilters) => {
//     setFilters({ ...filters, ...newFilters });
//   };

//   const handleClearFilters = () => {
//     setFilters({});
//   };

//   const handleItemSelect = (item) => {
//     setSelectedId(item.id);
//   };

//   const handleCreateNew = () => {
//     alert('Create new position');
//   };

//   const handleSearchChange = (value) => {
//     setSearchTerm(value);
//   };

//   const handleToggleFilters = () => {
//     setShowFilters(!showFilters);
//   };

//   const handleViewModeChange = (mode) => {
//     setViewMode(mode);
//   };

//   const renderListItem = (item, isSelected, onSelect) => (
//     <div
//       key={item.id}
//       onClick={onSelect}
//       className={`p-4 cursor-pointer hover:bg-gray-50 dark:hover:bg-gray-700 ${
//         isSelected ? 'bg-blue-50 dark:bg-blue-900/20 border-r-2 border-blue-600' : ''
//       }`}
//     >
//       <div className="flex justify-between items-start">
//         <div>
//           <h3 className="font-medium text-gray-900 dark:text-white">
//             {item.name}
//           </h3>
//           <p className="text-sm text-gray-500 dark:text-gray-400 mt-1">
//             {item.description}
//           </p>
//         </div>
//         <div className="flex flex-col items-end space-y-1">
//           <span className="inline-flex items-center px-2.5 py-0.5 rounded-full text-xs font-medium bg-gray-100 text-gray-800 dark:bg-gray-700 dark:text-gray-200">
//             {item.department}
//           </span>
//           <span className={`inline-flex items-center px-2.5 py-0.5 rounded-full text-xs font-medium ${
//             item.status === 'active' 
//               ? 'bg-green-100 text-green-800 dark:bg-green-900/20 dark:text-green-400'
//               : 'bg-red-100 text-red-800 dark:bg-red-900/20 dark:text-red-400'
//           }`}>
//             {item.status}
//           </span>
//         </div>
//       </div>
//     </div>
//   );

//   const renderFiltersComponent = (currentFilters, onFilterChange, onClearFilters) => (
//     <div className="pt-3 space-y-3">
//       <div className="grid grid-cols-1 md:grid-cols-2 gap-3">
//         <div>
//           <label className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-1">
//             Status
//           </label>
//           <select
//             value={currentFilters.status || ''}
//             onChange={(e) => onFilterChange({ status: e.target.value || undefined })}
//             className="w-full px-3 py-2 border border-gray-300 rounded-md focus:ring-blue-500 focus:border-blue-500 dark:bg-gray-700 dark:border-gray-600 dark:text-white"
//           >
//             <option value="">All Status</option>
//             <option value="active">Active</option>
//             <option value="inactive">Inactive</option>
//           </select>
//         </div>
//         <div>
//           <label className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-1">
//             Department
//           </label>
//           <select
//             value={currentFilters.department || ''}
//             onChange={(e) => onFilterChange({ department: e.target.value || undefined })}
//             className="w-full px-3 py-2 border border-gray-300 rounded-md focus:ring-blue-500 focus:border-blue-500 dark:bg-gray-700 dark:border-gray-600 dark:text-white"
//           >
//             <option value="">All Departments</option>
//             <option value="Engineering">Engineering</option>
//             <option value="Product">Product</option>
//             <option value="Design">Design</option>
//             <option value="Analytics">Analytics</option>
//           </select>
//         </div>
//       </div>
//       <div className="flex justify-end">
//         <button
//           onClick={onClearFilters}
//           className="px-3 py-1 text-sm text-gray-600 hover:text-gray-800 dark:text-gray-400 dark:hover:text-gray-200"
//         >
//           Clear Filters
//         </button>
//       </div>
//     </div>
//   );

//   const renderDetailsPanelComponent = (item) => (
//     <div className="p-6">
//       <h3 className="text-lg font-semibold text-gray-900 dark:text-white mb-4">
//         {item.name}
//       </h3>
//       <div className="space-y-4">
//         <div>
//           <label className="text-sm font-medium text-gray-500 dark:text-gray-400">
//             Description
//           </label>
//           <p className="text-gray-900 dark:text-white mt-1">
//             {item.description}
//           </p>
//         </div>
//         <div>
//           <label className="text-sm font-medium text-gray-500 dark:text-gray-400">
//             Department
//           </label>
//           <p className="text-gray-900 dark:text-white mt-1">
//             {item.department}
//           </p>
//         </div>
//         <div>
//           <label className="text-sm font-medium text-gray-500 dark:text-gray-400">
//             Status
//           </label>
//           <span className={`inline-flex items-center px-2.5 py-0.5 rounded-full text-xs font-medium mt-1 ${
//             item.status === 'active' 
//               ? 'bg-green-100 text-green-800 dark:bg-green-900/20 dark:text-green-400'
//               : 'bg-red-100 text-red-800 dark:bg-red-900/20 dark:text-red-400'
//           }`}>
//             {item.status}
//           </span>
//         </div>
//       </div>
//       <div className="mt-6 flex space-x-3">
//         <button className="px-4 py-2 bg-blue-600 text-white rounded-md hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-blue-500">
//           Edit
//         </button>
//         <button className="px-4 py-2 bg-red-600 text-white rounded-md hover:bg-red-700 focus:outline-none focus:ring-2 focus:ring-red-500">
//           Delete
//         </button>
//       </div>
//     </div>
//   );

//   return (
//     <div className="h-screen bg-gray-50 dark:bg-gray-900">
//       <DataListView
//         data={filteredData}
//         searchTerm={searchTerm}
//         onSearchChange={handleSearchChange}
//         searchPlaceholder="Search positions..."
//         showFilters={showFilters}
//         onToggleFilters={handleToggleFilters}
//         filters={filters}
//         onFilterChange={handleFilterChange}
//         onClearFilters={handleClearFilters}
//         selectedItemId={selectedId}
//         onItemSelect={handleItemSelect}
//         viewMode={viewMode}
//         onViewModeChange={handleViewModeChange}
//         detailsTitle="Position Details"
//         emptyStateTitle="No positions found"
//         emptyStateDescription="Try adjusting your search criteria."
//         createButtonText="Add Position"
//         onCreateNew={handleCreateNew}
//         renderListItem={renderListItem}
//         renderFilters={renderFiltersComponent}
//         renderDetailsPanel={renderDetailsPanelComponent}
//       />
//     </div>
//   );
// };

// export default ExampleUsage;
```

<!-- path: components/common/form/IPAddressInput.tsx -->
```typescript
import React, { useState, useCallback, useEffect } from 'react';
import { AlertCircle, CheckCircle2, Globe } from 'lucide-react';
// import { Label } from '@/components/common/ui';

// The ValidationState type remains useful for internal logic
interface ValidationState {
  isValid: boolean | null;
  type: 'IPv4' | 'IPv6' | null;
  error: string | null;
}

// Props are simplified. We now only expect a simple onChange.
interface IPAddressInputProps {
  value?: string;
  onChange?: (value: string) => void;
  placeholder?: string;
  allowIPv4?: boolean;
  allowIPv6?: boolean;
  className?: string;
}

const IPAddressInput: React.FC<IPAddressInputProps> = ({
  value = '',
  onChange = () => {},
  placeholder = 'Enter IP address',
  allowIPv4 = true,
  allowIPv6 = true,
  className = '',
}) => {
  const [validationState, setValidationState] = useState<ValidationState>({
    isValid: null,
    type: null,
    error: null,
  });

  // IPv4 validation
  const isValidIPv4 = useCallback((ip: string): boolean => {
    const ipv4Regex = /^(\d{1,3})\.(\d{1,3})\.(\d{1,3})\.(\d{1,3})$/;
    const match = ip.match(ipv4Regex);
    if (!match) return false;

    return match.slice(1).every((octet) => {
      const num = parseInt(octet, 10);
      return num >= 0 && num <= 255 && octet === num.toString();
    });
  }, []);

  const isValidIPv6Basic = useCallback((ip: string): boolean => {
    // Normalize the IPv6 address
    const normalized = ip.toLowerCase();

    // Handle :: compression
    if (normalized.includes('::')) {
      const parts = normalized.split('::');
      if (parts.length > 2) return false; // More than one ::

      const leftParts = parts[0] ? parts[0].split(':') : [];
      const rightParts = parts[1] ? parts[1].split(':') : [];
      const totalParts = leftParts.length + rightParts.length;

      if (totalParts > 8) return false;
    } else {
      // No compression, should have exactly 8 parts
      const parts = normalized.split(':');
      if (parts.length !== 8) return false;
    }

    // Validate each hexadecimal group
    const hexGroups = normalized
      .split('::')
      .join(':')
      .split(':')
      .filter((part) => part !== '');
    return hexGroups.every((group) => {
      if (group.length === 0 || group.length > 4) return false;
      return /^[0-9a-f]+$/i.test(group);
    });
  }, []);

  // IPv6 validation
  const isValidIPv6 = useCallback(
    (ip: string): boolean => {
      // Handle IPv6 with embedded IPv4
      const ipv6WithIPv4Regex =
        /^([0-9a-fA-F:]+):(\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3})$/;
      if (ipv6WithIPv4Regex.test(ip)) {
        const parts = ip.split(':');
        const ipv4Part = parts[parts.length - 1];
        const ipv6Part = parts.slice(0, -1).join(':') + ':';
        return isValidIPv4(ipv4Part) && isValidIPv6Basic(ipv6Part.slice(0, -1));
      }

      return isValidIPv6Basic(ip);
    },
    [isValidIPv4, isValidIPv6Basic]
  );

  const validateIP = useCallback(
    (ip: string): ValidationState => {
      if (!ip.trim()) {
        return { isValid: null, type: null, error: null };
      }

      let isIPv4Valid = false;
      let isIPv6Valid = false;

      if (allowIPv4) {
        isIPv4Valid = isValidIPv4(ip);
      }

      if (allowIPv6) {
        isIPv6Valid = isValidIPv6(ip);
      }

      if (isIPv4Valid) {
        return { isValid: true, type: 'IPv4', error: null };
      } else if (isIPv6Valid) {
        return { isValid: true, type: 'IPv6', error: null };
      } else {
        let error = 'Invalid IP address format';
        if (!allowIPv4 && !allowIPv6) {
          error = 'IP address input is disabled';
        } else if (!allowIPv4) {
          error = 'Only IPv6 addresses are allowed';
        } else if (!allowIPv6) {
          error = 'Only IPv4 addresses are allowed';
        }
        return { isValid: false, type: null, error };
      }
    },
    [allowIPv4, allowIPv6, isValidIPv4, isValidIPv6]
  );

  // const formatIPv6 = (ip: string): string => {
  //   // Basic IPv6 formatting - expand compressed notation for display
  //   if (!ip.includes('::')) return ip;

  //   const parts = ip.split('::');
  //   const leftParts = parts[0] ? parts[0].split(':') : [];
  //   const rightParts = parts[1] ? parts[1].split(':') : [];
  //   const missingParts = 8 - leftParts.length - rightParts.length;

  //   const expanded = [
  //     ...leftParts,
  //     ...Array(missingParts).fill('0000'),
  //     ...rightParts,
  //   ];

  //   return expanded.map((part) => part.padStart(4, '0')).join(':');
  // };

  // Update validation state whenever the prop value changes from the outside (e.g., from react-hook-form)
  useEffect(() => {
    setValidationState(validateIP(value));
  }, [value, validateIP]);

  const handleInputChange = (e: React.ChangeEvent<HTMLInputElement>): void => {
    const newValue = e.target.value;
    // We call the onChange from props directly, letting react-hook-form manage the state.
    onChange(newValue);
  };

  const getInputClass = (): string => {
    let baseClass = `w-full px-4 py-3 border rounded-lg transition-all duration-200 font-mono text-sm ${className}`;

    if (validationState.isValid === true) {
      baseClass +=
        ' border-green-500 bg-green-50 focus:border-green-600 focus:ring-2 focus:ring-green-200 dark:bg-green-900/20 dark:border-green-600 dark:focus:border-green-500 dark:focus:ring-green-500/20';
    } else if (validationState.isValid === false) {
      baseClass +=
        ' border-red-500 bg-red-50 focus:border-red-600 focus:ring-2 focus:ring-red-200 dark:bg-red-900/20 dark:border-red-600 dark:focus:border-red-500 dark:focus:ring-red-500/20';
    } else {
      baseClass +=
        ' border-gray-300 bg-white focus:border-blue-500 focus:ring-2 focus:ring-blue-200 dark:bg-gray-800 dark:border-gray-600 dark:text-white dark:focus:border-blue-400 dark:focus:ring-blue-400/20';
    }

    return baseClass;
  };

  return (
    <div className="w-full">
      <div className="relative">
        <input
          type="text"
          value={value} // Directly use the value from props
          onChange={handleInputChange}
          placeholder={placeholder}
          className={getInputClass()}
          autoComplete="off"
          spellCheck="false"
        />

        <div className="absolute right-3 top-1/2 transform -translate-y-1/2">
          {validationState.isValid === true && (
            <CheckCircle2 className="w-5 h-5 text-green-500 dark:text-green-400" />
          )}
          {validationState.isValid === false && (
            <AlertCircle className="w-5 h-5 text-red-500 dark:text-red-400" />
          )}
          {validationState.isValid === null && value && (
            <Globe className="w-5 h-5 text-gray-400 dark:text-gray-500" />
          )}
        </div>
      </div>

      <div className="mt-2 min-h-[1.5rem]">
        {validationState.isValid === false && (
          <div className="flex items-center gap-2 text-sm text-red-600 dark:text-red-400">
            <AlertCircle className="w-4 h-4" />
            <span>{validationState.error}</span>
          </div>
        )}
      </div>
    </div>
  );
};

export default IPAddressInput;

```

<!-- path: components/common/form/SectionCard.tsx -->
```typescript
import { ReactNode } from "react";
import { cn } from "@/utils/classNames";

interface SectionCardProps {
  title: string;
  icon?: ReactNode;
  children: ReactNode;
  className?: string;
}

export default function SectionCard({
  title,
  icon,
  children,
  className,
}: SectionCardProps) {
  return (
    <div
      className={cn(
        "border rounded-xl p-4 space-y-4 bg-white shadow-sm",
        "transition-all duration-200 hover:shadow-md",
        className
      )}
    >
      <div className="flex items-center space-x-2 border-b pb-2">
        {icon && <span className="text-xl text-primary">{icon}</span>}
        <h3 className="font-semibold text-gray-800 text-base">{title}</h3>
      </div>
      <div className="grid gap-4">{children}</div>
    </div>
  );
}

```

<!-- path: components/common/form/FormControls.tsx -->
```typescript
/* eslint-disable @typescript-eslint/no-explicit-any */
'use client';

import {
  Control,
  Controller,
  FieldError,
  FieldErrorsImpl,
  Merge,
  UseFormRegister,
  Path,
  FieldValues,
} from 'react-hook-form';
import {
  SearchableSelect,
  Option,
} from '@/components/common/ui/select/SearchableSelect';
import { Input } from '@/components/common/ui/Input';
import { Textarea } from '@/components/common/ui/textarea/Textarea';
import { Label, Switch } from '@/components/common/ui';
import { forwardRef } from 'react';
import DatePicker, { type DatePickerProps } from 'react-datepicker';
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from '@/components/common/ui/select/Select';
import IPAddressInput from '@/components/common/form/IPAddressInput';

// --- TYPE DEFINITIONS for Generic Components ---

type BaseProps<T extends FieldValues> = {
  name: Path<T>;
  label: string;
  error?: FieldError | Merge<FieldError, FieldErrorsImpl<any>>;
  required?: boolean;
  className?: string;
  labelClassName?: string;
};

// --- FORM INPUT COMPONENT ---

interface FormInputProps<T extends FieldValues>
  extends BaseProps<T>,
    Omit<React.InputHTMLAttributes<HTMLInputElement>, 'name' | 'size'> {
  register: UseFormRegister<T>;
}

export function FormInput<T extends FieldValues>({
  name,
  register,
  label,
  error,
  type = 'text',
  className,
  labelClassName,
  ...props
}: FormInputProps<T>) {
  return (
    <div className={className}>
      <Label
        htmlFor={name}
        required={props.required}
        className={labelClassName}
      >
        {label}
      </Label>
      <Input
        id={name}
        type={type}
        error={typeof error?.message === 'string' ? error.message : undefined}
        {...props}
        {...register(name, {
          // For number inputs, treat empty string as null and otherwise coerce to Number
          ...(type === 'number' && {
            setValueAs: (v) =>
              v === '' || v === null || typeof v === 'undefined' ? null : Number(v),
          }),
          // For date inputs, map empty to null and non-empty to Date object
          ...(type === 'date' && {
            setValueAs: (v) => (v ? new Date(v) : null),
          }),
        })}
      />
    </div>
  );
}

// --- FORM TEXTAREA COMPONENT ---

interface FormTextareaProps<T extends FieldValues>
  extends BaseProps<T>,
    Omit<
      React.TextareaHTMLAttributes<HTMLTextAreaElement>,
      'name' | 'value' | 'onChange'
    > {
  register?: UseFormRegister<T>;
  control?: Control<T>;
}

export function FormTextarea<T extends FieldValues>({
  name,
  control,
  label,
  error,
  className,
  labelClassName,
  ...props
}: FormTextareaProps<T>) {
  return (
    <div className={className}>
      <Label
        htmlFor={name}
        required={props.required}
        className={labelClassName}
      >
        {label}
      </Label>
      {control ? (
        <Controller
          name={name}
          control={control}
          render={({ field }) => (
            <Textarea
              id={name}
              value={(field.value as string) ?? ''}
              onChange={(_e, val) => field.onChange(val)}
              onBlur={field.onBlur}
              error={!!error}
              errorMessage={
                typeof error?.message === 'string' ? error.message : undefined
              }
              {...props}
            />
          )}
        />
      ) : (
        <Textarea
          id={name}
          error={!!error}
          errorMessage={
            typeof error?.message === 'string' ? error.message : undefined
          }
          {...props}
        />
      )}
    </div>
  );
}

// --- FORM SEARCHABLE SELECT COMPONENT ---

interface FormSearchableSelectProps<T extends FieldValues>
  extends BaseProps<T> {
  control: Control<T>;
  options: Option[];
  placeholder?: string;
  searchPlaceholder?: string;
  disabled?: boolean;
  clearable?: boolean;
}

export function FormSearchableSelect<T extends FieldValues>({
  name,
  control,
  label,
  options,
  error,
  className,
  labelClassName,
  ...props
}: FormSearchableSelectProps<T>) {
  // console.log("options",options);

  return (
    <div className={className}>
      <Label
        htmlFor={name}
        required={props.required}
        className={labelClassName}
      >
        {label}
      </Label>
      <Controller
        name={name}
        control={control}
        render={({ field }) => (
          <SearchableSelect
            {...props}
            value={(field.value as string) ?? ''}
            onChange={(value) => field.onChange(value === '' ? '' : value)}
            options={options}
            error={!!error}
          />
        )}
      />
      {error && (
        <p className="mt-1 text-sm text-red-500">
          {typeof error?.message === 'string' ? error.message : null}
        </p>
      )}
    </div>
  );
}

// --- FORM SELECT COMPONENT ---

interface FormSelectProps<T extends FieldValues> extends BaseProps<T> {
  control: Control<T>;
  options: Option[];
  placeholder?: string;
  searchPlaceholder?: string;
  disabled?: boolean;
  clearable?: boolean;
}

export function FormSelect<T extends FieldValues>({
  name,
  control,
  label,
  options,
  error,
  className,
  labelClassName,
  ...props
}: FormSelectProps<T>) {
  return (
    <div className={className}>
      <Label
        htmlFor={name}
        required={props.required}
        className={labelClassName}
      >
        {label}
      </Label>
      <Controller
        name={name}
        control={control}
        render={({ field }) => (
          <Select
            {...props}
            value={(field.value as string) ?? ''}
            onValueChange={(value) => field.onChange(value)}
          >
            <SelectTrigger className="w-full" aria-invalid={!!error}>
              <SelectValue placeholder={props.placeholder ?? 'Select'} />
            </SelectTrigger>
            <SelectContent>
              {options.map((option) => (
                <SelectItem
                  key={option.value}
                  value={option.value}
                  disabled={option.disabled}
                >
                  {option.label}
                </SelectItem>
              ))}
            </SelectContent>
          </Select>
        )}
      />
      {error && (
        <p className="mt-1 text-sm text-red-500">
          {typeof error?.message === 'string' ? error.message : null}
        </p>
      )}
    </div>
  );
}

// --- FORM DATE INPUT COMPONENT ---

// Keep your original prop intent; allow passing datepicker props safely
export interface FormDateInputProps<T extends FieldValues>
  extends BaseProps<T>,
    Omit<
      React.InputHTMLAttributes<HTMLInputElement>,
      'name' | 'type' | 'size'
    > {
  control: Control<T>;
  // Optional passthrough for DatePicker props (minDate, maxDate, showTimeSelect, etc.)
  pickerProps?: Partial<
    Omit<
      DatePickerProps,
      // Keep single-date mode: exclude props that change `onChange` signature
      | 'selected'
      | 'onChange'
      | 'customInput'
      | 'onBlur'
      | 'onSelect'
      | 'selectsRange'
      | 'selectsMultiple'
      | 'startDate'
      | 'endDate'
    >
  >;
}

/** A styled input used as ReactDatePicker's customInput to control theme + icon */
const DateTextInput = forwardRef<
  HTMLInputElement,
  React.InputHTMLAttributes<HTMLInputElement> & { errorText?: string }
>(({ className, errorText, ...rest }, ref) => {
  return (
    <div className="relative">
      <input
        ref={ref}
        {...rest}
        className={[
          'w-full rounded-md border bg-white text-gray-900',
          'dark:bg-gray-900 dark:text-gray-100 dark:border-gray-700',
          'px-10 py-2 outline-none',
          'focus:ring-2 focus:ring-blue-500 focus:border-blue-500',
          errorText
            ? 'border-red-500 focus:ring-red-500 focus:border-red-500'
            : 'border-gray-300',
          className ?? '',
        ].join(' ')}
        readOnly // recommended with customInput to avoid parsing issues
      />
      {/* Calendar icon (theme-aware via currentColor) */}
      <svg
        className="pointer-events-none absolute left-3 top-1/2 h-5 w-5 -translate-y-1/2 text-gray-500 dark:text-gray-300"
        viewBox="0 0 24 24"
        fill="none"
        stroke="currentColor"
        strokeWidth="2"
        strokeLinecap="round"
        strokeLinejoin="round"
        aria-hidden="true"
      >
        <rect x="3" y="4" width="18" height="18" rx="2" />
        <line x1="16" y1="2" x2="16" y2="6" />
        <line x1="8" y1="2" x2="8" y2="6" />
        <line x1="3" y1="10" x2="21" y2="10" />
      </svg>
      {errorText ? (
        <p className="mt-1 text-sm text-red-600">{errorText}</p>
      ) : null}
    </div>
  );
});
DateTextInput.displayName = 'DateTextInput';

export function FormDateInput<T extends FieldValues>({
  name,
  control,
  label,
  error,
  className,
  labelClassName,
  pickerProps,
  required,
  ...inputProps
}: FormDateInputProps<T>) {
  return (
    <div className={className}>
      {label ? (
        <Label htmlFor={name} className={labelClassName}>
          {label}
          {required ? <span className="ml-0.5 text-red-600">*</span> : null}
        </Label>
      ) : null}

      <Controller
        name={name}
        control={control}
        render={({ field }) => {
          // Normalize value to Date | null
          const raw = field.value as unknown;
          const selected: Date | null =
            raw == null || (raw as any) === ''
              ? null
              : typeof raw === 'object' &&
                raw !== null &&
                'getTime' in (raw as object)
              ? (raw as Date)
              : new Date(raw as any);

          return (
            // @ts-expect-error react-datepicker's prop union sometimes misinfers to multi-select variant.
            // We intentionally use single-date mode: `selected: Date | null` and `onChange(date | null)`.
            <DatePicker
              id={name}
              // --- recommended defaults for date-only fields ---
              selected={selected}
              onChange={(d: Date | null) =>
                field.onChange(d ? d.toISOString().split('T')[0] : null)
              }
              onBlur={field.onBlur}
              // Keep keyboard nav and accessibility
              // Use a date-only format; adjust as you like
              dateFormat={(pickerProps as any)?.dateFormat ?? 'yyyy-MM-dd'}
              // Show clear button by default; optional
              isClearable
              // Enable year and month dropdowns
              showMonthDropdown
              showYearDropdown
              dropdownMode="select" // Makes dropdowns selectable instead of scrollable
              // You can also set year range if needed
              yearDropdownItemNumber={15} // Shows 15 years in dropdown
              // Render portal into Next.js root so it appears above modals/overflows
              portalId="__next"
              // Custom input so we fully control theme + icon
              customInput={
                <DateTextInput
                  errorText={
                    typeof error?.message === 'string'
                      ? error.message
                      : undefined
                  }
                  placeholder={inputProps.placeholder ?? 'Select date'}
                />
              }
              // Pass through any extra ReactDatePicker props (minDate, maxDate, showTimeSelect, etc.)
              {...pickerProps}
            />
          );
        }}
      />
    </div>
  );
}

// --- FORM SWITCH COMPONENT ---

interface FormSwitchProps<T extends FieldValues> extends BaseProps<T> {
  control: Control<T>;
  description?: string;
}

export function FormSwitch<T extends FieldValues>({
  name,
  control,
  label,
  error,
  description,
  className,
}: FormSwitchProps<T>) {
  return (
    <div className={className}>
      <Controller
        name={name}
        control={control}
        render={({ field }) => (
          <div className="flex items-center space-x-2">
            <Switch
              id={name}
              checked={!!field.value}
              onChange={(checked: boolean) => field.onChange(checked)}
            />
            <div>
              <Label htmlFor={name}>{label}</Label>
              {description && (
                <p className="text-xs text-gray-500">{description}</p>
              )}
            </div>
          </div>
        )}
      />
      {error && (
        <p className="mt-1 text-sm text-red-500">
          {typeof error?.message === 'string' ? error.message : null}
        </p>
      )}
    </div>
  );
}

// --- FORM IP ADDRESS COMPONENT ---

interface FormIPAddressInputProps<T extends FieldValues> extends BaseProps<T> {
  control: Control<T>;
  placeholder?: string;
  allowIPv4?: boolean;
  allowIPv6?: boolean;
}

export function FormIPAddressInput<T extends FieldValues>({
  name,
  control,
  label,
  error,
  className,
  labelClassName,
  ...props
}: FormIPAddressInputProps<T>) {
  return (
    <div className={className}>
      <Label
        htmlFor={name}
        required={props.required}
        className={labelClassName}
      >
        {label}
      </Label>
      <Controller
        name={name}
        control={control}
        render={({ field }) => (
          <IPAddressInput
            {...props} // Pass through placeholder, allowIPv4, etc.
            value={field.value || ''} // Get value from react-hook-form
            onChange={field.onChange} // Use react-hook-form's onChange
          />
        )}
      />
      {error && (
        <p className="mt-1 text-sm text-red-500">
          {typeof error?.message === 'string' ? error.message : 'Invalid input'}
        </p>
      )}
    </div>
  );
}

```

<!-- path: components/common/form/FormCard.tsx -->
```typescript
import React from "react";
import { cn } from "@/utils/classNames";

interface FormCardProps {
  title: string;
  subtitle?: string;
  isLoading?: boolean;
  onCancel: () => void;
  onSubmit?: React.FormEventHandler<HTMLFormElement>;
  submitText?: string;
  cancelText?: string;
  children: React.ReactNode;
  footerContent?: React.ReactNode;
  widthClass?: string;
  disableSubmit?: boolean;
  heightClass?: string;
  standalone?: boolean; // New prop to control backdrop behavior
}

export const FormCard: React.FC<FormCardProps> = ({
  title,
  subtitle,
  isLoading = false,
  onCancel,
  onSubmit,
  submitText = "Submit",
  cancelText = "Cancel",
  children,
  footerContent,
  widthClass = "max-w-3xl",
  heightClass = "max-h-[90vh]",
  disableSubmit = false,
  standalone = false, // Default to false - no backdrop
}) => {
  const modalContent = (
    <div
      className={cn(
        "w-full overflow-hidden rounded-xl bg-white shadow-2xl dark:bg-gray-900 dark:border dark:border-gray-700 flex flex-col transform mx-auto",
        widthClass,
        heightClass
      )}
      style={{
        animation: "slideInScale 0.4s cubic-bezier(0.34, 1.56, 0.64, 1)",
        boxShadow: "0 25px 50px -12px rgba(0, 0, 0, 0.4), 0 0 0 1px rgba(255, 255, 255, 0.05)"
      }}
      onClick={(e) => e.stopPropagation()}
    >
      {/* Header */}
      <div 
        className="flex-shrink-0 px-6 py-4 border-b border-gray-200 dark:border-gray-700 flex items-center justify-between"
        style={{
          animation: "slideDown 0.5s ease-out 0.1s both"
        }}
      >
        <div>
          <h2 
            className="text-2xl font-bold text-gray-900 dark:text-white"
            style={{
              animation: "fadeInUp 0.6s ease-out 0.2s both"
            }}
          >
            {title}
          </h2>
          {subtitle && (
            <p 
              className="text-gray-600 dark:text-gray-400 text-sm mt-1"
              style={{
                animation: "fadeInUp 0.6s ease-out 0.3s both"
              }}
            >
              {subtitle}
            </p>
          )}
        </div>
        <button
          onClick={onCancel}
          disabled={isLoading}
          className="text-gray-400 hover:text-gray-600 dark:text-gray-500 dark:hover:text-gray-300 hover:bg-gray-100 dark:hover:bg-gray-800 rounded-full p-2 transition-all duration-300 hover:scale-110 hover:rotate-90"
          style={{
            animation: "fadeInRotate 0.5s ease-out 0.2s both"
          }}
        >
          <svg className="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M6 18L18 6M6 6l12 12" />
          </svg>
        </button>
      </div>

      {/* Form Body + Footer */}
      <form onSubmit={onSubmit} className="flex flex-col flex-1 min-h-0">
        {/* Body */}
        <div 
          className="flex-1 overflow-y-auto relative min-h-0"
          style={{
            animation: "fadeInUp 0.6s ease-out 0.3s both"
          }}
        >
          {isLoading && (
            <div 
              className="absolute inset-0 bg-white/80 dark:bg-gray-900/80 backdrop-blur-sm flex items-center justify-center z-10"
              style={{
                animation: "fadeIn 0.3s ease-out"
              }}
            >
              <div className="flex items-center space-x-2">
                <div 
                  className="w-4 h-4 bg-blue-600 rounded-full"
                  style={{
                    animation: "bounce 1.4s ease-in-out infinite both"
                  }}
                ></div>
                <div 
                  className="w-4 h-4 bg-blue-600 rounded-full"
                  style={{
                    animation: "bounce 1.4s ease-in-out 0.16s infinite both"
                  }}
                ></div>
                <div 
                  className="w-4 h-4 bg-blue-600 rounded-full"
                  style={{
                    animation: "bounce 1.4s ease-in-out 0.32s infinite both"
                  }}
                ></div>
                <span className="text-gray-600 dark:text-gray-300 ml-3">Loading...</span>
              </div>
            </div>
          )}
          <div className="p-6">{children}</div>
        </div>

        {/* Footer */}
        <div 
          className="flex-shrink-0 px-6 py-4 border-t border-gray-200 dark:border-gray-700 flex justify-between items-center bg-gray-50 dark:bg-gray-800/50"
          style={{
            animation: "slideUp 0.5s ease-out 0.4s both"
          }}
        >
          {footerContent ? (
            footerContent
          ) : (
            <div className="flex justify-end space-x-3 w-full">
              <button
                type="button"
                onClick={onCancel}
                disabled={isLoading}
                className="px-6 py-2 border rounded-md dark:border-gray-600 dark:text-gray-300 dark:hover:bg-gray-700 transition-all duration-300 hover:scale-105 hover:shadow-lg transform"
                style={{
                  animation: "fadeInLeft 0.5s ease-out 0.5s both"
                }}
              >
                {cancelText}
              </button>
              {onSubmit && (
                <button
                  type="submit"
                  disabled={isLoading || disableSubmit}
                  className="px-8 py-2 bg-blue-600 hover:bg-blue-700 dark:bg-blue-600 dark:hover:bg-blue-700 text-white shadow-lg hover:shadow-xl transform hover:-translate-y-1 hover:scale-105 transition-all duration-300 rounded-md"
                  style={{
                    animation: "fadeInRight 0.5s ease-out 0.6s both",
                    background: "linear-gradient(135deg, #3B82F6 0%, #1D4ED8 100%)"
                  }}
                >
                  {submitText}
                </button>
              )}
            </div>
          )}
        </div>
      </form>

      <style jsx>{`
        @keyframes fadeIn {
          from { opacity: 0; }
          to { opacity: 1; }
        }

        @keyframes slideInScale {
          0% {
            opacity: 0;
            transform: translateY(20px) scale(0.95);
          }
          100% {
            opacity: 1;
            transform: translateY(0) scale(1);
          }
        }

        @keyframes slideDown {
          from {
            opacity: 0;
            transform: translateY(-20px);
          }
          to {
            opacity: 1;
            transform: translateY(0);
          }
        }

        @keyframes slideUp {
          from {
            opacity: 0;
            transform: translateY(20px);
          }
          to {
            opacity: 1;
            transform: translateY(0);
          }
        }

        @keyframes fadeInUp {
          from {
            opacity: 0;
            transform: translateY(10px);
          }
          to {
            opacity: 1;
            transform: translateY(0);
          }
        }

        @keyframes fadeInLeft {
          from {
            opacity: 0;
            transform: translateX(-10px);
          }
          to {
            opacity: 1;
            transform: translateX(0);
          }
        }

        @keyframes fadeInRight {
          from {
            opacity: 0;
            transform: translateX(10px);
          }
          to {
            opacity: 1;
            transform: translateX(0);
          }
        }

        @keyframes fadeInRotate {
          from {
            opacity: 0;
            transform: rotate(-90deg) scale(0.8);
          }
          to {
            opacity: 1;
            transform: rotate(0deg) scale(1);
          }
        }

        @keyframes bounce {
          0%, 80%, 100% {
            transform: scale(0);
            opacity: 0.5;
          }
          40% {
            transform: scale(1);
            opacity: 1;
          }
        }
      `}</style>
    </div>
  );

  // If standalone, wrap with backdrop, otherwise return just the modal content
  if (standalone) {
    return (
      <div 
        className="fixed inset-0 z-[9999] flex items-center justify-center p-4"
        style={{
          background: "rgba(0, 0, 0, 0.6)",
          animation: "fadeIn 0.3s ease-out"
        }}
        onClick={(e) => {
          if (e.target === e.currentTarget) {
            onCancel();
          }
        }}
      >
        {modalContent}
      </div>
    );
  }

  // Return just the modal content without backdrop (for use within existing modals)
  return (
    <div className="flex items-center justify-center p-4 w-full">
      {modalContent}
    </div>
  );
};
```

<!-- path: components/common/form/index.ts -->
```typescript
export * from './FormCard';
export * from './FormControls';
export * from './SectionCard';
export * from './IPAddressInput';


```

<!-- path: components/common/ui/badges/RoleBadge.tsx -->
```typescript
// components/users/RoleBadge.tsx
import { UserRole } from "@/types/user-roles";

export const RoleBadge = ({ role }: { role: UserRole }) => {
  const getRoleConfig = (role: UserRole) => {
    switch (role) {
      case UserRole.ADMIN:
        return { 
          bg: "bg-gradient-to-r from-red-500/20 to-pink-500/20 dark:from-red-500/30 dark:to-pink-500/30", 
          text: "text-red-700 dark:text-red-300",
          border: "border-red-200/60 dark:border-red-500/40",
          shadow: "shadow-red-500/20 dark:shadow-red-500/30",
          icon: ""
        };
      case UserRole.MAANADMIN:
        return { 
          bg: "bg-gradient-to-r from-indigo-500/20 to-purple-500/20 dark:from-indigo-500/30 dark:to-purple-500/30", 
          text: "text-indigo-700 dark:text-indigo-300",
          border: "border-indigo-200/60 dark:border-indigo-500/40",
          shadow: "shadow-indigo-500/20 dark:shadow-indigo-500/30",
          icon: ""
        };
      case UserRole.SDHADMIN:
        return { 
          bg: "bg-gradient-to-r from-emerald-500/20 to-teal-500/20 dark:from-emerald-500/30 dark:to-teal-500/30", 
          text: "text-emerald-700 dark:text-emerald-300",
          border: "border-emerald-200/60 dark:border-emerald-500/40",
          shadow: "shadow-emerald-500/20 dark:shadow-emerald-500/30",
          icon: ""
        };
      case UserRole.VMUXADMIN:
        return { 
          bg: "bg-gradient-to-r from-slate-500/20 to-gray-500/20 dark:from-slate-500/30 dark:to-gray-500/30", 
          text: "text-slate-700 dark:text-slate-300",
          border: "border-slate-200/60 dark:border-slate-500/40",
          shadow: "shadow-slate-500/20 dark:shadow-slate-500/30",
          icon: ""
        };
      case UserRole.MNGADMIN:
        return { 
          bg: "bg-gradient-to-r from-amber-500/20 to-orange-500/20 dark:from-amber-500/30 dark:to-orange-500/30", 
          text: "text-amber-700 dark:text-amber-300",
          border: "border-amber-200/60 dark:border-amber-500/40",
          shadow: "shadow-amber-500/20 dark:shadow-amber-500/30",
          icon: ""
        };
      case UserRole.VIEWER:
        return { 
          bg: "bg-gradient-to-r from-gray-400/15 to-slate-400/15 dark:from-gray-500/25 dark:to-slate-500/25", 
          text: "text-gray-600 dark:text-gray-400",
          border: "border-gray-200/50 dark:border-gray-600/40",
          shadow: "shadow-gray-500/10 dark:shadow-gray-500/20",
          icon: ""
        };
      case UserRole.AUTHENTICATED:
        return { 
          bg: "bg-gradient-to-r from-sky-500/20 to-blue-500/20 dark:from-sky-500/30 dark:to-blue-500/30", 
          text: "text-sky-700 dark:text-sky-300",
          border: "border-sky-200/60 dark:border-sky-500/40",
          shadow: "shadow-sky-500/20 dark:shadow-sky-500/30",
          icon: ""
        };
      case UserRole.ANON:
        return { 
          bg: "bg-gradient-to-r from-zinc-400/15 to-stone-400/15 dark:from-zinc-500/25 dark:to-stone-500/25", 
          text: "text-zinc-600 dark:text-zinc-400",
          border: "border-zinc-200/50 dark:border-zinc-600/40",
          shadow: "shadow-zinc-500/10 dark:shadow-zinc-500/20",
          icon: ""
        };
      default:
        return { 
          bg: "bg-gradient-to-r from-neutral-400/15 to-gray-400/15 dark:from-neutral-500/25 dark:to-gray-500/25", 
          text: "text-neutral-600 dark:text-neutral-400",
          border: "border-neutral-200/50 dark:border-neutral-600/40",
          shadow: "shadow-neutral-500/10 dark:shadow-neutral-500/20",
          icon: ""
        };
    }
  };

  const { bg, text, border, shadow, icon } = getRoleConfig(role);
  const displayText = role.replace("_", " ").toLowerCase().replace(/\b\w/g, l => l.toUpperCase());

  return (
    <span
      className={`
        inline-flex items-center gap-1.5 px-3 py-1.5 
        rounded-full text-xs font-semibold tracking-wide
        border backdrop-blur-sm
        transition-all duration-300 ease-out
        hover:scale-105 hover:shadow-lg hover:-translate-y-0.5
        cursor-default select-none
        ${bg} ${text} ${border} ${shadow}
        dark:shadow-lg
      `}
    >
      <span className="text-[10px] leading-none" role="img" aria-hidden="true">
        {icon}
      </span>
      <span className="font-medium">
        {displayText}
      </span>
    </span>
  );
};

```

<!-- path: components/common/ui/badges/StatusBadge.tsx -->
```typescript
// components/users/StatusBadge.tsx

export const StatusBadge = ({ status }: { status: string | boolean | null }) => {
  const getStatusConfig = (status: string | boolean | null) => {
    // Handle null/undefined cases first
    if (status === null || status === undefined) {
      return { 
        bg: "bg-gradient-to-r from-gray-400/15 to-slate-400/15 dark:from-gray-500/25 dark:to-slate-500/25",
        text: "text-gray-600 dark:text-gray-400",
        border: "border-gray-200/50 dark:border-gray-600/40",
        shadow: "shadow-gray-500/10 dark:shadow-gray-500/20",
        dot: "bg-gray-500 dark:bg-gray-400",
        dotShadow: "shadow-gray-500/30",
        label: "Unknown",
        pulse: false
      };
    }

    // Handle boolean cases
    if (typeof status === 'boolean') {
      return status
        ? {
            bg: "bg-gradient-to-r from-green-500/20 to-emerald-500/20 dark:from-green-500/30 dark:to-emerald-500/30",
            text: "text-green-700 dark:text-green-300",
            border: "border-green-200/60 dark:border-green-500/40",
            shadow: "shadow-green-500/20 dark:shadow-green-500/30",
            dot: "bg-green-500 dark:bg-green-400",
            dotShadow: "shadow-green-500/40",
            label: "Active",
            pulse: true
          }
        : {
            bg: "bg-gradient-to-r from-red-500/20 to-rose-500/20 dark:from-red-500/30 dark:to-rose-500/30",
            text: "text-red-700 dark:text-red-300",
            border: "border-red-200/60 dark:border-red-500/40",
            shadow: "shadow-red-500/20 dark:shadow-red-500/30",
            dot: "bg-red-500 dark:bg-red-400",
            dotShadow: "shadow-red-500/40",
            label: "Inactive",
            pulse: false
          };
    }

    // Handle string cases
    switch (status.toLowerCase()) {
      case "active":
        return {
          bg: "bg-gradient-to-r from-green-500/20 to-emerald-500/20 dark:from-green-500/30 dark:to-emerald-500/30",
          text: "text-green-700 dark:text-green-300",
          border: "border-green-200/60 dark:border-green-500/40",
          shadow: "shadow-green-500/20 dark:shadow-green-500/30",
          dot: "bg-green-500 dark:bg-green-400",
          dotShadow: "shadow-green-500/40",
          label: "Active",
          pulse: true
        };
      case "inactive":
        return { 
          bg: "bg-gradient-to-r from-gray-400/15 to-slate-400/15 dark:from-gray-500/25 dark:to-slate-500/25",
          text: "text-gray-600 dark:text-gray-400",
          border: "border-gray-200/50 dark:border-gray-600/40",
          shadow: "shadow-gray-500/10 dark:shadow-gray-500/20",
          dot: "bg-gray-500 dark:bg-gray-400",
          dotShadow: "shadow-gray-500/30",
          label: "Inactive",
          pulse: false
        };
      case "suspended":
        return { 
          bg: "bg-gradient-to-r from-red-500/20 to-orange-500/20 dark:from-red-500/30 dark:to-orange-500/30",
          text: "text-red-700 dark:text-red-300",
          border: "border-red-200/60 dark:border-red-500/40",
          shadow: "shadow-red-500/20 dark:shadow-red-500/30",
          dot: "bg-red-500 dark:bg-red-400",
          dotShadow: "shadow-red-500/40",
          label: "Suspended",
          pulse: false
        };
      case "pending":
        return {
          bg: "bg-gradient-to-r from-amber-500/20 to-yellow-500/20 dark:from-amber-500/30 dark:to-yellow-500/30",
          text: "text-amber-700 dark:text-amber-300",
          border: "border-amber-200/60 dark:border-amber-500/40",
          shadow: "shadow-amber-500/20 dark:shadow-amber-500/30",
          dot: "bg-amber-500 dark:bg-amber-400",
          dotShadow: "shadow-amber-500/40",
          label: "Pending",
          pulse: true
        };
      case "verified":
        return {
          bg: "bg-gradient-to-r from-blue-500/20 to-cyan-500/20 dark:from-blue-500/30 dark:to-cyan-500/30",
          text: "text-blue-700 dark:text-blue-300",
          border: "border-blue-200/60 dark:border-blue-500/40",
          shadow: "shadow-blue-500/20 dark:shadow-blue-500/30",
          dot: "bg-blue-500 dark:bg-blue-400",
          dotShadow: "shadow-blue-500/40",
          label: "Verified",
          pulse: false
        };
      case "banned":
        return {
          bg: "bg-gradient-to-r from-red-600/25 to-red-800/25 dark:from-red-600/35 dark:to-red-800/35",
          text: "text-red-800 dark:text-red-200",
          border: "border-red-300/70 dark:border-red-400/50",
          shadow: "shadow-red-600/25 dark:shadow-red-600/35",
          dot: "bg-red-600 dark:bg-red-500",
          dotShadow: "shadow-red-600/50",
          label: "Banned",
          pulse: false
        };
      case "online":
        return {
          bg: "bg-gradient-to-r from-green-400/25 to-green-600/25 dark:from-green-400/35 dark:to-green-600/35",
          text: "text-green-800 dark:text-green-200",
          border: "border-green-300/70 dark:border-green-400/50",
          shadow: "shadow-green-500/25 dark:shadow-green-500/35",
          dot: "bg-green-500 dark:bg-green-400",
          dotShadow: "shadow-green-500/50",
          label: "Online",
          pulse: true
        };
      case "offline":
        return {
          bg: "bg-gradient-to-r from-slate-400/15 to-gray-500/15 dark:from-slate-500/25 dark:to-gray-600/25",
          text: "text-slate-600 dark:text-slate-400",
          border: "border-slate-200/50 dark:border-slate-600/40",
          shadow: "shadow-slate-500/10 dark:shadow-slate-500/20",
          dot: "bg-slate-500 dark:bg-slate-400",
          dotShadow: "shadow-slate-500/30",
          label: "Offline",
          pulse: false
        };
      default:
        return { 
          bg: "bg-gradient-to-r from-gray-400/15 to-slate-400/15 dark:from-gray-500/25 dark:to-slate-500/25",
          text: "text-gray-600 dark:text-gray-400",
          border: "border-gray-200/50 dark:border-gray-600/40",
          shadow: "shadow-gray-500/10 dark:shadow-gray-500/20",
          dot: "bg-gray-500 dark:bg-gray-400",
          dotShadow: "shadow-gray-500/30",
          label: typeof status === 'string' ? status.charAt(0).toUpperCase() + status.slice(1) : "Unknown",
          pulse: false
        };
    }
  };

  const config = getStatusConfig(status);

  return (
    <span
      className={`
        inline-flex items-center gap-2 px-3 py-1.5
        rounded-full text-xs font-semibold tracking-wide
        border backdrop-blur-sm
        transition-all duration-300 ease-out
        hover:scale-105 hover:shadow-lg hover:-translate-y-0.5
        cursor-default select-none
        ${config.bg} ${config.text} ${config.border} ${config.shadow}
        dark:shadow-lg
      `}
    >
      <span 
        className={`
          relative w-2 h-2 rounded-full shadow-sm
          ${config.dot} ${config.dotShadow}
          ${config.pulse ? 'animate-pulse' : ''}
        `}
      >
        {config.pulse && (
          <span 
            className={`
              absolute inset-0 w-2 h-2 rounded-full opacity-75
              animate-ping
              ${config.dot}
            `}
          />
        )}
      </span>
      <span className="font-medium">
        {config.label}
      </span>
    </span>
  );
};
```

<!-- path: components/common/ui/error/ErrorDisplay.tsx -->
```typescript
import React, { useState, MouseEvent } from "react";

interface ErrorDisplayProps {
  error?: string | string[] | null;
  variant?: "inline" | "alert" | "toast" | "banner";
  severity?: "error" | "warning" | "info";
  size?: "sm" | "md" | "lg";
  showIcon?: boolean;
  dismissible?: boolean;
  onDismiss?: () => void;
  className?: string;
  id?: string;
  title?: string;
  actions?: Array<{
    label: string;
    onClick: () => void;
    variant?: "primary" | "secondary";
  }>;
}

export const ErrorDisplay: React.FC<ErrorDisplayProps> = ({
  error,
  variant = "inline",
  severity = "error",
  size = "md",
  showIcon = true,
  dismissible = false,
  onDismiss,
  className = "",
  id,
  title,
  actions = []
}) => {
  const [dismissed, setDismissed] = useState(false);

  if (!error || dismissed) return null;

  const errorArray = Array.isArray(error) ? error : [error];
  const hasMultipleErrors = errorArray.length > 1;

  const iconConfig = {
    error: {
      icon: (
        <svg className="w-5 h-5" fill="currentColor" viewBox="0 0 20 20">
          <path
            fillRule="evenodd"
            d="M18 10a8 8 0 11-16 0 8 8 0 0116 0zm-7 4a1 1 0 
            11-2 0 1 1 0 012 0zm-1-9a1 1 0 00-1 1v4a1 1 0 
            102 0V6a1 1 0 00-1-1z"
            clipRule="evenodd"
          />
        </svg>
      ),
      colorClass: "text-red-600"
    },
    warning: {
      icon: (
        <svg className="w-5 h-5" fill="currentColor" viewBox="0 0 20 20">
          <path
            fillRule="evenodd"
            d="M8.257 3.099c.765-1.36 2.722-1.36 
            3.486 0l5.58 9.92c.75 1.334-.213 
            2.98-1.742 2.98H4.42c-1.53 
            0-2.493-1.646-1.743-2.98l5.58-9.92zM11 
            13a1 1 0 11-2 0 1 1 0 012 0zm-1-8a1 1 0 
            00-1 1v3a1 1 0 002 0V6a1 1 0 00-1-1z"
            clipRule="evenodd"
          />
        </svg>
      ),
      colorClass: "text-yellow-600"
    },
    info: {
      icon: (
        <svg className="w-5 h-5" fill="currentColor" viewBox="0 0 20 20">
          <path
            fillRule="evenodd"
            d="M18 10a8 8 0 11-16 0 8 8 0 
            0116 0zm-7-4a1 1 0 11-2 0 1 1 
            0 012 0zM9 9a1 1 0 000 2v3a1 1 
            0 001 1h1a1 1 0 100-2v-3a1 1 0 
            00-1-1H9z"
            clipRule="evenodd"
          />
        </svg>
      ),
      colorClass: "text-blue-600"
    }
  } as const;

  const sizeConfig = {
    sm: { text: "text-sm", padding: "p-3", iconSize: "w-4 h-4" },
    md: { text: "text-base", padding: "p-4", iconSize: "w-5 h-5" },
    lg: { text: "text-lg", padding: "p-5", iconSize: "w-6 h-6" }
  };

  const variantConfig = {
    inline: {
      container: "inline-flex items-start space-x-2",
      background: "",
      border: ""
    },
    alert: {
      container: "rounded-lg border",
      background:
        severity === "error"
          ? "bg-red-50"
          : severity === "warning"
          ? "bg-yellow-50"
          : "bg-blue-50",
      border:
        severity === "error"
          ? "border-red-200"
          : severity === "warning"
          ? "border-yellow-200"
          : "border-blue-200"
    },
    toast: {
      container: "rounded-lg border shadow-lg",
      background: "bg-white",
      border:
        severity === "error"
          ? "border-red-400"
          : severity === "warning"
          ? "border-yellow-400"
          : "border-blue-400"
    },
    banner: {
      container: "border-l-4",
      background:
        severity === "error"
          ? "bg-red-50"
          : severity === "warning"
          ? "bg-yellow-50"
          : "bg-blue-50",
      border:
        severity === "error"
          ? "border-l-red-400"
          : severity === "warning"
          ? "border-l-yellow-400"
          : "border-l-blue-400"
    }
  };

  const currentIcon = iconConfig[severity];
  const currentSize = sizeConfig[size];
  const currentVariant = variantConfig[variant];

  const handleDismiss = () => {
    setDismissed(true);
    onDismiss?.();
  };

  const handleActionClick =
    (actionOnClick: () => void) => (event: MouseEvent<HTMLButtonElement>) => {
      event.preventDefault();
      actionOnClick();
    };

  return (
    <div
      id={id}
      className={`${currentVariant.container} ${currentVariant.background} ${currentVariant.border} ${
        variant !== "inline" ? currentSize.padding : ""
      } ${className}`}
      role="alert"
      aria-live="polite"
    >
      {showIcon && variant !== "inline" && (
        <div className={`flex-shrink-0 ${currentIcon.colorClass}`}>
          <div className={currentSize.iconSize}>{currentIcon.icon}</div>
        </div>
      )}

      <div className={`flex-1 ${variant !== "inline" && showIcon ? "ml-3" : ""}`}>
        {title && (
          <h3
            className={`font-medium ${currentIcon.colorClass} ${currentSize.text} mb-1`}
          >
            {title}
          </h3>
        )}

        <div
          className={`${currentSize.text} ${
            variant === "inline" ? "inline-flex items-center space-x-2" : ""
          }`}
        >
          {variant === "inline" && showIcon && (
            <div className={`flex-shrink-0 ${currentIcon.colorClass}`}>
              <div className={currentSize.iconSize}>{currentIcon.icon}</div>
            </div>
          )}

          <div className={currentIcon.colorClass}>
            {hasMultipleErrors ? (
              <ul
                className={
                  variant === "inline"
                    ? "inline"
                    : "list-disc list-inside space-y-1"
                }
              >
                {errorArray.map((errorItem, index) => (
                  <li key={index}>
                    {variant === "inline" && index > 0 && ", "}
                    {errorItem}
                  </li>
                ))}
              </ul>
            ) : (
              <span>{errorArray[0]}</span>
            )}
          </div>
        </div>

        {actions.length > 0 && variant !== "inline" && (
          <div className="mt-3 flex space-x-2">
            {actions.map((action, index) => (
              <button
                key={index}
                type="button"
                onClick={handleActionClick(action.onClick)}
                className={`px-3 py-1 rounded text-sm font-medium transition-colors duration-200 ${
                  action.variant === "primary"
                    ? `${
                        severity === "error"
                          ? "bg-red-600 hover:bg-red-700"
                          : severity === "warning"
                          ? "bg-yellow-600 hover:bg-yellow-700"
                          : "bg-blue-600 hover:bg-blue-700"
                      } text-white`
                    : `${
                        severity === "error"
                          ? "text-red-600 hover:text-red-800 hover:bg-red-100"
                          : severity === "warning"
                          ? "text-yellow-600 hover:text-yellow-800 hover:bg-yellow-100"
                          : "text-blue-600 hover:text-blue-800 hover:bg-blue-100"
                      } border ${
                        severity === "error"
                          ? "border-red-300"
                          : severity === "warning"
                          ? "border-yellow-300"
                          : "border-blue-300"
                      }`
                }`}
              >
                {action.label}
              </button>
            ))}
          </div>
        )}
      </div>

      {dismissible && (
        <div className="ml-auto pl-3">
          <button
            type="button"
            onClick={handleDismiss}
            className={`inline-flex rounded-md p-1.5 focus:outline-none focus:ring-2 focus:ring-offset-2 ${currentIcon.colorClass} hover:bg-gray-100 focus:ring-gray-500`}
            aria-label="Dismiss"
          >
            <svg className="w-5 h-5" fill="currentColor" viewBox="0 0 20 20">
              <path
                fillRule="evenodd"
                d="M4.293 4.293a1 1 0 011.414 0L10 
                8.586l4.293-4.293a1 1 0 
                111.414 1.414L11.414 10l4.293 
                4.293a1 1 0 01-1.414 1.414L10 
                11.414l-4.293 4.293a1 1 0 
                01-1.414-1.414L8.586 10 4.293 
                5.707a1 1 0 010-1.414z"
                clipRule="evenodd"
              />
            </svg>
          </button>
        </div>
      )}
    </div>
  );
};

```

<!-- path: components/common/ui/Modal/DetailsModal.tsx -->
```typescript
import { motion, AnimatePresence } from "framer-motion";
import { FiX } from "react-icons/fi";
import Image from "next/image";
import { Modal } from "@/components/common/ui";
import { CardSpinner } from "@/components/common/ui/LoadingSpinner";
import { ReactNode } from "react";

// Generic field configuration interface
interface FieldConfig {
  key: string;
  label: string;
  icon?: ReactNode;
  formatter?: (value: any) => ReactNode;
  condition?: (data: any) => boolean;
  className?: string;
}

// Section configuration interface
interface SectionConfig {
  title: string;
  icon?: ReactNode;
  fields: FieldConfig[];
  condition?: (data: any) => boolean;
  className?: string;
  renderCustom?: (data: any) => ReactNode;
}

// Header configuration interface
interface HeaderConfig {
  title: (data: any) => string;
  subtitle?: (data: any) => string;
  avatar?: {
    urlKey: string;
    fallbackText: (data: any) => string;
  };
  badges?: Array<{
    key: string;
    component: (value: any) => ReactNode;
  }>;
}

// Main props interface
interface DetailsModalProps<T = any> {
  data: T | null;
  onClose: () => void;
  isOpen: boolean;
  config: {
    header: HeaderConfig;
    sections: SectionConfig[];
  };
  loading?: boolean;
  className?: string;
}

// Default formatters
const defaultFormatters = {
  date: (dateString: string | null | undefined) => {
    if (!dateString) return "Not provided";
    try {
      return new Date(dateString).toLocaleDateString("en-US", {
        year: "numeric",
        month: "long",
        day: "numeric",
      });
    } catch {
      return "Invalid date";
    }
  },
  
  dateTime: (dateString: string | null | undefined) => {
    if (!dateString) return "Never";
    try {
      return new Date(dateString).toLocaleString("en-US", {
        year: "numeric",
        month: "short",
        day: "numeric",
        hour: "2-digit",
        minute: "2-digit",
      });
    } catch {
      return "Invalid date";
    }
  },
  
  address: (address: any) => {
    if (!address || typeof address !== 'object') return null;
    const parts = [
      address.street,
      address.city,
      address.state,
      address.zip_code || address.zipCode,
      address.country,
    ].filter(Boolean);
    return parts.length > 0 ? parts.join(", ") : null;
  },
  
  json: (value: any) => {
    if (!value) return "Not provided";
    return (
      <pre className="text-sm text-gray-700 dark:text-gray-300 whitespace-pre-wrap font-mono leading-relaxed overflow-x-auto">
        {JSON.stringify(value, null, 2)}
      </pre>
    );
  },
  
  boolean: (value: boolean) => (
    <span
      className={`text-xs px-3 py-1 rounded-full font-semibold ${
        value
          ? "bg-green-100 text-green-700 dark:bg-green-900/30 dark:text-green-400"
          : "bg-red-100 text-red-700 dark:bg-red-900/30 dark:text-red-400"
      }`}
    >
      {value ? " Yes" : " No"}
    </span>
  ),
  
  email: (email: string, isVerified?: boolean) => (
    <div className="flex items-center justify-between">
      <span className="text-gray-900 dark:text-white font-medium flex-1">{email}</span>
      {typeof isVerified === 'boolean' && (
        <span
          className={`text-xs px-3 py-1 rounded-full font-semibold ml-3 ${
            isVerified
              ? "bg-green-100 text-green-700 dark:bg-green-900/30 dark:text-green-400"
              : "bg-red-100 text-red-700 dark:bg-red-900/30 dark:text-red-400"
          }`}
        >
          {isVerified ? " Verified" : " Unverified"}
        </span>
      )}
    </div>
  )
};

// Helper function to get nested value
const getNestedValue = (obj: any, key: string): any => {
  return key.split('.').reduce((current, prop) => current?.[prop], obj);
};

const DetailsModal = <T extends Record<string, any>>({
  data,
  onClose,
  isOpen,
  config,
  loading = false,
  className = ""
}: DetailsModalProps<T>) => {
  const containerVariants = {
    hidden: { opacity: 0 },
    visible: { 
      opacity: 1,
      transition: {
        duration: 0.3,
        staggerChildren: 0.1
      }
    },
    exit: { 
      opacity: 0,
      transition: {
        duration: 0.2
      }
    }
  };

  const modalVariants = {
    hidden: { 
      opacity: 0, 
      scale: 0.8,
      y: 50
    },
    visible: { 
      opacity: 1, 
      scale: 1,
      y: 0,
      transition: {
        type: "spring" as const,
        damping: 25,
        stiffness: 300
      }
    },
    exit: { 
      opacity: 0, 
      scale: 0.9,
      y: 30,
      transition: {
        duration: 0.2
      }
    }
  };

  const sectionVariants = {
    hidden: { opacity: 0, y: 20 },
    visible: { 
      opacity: 1, 
      y: 0,
      transition: {
        duration: 0.4,
        ease: "easeOut" as const
      }
    }
  };

  const fieldVariants = {
    hidden: { opacity: 0, x: -10 },
    visible: { 
      opacity: 1, 
      x: 0,
      transition: {
        duration: 0.3
      }
    }
  };

  const renderField = (field: FieldConfig, data: T) => {
    if (field.condition && !field.condition(data)) return null;
    
    const value = getNestedValue(data, field.key);
    const formattedValue = field.formatter ? field.formatter(value) : (value || "Not provided");

    return (
      <motion.div
        key={field.key}
        className={`group ${field.className || ""}`}
        variants={fieldVariants}
        whileHover={{ x: 4 }}
        transition={{ type: "spring", stiffness: 300 }}
      >
        <label className="text-sm font-semibold text-gray-500 dark:text-gray-400 block mb-2 uppercase tracking-wider">
          {field.label}
        </label>
        <div className="p-3 bg-gray-50 dark:bg-gray-800 rounded-lg border border-gray-200 dark:border-gray-700 group-hover:border-blue-300 dark:group-hover:border-blue-600 transition-colors">
          <div className="flex items-center gap-3">
            {field.icon && (
              <div className="text-gray-400 flex-shrink-0">
                {field.icon}
              </div>
            )}
            <div className="flex-1">
              {typeof formattedValue === 'string' ? (
                <p className="text-gray-900 dark:text-white font-medium">{formattedValue}</p>
              ) : (
                formattedValue
              )}
            </div>
          </div>
        </div>
      </motion.div>
    );
  };

  const renderSection = (section: SectionConfig, data: T) => {
    if (section.condition && !section.condition(data)) return null;

    return (
      <motion.div
        key={section.title}
        className={`space-y-6 ${section.className || ""}`}
        variants={sectionVariants}
      >
        <div className="flex items-center gap-3 pb-3 border-b border-gray-200 dark:border-gray-700">
          {section.icon && (
            <div className="p-2 bg-blue-100 dark:bg-blue-900/30 rounded-lg">
              {section.icon}
            </div>
          )}
          <h3 className="text-xl font-semibold text-gray-900 dark:text-white">
            {section.title}
          </h3>
        </div>

        {section.renderCustom ? (
          section.renderCustom(data)
        ) : (
          <div className="space-y-5">
            {section.fields.map(field => renderField(field, data))}
          </div>
        )}
      </motion.div>
    );
  };

  const renderHeader = (data: T) => {
    const { header } = config;
    const title = header.title(data);
    const subtitle = header.subtitle ? header.subtitle(data) : null;

    return (
      <div className="relative px-8 py-6 bg-gradient-to-r from-blue-50 via-indigo-50 to-purple-50 dark:from-gray-800 dark:via-gray-850 dark:to-gray-900 border-b border-gray-200/50 dark:border-gray-700/50">
        <div className="flex items-center justify-between">
          <motion.div 
            className="flex items-center gap-4"
            variants={fieldVariants}
          >
            {header.avatar && (
              <motion.div 
                className="flex-shrink-0 relative"
                whileHover={{ scale: 1.05 }}
                transition={{ type: "spring", stiffness: 300 }}
              >
                {getNestedValue(data, header.avatar.urlKey) ? (
                  <div className="relative">
                    <Image
                      className="h-16 w-16 rounded-full object-cover border-4 border-white shadow-lg ring-2 ring-blue-500/20"
                      src={getNestedValue(data, header.avatar.urlKey)}
                      alt={title}
                      width={64}
                      height={64}
                      onError={(e) => {
                        e.currentTarget.style.display = "none";
                        e.currentTarget.nextElementSibling?.classList.remove("hidden");
                      }}
                    />
                    <div className="absolute -bottom-1 -right-1 w-5 h-5 bg-green-500 border-2 border-white rounded-full"></div>
                  </div>
                ) : null}
                <div
                  className={`h-16 w-16 rounded-full bg-gradient-to-br from-blue-500 to-indigo-600 flex items-center justify-center shadow-lg ring-2 ring-blue-500/20 ${
                    getNestedValue(data, header.avatar.urlKey) ? "hidden" : ""
                  }`}
                >
                  <span className="text-xl font-bold text-white">
                    {header.avatar.fallbackText(data)}
                  </span>
                  <div className="absolute -bottom-1 -right-1 w-5 h-5 bg-green-500 border-2 border-white rounded-full"></div>
                </div>
              </motion.div>
            )}
            <div className="space-y-1">
              <motion.h2 
                className="text-2xl font-bold text-gray-900 dark:text-white"
                variants={fieldVariants}
              >
                {title}
              </motion.h2>
              {subtitle && (
                <motion.p 
                  className="text-gray-600 dark:text-gray-300 font-medium"
                  variants={fieldVariants}
                >
                  {subtitle}
                </motion.p>
              )}
              {header.badges && (
                <motion.div 
                  className="flex items-center gap-2 flex-wrap"
                  variants={fieldVariants}
                >
                  {header.badges.map((badge, index) => (
                    <div key={`${badge.key}-${index}`}>
                      {badge.component(getNestedValue(data, badge.key))}
                    </div>
                  ))}
                </motion.div>
              )}
            </div>
          </motion.div>
          <motion.button
            onClick={onClose}
            className="text-gray-400 hover:text-gray-600 dark:hover:text-gray-300 p-3 rounded-xl hover:bg-white/50 dark:hover:bg-gray-800/50 transition-all duration-200 backdrop-blur-sm"
            aria-label="Close modal"
            whileHover={{ scale: 1.1, rotate: 90 }}
            whileTap={{ scale: 0.95 }}
            transition={{ type: "spring", stiffness: 300 }}
          >
            <FiX size={24} />
          </motion.button>
        </div>
      </div>
    );
  };

  return (
    <AnimatePresence mode="wait">
      {isOpen && (
        <Modal isOpen={isOpen} onClose={onClose}>
          {loading ? (
            <motion.div
              initial={{ opacity: 0 }}
              animate={{ opacity: 1 }}
              exit={{ opacity: 0 }}
              className="fixed inset-0 bg-black/60 backdrop-blur-sm flex items-center justify-center z-50"
            >
              <CardSpinner />
            </motion.div>
          ) : data ? (
            <motion.div
              variants={containerVariants}
              initial="hidden"
              animate="visible"
              exit="exit"
              className="fixed inset-0 bg-black/60 backdrop-blur-sm flex items-center justify-center z-50 p-4"
            >
              <motion.div
                variants={modalVariants}
                className={`bg-white dark:bg-gray-900 rounded-2xl shadow-2xl max-w-5xl w-full max-h-[90vh] overflow-hidden border border-gray-200/50 dark:border-gray-700/50 ${className}`}
              >
                {renderHeader(data)}
                
                <div className="p-8 overflow-y-auto max-h-[calc(90vh-160px)] custom-scrollbar">
                  <div className="grid grid-cols-1 xl:grid-cols-2 gap-8">
                    {config.sections.map(section => renderSection(section, data))}
                  </div>
                </div>
              </motion.div>
            </motion.div>
          ) : null}
        </Modal>
      )}
    </AnimatePresence>
  );
};

// Export the component and formatters for reuse
export { DetailsModal, defaultFormatters, type FieldConfig, type SectionConfig, type HeaderConfig, type DetailsModalProps };
```

<!-- path: components/common/ui/Modal/ChangePasswordModal.tsx -->
```typescript
// components/common/Modal/ChangePasswordModal.tsx
import { useState } from "react";
import { FiEye, FiEyeOff } from "react-icons/fi";
import { toast } from "sonner";
import { LoadingSpinner } from "../LoadingSpinner";
import { Modal } from "./Modal"; // Make sure your Modal component is correctly imported

// --- MODIFIED Type Definition ---
export interface ChangePasswordData {
  newPassword: string;
  // currentPassword is no longer needed for the API call
}

interface ChangePasswordModalProps {
  onClose: () => void;
  // This function signature now matches our store
  changePassword: (data: ChangePasswordData) => Promise<boolean>;
  isLoading: boolean;
  isOpen: boolean;
}

export const ChangePasswordModal = ({
  isOpen,
  onClose,
  changePassword,
  isLoading,
}: ChangePasswordModalProps) => {
  // --- REMOVED currentPassword state ---
  const [newPassword, setNewPassword] = useState("");
  const [confirmPassword, setConfirmPassword] = useState("");
  const [showNewPassword, setShowNewPassword] = useState(false);

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    if (newPassword.length < 8) {
      toast.error("Password must be at least 8 characters long.");
      return;
    }
    if (newPassword !== confirmPassword) {
      toast.error("New passwords do not match.");
      return;
    }

    // --- MODIFIED: Call the function with the new data shape ---
    const success = await changePassword({ newPassword });

    if (success) {
      toast.success("Password updated successfully!");
      onClose();
    }
  };

  return (
    <Modal isOpen={isOpen} onClose={onClose} visible={false}
      className="h-screen w-screen transparent bg-gray-700 rounded-2xl">
      <form onSubmit={handleSubmit} className="p-6">
        <div className="flex items-start justify-between">
          <h3 className="text-lg font-medium text-gray-900 dark:text-white">
            Change Password
          </h3>
        </div>
        <div className="mt-4 space-y-4">
          {/* --- REMOVED Current Password Input Block --- */}

          <div className="relative">
            <label className="block text-sm font-medium text-gray-700 dark:text-gray-300">
              New Password
            </label>
            <input
              type={showNewPassword ? "text" : "password"}
              value={newPassword}
              onChange={(e) => setNewPassword(e.target.value)}
              required
              className="mt-1 w-full rounded-md border border-gray-300 bg-white px-3 py-2 text-gray-900 shadow-sm focus:ring-2 focus:ring-blue-500 dark:border-gray-600 dark:bg-gray-700 dark:text-white"
            />
            <button
              type="button"
              onClick={() => setShowNewPassword(!showNewPassword)}
              className="absolute right-0 bottom-2.5 flex items-center px-3 text-gray-400"
            >
              {showNewPassword ? <FiEyeOff /> : <FiEye />}
            </button>
          </div>
          <div>
            <label className="block text-sm font-medium text-gray-700 dark:text-gray-300">
              Confirm New Password
            </label>
            <input
              type={showNewPassword ? "text" : "password"}
              value={confirmPassword}
              onChange={(e) => setConfirmPassword(e.target.value)}
              required
              className="mt-1 w-full rounded-md border border-gray-300 bg-white px-3 py-2 text-gray-900 shadow-sm focus:ring-2 focus:ring-blue-500 dark:border-gray-600 dark:bg-gray-700 dark:text-white"
            />
          </div>
        </div>
        <div className="mt-6 flex justify-end space-x-3">
          <button
            type="button"
            onClick={onClose}
            className="rounded-md border border-gray-300 bg-white px-4 py-2 text-sm font-medium text-gray-700 hover:bg-gray-50 dark:border-gray-600 dark:bg-gray-800 dark:text-gray-300 dark:hover:bg-gray-700"
          >
            Cancel
          </button>
          <button
            type="submit"
            disabled={isLoading}
            className="inline-flex w-[120px] items-center justify-center rounded-md border border-transparent bg-blue-600 px-4 py-2 text-sm font-medium text-white hover:bg-blue-700 disabled:opacity-50"
          >
            {isLoading ? <LoadingSpinner size="sm" /> : "Save Changes"}
          </button>
        </div>
      </form>
    </Modal>
  );
};
```

<!-- path: components/common/ui/Modal/confirmModal.tsx -->
```typescript
import React, { useState, useEffect, useCallback, useRef } from 'react';

// Icon components with proper TypeScript support
interface IconProps {
  className?: string;
}

const icons = {
  Warning: ({ className = "w-6 h-6" }: IconProps) => (
    <svg className={className} fill="currentColor" viewBox="0 0 20 20">
      <path fillRule="evenodd" d="M8.257 3.099c.765-1.36 2.722-1.36 3.486 0l5.58 9.92c.75 1.334-.213 2.98-1.742 2.98H4.42c-1.53 0-2.493-1.646-1.743-2.98l5.58-9.92zM11 13a1 1 0 11-2 0 1 1 0 012 0zm-1-8a1 1 0 00-1 1v3a1 1 0 002 0V6a1 1 0 00-1-1z" clipRule="evenodd" />
    </svg>
  ),
  Close: ({ className = "w-5 h-5" }: IconProps) => (
    <svg className={className} fill="currentColor" viewBox="0 0 20 20">
      <path fillRule="evenodd" d="M4.293 4.293a1 1 0 011.414 0L10 8.586l4.293-4.293a1 1 0 111.414 1.414L11.414 10l4.293 4.293a1 1 0 01-1.414 1.414L10 11.414l-4.293 4.293a1 1 0 01-1.414-1.414L8.586 10 4.293 5.707a1 1 0 010-1.414z" clipRule="evenodd" />
    </svg>
  ),
  Check: ({ className = "w-6 h-6" }: IconProps) => (
    <svg className={className} fill="currentColor" viewBox="0 0 20 20">
      <path fillRule="evenodd" d="M16.707 5.293a1 1 0 010 1.414l-8 8a1 1 0 01-1.414 0l-4-4a1 1 0 011.414-1.414L8 12.586l7.293-7.293a1 1 0 011.414 0z" clipRule="evenodd" />
    </svg>
  ),
  Error: ({ className = "w-6 h-6" }: IconProps) => (
    <svg className={className} fill="currentColor" viewBox="0 0 20 20">
      <path fillRule="evenodd" d="M18 10a8 8 0 11-16 0 8 8 0 0116 0zm-7 4a1 1 0 11-2 0 1 1 0 012 0zm-1-9a1 1 0 00-1 1v4a1 1 0 102 0V6a1 1 0 00-1-1z" clipRule="evenodd" />
    </svg>
  ),
  Info: ({ className = "w-6 h-6" }: IconProps) => (
    <svg className={className} fill="currentColor" viewBox="0 0 20 20">
      <path fillRule="evenodd" d="M18 10a8 8 0 11-16 0 8 8 0 0116 0zm-7-4a1 1 0 11-2 0 1 1 0 012 0zM9 9a1 1 0 000 2v3a1 1 0 001 1h1a1 1 0 100-2v-3a1 1 0 00-1-1H9z" clipRule="evenodd" />
    </svg>
  ),
  Help: ({ className = "w-6 h-6" }: IconProps) => (
    <svg className={className} fill="currentColor" viewBox="0 0 20 20">
      <path fillRule="evenodd" d="M18 10a8 8 0 11-16 0 8 8 0 0116 0zm-8-3a1 1 0 00-.867.5 1 1 0 11-1.731-1A3 3 0 0113 8a3.001 3.001 0 01-2 2.83V11a1 1 0 11-2 0v-1a1 1 0 011-1 1 1 0 100-2zm0 8a1 1 0 100-2 1 1 0 000 2z" clipRule="evenodd" />
    </svg>
  ),
};

type ModalType = 'default' | 'danger' | 'warning' | 'info' | 'success';

interface ConfirmModalProps {
  isOpen: boolean;
  onConfirm: () => void | Promise<void>;
  onCancel: () => void;
  title?: string;
  message?: string | React.ReactNode;
  confirmText?: string;
  cancelText?: string;
  type?: ModalType;
  showIcon?: boolean;
  closeOnBackdrop?: boolean;
  closeOnEscape?: boolean;
  loading?: boolean;
  size?: 'sm' | 'md' | 'lg';
  className?: string;
  confirmButtonProps?: React.ButtonHTMLAttributes<HTMLButtonElement>;
  cancelButtonProps?: React.ButtonHTMLAttributes<HTMLButtonElement>;
}

const LoadingSpinner: React.FC<{ size?: 'sm' | 'md' }> = ({ size = 'md' }) => (
  <div
    className={`border-2 border-current border-t-transparent rounded-full animate-spin ${
      size === 'sm' ? 'w-4 h-4' : 'w-5 h-5'
    }`}
    aria-hidden="true"
  />
);

export const ConfirmModal: React.FC<ConfirmModalProps> = ({
  isOpen,
  onConfirm,
  onCancel,
  title = 'Confirm Action',
  message = 'Are you sure you want to proceed?',
  confirmText = 'Confirm',
  cancelText = 'Cancel',
  type = 'default',
  showIcon = true,
  closeOnBackdrop = true,
  closeOnEscape = true,
  loading = false,
  size = 'md',
  className,
  confirmButtonProps = {},
  cancelButtonProps = {},
}) => {
  const [isVisible, setIsVisible] = useState(false);
  const [isAnimating, setIsAnimating] = useState(false);
  const modalRef = useRef<HTMLDivElement>(null);
  const confirmButtonRef = useRef<HTMLButtonElement>(null);
  const cancelButtonRef = useRef<HTMLButtonElement>(null);
  const previousActiveElement = useRef<HTMLElement | null>(null);
  

  // Handle modal opening/closing
  useEffect(() => {
    if (isOpen) {
      // Store previously focused element
      previousActiveElement.current = document.activeElement as HTMLElement;
      
      setIsVisible(true);
      // Use requestAnimationFrame for smoother animations
      requestAnimationFrame(() => {
        setIsAnimating(true);
      });

      // Prevent body scroll
      document.body.style.overflow = 'hidden';
      document.body.style.paddingRight = `${window.innerWidth - document.documentElement.clientWidth}px`;
    } else {
      setIsAnimating(false);
      const timer = setTimeout(() => {
        setIsVisible(false);
        // Restore body scroll
        document.body.style.overflow = '';
        document.body.style.paddingRight = '';
        
        // Restore focus to previously active element
        if (previousActiveElement.current) {
          previousActiveElement.current.focus();
        }
      }, 200);

      return () => clearTimeout(timer);
    }
  }, [isOpen]);

  // Handle escape key
  const handleKeyDown = useCallback(
    (e: KeyboardEvent) => {
      if (!isOpen) return;

      if (e.key === 'Escape' && closeOnEscape && !loading) {
        onCancel();
        return;
      }

      // Handle tab navigation within modal
      if (e.key === 'Tab') {
        const focusableElements = modalRef.current?.querySelectorAll(
          'button, [href], input, select, textarea, [tabindex]:not([tabindex="-1"])'
        );

        if (!focusableElements?.length) return;

        const firstElement = focusableElements[0] as HTMLElement;
        const lastElement = focusableElements[focusableElements.length - 1] as HTMLElement;

        if (e.shiftKey) {
          // Shift + Tab
          if (document.activeElement === firstElement) {
            e.preventDefault();
            lastElement.focus();
          }
        } else {
          // Tab
          if (document.activeElement === lastElement) {
            e.preventDefault();
            firstElement.focus();
          }
        }
      }
    },
    [isOpen, closeOnEscape, loading, onCancel]
  );

  useEffect(() => {
    document.addEventListener('keydown', handleKeyDown);
    return () => document.removeEventListener('keydown', handleKeyDown);
  }, [handleKeyDown]);

  // Focus management
  useEffect(() => {
    if (isOpen && isAnimating) {
      // Focus the cancel button by default (safer option)
      setTimeout(() => {
        cancelButtonRef.current?.focus();
      }, 100);
    }
  }, [isOpen, isAnimating]);

  const handleBackdropClick = (e: React.MouseEvent) => {
    if (e.target === e.currentTarget && closeOnBackdrop && !loading) {
      onCancel();
    }
  };

  const handleConfirm = async () => {
    if (loading) return;
    
    try {
      await onConfirm();
    } catch (error) {
      console.error('Confirm action failed:', error);
    }
  };

  const getIcon = () => {
    const className = `w-6 h-6 ${getIconColor()}`;
    
    switch (type) {
      case 'danger':
        return <icons.Error className={className} />;
      case 'warning':
        return <icons.Warning className={className} />;
      case 'info':
        return <icons.Info className={className} />;
      case 'success':
        return <icons.Check className={className} />;
      default:
        return <icons.Help className={className} />;
    }
  };

  const getIconColor = () => {
    switch (type) {
      case 'danger':
        return 'text-red-500 dark:text-red-400';
      case 'warning':
        return 'text-yellow-500 dark:text-yellow-400';
      case 'info':
        return 'text-blue-500 dark:text-blue-400';
      case 'success':
        return 'text-green-500 dark:text-green-400';
      default:
        return 'text-gray-500 dark:text-gray-400';
    }
  };

  const getButtonStyles = () => {
    const baseConfirm = 'text-white font-medium transition-all duration-200 focus:outline-none focus:ring-2 focus:ring-offset-2 disabled:opacity-50 disabled:cursor-not-allowed';
    const baseCancel = 'font-medium transition-all duration-200 focus:outline-none focus:ring-2 focus:ring-offset-2 disabled:opacity-50 disabled:cursor-not-allowed';

    switch (type) {
      case 'danger':
        return {
          confirm: `${baseConfirm} bg-red-600 hover:bg-red-700 focus:ring-red-500 active:bg-red-800 dark:bg-red-700 dark:hover:bg-red-800 dark:focus:ring-red-600 dark:active:bg-red-900`,
          cancel: `${baseCancel} bg-gray-100 hover:bg-gray-200 text-gray-900 focus:ring-gray-500 dark:bg-gray-700 dark:hover:bg-gray-600 dark:text-gray-100 dark:focus:ring-gray-500`,
        };
      case 'warning':
        return {
          confirm: `${baseConfirm} bg-yellow-600 hover:bg-yellow-700 focus:ring-yellow-500 active:bg-yellow-800 dark:bg-yellow-700 dark:hover:bg-yellow-800 dark:focus:ring-yellow-600 dark:active:bg-yellow-900`,
          cancel: `${baseCancel} bg-gray-100 hover:bg-gray-200 text-gray-900 focus:ring-gray-500 dark:bg-gray-700 dark:hover:bg-gray-600 dark:text-gray-100 dark:focus:ring-gray-500`,
        };
      case 'success':
        return {
          confirm: `${baseConfirm} bg-green-600 hover:bg-green-700 focus:ring-green-500 active:bg-green-800 dark:bg-green-700 dark:hover:bg-green-800 dark:focus:ring-green-600 dark:active:bg-green-900`,
          cancel: `${baseCancel} bg-gray-100 hover:bg-gray-200 text-gray-900 focus:ring-gray-500 dark:bg-gray-700 dark:hover:bg-gray-600 dark:text-gray-100 dark:focus:ring-gray-500`,
        };
      case 'info':
        return {
          confirm: `${baseConfirm} bg-blue-600 hover:bg-blue-700 focus:ring-blue-500 active:bg-blue-800 dark:bg-blue-700 dark:hover:bg-blue-800 dark:focus:ring-blue-600 dark:active:bg-blue-900`,
          cancel: `${baseCancel} bg-gray-100 hover:bg-gray-200 text-gray-900 focus:ring-gray-500 dark:bg-gray-700 dark:hover:bg-gray-600 dark:text-gray-100 dark:focus:ring-gray-500`,
        };
      default:
        return {
          confirm: `${baseConfirm} bg-gray-900 hover:bg-gray-800 focus:ring-gray-700 active:bg-gray-950 dark:bg-gray-800 dark:hover:bg-gray-700 dark:focus:ring-gray-600 dark:active:bg-gray-900`,
          cancel: `${baseCancel} bg-gray-100 hover:bg-gray-200 text-gray-900 focus:ring-gray-500 dark:bg-gray-700 dark:hover:bg-gray-600 dark:text-gray-100 dark:focus:ring-gray-500`,
        };
    }
  };

  const getSizeClasses = () => {
    switch (size) {
      case 'sm':
        return 'max-w-sm';
      case 'lg':
        return 'max-w-lg';
      default:
        return 'max-w-md';
    }
  };

  const buttonStyles = getButtonStyles();

  if (!isVisible) return null;

  return (
    <div
      className={`fixed inset-0 z-50 flex items-center justify-center p-4 transition-all duration-200 ${
        isAnimating ? 'bg-black/50 dark:bg-black/70 backdrop-blur-sm' : 'bg-black/0'
      }`}
      onClick={handleBackdropClick}
      role="presentation"
    >
      <div
        ref={modalRef}
        className={`bg-white dark:bg-gray-900 rounded-xl shadow-2xl w-full transform transition-all duration-200 ${getSizeClasses()} ${
          isAnimating ? 'scale-100 opacity-100 translate-y-0' : 'scale-95 opacity-0 translate-y-4'
        } ${className || ''}`}
        role="dialog"
        aria-modal="true"
        aria-labelledby="modal-title"
        aria-describedby="modal-description"
      >
        {/* Header */}
        <div className="px-6 py-5 border-b border-gray-200 dark:border-gray-700">
          <div className="flex items-center justify-between">
            <div className="flex items-center space-x-3">
              {showIcon && (
                <div className="flex-shrink-0" aria-hidden="true">
                  {getIcon()}
                </div>
              )}
              <h3 
                id="modal-title" 
                className="text-lg font-semibold text-gray-900 dark:text-gray-100 leading-6"
              >
                {title}
              </h3>
            </div>
            <button
              onClick={onCancel}
              disabled={loading}
              className="flex-shrink-0 text-gray-400 hover:text-gray-600 dark:hover:text-gray-300 transition-colors p-2 rounded-full hover:bg-gray-100 dark:hover:bg-gray-800 focus:outline-none focus:ring-2 focus:ring-gray-500 disabled:opacity-50 disabled:cursor-not-allowed"
              aria-label="Close modal"
              type="button"
            >
              <icons.Close />
            </button>
          </div>
        </div>

        {/* Body */}
        <div className="px-6 py-5">
          <div id="modal-description" className="text-gray-600 dark:text-gray-300 leading-relaxed">
            {typeof message === 'string' ? (
              <p>{message}</p>
            ) : (
              message
            )}
          </div>
        </div>

        {/* Footer */}
        <div className="px-6 py-4 bg-gray-50 dark:bg-gray-800 rounded-b-xl flex justify-end space-x-3">
          <button
            ref={cancelButtonRef}
            onClick={onCancel}
            disabled={loading}
            className={`px-5 py-2.5 rounded-lg ${buttonStyles.cancel}`}
            type="button"
            {...cancelButtonProps}
          >
            {cancelText}
          </button>
          <button
            ref={confirmButtonRef}
            onClick={handleConfirm}
            disabled={loading}
            className={`px-5 py-2.5 rounded-lg ${buttonStyles.confirm} ${
              loading ? 'cursor-wait' : ''
            }`}
            type="button"
            {...confirmButtonProps}
          >
            {loading ? (
              <div className="flex items-center space-x-2" aria-label="Loading">
                <LoadingSpinner size="sm" />
                <span>Loading...</span>
              </div>
            ) : (
              confirmText
            )}
          </button>
        </div>
      </div>
    </div>
  );
};

// Hook for easier modal management
export const useConfirmModal = () => {
  const [isOpen, setIsOpen] = useState(false);
  const [loading, setLoading] = useState(false);
  const resolveRef = useRef<((value: boolean) => void) | null>(null);

  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  const confirm = useCallback((options?: Partial<ConfirmModalProps>): Promise<boolean> => {
    return new Promise((resolve) => {
      resolveRef.current = resolve;
      setIsOpen(true);
    });
  }, []);

  const handleConfirm = useCallback(async () => {
    if (resolveRef.current) {
      resolveRef.current(true);
      resolveRef.current = null;
    }
    setIsOpen(false);
    setLoading(false);
  }, []);

  const handleCancel = useCallback(() => {
    if (resolveRef.current) {
      resolveRef.current(false);
      resolveRef.current = null;
    }
    setIsOpen(false);
    setLoading(false);
  }, []);

  return {
    isOpen,
    loading,
    setLoading,
    confirm,
    handleConfirm,
    handleCancel,
  };
};

// Demo component
export const ConfirmModalDemo: React.FC = () => {
  const [modals, setModals] = useState({
    default: false,
    danger: false,
    warning: false,
    info: false,
    success: false,
    loading: false,
  });
  const [isLoading, setIsLoading] = useState(false);

  const openModal = (type: keyof typeof modals) => {
    setModals(prev => ({ ...prev, [type]: true }));
  };

  const closeModal = (type: keyof typeof modals) => {
    setModals(prev => ({ ...prev, [type]: false }));
    setIsLoading(false);
  };

  const handleConfirm = async (type: keyof typeof modals) => {
    if (type === 'loading') {
      setIsLoading(true);
      // Simulate async operation
      await new Promise(resolve => setTimeout(resolve, 2000));
      closeModal(type);
      alert('Action completed!');
    } else {
      closeModal(type);
      alert(`${type} action confirmed!`);
    }
  };

  return (
    <div className="p-8 bg-gray-100 dark:bg-gray-900 min-h-screen">
      <div className="max-w-4xl mx-auto">
        <h1 className="text-3xl font-bold text-gray-900 dark:text-gray-100 mb-8 text-center">
          Improved ConfirmModal Demo
        </h1>
        
        <div className="bg-white dark:bg-gray-800 rounded-lg shadow-md p-6 mb-8">
          <h2 className="text-xl font-semibold mb-4 dark:text-gray-200">Modal Types</h2>
          <div className="grid grid-cols-2 md:grid-cols-3 gap-4">
            {Object.keys(modals).map((type) => (
              <button
                key={type}
                onClick={() => openModal(type as keyof typeof modals)}
                className={`p-3 text-white rounded-md transition-colors font-medium ${
                  type === 'default' ? 'bg-gray-800 hover:bg-gray-900 dark:bg-gray-700 dark:hover:bg-gray-600' :
                  type === 'danger' ? 'bg-red-600 hover:bg-red-700 dark:bg-red-700 dark:hover:bg-red-800' :
                  type === 'warning' ? 'bg-yellow-600 hover:bg-yellow-700 dark:bg-yellow-700 dark:hover:bg-yellow-800' :
                  type === 'info' ? 'bg-blue-600 hover:bg-blue-700 dark:bg-blue-700 dark:hover:bg-blue-800' :
                  type === 'success' ? 'bg-green-600 hover:bg-green-700 dark:bg-green-700 dark:hover:bg-green-800' :
                  'bg-purple-600 hover:bg-purple-700 dark:bg-purple-700 dark:hover:bg-purple-800'
                }`}
              >
                {type.charAt(0).toUpperCase() + type.slice(1)} Modal
              </button>
            ))}
          </div>
        </div>

        {/* Modals */}
        <ConfirmModal
          isOpen={modals.default}
          onConfirm={() => handleConfirm('default')}
          onCancel={() => closeModal('default')}
          title="Confirm Action"
          message="This is a default confirmation modal. Are you sure you want to proceed?"
        />

        <ConfirmModal
          isOpen={modals.danger}
          onConfirm={() => handleConfirm('danger')}
          onCancel={() => closeModal('danger')}
          title="Delete Item"
          message="This action cannot be undone. Are you sure you want to delete this item permanently?"
          confirmText="Delete"
          cancelText="Keep"
          type="danger"
        />

        <ConfirmModal
          isOpen={modals.warning}
          onConfirm={() => handleConfirm('warning')}
          onCancel={() => closeModal('warning')}
          title="Unsaved Changes"
          message="You have unsaved changes that will be lost. Do you want to continue without saving?"
          confirmText="Continue"
          cancelText="Save First"
          type="warning"
        />

        <ConfirmModal
          isOpen={modals.info}
          onConfirm={() => handleConfirm('info')}
          onCancel={() => closeModal('info')}
          title="Information Required"
          message="Before proceeding, please confirm that you have read and understood the terms and conditions."
          confirmText="I Understand"
          cancelText="Cancel"
          type="info"
        />

        <ConfirmModal
          isOpen={modals.success}
          onConfirm={() => handleConfirm('success')}
          onCancel={() => closeModal('success')}
          title="Complete Setup"
          message="Your account setup is almost complete. Would you like to finish the configuration now?"
          confirmText="Complete Setup"
          cancelText="Later"
          type="success"
        />

        <ConfirmModal
          isOpen={modals.loading}
          onConfirm={() => handleConfirm('loading')}
          onCancel={() => closeModal('loading')}
          title="Process Data"
          message="This will process all selected items. This action may take a few moments to complete."
          confirmText="Process"
          cancelText="Cancel"
          type="default"
          loading={isLoading}
        />
      </div>
    </div>
  );
};
```

<!-- path: components/common/ui/Modal/Modal.tsx -->
```typescript
import { AnimatePresence, motion } from "framer-motion";
import { type ReactNode, useEffect } from "react";
import { IoClose } from "react-icons/io5";
import { cn } from "@/utils/classNames";

interface ModalProps {
  isOpen: boolean;
  onClose: () => void;
  title?: string;
  children: ReactNode;
  size?: "sm" | "md" | "lg" | "xl" | "full";
  showCloseButton?: boolean;
  closeOnOverlayClick?: boolean;
  closeOnEscape?: boolean;
  className?: string;
  visible?: boolean;
}

export const Modal = ({
  isOpen,
  onClose,
  title,
  children,
  size = "md",
  showCloseButton = true,
  closeOnOverlayClick = true,
  closeOnEscape = true,
  className,
  visible = true,
}: ModalProps) => {
  // Handle escape key
  useEffect(() => {
    if (!closeOnEscape || !isOpen) return;

    const handleEscape = (e: KeyboardEvent) => {
      if (e.key === "Escape") {
        onClose();
      }
    };

    document.addEventListener("keydown", handleEscape);
    return () => document.removeEventListener("keydown", handleEscape);
  }, [isOpen, closeOnEscape, onClose]);

  // Prevent body scroll when modal is open
  useEffect(() => {
    if (isOpen) {
      document.body.style.overflow = "hidden";
    } else {
      document.body.style.overflow = "unset";
    }

    return () => {
      document.body.style.overflow = "unset";
    };
  }, [isOpen]);

  const sizeClasses = {
    sm: "max-w-md",
    md: "max-w-lg",
    lg: "max-w-2xl",
    xl: "max-w-4xl",
    full: "max-w-[95vw] max-h-[95vh]",
  };

  const handleOverlayClick = (e: React.MouseEvent) => {
    if (closeOnOverlayClick && e.target === e.currentTarget) {
      onClose();
    }
  };

  return (
    <AnimatePresence>
      {isOpen && (
        <div className="fixed inset-0 z-50 flex items-center justify-center p-4">
          {/* Backdrop */}
          <motion.div
            initial={{ opacity: 0 }}
            animate={{ opacity: 1 }}
            exit={{ opacity: 0 }}
            className="absolute inset-0 bg-black/50 backdrop-blur-sm"
            onClick={handleOverlayClick}
          />

          {/* Modal */}
          <motion.div
            initial={{ opacity: 0, scale: 0.95, y: 20 }}
            animate={{ opacity: 1, scale: 1, y: 0 }}
            exit={{ opacity: 0, scale: 0.95, y: 20 }}
            transition={{ type: "spring", duration: 0.3 }}
            className={cn(
              "relative max-h-screen w-full overflow-y-auto rounded-lg bg-white shadow-xl",
              "dark:bg-gray-900 dark:border dark:border-gray-700 dark:shadow-lg dark:shadow-gray-900/50",
              sizeClasses[size],
              className,
            )}
          >
            {/* Header */}
            {(title || showCloseButton) && visible && (
              <div className="flex items-center justify-between border-b border-gray-200 p-6">
                {title && (
                  <h2 className="text-xl font-semibold text-gray-900">
                    {title}
                  </h2>
                )}
                {showCloseButton && (
                  <button
                    onClick={onClose}
                    className="rounded-full p-2 text-gray-400 transition-colors hover:bg-gray-100 hover:text-gray-600"
                    aria-label="Close modal"
                  >
                    <IoClose size={20} />
                  </button>
                )}
              </div>
            )}

            {/* Content */}
            <div className="p-6">{children}</div>
          </motion.div>
        </div>
      )}
    </AnimatePresence>
  );
};

```

<!-- path: components/common/ui/Modal/index.ts -->
```typescript
// Base Modal Component
export { Modal } from './Modal';

// Confirm Modal Components
export { ConfirmModal, useConfirmModal } from './confirmModal';

// ChangePasswordModal Components
export { ChangePasswordModal } from './ChangePasswordModal';

```

<!-- path: components/common/ui/ProgressBar/ProgressBar.tsx -->
```typescript
// src/components/common/ProgressBar/ProgressBar.tsx
import { motion } from 'framer-motion';
import { cn } from '@/utils/classNames';
import { type ReactNode } from 'react';

// Common types
export type Variant = 'default' | 'success' | 'warning' | 'danger' | 'info';

const sizeClasses = {
  xs: 'h-1',
  sm: 'h-2',
  md: 'h-3',
  lg: 'h-4',
};

const variantClasses: Record<Variant, string> = {
  default: 'bg-blue-500 dark:bg-blue-400',
  success: 'bg-green-500 dark:bg-green-400',
  warning: 'bg-yellow-500 dark:bg-yellow-400',
  danger: 'bg-red-500 dark:bg-red-400',
  info: 'bg-cyan-500 dark:bg-cyan-400',
};

const backgroundClasses: Record<Variant, string> = {
  default: 'bg-blue-100 dark:bg-blue-900',
  success: 'bg-green-100 dark:bg-green-900',
  warning: 'bg-yellow-100 dark:bg-yellow-900',
  danger: 'bg-red-100 dark:bg-red-900',
  info: 'bg-cyan-100 dark:bg-cyan-900',
};

// Linear ProgressBar
interface ProgressBarProps {
  value: number;
  max?: number;
  size?: keyof typeof sizeClasses;
  variant?: Variant;
  showLabel?: boolean;
  label?: string;
  showPercentage?: boolean;
  animated?: boolean;
  striped?: boolean;
  className?: string;
  barClassName?: string;
}

export const ProgressBar: React.FC<ProgressBarProps> = ({
  value,
  max = 100,
  size = 'md',
  variant = 'default',
  showLabel = false,
  label,
  showPercentage = true,
  animated = true,
  striped = false,
  className,
  barClassName,
}) => {
  const percentage = Math.min(Math.max((value / max) * 100, 0), 100);

  return (
    <div className={cn('w-full', className)}>
      {(showLabel || showPercentage) && (
        <div className="mb-2 flex items-center justify-between text-sm">
          {showLabel && <span className="font-medium text-gray-700 dark:text-gray-200">{label || 'Progress'}</span>}
          {showPercentage && <span className="text-gray-600 dark:text-gray-300">{Math.round(percentage)}%</span>}
        </div>
      )}

      <div className={cn('overflow-hidden rounded-full', sizeClasses[size], backgroundClasses[variant])}>
        <motion.div
          className={cn(
            'h-full rounded-full transition-all duration-300 ease-in-out',
            variantClasses[variant],
            striped && 'bg-stripes',
            striped && animated && 'animate-stripes',
            barClassName
          )}
          initial={{ width: 0 }}
          animate={{ width: `${percentage}%` }}
          transition={{ duration: animated ? 0.8 : 0, ease: 'easeOut' }}
        />
      </div>
    </div>
  );
};

// Stacked Progress Bars
interface StackedProgressBarProps {
  segments: { value: number; variant?: Variant }[];
  max?: number;
  size?: keyof typeof sizeClasses;
  animated?: boolean;
  className?: string;
}

export const StackedProgressBar: React.FC<StackedProgressBarProps> = ({
  segments,
  max = 100,
  size = 'md',
  animated = true,
  className,
}) => {
  return (
    <div className={cn('flex w-full overflow-hidden rounded-full', sizeClasses[size], className)}>
      {segments.map((seg, idx) => {
        const width = `${(seg.value / max) * 100}%`;
        const color = variantClasses[seg.variant || 'default'];
        return (
          <motion.div
            key={idx}
            className={cn('h-full', color)}
            initial={{ width: 0 }}
            animate={{ width }}
            transition={{ duration: animated ? 0.8 : 0, ease: 'easeOut' }}
          />
        );
      })}
    </div>
  );
};

// Step Progress Bar with icons
interface StepProgressProps {
  steps: Array<{
    id: string;
    label: string;
    description?: string;
    icon?: ReactNode;
  }>;
  currentStep: number;
  orientation?: 'horizontal' | 'vertical';
  className?: string;
}

export const StepProgress: React.FC<StepProgressProps> = ({
  steps,
  currentStep,
  orientation = 'horizontal',
  className,
}) => {
  const isHorizontal = orientation === 'horizontal';

  return (
    <div className={cn('flex', isHorizontal ? 'items-center space-x-4' : 'flex-col space-y-4', className)}>
      {steps.map((step, index) => {
        const isActive = index === currentStep;
        const isCompleted = index < currentStep;
        const isUpcoming = index > currentStep;

        return (
          <div key={step.id} className={cn('flex items-center', isHorizontal ? 'flex-row' : 'flex-col')}>
            <div className="flex items-center">
              <div
                className={cn(
                  'flex h-8 w-8 items-center justify-center rounded-full text-sm font-medium',
                  isCompleted && 'bg-green-500 text-white',
                  isActive && 'bg-blue-500 text-white',
                  isUpcoming && 'bg-gray-200 text-gray-600 dark:bg-gray-700 dark:text-gray-300'
                )}
              >
                {step.icon || (isCompleted ? (
                  <svg className="h-5 w-5" fill="currentColor" viewBox="0 0 20 20">
                    <path
                      fillRule="evenodd"
                      d="M16.707 5.293a1 1 0 010 1.414l-8 8a1 1 0 01-1.414 0l-4-4a1 1 0 011.414-1.414L8 12.586l7.293-7.293a1 1 0 011.414 0z"
                      clipRule="evenodd"
                    />
                  </svg>
                ) : (
                  index + 1
                ))}
              </div>
              {index < steps.length - 1 && (
                <div
                  className={cn(
                    isHorizontal ? 'h-0.5 w-12' : 'h-12 w-0.5',
                    isCompleted ? 'bg-green-500' : 'bg-gray-200 dark:bg-gray-700'
                  )}
                />
              )}
            </div>
            <div className={cn('ml-3', !isHorizontal && 'ml-0 mt-2')}>
              <p
                className={cn(
                  'text-sm font-medium',
                  isActive && 'text-blue-600 dark:text-blue-400',
                  isCompleted && 'text-green-600 dark:text-green-400',
                  isUpcoming && 'text-gray-500 dark:text-gray-400'
                )}
              >
                {step.label}
              </p>
              {step.description && <p className="text-xs text-gray-500 dark:text-gray-400">{step.description}</p>}
            </div>
          </div>
        );
      })}
    </div>
  );
};

```

<!-- path: components/common/ui/ProgressBar/index.ts -->
```typescript
export { ProgressBar } from './ProgressBar';
```

<!-- path: components/common/ui/switch/Switch.tsx -->
```typescript
import { MouseEvent } from "react";
import { Label } from "@/components/common/ui/label/Label";

// Type definitions
type SwitchSize = "sm" | "md" | "lg";
type SwitchColor = "primary" | "secondary" | "success" | "danger" | "warning";

// Omit the onChange from ButtonHTMLAttributes since we're using our own
interface SwitchProps
  extends Omit<React.ButtonHTMLAttributes<HTMLButtonElement>, "onChange"> {
  checked?: boolean;
  onChange?: (checked: boolean) => void;
  disabled?: boolean;
  size?: SwitchSize;
  color?: SwitchColor;
  label?: string;
  labelPosition?: "left" | "right";
  id?: string;
  className?: string;
  showStatusText?: boolean;
  showIcons?: boolean;
}

// Color classes for light and dark modes
const colorClasses: Record<SwitchColor, { light: string; dark: string }> = {
  primary: {
    light: "bg-blue-600",
    dark: "bg-blue-500",
  },
  secondary: {
    light: "bg-gray-600",
    dark: "bg-gray-500",
  },
  success: {
    light: "bg-green-600",
    dark: "bg-green-500",
  },
  danger: {
    light: "bg-red-600",
    dark: "bg-red-500",
  },
  warning: {
    light: "bg-yellow-600",
    dark: "bg-yellow-500",
  },
};

// Switch Component
export const Switch: React.FC<SwitchProps> = ({
  checked = false,
  onChange = () => {},
  disabled = false,
  size = "md",
  color = "primary",
  label,
  labelPosition = "right",
  id,
  className = "",
  showStatusText = false,
  showIcons = false,
  ...props
}) => {
  // Size classes
  const sizeClasses: Record<SwitchSize, { container: string; thumb: string }> =
    {
      sm: {
        container: "h-5 w-9",
        thumb: "h-4 w-4",
      },
      md: {
        container: "h-6 w-11",
        thumb: "h-5 w-5",
      },
      lg: {
        container: "h-7 w-14",
        thumb: "h-6 w-6",
      },
    };

  // Position classes based on checked state
  const translateClasses: Record<SwitchSize, string> = {
    sm: checked ? "translate-x-4" : "translate-x-0",
    md: checked ? "translate-x-5" : "translate-x-0",
    lg: checked ? "translate-x-7" : "translate-x-0",
  };

  const handleClick = (event: MouseEvent<HTMLButtonElement>) => {
    event.preventDefault(); // Prevent form submission if inside a form
    if (!disabled) {
      onChange(!checked);
    }
  };

  return (
    <div className={`inline-flex items-center gap-3 ${className}`}>
      {label && labelPosition === "left" && (
        <Label
          id={id ? `${id}-label` : undefined}
          htmlFor={id}
          className={`${labelPosition === "left" ? "order-first" : ""} ${
            disabled ? "cursor-not-allowed" : "cursor-pointer"
          }`}
          disabled={disabled}
        >
          {label}
        </Label>
      )}

      <div className="flex items-center gap-2">
        {showStatusText && (
          <span
            className={`text-sm ${
              disabled
                ? "text-gray-400 dark:text-gray-500"
                : "text-gray-600 dark:text-gray-300"
            }`}
          >
            {checked ? "On" : "Off"}
          </span>
        )}

        <button
          type="button"
          role="switch"
          aria-checked={checked}
          aria-labelledby={label && id ? `${id}-label` : undefined}
          disabled={disabled}
          onClick={handleClick}
          className={`
            ${
              sizeClasses[size].container
            } relative inline-flex shrink-0 cursor-pointer rounded-full border-2 border-transparent 
            transition-colors duration-200 ease-in-out focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-offset-2
            ${
              checked
                ? colorClasses[color].light
                : "bg-gray-200 dark:bg-gray-600"
            }
            ${disabled ? "opacity-50 cursor-not-allowed" : "hover:opacity-90"}
            dark:${checked ? colorClasses[color].dark : "bg-gray-600"}
          `}
          {...props}
        >
          <span
            className={`
              ${sizeClasses[size].thumb} ${translateClasses[size]} pointer-events-none 
              rounded-full bg-white shadow-lg transform ring-0 transition duration-200 ease-in-out
              flex items-center justify-center
            `}
          >
            {showIcons && (
              <>
                {checked ? (
                  <svg
                    className="h-3 w-3 text-blue-600 dark:text-blue-500"
                    fill="currentColor"
                    viewBox="0 0 20 20"
                  >
                    <path
                      fillRule="evenodd"
                      d="M16.707 5.293a1 1 0 010 1.414l-8 8a1 1 0 01-1.414 0l-4-4a1 1 0 011.414-1.414L8 12.586l7.293-7.293a1 1 0 011.414 0z"
                      clipRule="evenodd"
                    />
                  </svg>
                ) : (
                  <svg
                    className="h-3 w-3 text-gray-400 dark:text-gray-500"
                    fill="currentColor"
                    viewBox="0 0 20 20"
                  >
                    <path
                      fillRule="evenodd"
                      d="M4.293 4.293a1 1 0 011.414 0L10 8.586l4.293-4.293a1 1 0 111.414 1.414L11.414 10l4.293 4.293a1 1 0 01-1.414 1.414L10 11.414l-4.293 4.293a1 1 0 01-1.414-1.414L8.586 10 4.293 5.707a1 1 0 010-1.414z"
                      clipRule="evenodd"
                    />
                  </svg>
                )}
              </>
            )}
          </span>
        </button>
      </div>

      {label && labelPosition === "right" && (
        <Label
          id={id ? `${id}-label` : undefined}
          htmlFor={id}
          className={`${disabled ? "cursor-not-allowed" : "cursor-pointer"}`}
          disabled={disabled}
        >
          {label}
        </Label>
      )}
    </div>
  );
};

// // Basic usage
// <Switch checked={isActive} onChange={setIsActive} />

// // With label on left
// <Switch 
//   label="Dark Mode" 
//   labelPosition="left" 
//   checked={darkMode} 
//   onChange={setDarkMode} 
// />

// // With color and status text
// <Switch
//   color="success"
//   showStatusText
//   checked={isEnabled}
//   onChange={setIsEnabled}
// />

// // With icons and custom size
// <Switch
//   size="lg"
//   showIcons
//   checked={notifications}
//   onChange={setNotifications}
// />

// // Disabled switch
// <Switch
//   disabled
//   label="Read-only"
//   checked={false}
// />

```

<!-- path: components/common/ui/phoneInput/PhoneInputWithCountry.tsx -->
```typescript
"use client";

import { useState } from "react";
import { FaChevronDown } from "react-icons/fa";

interface Country {
  name: string;
  code: string;
  dialCode: string;
  flag: string;
}

// Full country list: name, code, dialCode, flag
const countries: Country[] = [
  { name: "India", code: "IN", dialCode: "+91", flag: "" },
  { name: "Afghanistan", code: "AF", dialCode: "+93", flag: "" },
  { name: "land Islands", code: "AX", dialCode: "+358", flag: "" },
  { name: "Albania", code: "AL", dialCode: "+355", flag: "" },
  { name: "Algeria", code: "DZ", dialCode: "+213", flag: "" },
  { name: "American Samoa", code: "AS", dialCode: "+1684", flag: "" },
  { name: "Andorra", code: "AD", dialCode: "+376", flag: "" },
  { name: "Angola", code: "AO", dialCode: "+244", flag: "" },
  { name: "Anguilla", code: "AI", dialCode: "+1264", flag: "" },
  { name: "Antarctica", code: "AQ", dialCode: "+672", flag: "" },
  { name: "Antigua and Barbuda", code: "AG", dialCode: "+1268", flag: "" },
  { name: "Argentina", code: "AR", dialCode: "+54", flag: "" },
  { name: "Armenia", code: "AM", dialCode: "+374", flag: "" },
  { name: "Aruba", code: "AW", dialCode: "+297", flag: "" },
  { name: "Australia", code: "AU", dialCode: "+61", flag: "" },
  { name: "Austria", code: "AT", dialCode: "+43", flag: "" },
  { name: "Azerbaijan", code: "AZ", dialCode: "+994", flag: "" },
  { name: "Bahamas", code: "BS", dialCode: "+1242", flag: "" },
  { name: "Bahrain", code: "BH", dialCode: "+973", flag: "" },
  { name: "Bangladesh", code: "BD", dialCode: "+880", flag: "" },
  { name: "Barbados", code: "BB", dialCode: "+1246", flag: "" },
  { name: "Belarus", code: "BY", dialCode: "+375", flag: "" },
  { name: "Belgium", code: "BE", dialCode: "+32", flag: "" },
  { name: "Belize", code: "BZ", dialCode: "+501", flag: "" },
  { name: "Benin", code: "BJ", dialCode: "+229", flag: "" },
  { name: "Bermuda", code: "BM", dialCode: "+1441", flag: "" },
  { name: "Bhutan", code: "BT", dialCode: "+975", flag: "" },
  { name: "Bolivia", code: "BO", dialCode: "+591", flag: "" },
  { name: "Bosnia and Herzegovina", code: "BA", dialCode: "+387", flag: "" },
  { name: "Botswana", code: "BW", dialCode: "+267", flag: "" },
  { name: "Brazil", code: "BR", dialCode: "+55", flag: "" },
  {
    name: "British Indian Ocean Territory",
    code: "IO",
    dialCode: "+246",
    flag: "",
  },
  { name: "Brunei Darussalam", code: "BN", dialCode: "+673", flag: "" },
  { name: "Bulgaria", code: "BG", dialCode: "+359", flag: "" },
  { name: "Burkina Faso", code: "BF", dialCode: "+226", flag: "" },
  { name: "Burundi", code: "BI", dialCode: "+257", flag: "" },
  { name: "Cambodia", code: "KH", dialCode: "+855", flag: "" },
  { name: "Cameroon", code: "CM", dialCode: "+237", flag: "" },
  { name: "Canada", code: "CA", dialCode: "+1", flag: "" },
  { name: "Cape Verde", code: "CV", dialCode: "+238", flag: "" },
  { name: "Cayman Islands", code: "KY", dialCode: "+1345", flag: "" },
  {
    name: "Central African Republic",
    code: "CF",
    dialCode: "+236",
    flag: "",
  },
  { name: "Chad", code: "TD", dialCode: "+235", flag: "" },
  { name: "Chile", code: "CL", dialCode: "+56", flag: "" },
  { name: "China", code: "CN", dialCode: "+86", flag: "" },
  { name: "Christmas Island", code: "CX", dialCode: "+61", flag: "" },
  { name: "Cocos (Keeling) Islands", code: "CC", dialCode: "+61", flag: "" },
  { name: "Colombia", code: "CO", dialCode: "+57", flag: "" },
  { name: "Comoros", code: "KM", dialCode: "+269", flag: "" },
  { name: "Congo", code: "CG", dialCode: "+242", flag: "" },
  {
    name: "Congo, The Democratic Republic of the",
    code: "CD",
    dialCode: "+243",
    flag: "",
  },
  { name: "Cook Islands", code: "CK", dialCode: "+682", flag: "" },
  { name: "Costa Rica", code: "CR", dialCode: "+506", flag: "" },
  { name: "Cte d'Ivoire", code: "CI", dialCode: "+225", flag: "" },
  { name: "Croatia", code: "HR", dialCode: "+385", flag: "" },
  { name: "Cuba", code: "CU", dialCode: "+53", flag: "" },
  { name: "Curaao", code: "CW", dialCode: "+599", flag: "" },
  { name: "Cyprus", code: "CY", dialCode: "+357", flag: "" },
  { name: "Czech Republic", code: "CZ", dialCode: "+420", flag: "" },
  { name: "Denmark", code: "DK", dialCode: "+45", flag: "" },
  { name: "Djibouti", code: "DJ", dialCode: "+253", flag: "" },
  { name: "Dominica", code: "DM", dialCode: "+1767", flag: "" },
  { name: "Dominican Republic", code: "DO", dialCode: "+1809", flag: "" },
  { name: "Ecuador", code: "EC", dialCode: "+593", flag: "" },
  { name: "Egypt", code: "EG", dialCode: "+20", flag: "" },
  { name: "El Salvador", code: "SV", dialCode: "+503", flag: "" },
  { name: "Equatorial Guinea", code: "GQ", dialCode: "+240", flag: "" },
  { name: "Eritrea", code: "ER", dialCode: "+291", flag: "" },
  { name: "Estonia", code: "EE", dialCode: "+372", flag: "" },
  { name: "Ethiopia", code: "ET", dialCode: "+251", flag: "" },
  {
    name: "Falkland Islands (Malvinas)",
    code: "FK",
    dialCode: "+500",
    flag: "",
  },
  { name: "Faroe Islands", code: "FO", dialCode: "+298", flag: "" },
  { name: "Fiji", code: "FJ", dialCode: "+679", flag: "" },
  { name: "Finland", code: "FI", dialCode: "+358", flag: "" },
  { name: "France", code: "FR", dialCode: "+33", flag: "" },
  { name: "French Guiana", code: "GF", dialCode: "+594", flag: "" },
  { name: "French Polynesia", code: "PF", dialCode: "+689", flag: "" },
  { name: "Gabon", code: "GA", dialCode: "+241", flag: "" },
  { name: "Gambia", code: "GM", dialCode: "+220", flag: "" },
  { name: "Georgia", code: "GE", dialCode: "+995", flag: "" },
  { name: "Germany", code: "DE", dialCode: "+49", flag: "" },
  { name: "Ghana", code: "GH", dialCode: "+233", flag: "" },
  { name: "Gibraltar", code: "GI", dialCode: "+350", flag: "" },
  { name: "Greece", code: "GR", dialCode: "+30", flag: "" },
  { name: "Greenland", code: "GL", dialCode: "+299", flag: "" },
  { name: "Grenada", code: "GD", dialCode: "+1473", flag: "" },
  { name: "Guadeloupe", code: "GP", dialCode: "+590", flag: "" },
  { name: "Guam", code: "GU", dialCode: "+1671", flag: "" },
  { name: "Guatemala", code: "GT", dialCode: "+502", flag: "" },
  { name: "Guernsey", code: "GG", dialCode: "+44", flag: "" },
  { name: "Guinea", code: "GN", dialCode: "+224", flag: "" },
  { name: "Guinea-Bissau", code: "GW", dialCode: "+245", flag: "" },
  { name: "Guyana", code: "GY", dialCode: "+592", flag: "" },
  { name: "Haiti", code: "HT", dialCode: "+509", flag: "" },
  { name: "Honduras", code: "HN", dialCode: "+504", flag: "" },
  { name: "Hong Kong", code: "HK", dialCode: "+852", flag: "" },
  { name: "Hungary", code: "HU", dialCode: "+36", flag: "" },
  { name: "Iceland", code: "IS", dialCode: "+354", flag: "" },
  { name: "Indonesia", code: "ID", dialCode: "+62", flag: "" },
  {
    name: "Iran, Islamic Republic of",
    code: "IR",
    dialCode: "+98",
    flag: "",
  },
  { name: "Iraq", code: "IQ", dialCode: "+964", flag: "" },
  { name: "Ireland", code: "IE", dialCode: "+353", flag: "" },
  { name: "Isle of Man", code: "IM", dialCode: "+44", flag: "" },
  { name: "Israel", code: "IL", dialCode: "+972", flag: "" },
  { name: "Italy", code: "IT", dialCode: "+39", flag: "" },
  { name: "Jamaica", code: "JM", dialCode: "+1876", flag: "" },
  { name: "Japan", code: "JP", dialCode: "+81", flag: "" },
  { name: "Jersey", code: "JE", dialCode: "+44", flag: "" },
  { name: "Jordan", code: "JO", dialCode: "+962", flag: "" },
  { name: "Kazakhstan", code: "KZ", dialCode: "+7", flag: "" },
  { name: "Kenya", code: "KE", dialCode: "+254", flag: "" },
  { name: "Kiribati", code: "KI", dialCode: "+686", flag: "" },
  {
    name: "Korea, Democratic People's Republic of",
    code: "KP",
    dialCode: "+850",
    flag: "",
  },
  { name: "Korea, Republic of", code: "KR", dialCode: "+82", flag: "" },
  { name: "Kuwait", code: "KW", dialCode: "+965", flag: "" },
  { name: "Kyrgyzstan", code: "KG", dialCode: "+996", flag: "" },
  {
    name: "Lao People's Democratic Republic",
    code: "LA",
    dialCode: "+856",
    flag: "",
  },
  { name: "Latvia", code: "LV", dialCode: "+371", flag: "" },
  { name: "Lebanon", code: "LB", dialCode: "+961", flag: "" },
  { name: "Lesotho", code: "LS", dialCode: "+266", flag: "" },
  { name: "Liberia", code: "LR", dialCode: "+231", flag: "" },
  { name: "Libya", code: "LY", dialCode: "+218", flag: "" },
  { name: "Liechtenstein", code: "LI", dialCode: "+423", flag: "" },
  { name: "Lithuania", code: "LT", dialCode: "+370", flag: "" },
  { name: "Luxembourg", code: "LU", dialCode: "+352", flag: "" },
  { name: "Macao", code: "MO", dialCode: "+853", flag: "" },
  {
    name: "Macedonia, The Former Yugoslav Republic of",
    code: "MK",
    dialCode: "+389",
    flag: "",
  },
  { name: "Madagascar", code: "MG", dialCode: "+261", flag: "" },
  { name: "Malawi", code: "MW", dialCode: "+265", flag: "" },
  { name: "Malaysia", code: "MY", dialCode: "+60", flag: "" },
  { name: "Maldives", code: "MV", dialCode: "+960", flag: "" },
  { name: "Mali", code: "ML", dialCode: "+223", flag: "" },
  { name: "Malta", code: "MT", dialCode: "+356", flag: "" },
  { name: "Marshall Islands", code: "MH", dialCode: "+692", flag: "" },
  { name: "Martinique", code: "MQ", dialCode: "+596", flag: "" },
  { name: "Mauritania", code: "MR", dialCode: "+222", flag: "" },
  { name: "Mauritius", code: "MU", dialCode: "+230", flag: "" },
  { name: "Mayotte", code: "YT", dialCode: "+262", flag: "" },
  { name: "Mexico", code: "MX", dialCode: "+52", flag: "" },
  {
    name: "Micronesia, Federated States of",
    code: "FM",
    dialCode: "+691",
    flag: "",
  },
  { name: "Moldova, Republic of", code: "MD", dialCode: "+373", flag: "" },
  { name: "Monaco", code: "MC", dialCode: "+377", flag: "" },
  { name: "Mongolia", code: "MN", dialCode: "+976", flag: "" },
  { name: "Montenegro", code: "ME", dialCode: "+382", flag: "" },
  { name: "Montserrat", code: "MS", dialCode: "+1664", flag: "" },
  { name: "Morocco", code: "MA", dialCode: "+212", flag: "" },
  { name: "Mozambique", code: "MZ", dialCode: "+258", flag: "" },
  { name: "Myanmar", code: "MM", dialCode: "+95", flag: "" },
  { name: "Namibia", code: "NA", dialCode: "+264", flag: "" },
  { name: "Nauru", code: "NR", dialCode: "+674", flag: "" },
  { name: "Nepal", code: "NP", dialCode: "+977", flag: "" },
  { name: "Netherlands", code: "NL", dialCode: "+31", flag: "" },
  { name: "New Caledonia", code: "NC", dialCode: "+687", flag: "" },
  { name: "New Zealand", code: "NZ", dialCode: "+64", flag: "" },
  { name: "Nicaragua", code: "NI", dialCode: "+505", flag: "" },
  { name: "Niger", code: "NE", dialCode: "+227", flag: "" },
  { name: "Nigeria", code: "NG", dialCode: "+234", flag: "" },
  { name: "Niue", code: "NU", dialCode: "+683", flag: "" },
  { name: "Norfolk Island", code: "NF", dialCode: "+672", flag: "" },
  {
    name: "Northern Mariana Islands",
    code: "MP",
    dialCode: "+1670",
    flag: "",
  },
  { name: "Norway", code: "NO", dialCode: "+47", flag: "" },
  { name: "Oman", code: "OM", dialCode: "+968", flag: "" },
  { name: "Pakistan", code: "PK", dialCode: "+92", flag: "" },
  { name: "Palau", code: "PW", dialCode: "+680", flag: "" },
  { name: "Palestine, State of", code: "PS", dialCode: "+970", flag: "" },
  { name: "Panama", code: "PA", dialCode: "+507", flag: "" },
  { name: "Papua New Guinea", code: "PG", dialCode: "+675", flag: "" },
  { name: "Paraguay", code: "PY", dialCode: "+595", flag: "" },
  { name: "Peru", code: "PE", dialCode: "+51", flag: "" },
  { name: "Philippines", code: "PH", dialCode: "+63", flag: "" },
  { name: "Pitcairn", code: "PN", dialCode: "+870", flag: "" },
  { name: "Poland", code: "PL", dialCode: "+48", flag: "" },
  { name: "Portugal", code: "PT", dialCode: "+351", flag: "" },
  { name: "Puerto Rico", code: "PR", dialCode: "+1", flag: "" },
  { name: "Qatar", code: "QA", dialCode: "+974", flag: "" },
  { name: "Runion", code: "RE", dialCode: "+262", flag: "" },
  { name: "Romania", code: "RO", dialCode: "+40", flag: "" },
  { name: "Russia", code: "RU", dialCode: "+7", flag: "" },
  { name: "Rwanda", code: "RW", dialCode: "+250", flag: "" },
  { name: "Saint Barthlemy", code: "BL", dialCode: "+590", flag: "" },
  { name: "Saint Helena", code: "SH", dialCode: "+290", flag: "" },
  { name: "Saint Kitts and Nevis", code: "KN", dialCode: "+1869", flag: "" },
  { name: "Saint Lucia", code: "LC", dialCode: "+1758", flag: "" },
  {
    name: "Saint Martin (French part)",
    code: "MF",
    dialCode: "+590",
    flag: "",
  },
  {
    name: "Saint Pierre and Miquelon",
    code: "PM",
    dialCode: "+508",
    flag: "",
  },
  {
    name: "Saint Vincent and the Grenadines",
    code: "VC",
    dialCode: "+1784",
    flag: "",
  },
  { name: "Samoa", code: "WS", dialCode: "+685", flag: "" },
  { name: "San Marino", code: "SM", dialCode: "+378", flag: "" },
  { name: "Sao Tome and Principe", code: "ST", dialCode: "+239", flag: "" },
  { name: "Saudi Arabia", code: "SA", dialCode: "+966", flag: "" },
  { name: "Senegal", code: "SN", dialCode: "+221", flag: "" },
  { name: "Serbia", code: "RS", dialCode: "+381", flag: "" },
  { name: "Seychelles", code: "SC", dialCode: "+248", flag: "" },
  { name: "Sierra Leone", code: "SL", dialCode: "+232", flag: "" },
  { name: "Singapore", code: "SG", dialCode: "+65", flag: "" },
  {
    name: "Sint Maarten (Dutch part)",
    code: "SX",
    dialCode: "+1721",
    flag: "",
  },
  { name: "Slovakia", code: "SK", dialCode: "+421", flag: "" },
  { name: "Slovenia", code: "SI", dialCode: "+386", flag: "" },
  { name: "Solomon Islands", code: "SB", dialCode: "+677", flag: "" },
  { name: "Somalia", code: "SO", dialCode: "+252", flag: "" },
  { name: "South Africa", code: "ZA", dialCode: "+27", flag: "" },
  { name: "South Sudan", code: "SS", dialCode: "+211", flag: "" },
  { name: "Spain", code: "ES", dialCode: "+34", flag: "" },
  { name: "Sri Lanka", code: "LK", dialCode: "+94", flag: "" },
  { name: "Sudan", code: "SD", dialCode: "+249", flag: "" },
  { name: "Suriname", code: "SR", dialCode: "+597", flag: "" },
  { name: "Svalbard and Jan Mayen", code: "SJ", dialCode: "+47", flag: "" },
  { name: "Swaziland", code: "SZ", dialCode: "+268", flag: "" },
  { name: "Sweden", code: "SE", dialCode: "+46", flag: "" },
  { name: "Switzerland", code: "CH", dialCode: "+41", flag: "" },
  { name: "Syrian Arab Republic", code: "SY", dialCode: "+963", flag: "" },
  { name: "Taiwan", code: "TW", dialCode: "+886", flag: "" },
  { name: "Tajikistan", code: "TJ", dialCode: "+992", flag: "" },
  {
    name: "Tanzania, United Republic of",
    code: "TZ",
    dialCode: "+255",
    flag: "",
  },
  { name: "Thailand", code: "TH", dialCode: "+66", flag: "" },
  { name: "Timor-Leste", code: "TL", dialCode: "+670", flag: "" },
  { name: "Togo", code: "TG", dialCode: "+228", flag: "" },
  { name: "Tokelau", code: "TK", dialCode: "+690", flag: "" },
  { name: "Tonga", code: "TO", dialCode: "+676", flag: "" },
  { name: "Trinidad and Tobago", code: "TT", dialCode: "+1868", flag: "" },
  { name: "Tunisia", code: "TN", dialCode: "+216", flag: "" },
  { name: "Turkey", code: "TR", dialCode: "+90", flag: "" },
  { name: "Turkmenistan", code: "TM", dialCode: "+993", flag: "" },
  {
    name: "Turks and Caicos Islands",
    code: "TC",
    dialCode: "+1649",
    flag: "",
  },
  { name: "Tuvalu", code: "TV", dialCode: "+688", flag: "" },
  { name: "Uganda", code: "UG", dialCode: "+256", flag: "" },
  { name: "Ukraine", code: "UA", dialCode: "+380", flag: "" },
  { name: "United Arab Emirates", code: "AE", dialCode: "+971", flag: "" },
  { name: "United Kingdom", code: "GB", dialCode: "+44", flag: "" },
  { name: "United States", code: "US", dialCode: "+1", flag: "" },
  { name: "Uruguay", code: "UY", dialCode: "+598", flag: "" },
  { name: "Uzbekistan", code: "UZ", dialCode: "+998", flag: "" },
  { name: "Vanuatu", code: "VU", dialCode: "+678", flag: "" },
  { name: "Venezuela", code: "VE", dialCode: "+58", flag: "" },
  { name: "Vietnam", code: "VN", dialCode: "+84", flag: "" },
  {
    name: "Virgin Islands, British",
    code: "VG",
    dialCode: "+1284",
    flag: "",
  },
  { name: "Virgin Islands, U.S.", code: "VI", dialCode: "+1340", flag: "" },
  { name: "Wallis and Futuna", code: "WF", dialCode: "+681", flag: "" },
  { name: "Western Sahara", code: "EH", dialCode: "+212", flag: "" },
  { name: "Yemen", code: "YE", dialCode: "+967", flag: "" },
  { name: "Zambia", code: "ZM", dialCode: "+260", flag: "" },
  { name: "Zimbabwe", code: "ZW", dialCode: "+263", flag: "" },
];
interface PhoneInputWithCountryProps {
  value: string | null;
  onChange: (value: string) => void;
}

export default function PhoneInputWithCountry({
  value,
  onChange,
}: PhoneInputWithCountryProps) {
  const [selectedCountry, setSelectedCountry] = useState<Country>(countries[0]);

  const handleNumberChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    const number = e.target.value.replace(/\D/g, "");
    onChange(`${selectedCountry.dialCode}${number}`);
  };

  const handleCountryChange = (e: React.ChangeEvent<HTMLSelectElement>) => {
    const country = countries.find((c) => c.code === e.target.value);
    if (country) {
      setSelectedCountry(country);
      const currentNumber = (value ?? "").replace(/^\+\d+/, "");
      const newValue = `${country.dialCode}${currentNumber}`;
      if (newValue !== value) {
        onChange(newValue);
      }
    }
  };

  return (
    <div className="flex flex-col gap-2">
      <label className="text-sm font-medium text-gray-700 dark:text-gray-300">
        Phone Number
      </label>
      <div className="flex gap-2">
        <div className="relative w-44">
          <select
            value={selectedCountry.code}
            onChange={handleCountryChange}
            className="w-full cursor-pointer appearance-none rounded-lg border border-gray-300 bg-white py-2 pr-8 pl-3 text-sm focus:ring-2 focus:ring-blue-500 focus:outline-none dark:border-gray-600 dark:bg-gray-800 dark:text-white"
          >
            {countries.map((country) => (
              <option key={country.code} value={country.code}>
                {country.flag} {country.dialCode}
              </option>
            ))}
          </select>
          <FaChevronDown className="pointer-events-none absolute top-3 right-2 text-gray-500" />
        </div>

        <input
          type="tel"
          placeholder="Enter phone number"
          value={(value ?? "").replace(selectedCountry.dialCode, "")}
          onChange={handleNumberChange}
          className="flex-1 rounded-lg border border-gray-300 px-3 py-2 text-sm focus:ring-2 focus:ring-blue-500 focus:outline-none dark:border-gray-600 dark:bg-gray-800 dark:text-white"
        />
      </div>
      <p className="text-xs text-gray-500 dark:text-gray-400">
        Full Contact Number: <span className="font-medium">{value}</span>
      </p>
    </div>
  );
}

```

<!-- path: components/common/ui/phoneInput/index.ts -->
```typescript
export { default as PhoneInputWithCountry } from './PhoneInputWithCountry';
```

<!-- path: components/common/ui/theme/ThemeToggle.tsx -->
```typescript
"use client";

import { useThemeStore, Theme } from "@/stores/themeStore";
import { useState, useRef, useEffect } from "react";
import { FiChevronDown, FiMonitor, FiMoon, FiSun } from "react-icons/fi";

export default function ThemeToggle() {
  const { theme, setTheme, hydrated } = useThemeStore();
  const [isOpen, setIsOpen] = useState(false);
  const dropdownRef = useRef<HTMLDivElement>(null);
  const timeoutRef = useRef<NodeJS.Timeout | null>(null);

  const options = [
    { value: "light" as Theme, icon: <FiSun size={16} />, label: "Light" },
    { value: "dark" as Theme, icon: <FiMoon size={16} />, label: "Dark" },
    { value: "system" as Theme, icon: <FiMonitor size={16} />, label: "System" },
  ];

  const currentOption = options.find((opt) => opt.value === theme);

  useEffect(() => {
    return () => {
      if (timeoutRef.current) {
        clearTimeout(timeoutRef.current);
      }
    };
  }, []);

  useEffect(() => {
    const handleClickOutside = (event: MouseEvent) => {
      if (
        dropdownRef.current &&
        !dropdownRef.current.contains(event.target as Node)
      ) {
        setIsOpen(false);
      }
    };

    document.addEventListener("mousedown", handleClickOutside);
    return () => document.removeEventListener("mousedown", handleClickOutside);
  }, []);

  const handleMouseEnter = () => {
    if (timeoutRef.current) {
      clearTimeout(timeoutRef.current);
    }
    setIsOpen(true);
  };

  const handleMouseLeave = () => {
    timeoutRef.current = setTimeout(() => {
      setIsOpen(false);
    }, 300);
  };

  const handleOptionClick = (value: Theme) => {
    setTheme(value);
    setIsOpen(false);
    if (timeoutRef.current) {
      clearTimeout(timeoutRef.current);
    }
  };

  // Show loading state until hydrated
  if (!hydrated) {
    return (
      <div className="h-10 w-32 animate-pulse rounded-lg bg-gray-200 dark:bg-gray-700" />
    );
  }

  return (
    <div
      ref={dropdownRef}
      className="relative"
      onMouseEnter={handleMouseEnter}
      onMouseLeave={handleMouseLeave}
    >
      <button
        onClick={() => setIsOpen(!isOpen)}
        className="flex items-center gap-2 rounded-lg bg-gray-200 px-3 py-2 text-gray-700 hover:bg-gray-300 dark:bg-gray-700 dark:text-white dark:hover:bg-gray-600"
        aria-expanded={isOpen}
      >
        {currentOption?.icon}
        <span className="text-sm">{currentOption?.label}</span>
        <FiChevronDown
          size={16}
          className={`transition-transform ${isOpen ? "rotate-180" : ""}`}
        />
      </button>

      {isOpen && (
        <div
          className="absolute z-10 mt-1 w-full rounded-lg border border-gray-200 bg-white shadow-lg dark:border-gray-700 dark:bg-gray-800"
          onMouseEnter={handleMouseEnter}
          onMouseLeave={handleMouseLeave}
        >
          {options.map((opt) => (
            <button
              key={opt.value}
              onClick={() => handleOptionClick(opt.value)}
              className={`flex w-full items-center gap-2 px-3 py-2 text-left text-gray-700 dark:text-white ${
                theme === opt.value
                  ? "bg-blue-100 text-blue-700 dark:bg-blue-900/50 dark:text-blue-300"
                  : "hover:bg-gray-100 dark:hover:bg-gray-700"
              }`}
            >
              {opt.icon}
              <span>{opt.label}</span>
            </button>
          ))}
        </div>
      )}
    </div>
  );
}
```

<!-- path: components/common/ui/label/Label.tsx -->
```typescript
// Type definitions
type LabelSize = "xs" | "sm" | "md" | "lg" | "xl";
type LabelWeight = "normal" | "medium" | "semibold" | "bold";

interface LabelProps extends React.LabelHTMLAttributes<HTMLLabelElement> {
  children: React.ReactNode;
  htmlFor?: string;
  required?: boolean;
  disabled?: boolean;
  size?: LabelSize;
  weight?: LabelWeight;
  className?: string;
  showRequiredSymbol?: boolean;
  tooltip?: string;
}

// Label Component  
export const Label: React.FC<LabelProps> = ({ 
  children, 
  htmlFor, 
  required = false, 
  disabled = false,
  size = "md",
  weight = "medium",
  className = "",
  showRequiredSymbol = true,
  tooltip,
  ...props 
}) => {
  const sizeClasses: Record<LabelSize, string> = {
    xs: "text-xs",
    sm: "text-sm",
    md: "text-base", 
    lg: "text-lg",
    xl: "text-xl"
  };

  const weightClasses: Record<LabelWeight, string> = {
    normal: "font-normal",
    medium: "font-medium",
    semibold: "font-semibold",
    bold: "font-bold"
  };

  return (
    <label
      htmlFor={htmlFor}
      className={`
        ${sizeClasses[size]} 
        ${weightClasses[weight]} 
        block text-gray-900 dark:text-gray-100
        ${disabled ? 'text-gray-400 dark:text-gray-500 cursor-not-allowed' : 'cursor-pointer'}
        ${className}
        relative
      `}
      aria-disabled={disabled}
      data-tooltip={tooltip}
      {...props}
    >
      {children}
      {required && showRequiredSymbol && (
        <span className="text-red-500 dark:text-red-400 ml-1">*</span>
      )}
      {tooltip && (
        <span className="ml-2 text-gray-400 dark:text-gray-500 hover:text-gray-500 dark:hover:text-gray-400">
          <svg 
            xmlns="http://www.w3.org/2000/svg" 
            className="h-4 w-4 inline" 
            fill="none" 
            viewBox="0 0 24 24" 
            stroke="currentColor"
          >
            <path 
              strokeLinecap="round" 
              strokeLinejoin="round" 
              strokeWidth={2} 
              d="M13 16h-1v-4h-1m1-4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z" 
            />
          </svg>
        </span>
      )}
    </label>
  );
};


// // Usage
// // Basic usage
// <Label htmlFor="email">Email Address</Label>

// // With required field
// <Label htmlFor="password" required>Password</Label>

// // With tooltip
// <Label htmlFor="api-key" tooltip="Your unique API identifier">API Key</Label>

// // Custom size and weight
// <Label htmlFor="name" size="lg" weight="bold">Full Name</Label>

// // Disabled state
// <Label htmlFor="readonly" disabled>Read-only Field</Label>
```

<!-- path: components/common/ui/Button/Button.tsx -->
```typescript
// src/components/common/Button/Button.tsx
import { forwardRef, type ButtonHTMLAttributes } from 'react';
import { FiChevronDown } from 'react-icons/fi';
import { cn } from '@/utils/classNames';
import { ButtonSpinner } from '../LoadingSpinner';

export interface ButtonProps extends ButtonHTMLAttributes<HTMLButtonElement> {
  variant?: 'primary' | 'secondary' | 'success' | 'warning' | 'danger' | 'ghost' | 'outline';
  size?: 'xs' | 'sm' | 'md' | 'lg' | 'xl';
  loading?: boolean;
  loadingText?: string;
  leftIcon?: React.ReactNode;
  rightIcon?: React.ReactNode;
  fullWidth?: boolean;
  rounded?: 'none' | 'sm' | 'md' | 'lg' | 'full';
  isdropdown?: boolean;
}

const variants = {
  primary: 'bg-blue-600 text-white hover:bg-blue-700 focus:ring-blue-500 disabled:bg-blue-300',
  secondary: 'bg-gray-600 text-white hover:bg-gray-700 focus:ring-gray-500 disabled:bg-gray-300',
  success: 'bg-green-600 text-white hover:bg-green-700 focus:ring-green-500 disabled:bg-green-300',
  warning: 'bg-yellow-600 text-white hover:bg-yellow-700 focus:ring-yellow-500 disabled:bg-yellow-300',
  danger: 'bg-red-600 text-white hover:bg-red-700 focus:ring-red-500 disabled:bg-red-300',
  ghost: 'text-gray-700 hover:bg-gray-100 focus:ring-gray-500 disabled:text-gray-400',
  outline: 'border border-gray-300 text-gray-700 hover:bg-gray-50 focus:ring-gray-500 disabled:text-gray-400 disabled:border-gray-200',
};

const sizes = {
  xs: 'px-2 py-1 text-xs',
  sm: 'px-3 py-1.5 text-sm',
  md: 'px-4 py-2 text-sm',
  lg: 'px-5 py-2.5 text-base',
  xl: 'px-6 py-3 text-lg',
};

const roundedOptions = {
  none: 'rounded-none',
  sm: 'rounded-sm',
  md: 'rounded-md',
  lg: 'rounded-lg',
  full: 'rounded-full',
};

export const Button = forwardRef<HTMLButtonElement, ButtonProps>(
  (
    {
      variant = 'primary',
      size = 'md',
      loading = false,
      loadingText,
      leftIcon,
      rightIcon,
      fullWidth = false,
      rounded = 'md',
      disabled,
      isdropdown,
      children,
      className,
      ...props
    },
    ref
  ) => {
    const isDisabled = disabled || loading;

    return (
      <button
        ref={ref}
        disabled={isDisabled}
        className={cn(
          // Base styles
          'inline-flex items-center justify-center font-medium transition-all duration-200 focus:outline-none focus:ring-2 focus:ring-offset-2',
          // Variant styles
          variants[variant],
          // Size styles
          sizes[size],
          // Rounded styles
          roundedOptions[rounded],
          // Full width
          fullWidth && 'w-full',
          // Disabled cursor
          isDisabled && 'cursor-not-allowed',
          // Custom className
          className
        )}
        {...props}
      >
        {/* Loading spinner */}
        {loading && (
          <ButtonSpinner
            size={size === 'xs' ? 'xs' : size === 'sm' ? 'sm' : 'sm'}
          />
        )}

        {/* Left icon */}
        {!loading && leftIcon && (
          <span className="mr-2 flex items-center">
            {leftIcon}
          </span>
        )}

        {/* Button content */}
        <span>
          {loading && loadingText ? loadingText : children}
        </span>

        {/* Right icon or dropdown indicator */}
        {!loading && (rightIcon || isdropdown) && (
          <span className="ml-2 flex items-center">
            {rightIcon || <FiChevronDown className="h-4 w-4" />}
          </span>
        )}
      </button>
    );
  }
);

Button.displayName = 'Button';

// Icon button variant
interface IconButtonProps extends Omit<ButtonProps, 'leftIcon' | 'rightIcon'> {
  icon: React.ReactNode;
  label?: string; // For accessibility
}

export const IconButton = forwardRef<HTMLButtonElement, IconButtonProps>(
  ({ icon, label, size = 'md', className, ...props }, ref) => {
    const iconSizes = {
      xs: 'h-3 w-3',
      sm: 'h-4 w-4',
      md: 'h-5 w-5',
      lg: 'h-6 w-6',
      xl: 'h-7 w-7',
    };

    return (
      <Button
        ref={ref}
        size={size}
        className={cn(
          'aspect-square !p-0',
          className
        )}
        aria-label={label}
        {...props}
      >
        <span className={iconSizes[size]}>
          {icon}
        </span>
      </Button>
    );
  }
);

IconButton.displayName = 'IconButton';

// Button group component
interface ButtonGroupProps {
  children: React.ReactNode;
  orientation?: 'horizontal' | 'vertical';
  attached?: boolean;
  className?: string;
}

export const ButtonGroup: React.FC<ButtonGroupProps> = ({
  children,
  orientation = 'horizontal',
  attached = false,
  className,
}) => {
  return (
    <div
      className={cn(
        'inline-flex',
        orientation === 'horizontal' ? 'flex-row' : 'flex-col',
        attached && orientation === 'horizontal' && '[&>*:not(:first-child)]:ml-0 [&>*:not(:first-child)]:rounded-l-none [&>*:not(:last-child)]:rounded-r-none [&>*]:border-r-0 [&>*:last-child]:border-r',
        attached && orientation === 'vertical' && '[&>*:not(:first-child)]:mt-0 [&>*:not(:first-child)]:rounded-t-none [&>*:not(:last-child)]:rounded-b-none [&>*]:border-b-0 [&>*:last-child]:border-b',
        !attached && orientation === 'horizontal' && 'space-x-2',
        !attached && orientation === 'vertical' && 'space-y-2',
        className
      )}
    >
      {children}
    </div>
  );
};

// Floating Action Button
interface FABProps extends Omit<ButtonProps, 'size' | 'variant'> {
  size?: 'md' | 'lg';
  position?: 'bottom-right' | 'bottom-left' | 'top-right' | 'top-left';
  icon?: React.ReactNode;
}

export const FloatingActionButton: React.FC<FABProps> = ({
  size = 'lg',
  position = 'bottom-right',
  icon,
  children,
  className,
  ...props
}) => {
  const positions = {
    'bottom-right': 'fixed bottom-6 right-6',
    'bottom-left': 'fixed bottom-6 left-6',
    'top-right': 'fixed top-6 right-6',
    'top-left': 'fixed top-6 left-6',
  };

  const fabSizes = {
    md: 'h-12 w-12',
    lg: 'h-14 w-14',
  };

  return (
    <Button
      variant="primary"
      rounded="full"
      className={cn(
        positions[position],
        fabSizes[size],
        'shadow-lg hover:shadow-xl z-50 !p-0',
        className
      )}
      {...props}
    >
      {icon || children}
    </Button>
  );
};

// Specialized exam buttons
export const SubmitButton: React.FC<Omit<ButtonProps, 'variant'>> = (props) => (
  <Button variant="success" {...props} />
);

export const CancelButton: React.FC<Omit<ButtonProps, 'variant'>> = (props) => (
  <Button variant="outline" {...props} />
);

export const DeleteButton: React.FC<Omit<ButtonProps, 'variant'>> = (props) => (
  <Button variant="danger" {...props} />
);

export const NextButton: React.FC<Omit<ButtonProps, 'variant' | 'rightIcon'>> = (props) => (
  <Button
    variant="primary"
    rightIcon={
      <svg className="h-4 w-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
        <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M9 5l7 7-7 7" />
      </svg>
    }
    {...props}
  />
);

export const PreviousButton: React.FC<Omit<ButtonProps, 'variant' | 'leftIcon'>> = (props) => (
  <Button
    variant="secondary"
    leftIcon={
      <svg className="h-4 w-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
        <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M15 19l-7-7 7-7" />
      </svg>
    }
    {...props}
  />
);
```

<!-- path: components/common/ui/Button/index.ts -->
```typescript
export { Button } from './Button';
```

<!-- path: components/common/ui/select/Select.tsx -->
```typescript
"use client"

import * as React from "react"
import * as SelectPrimitive from "@radix-ui/react-select"
import { CheckIcon, ChevronDownIcon, ChevronUpIcon } from "lucide-react"

import { cn } from "@/lib/utils"

function Select({
  ...props
}: React.ComponentProps<typeof SelectPrimitive.Root>) {
  return <SelectPrimitive.Root data-slot="select" {...props} />
}

function SelectGroup({
  ...props
}: React.ComponentProps<typeof SelectPrimitive.Group>) {
  return <SelectPrimitive.Group data-slot="select-group" {...props} />
}

function SelectValue({
  ...props
}: React.ComponentProps<typeof SelectPrimitive.Value>) {
  return <SelectPrimitive.Value data-slot="select-value" {...props} />
}

function SelectTrigger({
  className,
  size = "default",
  children,
  ...props
}: React.ComponentProps<typeof SelectPrimitive.Trigger> & {
  size?: "sm" | "default"
}) {
  return (
    <SelectPrimitive.Trigger
      data-slot="select-trigger"
      data-size={size}
      className={cn(
        "data-[placeholder]:text-muted-foreground [&_svg:not([class*='text-'])]:text-muted-foreground aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive flex w-full items-center justify-between gap-2 rounded-md border px-3 py-2 text-sm whitespace-nowrap shadow-xs transition-[color,box-shadow] outline-none disabled:cursor-not-allowed disabled:opacity-50 data-[size=default]:h-9 data-[size=sm]:h-8 *:data-[slot=select-value]:line-clamp-1 *:data-[slot=select-value]:flex *:data-[slot=select-value]:items-center *:data-[slot=select-value]:gap-2 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4",
        // Align with SearchableSelect visuals
        "bg-white dark:bg-gray-700 border-gray-300 dark:border-gray-600 hover:border-gray-400 dark:hover:border-gray-500 focus-visible:ring-2 focus-visible:ring-blue-500",
        className
      )}
      {...props}
    >
      {children}
      <SelectPrimitive.Icon asChild>
        <ChevronDownIcon className="size-4 opacity-50" />
      </SelectPrimitive.Icon>
    </SelectPrimitive.Trigger>
  )
}

function SelectContent({
  className,
  children,
  position = "popper",
  ...props
}: React.ComponentProps<typeof SelectPrimitive.Content>) {
  return (
    <SelectPrimitive.Portal>
      <SelectPrimitive.Content
        data-slot="select-content"
        className={cn(
          "data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 relative z-50 max-h-(--radix-select-content-available-height) min-w-[8rem] origin-(--radix-select-content-transform-origin) overflow-x-hidden overflow-y-auto rounded-md border shadow-lg",
          // Align with SearchableSelect visuals
          "bg-white dark:bg-gray-700 text-gray-900 dark:text-white border-gray-300 dark:border-gray-600",
          position === "popper" &&
            "data-[side=bottom]:translate-y-1 data-[side=left]:-translate-x-1 data-[side=right]:translate-x-1 data-[side=top]:-translate-y-1",
          className
        )}
        position={position}
        {...props}
      >
        <SelectScrollUpButton />
        <SelectPrimitive.Viewport
          className={cn(
            "p-1",
            position === "popper" &&
              "h-[var(--radix-select-trigger-height)] w-full min-w-[var(--radix-select-trigger-width)] scroll-my-1"
          )}
        >
          {children}
        </SelectPrimitive.Viewport>
        <SelectScrollDownButton />
      </SelectPrimitive.Content>
    </SelectPrimitive.Portal>
  )
}

function SelectLabel({
  className,
  ...props
}: React.ComponentProps<typeof SelectPrimitive.Label>) {
  return (
    <SelectPrimitive.Label
      data-slot="select-label"
      className={cn("text-muted-foreground px-2 py-1.5 text-xs", className)}
      {...props}
    />
  )
}

function SelectItem({
  className,
  children,
  ...props
}: React.ComponentProps<typeof SelectPrimitive.Item>) {
  return (
    <SelectPrimitive.Item
      data-slot="select-item"
      className={cn(
        "relative flex w-full cursor-default items-center gap-2 rounded-sm py-1.5 pr-8 pl-2 text-sm outline-hidden select-none [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4 *:[span]:last:flex *:[span]:last:items-center *:[span]:last:gap-2",
        // Disabled
        "data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
        // Base text colors
        "text-gray-900 dark:text-white [&_svg:not([class*='text-'])]:text-gray-400",
        // Hover/focus and selected states to mirror SearchableSelect
        "hover:bg-gray-100 dark:hover:bg-gray-600",
        "data-[highlighted]:bg-blue-100 dark:data-[highlighted]:bg-blue-900/50 data-[highlighted]:text-blue-900 dark:data-[highlighted]:text-blue-200",
        "data-[state=checked]:bg-blue-50 dark:data-[state=checked]:bg-blue-900/30 data-[state=checked]:text-blue-700 dark:data-[state=checked]:text-blue-300 font-medium",
        className
      )}
      {...props}
    >
      <span className="absolute right-2 flex size-3.5 items-center justify-center">
        <SelectPrimitive.ItemIndicator>
          <CheckIcon className="size-4" />
        </SelectPrimitive.ItemIndicator>
      </span>
      <SelectPrimitive.ItemText>{children}</SelectPrimitive.ItemText>
    </SelectPrimitive.Item>
  )
}

function SelectSeparator({
  className,
  ...props
}: React.ComponentProps<typeof SelectPrimitive.Separator>) {
  return (
    <SelectPrimitive.Separator
      data-slot="select-separator"
      className={cn("bg-border pointer-events-none -mx-1 my-1 h-px", className)}
      {...props}
    />
  )
}

function SelectScrollUpButton({
  className,
  ...props
}: React.ComponentProps<typeof SelectPrimitive.ScrollUpButton>) {
  return (
    <SelectPrimitive.ScrollUpButton
      data-slot="select-scroll-up-button"
      className={cn(
        "flex cursor-default items-center justify-center py-1",
        className
      )}
      {...props}
    >
      <ChevronUpIcon className="size-4" />
    </SelectPrimitive.ScrollUpButton>
  )
}

function SelectScrollDownButton({
  className,
  ...props
}: React.ComponentProps<typeof SelectPrimitive.ScrollDownButton>) {
  return (
    <SelectPrimitive.ScrollDownButton
      data-slot="select-scroll-down-button"
      className={cn(
        "flex cursor-default items-center justify-center py-1",
        className
      )}
      {...props}
    >
      <ChevronDownIcon className="size-4" />
    </SelectPrimitive.ScrollDownButton>
  )
}

export {
  Select,
  SelectContent,
  SelectGroup,
  SelectItem,
  SelectLabel,
  SelectScrollDownButton,
  SelectScrollUpButton,
  SelectSeparator,
  SelectTrigger,
  SelectValue,
}

```

<!-- path: components/common/ui/select/SearchableSelect.tsx -->
```typescript
"use client";

import { Label } from "@/components/common/ui/label/Label";
import { useState, useRef, useEffect, useMemo, useLayoutEffect } from "react";
import { createPortal } from "react-dom";
import { FiChevronDown, FiX, FiSearch } from "react-icons/fi";

// The Option interface remains the same
interface Option {
  value: string;
  label: string;
  disabled?: boolean;
}

export type { Option };

// The props interface remains the same
interface SearchableSelectProps {
  options: Option[];
  value?: string;
  onChange: (value: string | null) => void;
  placeholder?: string;
  searchPlaceholder?: string;
  className?: string;
  disabled?: boolean;
  clearable?: boolean;
  maxHeight?: number;
  noOptionsMessage?: string;
  loading?: boolean;
  required?: boolean;
  error?: boolean;
  sortOptions?: boolean;
  label?: string;
}

export const SearchableSelect: React.FC<SearchableSelectProps> = ({
  options = [],
  value = "",
  onChange,
  placeholder = "Select an option",
  searchPlaceholder = "Search options...",
  className = "",
  disabled = false,
  clearable = true,
  maxHeight = 200,
  noOptionsMessage = "No options found",
  loading = false,
  required = false,
  error = false,
  sortOptions = true,
  label = "",
}) => {
  const [isOpen, setIsOpen] = useState(false);
  const [searchTerm, setSearchTerm] = useState("");
  const [focusedIndex, setFocusedIndex] = useState(-1);
  
  // NEW: State for the dropdown's calculated position
  const [dropdownStyle, setDropdownStyle] = useState<React.CSSProperties>({});

  // Refs for the trigger, the dropdown itself, and the list items
  const triggerRef = useRef<HTMLDivElement>(null);
  const dropdownRef = useRef<HTMLDivElement>(null);
  const searchInputRef = useRef<HTMLInputElement>(null);
  const optionRefs = useRef<(HTMLDivElement | null)[]>([]);

  // Memoized filtering and sorting logic (no changes needed here)
  const filteredOptions = useMemo(() => {
    const processedOptions = [...options];
    if (sortOptions) {
      processedOptions.sort((a, b) => a.label.localeCompare(b.label, undefined, { sensitivity: 'base', numeric: true }));
    }
    if (!searchTerm.trim()) return processedOptions;
    return processedOptions.filter(option =>
      option.label.toLowerCase().includes(searchTerm.toLowerCase())
    );
  }, [options, searchTerm, sortOptions]);

  const selectedOption = options.find(option => option.value === value);
  const selectedLabel = selectedOption?.label || "";
  const hasValue = selectedLabel.length > 0;

  // NEW: Effect to calculate dropdown position using useLayoutEffect for precision
  useLayoutEffect(() => {
    if (isOpen && triggerRef.current) {
      const rect = triggerRef.current.getBoundingClientRect();
      setDropdownStyle({
        // Position fixed relative to the viewport
        position: 'fixed', 
        top: `${rect.bottom + 4}px`, // 4px gap below the trigger
        left: `${rect.left}px`,
        width: `${rect.width}px`, // Match the trigger's width
      });
    }
  }, [isOpen]);

  // Updated Effect to handle clicks outside both the trigger and the dropdown
  useEffect(() => {
    const handleClickOutside = (event: MouseEvent) => {
      if (
        triggerRef.current && !triggerRef.current.contains(event.target as Node) &&
        dropdownRef.current && !dropdownRef.current.contains(event.target as Node)
      ) {
        setIsOpen(false);
        setSearchTerm("");
        setFocusedIndex(-1);
      }
    };
    document.addEventListener("mousedown", handleClickOutside);
    return () => document.removeEventListener("mousedown", handleClickOutside);
  }, []);

  // Effect to focus search input when dropdown opens
  useEffect(() => {
    if (isOpen && searchInputRef.current) {
      // Small timeout to allow the portal to render and be focusable
      setTimeout(() => searchInputRef.current?.focus(), 0);
    }
  }, [isOpen]);
  
  // Keyboard navigation logic (no changes needed here)
  const handleKeyDown = (e: React.KeyboardEvent) => {
    if (disabled) return;
    switch (e.key) {
      case "Enter":
        e.preventDefault();
        if (!isOpen) setIsOpen(true);
        else if (focusedIndex >= 0 && filteredOptions[focusedIndex]) {
          handleOptionSelect(filteredOptions[focusedIndex].value);
        }
        break;
      case "Escape":
        setIsOpen(false);
        setSearchTerm("");
        setFocusedIndex(-1);
        break;
      case "ArrowDown":
        e.preventDefault();
        if (!isOpen) setIsOpen(true);
        else setFocusedIndex(prev => prev < filteredOptions.length - 1 ? prev + 1 : 0);
        break;
      case "ArrowUp":
        e.preventDefault();
        if (isOpen) setFocusedIndex(prev => prev > 0 ? prev - 1 : filteredOptions.length - 1);
        break;
      case "Tab":
        setIsOpen(false);
        setSearchTerm("");
        setFocusedIndex(-1);
        break;
    }
  };

  // Scroll focused option into view (no changes needed here)
  useEffect(() => {
    if (focusedIndex >= 0 && optionRefs.current[focusedIndex]) {
      optionRefs.current[focusedIndex]?.scrollIntoView({ block: "nearest", behavior: "smooth" });
    }
  }, [focusedIndex]);

  // Handlers (no changes needed here)
  const handleOptionSelect = (optionValue: string) => {
    onChange(optionValue);
    setIsOpen(false);
    setSearchTerm("");
    setFocusedIndex(-1);
  };

  const handleClear = (e: React.MouseEvent) => {
    e.stopPropagation();
    onChange(null);
  };

  const toggleDropdown = () => {
    if (!disabled) {
      setIsOpen(!isOpen);
      if (!isOpen) {
        setSearchTerm("");
        setFocusedIndex(-1);
      }
    }
  };
  
  const baseClasses = `relative w-full rounded-md border px-3 py-2 focus-within:ring-2 focus-within:ring-blue-500 focus-within:outline-none transition-colors cursor-pointer ${error ? "border-red-300 dark:border-red-600" : "border-gray-300 dark:border-gray-600"} ${disabled ? "bg-gray-100 cursor-not-allowed dark:bg-gray-600" : `${hasValue ? "bg-gray-50 dark:bg-gray-800" : "bg-white dark:bg-gray-900"} hover:border-gray-400 dark:hover:border-gray-500`} dark:text-white dark:focus-within:ring-blue-600`;

  // Extracted Dropdown JSX to be used in the portal
  const DropdownContent = (
    <div
      ref={dropdownRef}
      style={dropdownStyle}
      className="z-[999] bg-white dark:bg-gray-900 border border-gray-300 dark:border-gray-600 rounded-md shadow-lg"
    >
      <div className="p-2 border-b border-gray-200 dark:border-gray-600">
        <div className="relative">
          <FiSearch className="absolute left-3 top-1/2 transform -translate-y-1/2 w-4 h-4 text-gray-400 dark:text-gray-500" />
          <input
            ref={searchInputRef}
            type="text"
            placeholder={searchPlaceholder}
            value={searchTerm}
            onChange={(e) => {
              setSearchTerm(e.target.value);
              setFocusedIndex(-1);
            }}
            onKeyDown={handleKeyDown}
            className="w-full pl-10 pr-3 py-2 text-sm border border-gray-300 dark:border-gray-600 rounded-md focus:ring-2 focus:ring-blue-500 focus:outline-none bg-white dark:bg-gray-900 text-gray-900 dark:text-white placeholder-gray-500 dark:placeholder-gray-400"
          />
        </div>
      </div>
      <div
        className="overflow-y-auto"
        style={{ maxHeight: `${maxHeight}px` }}
        role="listbox"
      >
        {loading ? (
          <div className="px-3 py-2 text-sm text-gray-500 dark:text-gray-400 text-center">Loading...</div>
        ) : filteredOptions.length === 0 ? (
          <div className="px-3 py-2 text-sm text-gray-500 dark:text-gray-400 text-center">{noOptionsMessage}</div>
        ) : (
          filteredOptions.map((option, index) => (
            <div
              key={option.value}
              ref={(el) => { optionRefs.current[index] = el; }}
              className={`px-3 py-2 text-sm cursor-pointer transition-colors ${option.disabled ? "text-gray-400 dark:text-gray-500 cursor-not-allowed" : "text-gray-900 dark:text-white hover:bg-gray-100 dark:hover:bg-gray-600"} ${index === focusedIndex ? "bg-blue-100 dark:bg-blue-900/50 text-blue-900 dark:text-blue-200" : ""} ${option.value === value ? "bg-blue-50 dark:bg-blue-900/30 text-blue-700 dark:text-blue-300 font-medium" : ""}`}
              onClick={() => !option.disabled && handleOptionSelect(option.value)}
              role="option"
              aria-selected={option.value === value}
            >
              {option.label}
            </div>
          ))
        )}
      </div>
    </div>
  );

  return (
    <div ref={triggerRef} className={`relative ${className}`}>
      {/* The trigger element remains in its original position */}
      <Label>{label}</Label>
      <div
        className={`${baseClasses.trim()} ${isOpen ? "ring-2 ring-blue-500 dark:ring-blue-600" : ""}`}
        onClick={toggleDropdown}
        onKeyDown={handleKeyDown}
        tabIndex={disabled ? -1 : 0}
        role="combobox"
        aria-controls="options-list"
        aria-expanded={isOpen}
        aria-haspopup="listbox"
        aria-required={required}
      >
        <div className="flex items-center justify-between">
          <span className={`block truncate ${!selectedLabel ? "text-gray-500 dark:text-gray-400" : ""}`}>
            {selectedLabel || placeholder}
          </span>
          <div className="flex items-center gap-1">
            {clearable && value && !disabled && (
              <button type="button" onClick={handleClear} className="flex items-center justify-center w-4 h-4 text-gray-400 hover:text-gray-600 dark:hover:text-gray-300" tabIndex={-1}>
                <FiX className="w-3 h-3" />
              </button>
            )}
            <FiChevronDown className={`w-4 h-4 text-gray-400 transition-transform ${isOpen ? "rotate-180" : ""}`} />
          </div>
        </div>
      </div>

      {/* RENDER THE DROPDOWN IN A PORTAL */}
      {isOpen && typeof document !== 'undefined' && createPortal(DropdownContent, document.body)}
    </div>
  );
};
```

<!-- path: components/common/ui/textarea/Textarea.tsx -->
```typescript
/* eslint-disable @typescript-eslint/no-unused-vars */
import { useState, ChangeEvent, FocusEvent } from "react";
import { Label } from "@/components/common/ui/label/Label";

// Type definitions
type TextareaResize = "none" | "both" | "horizontal" | "vertical";
type TextareaVariant = "default" | "filled" | "outlined";

interface TextareaProps extends Omit<React.TextareaHTMLAttributes<HTMLTextAreaElement>, "onChange"> {
  value?: string;
  onChange?: (e: ChangeEvent<HTMLTextAreaElement>, value: string) => void;
  placeholder?: string;
  disabled?: boolean;
  required?: boolean;
  error?: boolean;
  errorMessage?: string;
  label?: string;
  helperText?: string;
  rows?: number;
  maxLength?: number;
  resize?: TextareaResize;
  variant?: TextareaVariant;
  className?: string;
  id?: string;
  showCharCount?: boolean;
  fullWidth?: boolean;
}

// Textarea Component
export const Textarea: React.FC<TextareaProps> = ({
  value = "",
  onChange = (e: ChangeEvent<HTMLTextAreaElement>, value: string) => {},
  placeholder = "",
  disabled = false,
  required = false,
  error = false,
  errorMessage = "",
  label,
  helperText,
  rows = 4,
  maxLength,
  resize = "vertical",
  variant = "default",
  className = "",
  id,
  showCharCount = true,
  fullWidth = true,
  ...props
}) => {
  const [focused, setFocused] = useState<boolean>(false);
  const [charCount, setCharCount] = useState<number>(value.length);
  const hasValue = String(value ?? '').length > 0;

  const handleChange = (e: ChangeEvent<HTMLTextAreaElement>) => {
    const newValue = e.target.value;
    setCharCount(newValue.length);
    onChange(e, newValue);
  };

  const handleFocus = (e: FocusEvent<HTMLTextAreaElement>) => {
    setFocused(true);
    props.onFocus?.(e);
  };

  const handleBlur = (e: FocusEvent<HTMLTextAreaElement>) => {
    setFocused(false);
    props.onBlur?.(e);
  };

  const resizeClasses: Record<TextareaResize, string> = {
    none: "resize-none",
    both: "resize",
    horizontal: "resize-x",
    vertical: "resize-y",
  };

  const variantClasses: Record<TextareaVariant, string> = {
    default: "border shadow-sm",
    filled: "border-b-2 bg-gray-50 dark:bg-gray-900",
    outlined: "border-2"
  };

  const uniqueId = id || `textarea-${Math.random().toString(36).substr(2, 9)}`;

  return (
    <div className={`${fullWidth ? "w-full" : "w-fit"} ${className}`}>
      {label && (
        <Label
          htmlFor={uniqueId}
          required={required}
          disabled={disabled}
          className="mb-2"
        >
          {label}
        </Label>
      )}

      <div className="relative">
        <textarea
          id={uniqueId}
          value={value}
          onChange={handleChange}
          onFocus={handleFocus}
          onBlur={handleBlur}
          placeholder={placeholder}
          disabled={disabled}
          required={required}
          rows={rows}
          maxLength={maxLength}
          className={`
            ${fullWidth ? "w-full" : "w-fit"} 
            px-3 py-2 rounded-lg transition-all duration-200
            ${resizeClasses[resize]}
            ${variantClasses[variant]}
            ${
              error
                ? "border-red-300 focus:border-red-500 focus:ring-red-500 dark:border-red-500 dark:focus:border-red-600"
                : focused
                ? "border-blue-500 ring-2 ring-blue-500 ring-opacity-20 dark:border-blue-400 dark:ring-blue-400"
                : "border-gray-300 hover:border-gray-400 dark:border-gray-600 dark:hover:border-gray-500"
            }
            ${
              disabled
                ? "bg-gray-50 text-gray-400 cursor-not-allowed dark:bg-gray-900 dark:text-gray-500"
                : hasValue
                  ? "bg-gray-100 text-gray-900 dark:bg-gray-800 dark:text-gray-100"
                  : "bg-white text-gray-900 dark:bg-gray-900 dark:text-gray-100"
            }
            focus:outline-none placeholder-gray-400 dark:placeholder-gray-500
          `}
          {...props}
        />

        {maxLength && showCharCount && (
          <div className="absolute bottom-2 right-2 text-xs text-gray-400 dark:text-gray-400 bg-white dark:bg-gray-900 px-1 rounded">
            {charCount}/{maxLength}
          </div>
        )}
      </div>

      {(errorMessage || helperText) && (
        <div className="mt-1">
          {error && errorMessage && (
            <p className="text-sm text-red-600 dark:text-red-400 flex items-center">
              <svg
                className="w-4 h-4 mr-1"
                fill="currentColor"
                viewBox="0 0 20 20"
              >
                <path
                  fillRule="evenodd"
                  d="M18 10a8 8 0 11-16 0 8 8 0 0116 0zm-7 4a1 1 0 11-2 0 1 1 0 012 0zm-1-9a1 1 0 00-1 1v4a1 1 0 102 0V6a1 1 0 00-1-1z"
                  clipRule="evenodd"
                />
              </svg>
              {errorMessage}
            </p>
          )}
          {!error && helperText && (
            <p className="text-sm text-gray-500 dark:text-gray-400">{helperText}</p>
          )}
        </div>
      )}
    </div>
  );
};
```

<!-- path: components/common/ui/tabs.tsx -->
```typescript
"use client"

import * as React from "react"
import * as TabsPrimitive from "@radix-ui/react-tabs"

import { cn } from "@/lib/utils"

function Tabs({
  className,
  ...props
}: React.ComponentProps<typeof TabsPrimitive.Root>) {
  return (
    <TabsPrimitive.Root
      data-slot="tabs"
      className={cn("flex flex-col gap-2", className)}
      {...props}
    />
  )
}

function TabsList({
  className,
  ...props
}: React.ComponentProps<typeof TabsPrimitive.List>) {
  return (
    <TabsPrimitive.List
      data-slot="tabs-list"
      className={cn(
        "bg-muted text-muted-foreground inline-flex h-9 w-fit items-center justify-center rounded-lg p-[3px]",
        className
      )}
      {...props}
    />
  )
}

function TabsTrigger({
  className,
  ...props
}: React.ComponentProps<typeof TabsPrimitive.Trigger>) {
  return (
    <TabsPrimitive.Trigger
      data-slot="tabs-trigger"
      className={cn(
        "data-[state=active]:bg-background dark:data-[state=active]:text-foreground focus-visible:border-ring focus-visible:ring-ring/50 focus-visible:outline-ring dark:data-[state=active]:border-input dark:data-[state=active]:bg-input/30 text-foreground dark:text-muted-foreground inline-flex h-[calc(100%-1px)] flex-1 items-center justify-center gap-1.5 rounded-md border border-transparent px-2 py-1 text-sm font-medium whitespace-nowrap transition-[color,box-shadow] focus-visible:ring-[3px] focus-visible:outline-1 disabled:pointer-events-none disabled:opacity-50 data-[state=active]:shadow-sm [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4",
        className
      )}
      {...props}
    />
  )
}

function TabsContent({
  className,
  ...props
}: React.ComponentProps<typeof TabsPrimitive.Content>) {
  return (
    <TabsPrimitive.Content
      data-slot="tabs-content"
      className={cn("flex-1 outline-none", className)}
      {...props}
    />
  )
}

export { Tabs, TabsList, TabsTrigger, TabsContent }

```

<!-- path: components/common/ui/index.ts -->
```typescript
export { Button } from './Button';
export { Card } from './Card';
export { CardHeader } from './Card';
export { CardBody } from './Card';
export { CardFooter } from './Card';
export { Input } from './Input';
export { LoadingSpinner } from './LoadingSpinner';
export { ProgressBar } from './ProgressBar';
export { PhoneInputWithCountry } from './phoneInput';
export { Modal } from './Modal';
export { ChangePasswordModal } from './Modal';
export { Label } from './label/Label';
export { Switch } from './switch/Switch';
export { Textarea } from './textarea/Textarea';
export { ButtonSpinner } from './LoadingSpinner';
export { ConfirmModal } from './Modal';
export { ErrorDisplay } from './error/ErrorDisplay';
export { RoleBadge } from './badges/RoleBadge';
export { StatusBadge } from './badges/StatusBadge';
export {PageSpinner} from './LoadingSpinner';




```

<!-- path: components/common/ui/table/TableSkeleton.tsx -->
```typescript
import React from 'react';

interface SkeletonProps {
  className?: string;
  variant?: 'text' | 'rect' | 'circle' | 'rounded';
  width?: string | number;
  height?: string | number;
  animation?: 'pulse' | 'wave' | 'none';
}

const Skeleton: React.FC<SkeletonProps> = ({
  className = '',
  variant = 'text',
  width,
  height,
  animation = 'pulse',
}) => {
  const getVariantClasses = () => {
    switch (variant) {
      case 'text':
        return 'h-4 rounded';
      case 'rect':
        return 'rounded';
      case 'circle':
        return 'rounded-full';
      case 'rounded':
        return 'rounded-lg';
      default:
        return 'h-4 rounded';
    }
  };

  const getAnimationClasses = () => {
    switch (animation) {
      case 'pulse':
        return 'animate-pulse';
      case 'wave':
        return 'animate-wave';
      case 'none':
        return '';
      default:
        return 'animate-pulse';
    }
  };

  const style: React.CSSProperties = {
    width: width || '100%',
    height: height || (variant === 'text' ? '1rem' : '2rem'),
  };

  return (
    <div
      className={`bg-gray-300 dark:bg-gray-700 ${getVariantClasses()} ${getAnimationClasses()} ${className}`}
      style={style}
    />
  );
};

// Compound components for common patterns
interface TableSkeletonProps {
  rows?: number;
  columns?: number;
  showHeader?: boolean;
  className?: string;
}

export const TableSkeleton: React.FC<TableSkeletonProps> = ({
  rows = 5,
  columns = 6,
  showHeader = true,
  className = '',
}) => {
  return (
    <div className={`w-full ${className}`}>
      {showHeader && (
        <div className="mb-4 flex gap-4 border-b border-gray-200 pb-4 dark:border-gray-700">
          {Array.from({ length: columns }, (_, i) => (
            <Skeleton key={`header-${i}`} variant="text" width="100%" height="1.5rem" />
          ))}
        </div>
      )}
      <div className="space-y-3">
        {Array.from({ length: rows }, (_, rowIndex) => (
          <div key={`row-${rowIndex}`} className="flex gap-4">
            {Array.from({ length: columns }, (_, colIndex) => (
              <Skeleton
                key={`cell-${rowIndex}-${colIndex}`}
                variant="text"
                width="100%"
                height="2.5rem"
              />
            ))}
          </div>
        ))}
      </div>
    </div>
  );
};

interface CardSkeletonProps {
  showImage?: boolean;
  showTitle?: boolean;
  showDescription?: boolean;
  lines?: number;
  className?: string;
}

export const CardSkeleton: React.FC<CardSkeletonProps> = ({
  showImage = true,
  showTitle = true,
  showDescription = true,
  lines = 3,
  className = '',
}) => {
  return (
    <div className={`rounded-lg border border-gray-200 bg-white p-4 dark:border-gray-700 dark:bg-gray-800 ${className}`}>
      {showImage && (
        <Skeleton variant="rounded" width="100%" height="12rem" className="mb-4" />
      )}
      {showTitle && (
        <Skeleton variant="text" width="60%" height="1.5rem" className="mb-2" />
      )}
      {showDescription && (
        <div className="space-y-2">
          {Array.from({ length: lines }, (_, i) => (
            <Skeleton
              key={i}
              variant="text"
              width={i === lines - 1 ? '80%' : '100%'}
              height="1rem"
            />
          ))}
        </div>
      )}
    </div>
  );
};

interface StatsSkeletonProps {
  count?: number;
  className?: string;
}

export const StatsCardsSkeleton: React.FC<StatsSkeletonProps> = ({
  count = 4,
  className = '',
}) => {
  return (
    <div className={`grid grid-cols-1 gap-4 sm:grid-cols-2 md:grid-cols-4 ${className}`}>
      {Array.from({ length: count }, (_, i) => (
        <div
          key={i}
          className="rounded-lg border border-gray-200 bg-white p-4 dark:border-gray-700 dark:bg-gray-800"
        >
          <Skeleton variant="text" width="60%" height="2.5rem" className="mb-2" />
          <Skeleton variant="text" width="80%" height="1rem" />
        </div>
      ))}
    </div>
  );
};

interface PageSkeletonProps {
  showHeader?: boolean;
  showStats?: boolean;
  showFilters?: boolean;
  showTable?: boolean;
  statsCount?: number;
  tableRows?: number;
  tableColumns?: number;
  className?: string;
}

export const PageSkeleton: React.FC<PageSkeletonProps> = ({
  showHeader = true,
  showStats = true,
  showFilters = true,
  showTable = true,
  statsCount = 4,
  tableRows = 10,
  tableColumns = 6,
  className = '',
}) => {
  return (
    <div className={`min-h-screen bg-gray-50 p-6 dark:bg-gray-900 ${className}`}>
      <div className="mx-auto">
        {/* Header Skeleton */}
        {showHeader && (
          <div className="mb-6">
            <div className="mb-4 flex flex-col items-start justify-between gap-4 sm:flex-row sm:items-center">
              <div className="flex-1">
                <Skeleton variant="text" width="200px" height="2rem" className="mb-2" />
                <Skeleton variant="text" width="300px" height="1rem" />
              </div>
              <Skeleton variant="rounded" width="150px" height="40px" />
            </div>
          </div>
        )}

        {/* Stats Skeleton */}
        {showStats && <StatsCardsSkeleton count={statsCount} className="mb-6" />}

        {/* Filters Skeleton */}
        {showFilters && (
          <div className="mb-6 flex flex-wrap gap-4 rounded-lg border border-gray-200 bg-white p-4 dark:border-gray-700 dark:bg-gray-800">
            <Skeleton variant="rounded" width="200px" height="40px" />
            <Skeleton variant="rounded" width="150px" height="40px" />
            <Skeleton variant="rounded" width="150px" height="40px" />
            <Skeleton variant="rounded" width="100px" height="40px" />
          </div>
        )}

        {/* Table Skeleton */}
        {showTable && (
          <div className="rounded-lg border border-gray-200 bg-white p-4 dark:border-gray-700 dark:bg-gray-800">
            <TableSkeleton rows={tableRows} columns={tableColumns} />
            {/* Pagination Skeleton */}
            <div className="mt-4 flex items-center justify-between border-t border-gray-200 pt-4 dark:border-gray-700">
              <Skeleton variant="text" width="150px" height="1rem" />
              <div className="flex gap-2">
                {Array.from({ length: 5 }, (_, i) => (
                  <Skeleton key={i} variant="rounded" width="40px" height="40px" />
                ))}
              </div>
            </div>
          </div>
        )}
      </div>
    </div>
  );
};

export default Skeleton;
```

<!-- path: components/common/ui/LoadingSpinner/LoadingSpinner.tsx -->
```typescript
// components/common/ui/LoadingSpinner/LoadingSpinner.tsx
import { cn } from '@/utils/classNames';

interface LoadingSpinnerProps {
  size?: 'xs' | 'sm' | 'md' | 'lg' | 'xl';
  color?: 'primary' | 'secondary' | 'white' | 'gray';
  className?: string;
  text?: string;
  overlay?: boolean;
}

const sizeClasses = {
  xs: 'h-3 w-3',
  sm: 'h-4 w-4',
  md: 'h-6 w-6',
  lg: 'h-8 w-8',
  xl: 'h-12 w-12',
};

const colorClasses = {
  primary: 'text-blue-600 dark:text-blue-400',
  secondary: 'text-gray-600 dark:text-gray-400',
  white: 'text-white dark:text-white',
  gray: 'text-gray-400 dark:text-gray-500',
};

const textSizeClasses = {
  xs: 'text-xs',
  sm: 'text-sm',
  md: 'text-base',
  lg: 'text-lg',
  xl: 'text-xl',
};

export const LoadingSpinner: React.FC<LoadingSpinnerProps> = ({
  size = 'md',
  color = 'primary',
  className,
  text,
  overlay = false,
}) => {
  const spinnerContent = (
    <div className={cn('flex flex-col items-center justify-center gap-3', className)}>
      <svg
        className={cn(
          'animate-spin',
          sizeClasses[size],
          colorClasses[color]
        )}
        xmlns="http://www.w3.org/2000/svg"
        fill="none"
        viewBox="0 0 24 24"
      >
        <circle
          className="opacity-25"
          cx="12"
          cy="12"
          r="10"
          stroke="currentColor"
          strokeWidth="4"
        />
        <path
          className="opacity-75"
          fill="currentColor"
          d="M4 12a8 8 0 0 1 8-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 0 1 4 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"
        />
      </svg>
      
      {text && (
        <p className={cn(
          'font-medium text-gray-600 dark:text-gray-300',
          textSizeClasses[size]
        )}>
          {text}
        </p>
      )}
    </div>
  );

  if (overlay) {
    return (
      <div className="fixed inset-0 z-50 flex items-center justify-center bg-black bg-opacity-25 dark:bg-black dark:bg-opacity-40 backdrop-blur-sm">
        <div className="rounded-lg bg-white dark:bg-gray-800 p-6 shadow-lg">
          {spinnerContent}
        </div>
      </div>
    );
  }

  return spinnerContent;
};

// Variants for specific use cases
export const ButtonSpinner: React.FC<{ size?: 'xs' | 'sm' | 'md' }> = ({ 
  size = 'sm' 
}) => (
  <LoadingSpinner size={size} color="primary" className="inline-flex" />
);

export const PageSpinner: React.FC<{ text?: string }> = ({ 
  text = 'Loading...' 
}) => (
  <div className="flex min-h-screen items-center justify-center">
    <LoadingSpinner size="lg" text={text} />
  </div>
);

export const CardSpinner: React.FC<{ text?: string }> = ({ 
  text 
}) => (
  <div className="flex items-center justify-center py-12">
    <LoadingSpinner size="md" text={text} />
  </div>
);

// Loading skeleton components
export const LoadingSkeleton: React.FC<{
  className?: string;
  rows?: number;
}> = ({ className, rows = 1 }) => (
  <div className={cn('animate-pulse space-y-3', className)}>
    {Array.from({ length: rows }).map((_, index) => (
      <div
        key={index}
        className="h-4 rounded bg-gray-200 dark:bg-gray-700"
        style={{
          width: `${Math.random() * 40 + 60}%`,
        }}
      />
    ))}
  </div>
);

export const LoadingCard: React.FC<{
  className?: string;
}> = ({ className }) => (
  <div className={cn('animate-pulse rounded-lg border border-gray-200 dark:border-gray-700 p-6', className)}>
    <div className="space-y-4">
      <div className="h-6 w-3/4 rounded bg-gray-200 dark:bg-gray-700" />
      <div className="space-y-2">
        <div className="h-4 rounded bg-gray-200 dark:bg-gray-700" />
        <div className="h-4 w-5/6 rounded bg-gray-200 dark:bg-gray-700" />
      </div>
      <div className="h-10 w-24 rounded bg-gray-200 dark:bg-gray-700" />
    </div>
  </div>
);
```

<!-- path: components/common/ui/LoadingSpinner/AdvancedLoader.tsx -->
```typescript
"use client";

import React, { useState, useEffect } from "react";

const AdvancedLoader: React.FC<{ children: React.ReactNode }> = ({ children }) => {
  const [loadingProgress, setLoadingProgress] = useState(0);
  const [isLoading, setIsLoading] = useState(true);
  const [loadingText, setLoadingText] = useState("Initializing...");

  useEffect(() => {
    const loadingSteps = [
      { progress: 20, text: "Loading assets..." },
      { progress: 40, text: "Connecting to server..." },
      { progress: 60, text: "Fetching data..." },
      { progress: 80, text: "Preparing interface..." },
      { progress: 100, text: "Almost ready..." },
    ];

    let currentStep = 0;
    const interval = setInterval(() => {
      if (currentStep < loadingSteps.length) {
        const step = loadingSteps[currentStep];
        setLoadingProgress(step.progress);
        setLoadingText(step.text);
        currentStep++;
      } else {
        clearInterval(interval);
        setTimeout(() => {
          setIsLoading(false);
        }, 500);
      }
    }, 600);

    return () => clearInterval(interval);
  }, []);

  if (isLoading) {
    return (
      <div className='fixed inset-0 bg-gradient-to-r from-indigo-900 via-purple-900 to-pink-900 flex items-center justify-center'>
        <div className='text-center max-w-md mx-auto px-6'>
          {/* Logo or Brand */}
          <div className='mb-8'>
            <div className='w-16 h-16 mx-auto bg-white bg-opacity-20 rounded-full flex items-center justify-center'>
              <div className='w-8 h-8 bg-white rounded-sm'></div>
            </div>
          </div>

          {/* Main Loader */}
          <div className='relative mb-8'>
            <div className='w-32 h-32 mx-auto relative'>
              <svg className='w-32 h-32 transform -rotate-90' viewBox='0 0 100 100'>
                <circle cx='50' cy='50' r='40' stroke='rgba(255,255,255,0.2)' strokeWidth='8' fill='none' />
                <circle
                  cx='50'
                  cy='50'
                  r='40'
                  stroke='white'
                  strokeWidth='8'
                  fill='none'
                  strokeLinecap='round'
                  strokeDasharray={`${2 * Math.PI * 40}`}
                  strokeDashoffset={`${2 * Math.PI * 40 * (1 - loadingProgress / 100)}`}
                  className='transition-all duration-500 ease-out'
                />
              </svg>
              <div className='absolute inset-0 flex items-center justify-center'>
                <span className='text-white text-2xl font-bold'>{loadingProgress}%</span>
              </div>
            </div>
          </div>

          {/* Loading Text */}
          <div className='mb-6'>
            <p className='text-white text-lg font-medium'>{loadingText}</p>
          </div>

          {/* Progress Bar */}
          <div className='w-full bg-white bg-opacity-20 rounded-full h-2 mb-4'>
            <div className='bg-white rounded-full h-2 transition-all duration-500 ease-out' style={{ width: `${loadingProgress}%` }}></div>
          </div>

          {/* Dots Animation */}
          <div className='flex justify-center space-x-2'>
            {[0, 1, 2].map((i) => (
              <div
                key={i}
                className='w-2 h-2 bg-white rounded-full animate-pulse'
                style={{
                  animationDelay: `${i * 0.2}s`,
                  animationDuration: "1s",
                }}></div>
            ))}
          </div>
        </div>
      </div>
    );
  }

  return <>{children}</>;
};

export default AdvancedLoader;

```

<!-- path: components/common/ui/LoadingSpinner/index.ts -->
```typescript
export { LoadingSpinner } from './LoadingSpinner';
export { ButtonSpinner, PageSpinner, CardSpinner, LoadingSkeleton, LoadingCard } from './LoadingSpinner';
```

<!-- path: components/common/ui/Input/Input.tsx -->
```typescript
"use client";

import React, { forwardRef, useEffect, useId, useRef, useState } from 'react';
import { clsx } from 'clsx';
import { FiX } from 'react-icons/fi';

interface InputProps extends Omit<React.InputHTMLAttributes<HTMLInputElement>, 'size'> {
  error?: string;
  leftIcon?: React.ReactNode;
  isLoading?: boolean;
  fullWidth?: boolean;
  clearable?: boolean;
  onClear?: () => void;
}

const Input = forwardRef<HTMLInputElement, InputProps>(
  (
    {
      className,
      type = 'text',
      error,
      leftIcon,
      isLoading = false,
      disabled,
      fullWidth = true,
      clearable = false,
      onClear,
      id,
      value,
      ...props
    },
    ref
  ) => {
    const generatedId = useId();
    const inputId = id || generatedId;
    const innerRef = useRef<HTMLInputElement | null>(null);
    const [liveHasValue, setLiveHasValue] = useState<boolean>(false);

    // Merge forwarded ref with local ref
    const setRefs = (el: HTMLInputElement | null) => {
      innerRef.current = el;
      if (typeof ref === 'function') ref(el);
      else if (ref && 'current' in ref) (ref as React.MutableRefObject<HTMLInputElement | null>).current = el;
    };

    // Initialize hasValue on mount and when value/defaultValue changes
    useEffect(() => {
      const dv = (props as { defaultValue?: string | number })?.defaultValue;
      const raw = value ?? dv ?? innerRef.current?.value ?? '';
      setLiveHasValue(String(raw).length > 0);
      // eslint-disable-next-line react-hooks/exhaustive-deps
    }, [value, (props as { defaultValue?: string | number })?.defaultValue]);

    // Handle clear action
    const handleClear = () => {
      // Create a synthetic event that react-hook-form can understand
      const syntheticEvent = {
        target: { value: '' },
        currentTarget: { value: '' },
      } as React.ChangeEvent<HTMLInputElement>;
      
      // If an onChange is passed from register, call it with an empty value
      props.onChange?.(syntheticEvent);
      
      onClear?.();
      
      // Focus the input
      if (ref && 'current' in ref && ref.current) {
        ref.current.focus();
      }
    };
    
    const shouldShowClear = clearable && !disabled && !isLoading && (String((value as any) || '').length > 0 || liveHasValue);
    const defaultValue = (props as { defaultValue?: string | number })?.defaultValue;
    const rawVal = value ?? defaultValue ?? '';
    const hasValue = liveHasValue || String(rawVal).length > 0;

    const inputClasses = clsx(
      'rounded-lg border transition-all duration-200 font-medium w-full',
      'focus:outline-none focus:ring-2 focus:border-transparent',
      'placeholder:text-gray-400 dark:placeholder-gray-500',
      'px-4 py-2.5 text-base', // Standard size
      leftIcon && 'pl-11',
      shouldShowClear && 'pr-11',
      // Place external classes earlier so our bg utilities later will override
      className,
      error ? 'border-red-500 focus:ring-red-500 dark:border-red-600' : 'border-gray-300 dark:border-gray-600 hover:border-gray-400 dark:hover:border-gray-500 focus:ring-blue-500',
      // Disabled style
      (disabled || isLoading) && 'bg-gray-100 dark:bg-gray-900 text-gray-500 cursor-not-allowed',
      // Active background: apply bg-gray-100 in normal mode and dark:bg-gray-800 in dark mode when input has value
      !(disabled || isLoading) && hasValue && 'bg-gray-50 dark:bg-gray-800!',
      // Default background when no value
      !(disabled || isLoading) && !hasValue && 'bg-white dark:bg-gray-900',
      // Text colors
      !(disabled || isLoading) && 'text-gray-900 dark:text-gray-100'
    );
    
    return (
      <div className={clsx('relative', fullWidth && 'w-full')}>
        {leftIcon && <div className="absolute left-3 top-1/2 -translate-y-1/2 pointer-events-none text-gray-400">{leftIcon}</div>}
        <input
          id={inputId}
          ref={setRefs}
          type={type}
          className={inputClasses}
          disabled={disabled || isLoading}
          value={value as any}
          onChange={(e) => {
            setLiveHasValue(e.currentTarget.value.length > 0);
            props.onChange?.(e);
          }}
          aria-invalid={!!error}
          {...props}
        />
        {shouldShowClear && (
          <button type="button" onClick={handleClear} className="absolute right-3 top-1/2 -translate-y-1/2 text-gray-400 hover:text-gray-600">
            <FiX />
          </button>
        )}
        {error && <p className="mt-1.5 text-sm text-red-600">{error}</p>}
      </div>
    );
  }
);

Input.displayName = 'Input';
export default Input;
```

<!-- path: components/common/ui/Input/index.ts -->
```typescript
export { default as Input } from './Input';

```

<!-- path: components/common/ui/card/Card.tsx -->
```typescript
import { type ReactNode, forwardRef } from 'react';
import { motion } from 'framer-motion';
import { cn } from '@/utils/classNames';

interface CardProps {
  children: ReactNode;
  className?: string;
  variant?: 'default' | 'outlined' | 'elevated' | 'ghost';
  size?: 'sm' | 'md' | 'lg';
  hover?: boolean;
  clickable?: boolean;
  onClick?: () => void;
  padding?: 'none' | 'sm' | 'md' | 'lg';
  rounded?: 'none' | 'sm' | 'md' | 'lg' | 'xl';
}

interface CardHeaderProps {
  children: ReactNode;
  className?: string;
}

interface CardBodyProps {
  children: ReactNode;
  className?: string;
}

interface CardFooterProps {
  children: ReactNode;
  className?: string;
}

const Card = forwardRef<HTMLDivElement, CardProps>(
  ({
    children,
    className,
    variant = 'default',
    size = 'md',
    hover = false,
    clickable = false,
    onClick,
    padding = 'md',
    rounded = 'lg',
    ...props
  }, ref) => {
    const variantClasses = {
      default: 'bg-white border border-gray-200 shadow-sm',
      outlined: 'bg-white border-2 border-gray-300',
      elevated: 'bg-white shadow-lg border border-gray-100',
      ghost: 'bg-transparent'
    };

    const sizeClasses = {
      sm: 'text-sm',
      md: 'text-base',
      lg: 'text-lg'
    };

    const paddingClasses = {
      none: '',
      sm: 'p-3',
      md: 'p-4',
      lg: 'p-6'
    };

    const roundedClasses = {
      none: '',
      sm: 'rounded-sm',
      md: 'rounded-md',
      lg: 'rounded-lg',
      xl: 'rounded-xl'
    };

    const Component = clickable || onClick ? motion.div : 'div';
    const motionProps = clickable || onClick ? {
      whileHover: hover ? { y: -2, scale: 1.02 } : undefined,
      whileTap: { scale: 0.98 },
      transition: { type: "spring" as const, stiffness: 400, damping: 25 }
    } : {};

    return (
      <Component
        ref={ref}
        className={cn(
          'transition-all duration-200',
          variantClasses[variant],
          sizeClasses[size],
          paddingClasses[padding],
          roundedClasses[rounded],
          clickable || onClick ? 'cursor-pointer' : '',
          hover && (clickable || onClick) ? 'hover:shadow-md hover:border-gray-300' : '',
          className
        )}
        onClick={onClick}
        {...motionProps}
        {...props}
      >
        {children}
      </Component>
    );
  }
);

Card.displayName = 'Card';

const CardHeader = ({ children, className }: CardHeaderProps) => (
  <div className={cn('border-b border-gray-200 pb-3 mb-4', className)}>
    {children}
  </div>
);

const CardBody = ({ children, className }: CardBodyProps) => (
  <div className={cn('flex-1', className)}>
    {children}
  </div>
);

const CardFooter = ({ children, className }: CardFooterProps) => (
  <div className={cn('border-t border-gray-200 pt-3 mt-4', className)}>
    {children}
  </div>
);

export { Card, CardHeader, CardBody, CardFooter };
```

<!-- path: components/common/ui/card/index.ts -->
```typescript
export { Card } from './Card';
export { CardHeader } from './Card';
export { CardBody } from './Card';
export { CardFooter } from './Card';
```

<!-- path: components/common/BulkActions.tsx -->
```typescript
// BulkActions Component (Enhanced version)
import { FiTrash2, FiCheck, FiX } from "react-icons/fi";

interface BulkActionsProps {
  selectedCount: number;
  isOperationLoading?: boolean;
  onBulkDelete: () => void;
  onBulkUpdateStatus: (status: "active" | "inactive") => void;
  onClearSelection: () => void;
  entityName?: string;
  showStatusUpdate?: boolean;
  canDelete?: () => boolean;
  customActions?: Array<{
    label: string;
    icon?: React.ComponentType<{ className?: string }>;
    onClick: () => void;
    variant?: 'primary' | 'secondary' | 'danger';
    disabled?: boolean;
  }>;
}

export function BulkActions({
  selectedCount,
  isOperationLoading = false,
  onBulkDelete,
  onBulkUpdateStatus,
  onClearSelection,
  entityName = "item",
  showStatusUpdate = true,
  canDelete = () => true,
  customActions = [],
}: BulkActionsProps) {
  if (selectedCount === 0) return null;

  const handleStatusChange = (e: React.ChangeEvent<HTMLSelectElement>) => {
    const value = e.target.value as "active" | "inactive" | "";
    if (value) {
      onBulkUpdateStatus(value);
      // Reset select to default
      e.target.value = "";
    }
  };

  const getButtonClasses = (variant: 'primary' | 'secondary' | 'danger' = 'primary') => {
    const baseClasses = "px-3 py-1 rounded text-sm font-medium transition-colors disabled:opacity-50 disabled:cursor-not-allowed flex items-center gap-1";
    
    switch (variant) {
      case 'danger':
        return `${baseClasses} bg-red-600 text-white hover:bg-red-700 dark:bg-red-700 dark:hover:bg-red-800`;
      case 'secondary':
        return `${baseClasses} bg-gray-100 text-gray-700 hover:bg-gray-200 dark:bg-gray-700 dark:text-gray-300 dark:hover:bg-gray-600`;
      default:
        return `${baseClasses} bg-blue-600 text-white hover:bg-blue-700 dark:bg-blue-700 dark:hover:bg-blue-800`;
    }
  };

  return (
    <div className="bg-blue-50 border border-blue-200 rounded-lg p-4 mb-6 dark:bg-blue-900/20 dark:border-blue-700/50 transition-all duration-200">
      <div className="flex items-center justify-between flex-wrap gap-3">
        <div className="flex items-center gap-2">
          <FiCheck className="w-4 h-4 text-blue-600 dark:text-blue-400" />
          <p className="text-blue-900 dark:text-blue-100 font-medium">
            {selectedCount} {entityName}{selectedCount !== 1 ? 's' : ''} selected
          </p>
        </div>
        
        <div className="flex items-center gap-2 flex-wrap">
          {/* Status Update Dropdown */}
          {showStatusUpdate && (
            <select
              onChange={handleStatusChange}
              defaultValue=""
              className="text-sm border rounded px-2 py-1 min-w-[100px]
                        bg-white text-gray-900 border-gray-300
                        dark:bg-gray-700 dark:text-gray-100 dark:border-gray-600
                        disabled:opacity-50 focus:outline-none focus:ring-2 focus:ring-blue-500"
              disabled={isOperationLoading}
            >
              <option value="">Set Status</option>
              <option value="active"> Active</option>
              <option value="inactive"> Inactive</option>
            </select>
          )}

          {/* Custom Actions */}
          {customActions.map((action, index) => (
            <button
              key={index}
              onClick={action.onClick}
              disabled={isOperationLoading || action.disabled}
              className={getButtonClasses(action.variant)}
            >
              {action.icon && <action.icon className="w-4 h-4" />}
              {action.label}
            </button>
          ))}
          
          {/* Delete Button */}
          <button
            onClick={onBulkDelete}
            disabled={isOperationLoading || !canDelete()}
            className={getButtonClasses('danger')}
            title={`Delete ${selectedCount} selected ${entityName}${selectedCount !== 1 ? 's' : ''}`}
          >
            <FiTrash2 className="w-4 h-4" />
            Delete {selectedCount > 1 && `(${selectedCount})`}
          </button>
          
          {/* Clear Selection Button */}
          <button
            onClick={onClearSelection}
            disabled={isOperationLoading}
            className="text-gray-500 hover:text-gray-700 dark:text-gray-400 dark:hover:text-gray-300 
                      text-sm px-2 py-1 rounded transition-colors flex items-center gap-1"
            title="Clear selection"
          >
            <FiX className="w-4 h-4" />
            Clear
          </button>
        </div>
      </div>

      {/* Loading Indicator */}
      {isOperationLoading && (
        <div className="mt-3 flex items-center gap-2 text-sm text-blue-700 dark:text-blue-300">
          <div className="w-4 h-4 border-2 border-blue-600 border-t-transparent rounded-full animate-spin"></div>
          Processing {selectedCount} {entityName}{selectedCount !== 1 ? 's' : ''}...
        </div>
      )}
    </div>
  );
}


```

<!-- path: components/common/filters/FilterInputs.tsx -->
```typescript
import { SearchableSelect, Option } from '@/components/common/ui/select/SearchableSelect';
import { Input } from '@/components/common/ui/Input';
import { Filters } from '@/hooks/database';
import React from 'react';
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from '../ui/select/Select';

// --- TYPE DEFINITIONS ---

interface FilterWrapperProps {
  label: string;
}

interface SelectFilterProps extends FilterWrapperProps {
  filterKey: string; // The key to modify in the filters object
  filters: Filters;
  setFilters: React.Dispatch<React.SetStateAction<Filters>>;
  options: Option[];
  placeholder?: string;
}

interface InputFilterProps extends FilterWrapperProps {
  filterKey: string;
  filters: Filters;
  setFilters: React.Dispatch<React.SetStateAction<Filters>>;
  placeholder?: string;
}

// --- COMPONENTS ---

export const SelectFilter: React.FC<SelectFilterProps> = ({
  label,
  filterKey,
  filters,
  setFilters,
  options,
  placeholder,
}) => {
  // Safely extract the current value, ensuring it's a string for the component.
  const currentValue = filters[filterKey];
  const valueAsString =
    typeof currentValue === 'string' || typeof currentValue === 'number'
      ? String(currentValue)
      : '';

  const handleChange = (newValue: string | null) => {
    setFilters((prevFilters) => {
      const newFilters = { ...prevFilters };
      if (newValue === null || newValue === '') {
        // When cleared, remove the key entirely for a cleaner state.
        delete newFilters[filterKey];
      } else {
        newFilters[filterKey] = newValue;
      }
      return newFilters;
    });
  };

  return (
    <div className="space-y-2">
      <label className="block text-sm font-medium text-gray-700 dark:text-gray-300">
        {label}
      </label>
      <SearchableSelect
        options={options}
        value={valueAsString}
        onChange={handleChange}
        placeholder={placeholder || `All ${label}s`}
        clearable
      />
      {/* <Select
        value={(valueAsString as string) ?? ''}
        onValueChange={(value) => handleChange(value)}
      >
        <SelectTrigger className="w-full">
          <SelectValue placeholder={placeholder ?? 'Select'} />
        </SelectTrigger>
        <SelectContent>
          {options.map((option) => (
            <SelectItem
              key={option.value}
              value={option.value}
              disabled={option.disabled}
            >
              {option.label}
            </SelectItem>
          ))}
        </SelectContent>
      </Select> */}
    </div>
  );
};

export const InputFilter: React.FC<InputFilterProps> = ({
  label,
  filterKey,
  filters,
  setFilters,
  placeholder,
}) => {
  // Safely extract the current value
  const currentValue = filters[filterKey];
  const valueAsString =
    typeof currentValue === 'string' || typeof currentValue === 'number'
      ? String(currentValue)
      : '';

  const handleChange = (newValue: string) => {
    setFilters((prevFilters) => {
      const newFilters = { ...prevFilters };
      if (newValue === '') {
        delete newFilters[filterKey];
      } else {
        newFilters[filterKey] = newValue;
      }
      return newFilters;
    });
  };

  return (
    <div className="space-y-2">
      <label className="block text-sm font-medium text-gray-700 dark:text-gray-300">
        {label}
      </label>
      <Input
        type="text"
        value={valueAsString}
        onChange={(e) => handleChange(e.target.value)}
        placeholder={placeholder || `Filter by ${label}...`}
      />
    </div>
  );
};

```

<!-- path: components/common/filters/SearchAndFilters.tsx -->
```typescript
import { motion } from "framer-motion";
import { FiSearch, FiX, FiFilter, FiChevronDown, FiChevronUp } from "react-icons/fi";

interface SearchAndFiltersProps {
  searchTerm: string;
  onSearchChange: (value: string) => void;
  showFilters: boolean;
  onToggleFilters: () => void;
  onClearFilters: () => void;
  hasActiveFilters: boolean;
  activeFilterCount: number; // More descriptive than a boolean
  searchPlaceholder?: string;
  children: React.ReactNode;
}

export function SearchAndFilters({
  searchTerm,
  onSearchChange,
  showFilters,
  onToggleFilters,
  onClearFilters,
  hasActiveFilters,
  activeFilterCount,
  searchPlaceholder = "Search...",
  children,
}: SearchAndFiltersProps) {
  return (
    <div className="space-y-3 sm:space-y-4 w-full p-4 border-b border-gray-200 dark:border-gray-700">
      {/* Search and Controls Row */}
      <div className="flex flex-col space-y-3 sm:space-y-0 sm:flex-row sm:gap-3 sm:justify-between sm:items-center">
        {/* Search Input */}
        <div className="flex-1 sm:max-w-md lg:max-w-xl">
          <div className="relative">
            <FiSearch className="absolute left-3 top-1/2 transform -translate-y-1/2 text-gray-400 w-4 h-4 sm:w-5 sm:h-5" />
            <input
              type="text"
              placeholder={searchPlaceholder}
              value={searchTerm}
              onChange={(e) => onSearchChange(e.target.value)}
              className="w-full pl-9 sm:pl-10 pr-4 py-2.5 sm:py-2 text-sm sm:text-base border border-gray-300 dark:border-gray-600 rounded-lg bg-white dark:bg-gray-700 text-gray-900 dark:text-white placeholder-gray-500 dark:placeholder-gray-400 focus:ring-2 focus:ring-blue-500 focus:border-blue-500 transition-colors"
            />
          </div>
        </div>

        {/* Filter and Clear Buttons */}
        <div className="flex gap-2 sm:gap-3">
          <button
            onClick={onToggleFilters}
            className={`flex items-center gap-2 px-3 sm:px-4 py-2.5 sm:py-2 border rounded-lg font-medium text-sm sm:text-base transition-all duration-200 flex-1 sm:flex-none justify-center sm:justify-start ${
              showFilters || activeFilterCount > 0
                ? "border-blue-500 bg-blue-50 text-blue-700 dark:border-blue-400 dark:bg-blue-900/30 dark:text-blue-300 shadow-sm"
                : "border-gray-300 dark:border-gray-600 hover:bg-gray-50 dark:hover:bg-gray-700 text-gray-700 dark:text-gray-300 hover:border-gray-400"
            }`}
          >
            <FiFilter size={16} className="w-4 h-4 sm:w-4 sm:h-4" />
            <span className="hidden sm:inline">Filters</span>
            <span className="sm:hidden">Filter</span>
            {showFilters ? <FiChevronUp size={14} /> : <FiChevronDown size={14} />}
            {activeFilterCount > 0 && (
              <span className="bg-blue-600 text-white text-xs rounded-full px-1.5 sm:px-2 py-0.5 font-semibold min-w-[18px] sm:min-w-[20px] text-center leading-none">
                {activeFilterCount}
              </span>
            )}
          </button>

          {hasActiveFilters && (
            <button
              onClick={onClearFilters}
              className="flex items-center gap-2 px-3 sm:px-4 py-2.5 sm:py-2 text-sm sm:text-base text-red-600 hover:bg-red-50 dark:hover:bg-red-900/20 rounded-lg transition-colors font-medium border border-transparent hover:border-red-200 flex-shrink-0"
            >
              <FiX className="w-4 h-4" />
              <span className="hidden sm:inline">Clear All</span>
              <span className="sm:hidden">Clear</span>
            </button>
          )}
        </div>
      </div>

      {/* Collapsible Filter Panel */}
      {showFilters && (
        <motion.div
          initial={{ opacity: 0, height: 0 }}
          animate={{ opacity: 1, height: "auto" }}
          exit={{ opacity: 0, height: 0 }}
          transition={{ duration: 0.2, ease: "easeInOut" }}
          className="overflow-hidden"
        >
          <div className="pt-3 sm:pt-4">
            <div className="p-3 sm:p-4 bg-gray-50 dark:bg-gray-800/50 rounded-lg border border-gray-200 dark:border-gray-700">
              <div className="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 gap-4">
                {children}
              </div>
            </div>
          </div>
        </motion.div>
      )}
    </div>
  );
}
```

<!-- path: components/common/TruncateTooltip.tsx -->
```typescript
// @/components/common/TruncateTooltip.tsx
import React, { useEffect, useRef, useState } from "react";

export interface TruncateTooltipProps {
  text: string;
  className?: string;
  /**
   * Optional id suffix for ARIA. If omitted, a random id will be generated.
   */
  id?: string;
  /**
   * Optional: control max width of tooltip in px. Default 320.
   */
  maxWidth?: number;
}

/**
 * Renders truncated single-line text and shows a custom tooltip on hover/focus
 * only when the content is visually truncated.
 */
export const TruncateTooltip: React.FC<TruncateTooltipProps> = ({
  text,
  className,
  id,
  maxWidth = 320,
}) => {
  const [isOverflowing, setIsOverflowing] = useState(false);
  const [showTooltip, setShowTooltip] = useState(false);
  const [pos, setPos] = useState<{ top: number; left: number }>({ top: 0, left: 0 });
  const textRef = useRef<HTMLSpanElement>(null);
  const tooltipId = `tt-${id ?? Math.random().toString(36).slice(2)}`;

  const checkOverflow = () => {
    const el = textRef.current;
    if (!el) return false;
    // Compare scrollWidth vs clientWidth on the measured element itself
    const overflow = el.scrollWidth > el.clientWidth;
    setIsOverflowing(overflow);
    return overflow;
  };

  useEffect(() => {
    const el = textRef.current;
    if (!el) return;
    checkOverflow();
    const ro = new ResizeObserver(() => checkOverflow());
    ro.observe(el);
    const onWin = () => checkOverflow();
    window.addEventListener("resize", onWin);
    return () => {
      ro.disconnect();
      window.removeEventListener("resize", onWin);
    };
  }, []);

  const show = () => {
    if (checkOverflow()) {
      const el = textRef.current!;
      const rect = el.getBoundingClientRect();
      // Clamp tooltip within viewport horizontally
      const left = Math.min(Math.max(8, rect.left), window.innerWidth - maxWidth - 8);
      setPos({ top: rect.bottom + 8, left });
      setShowTooltip(true);
    }
  };
  const hide = () => setShowTooltip(false);

  return (
    <>
      <span
        ref={textRef}
        className={`truncate block max-w-full overflow-hidden min-w-0 flex-1 ${className ?? ""}`}
        onMouseEnter={show}
        onMouseLeave={hide}
        onFocus={show}
        onBlur={hide}
        tabIndex={isOverflowing ? 0 : -1}
        title={isOverflowing ? text : undefined}
        aria-describedby={showTooltip && isOverflowing ? tooltipId : undefined}
      >
        {text}
      </span>
      {showTooltip && isOverflowing && (
        <div
          id={tooltipId}
          role="tooltip"
          className="fixed px-3 py-2 text-sm text-white bg-gray-900 dark:bg-gray-100 dark:text-gray-900 rounded-lg shadow-xl border border-gray-200 dark:border-gray-300 whitespace-normal break-words pointer-events-none z-[9999]"
          style={{ top: pos.top, left: pos.left, maxWidth }}
        >
          {text}
        </div>
      )}
    </>
  );
};

export default TruncateTooltip;

```

<!-- path: components/ofc/ofc-types.ts -->
```typescript
import { Database } from "@/types/supabase-types";

export interface OfcCablesFilters {
  search: string;
  ofc_type_id: string;
  status: "true" | "false" | "";
  maintenance_terminal_id: string;
}

// FIX: This type now correctly includes the optional 'total_count' field 
// which is added by the useTableQuery hook when `includeCount` is true.
export type OfcCablesWithRelations = 
  Database["public"]["Views"]["v_ofc_cables_complete"]["Row"] & {
  total_count?: number;
  active_count?: number;
  inactive_count?: number;
  // NOTE: These fields exist on the base table `ofc_cables` and are used by
  // `OfcForm` for initializing edit state, but they are not present in the
  // generated View Row type. Keep them optional to avoid lying about what the
  // view guarantees while allowing the component to reference them safely.
  sn_id?: string | null;
  en_id?: string | null;
  ofc_type: {
    id: string;
    name: string;
  } | null;
  maintenance_area: {
    id: string;
    name: string;
  } | null;
};


```

<!-- path: components/ofc/DRY-guide-ofc.md -->
```markdown
# DRY Guide: Building Data Pages (based on Rings & Employees)

This guide outlines patterns from `app/dashboard/rings/page.tsx` and `app/dashboard/employees/page.tsx` to help build future CRUD/data pages with minimal duplication.

## Core Building Blocks

- __Data access hooks__ (`@/hooks/database`):
  - `useTableQuery()` for simple tables.
  - `useTableWithRelations()` when joining related tables (e.g., rings with lookup types and maintenance areas).
  - Mutations: `useTableInsert()`, `useTableUpdate()`, `useTableDelete()`, `useToggleStatus()`.
- __Table layer__ (`@/components/table/DataTable`):
  - Supports pagination, actions, selection, custom toolbar, export.
  - Columns defined separately per entity.
- __Columns__:
  - Employees: `components/employee/EmployeeTableColumns.tsx` via `getEmployeeTableColumns()`.
- __Filters UI__:
  - Employees: `components/employee/EmployeeFilters.tsx` (search + dropdowns), typed by `components/employee/employee-types.ts`.
- __Modals / Forms__:
  - Employees: `components/employee/EmployeeForm.tsx` and `EmployeeDetailsModal.tsx`.

## Page Skeleton Template

1) __State__

- Pagination: `currentPage`, `pageLimit`.
- Filters: local UI state -> derived server filters (memoized).
- Debounced search: `useDebounce`/`useDebouncedCallback`.
- Selection (optional): selected IDs.
- Modal state: add/edit/view flags.

2) __Filters -> Server Filters__

- Keep a small UI type, e.g. `EmployeeFilters` with string fields.
- Derive DB filters with `useMemo`, convert empty to undefined.
- Example: employees maps `status` string to boolean.

3) __Data Fetch__

- Prefer `useTableQuery` for single-table lists.
- Use `useTableWithRelations` for joined displays (e.g., rings shows related `lookup_types` and `maintenance_areas`).
- Always pass `orderBy`, `limit`, `offset`.

4) __Total Count Strategy__

- If your hooks provide window `total_count`, read it.
- Fallback to HEAD count: `supabase.from(table).select("id", { count: "exact", head: true })`.
- Use max(windowCount, headCount, pageLen) to avoid undercount.

5) __Columns__

- Define per-entity `getXTableColumns()` function in a colocated `components/<entity>/` file.
- Use `Row<"table">` for types; for relations, use custom `render` functions casting as needed.
- Centralize formatting (e.g., `formatDate`) in `@/utils/formatters`.

6) __Actions__

- Build an array of row actions with keys, labels, icons, and `hidden` predicates.
- Use shared mutation hooks (toggle status, delete) and wrap confirmations in a generic modal (`ConfirmModal`).

7) __Toolbar__

- Compose filters component into a `customToolbar` for the `DataTable`.
- Leave `searchable=false` and `filterable=false` on `DataTable` if filtering handled externally.

8) __Modals / Forms__

- Add/Edit: open with `editingRecord` or `null` for create.
- On success, `refetch()` and close modal.

## Suggested Abstractions to Reuse

- __ListPageTemplate__ (optional HOC or component):
  - Props: `tableName`, `columns`, `queryHook`, `filtersUI`, `rowActions`, `header`, `exportOptions?`.
  - Internally handle pagination, debounced search, count calculation, and render `DataTable` with `customToolbar`.
- __FilterBuilder__ helpers:
  - Map UI filters to DB filters (e.g., `status: "true" | "false" | "" -> boolean | undefined`).
- __Lookup maps__ utilities:
  - `toIdNameMap(rows)` for fast rendering of related names in tables.

## Minimal Step-by-Step for a New Page

1. __Create columns__ in `components/<entity>/<Entity>TableColumns.ts(x)`.
2. __Create filters UI__ in `components/<entity>/<Entity>Filters.tsx` if needed.
3. __Create form/modal__ for add/edit if page is editable.
4. __Implement page__ `app/dashboard/<entity>/page.tsx`:
   - Local state: pagination, filters, modal flags.
   - Derive server filters via `useMemo`.
   - Fetch data with `useTableQuery` or `useTableWithRelations`.
   - Compute `totalCount` using window count + HEAD fallback.
   - Assemble `columns`, `actions`, and `customToolbar`.
   - Render `DataTable` with pagination handlers.
5. __Wire mutations__ via `useTableInsert`, `useTableUpdate`, `useTableDelete`, `useToggleStatus`.
6. __Test__ pagination, filtering, create/update/delete, toggling status.

## Example References

- Employees Page: `app/dashboard/employees/page.tsx`
  - Filters: `components/employee/EmployeeFilters.tsx`
  - Columns: `components/employee/EmployeeTableColumns.tsx`
  - Form/Details: `components/employee/EmployeeForm.tsx`, `EmployeeDetailsModal.tsx`

## Conventions

- Keep entity-specific code under `components/<entity>/`.
- Keep page logic under `app/dashboard/<entity>/page.tsx`.
- Use Tailwind utilities consistently; encapsulate repeated UI in shared components.
- Keep icons in page/components, not mixed into hooks.

## Checklist

- [X] Columns defined and typed
- [X] Filters UI working and mapped to DB
- [ ] Pagination state + handlers
- [ ] Accurate total count
- [ ] Row actions wired
- [ ] Modals open/close, refetch on success
- [ ] No duplicate logic (extract helpers if repeated)

```

<!-- path: components/ofc/hooks/useNodesPageState.ts -->
```typescript
// hooks/useNodesPageState.ts
import { useState, useCallback } from 'react';
import { NodeWithRelations } from '@/components/nodes/nodes_types';
import { NodesFilters } from '@/components/nodes/nodes_types';
import { DEFAULTS } from '@/config/constants';

export const useNodesPageState = () => {
  const [searchTerm, setSearchTerm] = useState("");
  const [currentPage, setCurrentPage] = useState(1);
  const [pageLimit, setPageLimit] = useState(DEFAULTS.PAGE_SIZE);
  const [filters, setFilters] = useState<NodesFilters>({});
  const [isFormOpen, setFormOpen] = useState(false);
  const [editingNode, setEditingNode] = useState<NodeWithRelations | null>(null);

  const resetPagination = useCallback(() => setCurrentPage(1), []);

  const openCreateForm = useCallback(() => {
    setEditingNode(null);
    setFormOpen(true);
  }, []);

  const openEditForm = useCallback((node: NodeWithRelations) => {
    setEditingNode(node);
    setFormOpen(true);
  }, []);

  const closeForm = useCallback(() => {
    setFormOpen(false);
    setEditingNode(null);
  }, []);

  const updateFilters = useCallback((newFilters: Partial<NodesFilters>) => {
    setFilters(prev => ({ ...prev, ...newFilters }));
    resetPagination();
  }, [resetPagination]);

  const updatePagination = useCallback((page: number, pageSize: number) => {
    setCurrentPage(page);
    setPageLimit(pageSize);
  }, []);

  return {
    // State
    searchTerm,
    currentPage,
    pageLimit,
    filters,
    isFormOpen,
    editingNode,
    
    // Actions
    setSearchTerm,
    resetPagination,
    openCreateForm,
    openEditForm,
    closeForm,
    updateFilters,
    updatePagination,
  };
};
```

<!-- path: components/ofc/hooks/useNodesTableActions.ts -->
```typescript
import { FiEdit2 } from "react-icons/fi";
// hooks/useNodesTableActions.ts
import { useMemo, createElement } from "react";
import { Row } from "@/hooks/database";
import { NodeWithRelations } from "@/components/nodes/nodes_types";
import { FiToggleRight, FiToggleLeft, FiTrash2 } from "react-icons/fi";

interface UseNodesTableActionsProps {
  onEdit: (node: NodeWithRelations) => void;
  onToggleStatus: (id: string, status: boolean) => void;
  onDelete: (id: string, name: string) => void;
}

export const useNodesTableActions = ({ onEdit, onToggleStatus, onDelete }: UseNodesTableActionsProps) => {
  return useMemo(
    () => [
      {
        key: "edit",
        label: "Edit",
        onClick: (record: Row<"nodes">) => onEdit(record as NodeWithRelations),
        icon: createElement(FiEdit2),
      },
      {
        key: "activate",
        label: "Activate",
        hidden: (r: Row<"nodes">) => Boolean((r as any).status) === true,
        onClick: (r: Row<"nodes">) => onToggleStatus((r as any).id, true),
        icon: createElement(FiToggleRight),
      },
      {
        key: "deactivate",
        label: "Deactivate",
        hidden: (r: Row<"nodes">) => Boolean((r as any).status) === false,
        onClick: (r: Row<"nodes">) => onToggleStatus((r as any).id, false),
        icon: createElement(FiToggleLeft),
      },
      {
        key: "delete",
        label: "Delete",
        variant: "danger" as const,
        onClick: (r: Row<"nodes">) => onDelete((r as any).id, String((r as any).name ?? "this node")),
        icon: createElement(FiTrash2),
      },
    ],
    [onEdit, onToggleStatus, onDelete]
  );
};

```

<!-- path: components/ofc/hooks/index.ts -->
```typescript
export * from "./useNodesPageState";
export * from "./useNodesTableActions";

```

<!-- path: components/ofc/RouteEvolutionManager.tsx -->
```typescript
import { useState, useEffect } from 'react';

interface ExistingRoute {
  id: string;
  route_name: string;
  capacity: number;
  start_node: string;
  end_node: string;
  current_rkm: number;
  status: boolean;
  // New fields for evolution tracking
  evolution_status: 'simple' | 'with_jcs' | 'fully_segmented';
  has_active_segments: boolean;
}

interface JunctionClosure {
  id: string;
  name: string;
  latitude: number;
  longitude: number;
  jc_type: 'inline' | 'branching' | 'terminal';
  capacity: number;
  parent_route_id: string;
  position_on_route: number; // 0-100%
  status: boolean;
}

interface CableSegment {
  id: string;
  original_route_id: string;
  segment_order: number;
  start_point_id: string;
  end_point_id: string;
  start_point_type: 'node' | 'jc';
  end_point_type: 'node' | 'jc';
  fiber_count: number;
  distance_km: number;
  is_active: boolean;
}

interface FiberSplice {
  id: string;
  jc_id: string;
  incoming_segment_id: string;
  incoming_fiber_number: number;
  outgoing_segment_id: string;
  outgoing_fiber_number: number;
  splice_type: 'through' | 'tap' | 'split';
  splice_date: string;
  loss_db: number;
  status: 'active' | 'spare' | 'faulty';
}

const RouteEvolutionManager = () => {
  const [selectedRoute, setSelectedRoute] = useState<ExistingRoute | null>(null);
  const [evolutionMode, setEvolutionMode] = useState<'view' | 'add_jc' | 'configure_splices' | 'commit'>('view');
  const [jcsOnRoute, setJcsOnRoute] = useState<JunctionClosure[]>([]);
  const [projectedSegments, setProjectedSegments] = useState<CableSegment[]>([]);
  const [projectedSplices, setProjectedSplices] = useState<FiberSplice[]>([]);
  
  // Mock existing routes with evolution status
  const [existingRoutes] = useState<ExistingRoute[]>([
    {
      id: 'route-1',
      route_name: 'NodeA  NodeB _ 1',
      capacity: 24,
      start_node: 'NodeA',
      end_node: 'NodeB',
      current_rkm: 15.5,
      status: true,
      evolution_status: 'simple',
      has_active_segments: false
    },
    {
      id: 'route-2', 
      route_name: 'NodeC  NodeD _ 1',
      capacity: 48,
      start_node: 'NodeC',
      end_node: 'NodeD', 
      current_rkm: 22.3,
      status: true,
      evolution_status: 'with_jcs',
      has_active_segments: false
    },
    {
      id: 'route-3',
      route_name: 'NodeE  NodeF _ 1',
      capacity: 96,
      start_node: 'NodeE',
      end_node: 'NodeF',
      current_rkm: 8.7,
      status: true,
      evolution_status: 'fully_segmented',
      has_active_segments: true
    }
  ]);

  const [newJC, setNewJC] = useState({
    name: '',
    latitude: 0,
    longitude: 0,
    jc_type: 'inline' as const,
    capacity: 24,
    position_on_route: 50
  });

  // Load existing JCs for selected route
  useEffect(() => {
    if (!selectedRoute) {
      setJcsOnRoute([]);
      return;
    }

    // Mock loading existing JCs for the route
    if (selectedRoute.evolution_status === 'with_jcs' || selectedRoute.evolution_status === 'fully_segmented') {
      // This would be a real API call: loadJCsForRoute(selectedRoute.id)
      const mockExistingJCs: JunctionClosure[] = [
        {
          id: 'jc-existing-1',
          name: 'JC-001',
          latitude: 23.5254,
          longitude: 87.2926,
          jc_type: 'inline',
          capacity: 24,
          parent_route_id: selectedRoute.id,
          position_on_route: 33,
          status: true
        }
      ];
      setJcsOnRoute(selectedRoute.id === 'route-2' ? mockExistingJCs : []);
    } else {
      setJcsOnRoute([]);
    }
  }, [selectedRoute]);

  // Generate projected segments when JCs change
  useEffect(() => {
    if (!selectedRoute) {
      setProjectedSegments([]);
      return;
    }

    // Sort JCs by position on route
    const sortedJCs = [...jcsOnRoute]
      .filter(jc => jc.status)
      .sort((a, b) => a.position_on_route - b.position_on_route);
    
    const segments: CableSegment[] = [];
    let segmentOrder = 1;

    // Create all route points (start node  JCs  end node)
    const allPoints = [
      { 
        id: selectedRoute.start_node, 
        type: 'node' as const, 
        name: selectedRoute.start_node,
        position: 0 
      },
      ...sortedJCs.map(jc => ({ 
        id: jc.id, 
        type: 'jc' as const, 
        name: jc.name,
        position: jc.position_on_route 
      })),
      { 
        id: selectedRoute.end_node, 
        type: 'node' as const, 
        name: selectedRoute.end_node,
        position: 100 
      }
    ];

    // Generate segments between consecutive points
    for (let i = 0; i < allPoints.length - 1; i++) {
      const startPoint = allPoints[i];
      const endPoint = allPoints[i + 1];
      const segmentDistance = selectedRoute.current_rkm * (endPoint.position - startPoint.position) / 100;

      segments.push({
        id: `segment-${selectedRoute.id}-${segmentOrder}`,
        original_route_id: selectedRoute.id,
        segment_order: segmentOrder,
        start_point_id: startPoint.id,
        end_point_id: endPoint.id,
        start_point_type: startPoint.type,
        end_point_type: endPoint.type,
        fiber_count: selectedRoute.capacity,
        distance_km: Math.round(segmentDistance * 100) / 100,
        is_active: true
      });
      segmentOrder++;
    }

    setProjectedSegments(segments);
  }, [selectedRoute, jcsOnRoute]);

  const addJCToRoute = () => {
    if (!newJC.name || !selectedRoute) return;

    const jc: JunctionClosure = {
      id: `jc-${Date.now()}`,
      name: newJC.name,
      latitude: newJC.latitude,
      longitude: newJC.longitude,
      jc_type: newJC.jc_type,
      capacity: newJC.capacity,
      parent_route_id: selectedRoute.id,
      position_on_route: newJC.position_on_route,
      status: true
    };

    setJcsOnRoute([...jcsOnRoute, jc]);
    
    // Reset form
    setNewJC({
      name: '',
      latitude: 0,
      longitude: 0,
      jc_type: 'inline',
      capacity: 24,
      position_on_route: 50
    });
  };

  const removeJC = (jcId: string) => {
    setJcsOnRoute(jcsOnRoute.filter(jc => jc.id !== jcId));
  };

  const generateDefaultSplices = () => {
    const splices: FiberSplice[] = [];
    
    projectedSegments.forEach((segment, segIndex) => {
      if (segment.end_point_type === 'jc') {
        const nextSegment = projectedSegments[segIndex + 1];
        if (nextSegment) {
          // Create through splices for all fibers by default
          for (let fiberNum = 1; fiberNum <= segment.fiber_count; fiberNum++) {
            splices.push({
              id: `splice-${segment.id}-${nextSegment.id}-${fiberNum}`,
              jc_id: segment.end_point_id,
              incoming_segment_id: segment.id,
              incoming_fiber_number: fiberNum,
              outgoing_segment_id: nextSegment.id,
              outgoing_fiber_number: fiberNum,
              splice_type: 'through',
              splice_date: new Date().toISOString().split('T')[0],
              loss_db: 0.1,
              status: 'active'
            });
          }
        }
      }
    });

    setProjectedSplices(splices);
  };

  const commitEvolution = async () => {
    if (!selectedRoute || jcsOnRoute.length === 0) return;

    const evolutionData = {
      originalRoute: selectedRoute,
      junctionClosures: jcsOnRoute,
      cableSegments: projectedSegments,
      fiberSplices: projectedSplices,
      evolutionType: 'add_jc_and_segment',
      notes: `Added ${jcsOnRoute.length} JCs and split into ${projectedSegments.length} segments`
    };

    // This would be your actual API calls:
    // await createJunctionClosures(jcsOnRoute);
    // await createCableSegments(projectedSegments);
    // await createFiberSplices(projectedSplices);
    // await logRouteEvolution(evolutionData);
    // await updateRouteStatus(selectedRoute.id, { evolution_status: 'fully_segmented' });
    
    console.log('Evolution data to commit:', evolutionData);
    alert('Route evolution committed! Check console for details.');
    
    // Reset form
    setSelectedRoute(null);
    setJcsOnRoute([]);
    setEvolutionMode('view');
  };

  const getEvolutionStatusColor = (status: string) => {
    switch (status) {
      case 'simple': return 'bg-gray-100 text-gray-800 dark:bg-gray-700 dark:text-gray-200';
      case 'with_jcs': return 'bg-yellow-100 text-yellow-800 dark:bg-yellow-900 dark:text-yellow-200';
      case 'fully_segmented': return 'bg-green-100 text-green-800 dark:bg-green-900 dark:text-green-200';
      default: return 'bg-gray-100 text-gray-800';
    }
  };

  return (
    <div className="max-w-7xl mx-auto p-6 bg-white dark:bg-gray-900">
      <div className="mb-8">
        <h1 className="text-3xl font-bold text-gray-900 dark:text-white mb-2">
          Route Evolution Manager v2
        </h1>
        <p className="text-gray-600 dark:text-gray-400">
          Evolve simple routes by adding Junction Closures and creating cable segments
        </p>
      </div>

      {/* Route Selection */}
      <div className="mb-6">
        <label className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2">
          Select Route to Evolve
        </label>
        <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4">
          {existingRoutes.map(route => (
            <div
              key={route.id}
              onClick={() => {
                setSelectedRoute(route);
                setEvolutionMode('view');
              }}
              className={`p-4 border-2 rounded-lg cursor-pointer transition-all ${
                selectedRoute?.id === route.id
                  ? 'border-blue-500 bg-blue-50 dark:bg-blue-900/20'
                  : 'border-gray-200 dark:border-gray-600 hover:border-blue-300 dark:hover:border-blue-700'
              }`}
            >
              <div className="font-medium text-gray-900 dark:text-white mb-2">
                {route.route_name}
              </div>
              <div className="text-sm text-gray-600 dark:text-gray-400 space-y-1">
                <div>{route.capacity} fibers  {route.current_rkm} km</div>
                <div className="flex justify-between items-center">
                  <span>{route.start_node}  {route.end_node}</span>
                  <span className={`px-2 py-1 rounded text-xs ${getEvolutionStatusColor(route.evolution_status)}`}>
                    {route.evolution_status.replace('_', ' ')}
                  </span>
                </div>
              </div>
            </div>
          ))}
        </div>
      </div>

      {selectedRoute && (
        <div className="grid grid-cols-1 xl:grid-cols-3 gap-6">
          {/* Left Panel - Route Info & Actions */}
          <div className="space-y-6">
            <div className="bg-gray-50 dark:bg-gray-800 p-4 rounded-lg">
              <h3 className="text-lg font-semibold text-gray-900 dark:text-white mb-3">
                Route Details
              </h3>
              <div className="space-y-2 text-sm">
                <div className="flex justify-between">
                  <span className="text-gray-600 dark:text-gray-400">ID:</span>
                  <span className="text-gray-900 dark:text-white font-mono text-xs">{selectedRoute.id}</span>
                </div>
                <div className="flex justify-between">
                  <span className="text-gray-600 dark:text-gray-400">Name:</span>
                  <span className="text-gray-900 dark:text-white font-mono">{selectedRoute.route_name}</span>
                </div>
                <div className="flex justify-between">
                  <span className="text-gray-600 dark:text-gray-400">Capacity:</span>
                  <span className="text-gray-900 dark:text-white">{selectedRoute.capacity} fibers</span>
                </div>
                <div className="flex justify-between">
                  <span className="text-gray-600 dark:text-gray-400">Distance:</span>
                  <span className="text-gray-900 dark:text-white">{selectedRoute.current_rkm} km</span>
                </div>
                <div className="flex justify-between">
                  <span className="text-gray-600 dark:text-gray-400">Status:</span>
                  <span className={`px-2 py-1 rounded text-xs ${getEvolutionStatusColor(selectedRoute.evolution_status)}`}>
                    {selectedRoute.evolution_status.replace('_', ' ')}
                  </span>
                </div>
              </div>
            </div>

            {/* Evolution Actions */}
            <div className="bg-gray-50 dark:bg-gray-800 p-4 rounded-lg">
              <h3 className="text-lg font-semibold text-gray-900 dark:text-white mb-3">
                Evolution Actions
              </h3>
              <div className="space-y-2">
                <button
                  onClick={() => setEvolutionMode('add_jc')}
                  disabled={selectedRoute.evolution_status === 'fully_segmented'}
                  className={`w-full p-2 rounded-md text-left text-sm ${
                    evolutionMode === 'add_jc' 
                      ? 'bg-blue-500 text-white' 
                      : 'bg-white dark:bg-gray-700 border border-gray-300 dark:border-gray-600 text-gray-700 dark:text-gray-300 hover:bg-gray-50 dark:hover:bg-gray-600 disabled:opacity-50 disabled:cursor-not-allowed'
                  }`}
                >
                   Add Junction Closure
                </button>
                <button
                  onClick={() => {
                    generateDefaultSplices();
                    setEvolutionMode('configure_splices');
                  }}
                  disabled={jcsOnRoute.length === 0}
                  className={`w-full p-2 rounded-md text-left text-sm ${
                    evolutionMode === 'configure_splices' 
                      ? 'bg-blue-500 text-white' 
                      : 'bg-white dark:bg-gray-700 border border-gray-300 dark:border-gray-600 text-gray-700 dark:text-gray-300 hover:bg-gray-50 dark:hover:bg-gray-600 disabled:opacity-50 disabled:cursor-not-allowed'
                  }`}
                >
                   Configure Splices
                </button>
                <button
                  onClick={() => setEvolutionMode('commit')}
                  disabled={jcsOnRoute.length === 0 || projectedSegments.length === 0}
                  className={`w-full p-2 rounded-md text-left text-sm ${
                    evolutionMode === 'commit' 
                      ? 'bg-purple-500 text-white' 
                      : 'bg-white dark:bg-gray-700 border border-gray-300 dark:border-gray-600 text-gray-700 dark:text-gray-300 hover:bg-gray-50 dark:hover:bg-gray-600 disabled:opacity-50 disabled:cursor-not-allowed'
                  }`}
                >
                   Review & Commit
                </button>
              </div>
            </div>

            {/* Add JC Form */}
            {evolutionMode === 'add_jc' && (
              <div className="bg-yellow-50 dark:bg-yellow-900/20 p-4 rounded-lg border border-yellow-200 dark:border-yellow-800">
                <h4 className="font-semibold text-gray-900 dark:text-white mb-3">Add New Junction Closure</h4>
                <div className="space-y-3">
                  <div>
                    <label className="block text-xs font-medium text-gray-700 dark:text-gray-300 mb-1">
                      JC Name *
                    </label>
                    <input
                      type="text"
                      value={newJC.name}
                      onChange={(e) => setNewJC({...newJC, name: e.target.value})}
                      placeholder="JC-ABC-001"
                      className="w-full p-2 text-sm border border-gray-300 dark:border-gray-600 rounded bg-white dark:bg-gray-700 text-gray-900 dark:text-white"
                    />
                  </div>
                  
                  <div className="grid grid-cols-2 gap-2">
                    <div>
                      <label className="block text-xs font-medium text-gray-700 dark:text-gray-300 mb-1">
                        Latitude
                      </label>
                      <input
                        type="number"
                        step="0.000001"
                        value={newJC.latitude || ''}
                        onChange={(e) => setNewJC({...newJC, latitude: Number(e.target.value)})}
                        className="w-full p-2 text-sm border border-gray-300 dark:border-gray-600 rounded bg-white dark:bg-gray-700 text-gray-900 dark:text-white"
                      />
                    </div>
                    <div>
                      <label className="block text-xs font-medium text-gray-700 dark:text-gray-300 mb-1">
                        Longitude
                      </label>
                      <input
                        type="number"
                        step="0.000001"
                        value={newJC.longitude || ''}
                        onChange={(e) => setNewJC({...newJC, longitude: Number(e.target.value)})}
                        className="w-full p-2 text-sm border border-gray-300 dark:border-gray-600 rounded bg-white dark:bg-gray-700 text-gray-900 dark:text-white"
                      />
                    </div>
                  </div>

                  <div>
                    <label className="block text-xs font-medium text-gray-700 dark:text-gray-300 mb-1">
                      Position on Route: {newJC.position_on_route}%
                    </label>
                    <input
                      type="range"
                      min="5"
                      max="95"
                      value={newJC.position_on_route}
                      onChange={(e) => setNewJC({...newJC, position_on_route: Number(e.target.value)})}
                      className="w-full"
                    />
                    <div className="text-xs text-gray-500 dark:text-gray-400 text-center">
                      ~{(selectedRoute.current_rkm * newJC.position_on_route / 100).toFixed(1)} km from {selectedRoute.start_node}
                    </div>
                  </div>

                  <div className="grid grid-cols-2 gap-2">
                    <div>
                      <label className="block text-xs font-medium text-gray-700 dark:text-gray-300 mb-1">
                        JC Type
                      </label>
                      <select
                        value={newJC.jc_type}
                        onChange={(e) => setNewJC({...newJC, jc_type: e.target.value as any})}
                        className="w-full p-2 text-sm border border-gray-300 dark:border-gray-600 rounded bg-white dark:bg-gray-700 text-gray-900 dark:text-white"
                      >
                        <option value="inline">Inline</option>
                        <option value="branching">Branching</option>
                        <option value="terminal">Terminal</option>
                      </select>
                    </div>
                    <div>
                      <label className="block text-xs font-medium text-gray-700 dark:text-gray-300 mb-1">
                        Splice Capacity
                      </label>
                      <select
                        value={newJC.capacity}
                        onChange={(e) => setNewJC({...newJC, capacity: Number(e.target.value)})}
                        className="w-full p-2 text-sm border border-gray-300 dark:border-gray-600 rounded bg-white dark:bg-gray-700 text-gray-900 dark:text-white"
                      >
                        <option value={24}>24 splice</option>
                        <option value={48}>48 splice</option>
                        <option value={96}>96 splice</option>
                        <option value={144}>144 splice</option>
                      </select>
                    </div>
                  </div>

                  <button
                    onClick={addJCToRoute}
                    disabled={!newJC.name || newJC.latitude === 0 || newJC.longitude === 0}
                    className="w-full p-2 bg-green-500 text-white rounded-md hover:bg-green-600 disabled:bg-gray-300 disabled:cursor-not-allowed text-sm"
                  >
                    Add JC to Route
                  </button>
                </div>
              </div>
            )}
          </div>

          {/* Middle Panel - Route Visualization */}
          <div className="bg-gray-50 dark:bg-gray-800 p-4 rounded-lg">
            <h3 className="text-lg font-semibold text-gray-900 dark:text-white mb-4">
              Route Visualization
            </h3>
            
            {selectedRoute && (
              <div className="space-y-4">
                {/* Route Path Diagram */}
                <div className="relative">
                  <div className="flex items-center space-x-2 overflow-x-auto pb-4">
                    {/* Start Node */}
                    <div className="flex-shrink-0 text-center">
                      <div className="w-12 h-12 bg-blue-500 rounded-full flex items-center justify-center text-white font-bold text-xs">
                        N
                      </div>
                      <div className="text-xs mt-1 text-gray-600 dark:text-gray-400 max-w-16 truncate">
                        {selectedRoute.start_node}
                      </div>
                      <div className="text-xs text-gray-500">0%</div>
                    </div>

                    {/* JCs along the route */}
                    {jcsOnRoute
                      .filter(jc => jc.status)
                      .sort((a, b) => a.position_on_route - b.position_on_route)
                      .map((jc) => (
                        <div key={jc.id} className="flex items-center">
                          <div className="w-16 h-0.5 bg-gray-400"></div>
                          <div className="flex-shrink-0 text-center relative">
                            <div className={`w-10 h-10 rounded-full flex items-center justify-center text-white text-xs font-bold ${
                              jc.jc_type === 'branching' ? 'bg-orange-500' : 
                              jc.jc_type === 'terminal' ? 'bg-red-500' : 'bg-green-500'
                            }`}>
                              JC
                            </div>
                            <div className="text-xs mt-1 text-gray-600 dark:text-gray-400 max-w-16 truncate">
                              {jc.name}
                            </div>
                            <div className="text-xs text-gray-500">{jc.position_on_route}%</div>
                            {evolutionMode === 'add_jc' && (
                              <button
                                onClick={() => removeJC(jc.id)}
                                className="absolute -top-2 -right-2 w-4 h-4 bg-red-500 text-white rounded-full text-xs hover:bg-red-600"
                              >
                                
                              </button>
                            )}
                          </div>
                        </div>
                      ))}

                    {/* End Node */}
                    <div className="flex items-center">
                      <div className="w-16 h-0.5 bg-gray-400"></div>
                      <div className="flex-shrink-0 text-center">
                        <div className="w-12 h-12 bg-blue-500 rounded-full flex items-center justify-center text-white font-bold text-xs">
                          N
                        </div>
                        <div className="text-xs mt-1 text-gray-600 dark:text-gray-400 max-w-16 truncate">
                          {selectedRoute.end_node}
                        </div>
                        <div className="text-xs text-gray-500">100%</div>
                      </div>
                    </div>
                  </div>
                </div>

                {/* JCs Summary */}
                {jcsOnRoute.length > 0 && (
                  <div className="space-y-2">
                    <div className="text-sm font-medium text-gray-700 dark:text-gray-300">
                      Junction Closures on Route:
                    </div>
                    {jcsOnRoute.map((jc) => (
                      <div key={jc.id} className="flex justify-between items-center text-xs p-2 bg-white dark:bg-gray-700 rounded">
                        <span className="font-medium">{jc.name}</span>
                        <div className="flex items-center space-x-2">
                          <span className={`px-2 py-1 rounded ${
                            jc.jc_type === 'branching' ? 'bg-orange-100 text-orange-800 dark:bg-orange-900 dark:text-orange-200' : 
                            jc.jc_type === 'terminal' ? 'bg-red-100 text-red-800 dark:bg-red-900 dark:text-red-200' : 
                            'bg-green-100 text-green-800 dark:bg-green-900 dark:text-green-200'
                          }`}>
                            {jc.jc_type}
                          </span>
                          <span className="text-gray-500">{jc.capacity}f</span>
                        </div>
                      </div>
                    ))}
                  </div>
                )}
              </div>
            )}
          </div>

          {/* Right Panel - Projected Segments */}
          <div className="xl:col-span-2 space-y-4">
            <div className="flex justify-between items-center">
              <h3 className="text-lg font-semibold text-gray-900 dark:text-white">
                {evolutionMode === 'configure_splices' ? 'Splice Configuration' : 'Projected Cable Segments'}
              </h3>
              {evolutionMode === 'commit' && (
                <button
                  onClick={commitEvolution}
                  className="px-6 py-2 bg-purple-600 text-white rounded-md hover:bg-purple-700 font-medium"
                >
                  Commit Evolution
                </button>
              )}
            </div>

            {evolutionMode === 'configure_splices' && projectedSplices.length > 0 ? (
              <div className="space-y-4">
                <div className="text-sm text-gray-600 dark:text-gray-400 mb-4">
                  Configure fiber splicing at each Junction Closure. Default: all fibers pass through.
                </div>
                {/* Splice Configuration Table */}
<div className="overflow-x-auto">
  <table className="min-w-full divide-y divide-gray-200 dark:divide-gray-700">
    <thead className="bg-gray-50 dark:bg-gray-800">
      <tr>
        <th className="px-4 py-3 text-left text-xs font-medium text-gray-500 dark:text-gray-400 uppercase tracking-wider">JC</th>
        <th className="px-4 py-3 text-left text-xs font-medium text-gray-500 dark:text-gray-400 uppercase tracking-wider">Incoming Segment</th>
        <th className="px-4 py-3 text-left text-xs font-medium text-gray-500 dark:text-gray-400 uppercase tracking-wider">Outgoing Segment</th>
        <th className="px-4 py-3 text-left text-xs font-medium text-gray-500 dark:text-gray-400 uppercase tracking-wider">Fiber</th>
        <th className="px-4 py-3 text-left text-xs font-medium text-gray-500 dark:text-gray-400 uppercase tracking-wider">Splice Type</th>
        <th className="px-4 py-3 text-left text-xs font-medium text-gray-500 dark:text-gray-400 uppercase tracking-wider">Status</th>
      </tr>
    </thead>
    <tbody className="bg-white dark:bg-gray-900 divide-y divide-gray-200 dark:divide-gray-700">
      {projectedSplices.map((splice) => {
        const jc = jcsOnRoute.find(j => j.id === splice.jc_id);
        const incomingSegment = projectedSegments.find(s => s.id === splice.incoming_segment_id);
        const outgoingSegment = projectedSegments.find(s => s.id === splice.outgoing_segment_id);
        
        return (
          <tr key={splice.id} className="hover:bg-gray-50 dark:hover:bg-gray-800">
            <td className="px-4 py-3 whitespace-nowrap text-sm font-medium text-gray-900 dark:text-white">
              {jc?.name || 'Unknown JC'}
            </td>
            <td className="px-4 py-3 whitespace-nowrap text-sm text-gray-500 dark:text-gray-400">
              {incomingSegment?.start_point_id}  {incomingSegment?.end_point_id}
            </td>
            <td className="px-4 py-3 whitespace-nowrap text-sm text-gray-500 dark:text-gray-400">
              {outgoingSegment?.start_point_id}  {outgoingSegment?.end_point_id}
            </td>
            <td className="px-4 py-3 whitespace-nowrap text-sm text-gray-500 dark:text-gray-400">
              #{splice.incoming_fiber_number}  #{splice.outgoing_fiber_number}
            </td>
            <td className="px-4 py-3 whitespace-nowrap text-sm text-gray-500 dark:text-gray-400">
              <select
                value={splice.splice_type}
                onChange={(e) => {
                  const updatedSplices = projectedSplices.map(s => 
                    s.id === splice.id ? {...s, splice_type: e.target.value as any} : s
                  );
                  setProjectedSplices(updatedSplices);
                }}
                className="border border-gray-300 dark:border-gray-600 rounded bg-white dark:bg-gray-700 text-gray-900 dark:text-white p-1 text-xs"
              >
                <option value="through">Through</option>
                <option value="tap">Tap</option>
                <option value="split">Split</option>
              </select>
            </td>
            <td className="px-4 py-3 whitespace-nowrap text-sm text-gray-500 dark:text-gray-400">
              <select
                value={splice.status}
                onChange={(e) => {
                  const updatedSplices = projectedSplices.map(s => 
                    s.id === splice.id ? {...s, status: e.target.value as any} : s
                  );
                  setProjectedSplices(updatedSplices);
                }}
                className="border border-gray-300 dark:border-gray-600 rounded bg-white dark:bg-gray-700 text-gray-900 dark:text-white p-1 text-xs"
              >
                <option value="active">Active</option>
                <option value="spare">Spare</option>
                <option value="faulty">Faulty</option>
              </select>
            </td>
          </tr>
        );
      })}
    </tbody>
  </table>
</div>

<div className="flex justify-end space-x-3 mt-4">
  <button
    onClick={() => setEvolutionMode('add_jc')}
    className="px-4 py-2 border border-gray-300 dark:border-gray-600 rounded-md text-gray-700 dark:text-gray-300 hover:bg-gray-50 dark:hover:bg-gray-700"
  >
    Back to JCs
  </button>
  <button
    onClick={() => setEvolutionMode('commit')}
    className="px-4 py-2 bg-blue-600 text-white rounded-md hover:bg-blue-700"
  >
    Review & Continue
  </button>
</div>
</div>
) : evolutionMode === 'commit' ? (
<div className="space-y-4">
  <div className="bg-blue-50 dark:bg-blue-900/20 p-4 rounded-lg border border-blue-200 dark:border-blue-800">
    <h4 className="font-semibold text-blue-800 dark:text-blue-200 mb-2">Ready to Commit</h4>
    <p className="text-sm text-blue-700 dark:text-blue-300">
      This will permanently update the route structure with {jcsOnRoute.length} new junction closures and {projectedSegments.length} cable segments.
    </p>
  </div>

  <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
    <div className="bg-white dark:bg-gray-800 p-4 rounded-lg border border-gray-200 dark:border-gray-700">
      <h4 className="font-semibold text-gray-900 dark:text-white mb-3">Junction Closures</h4>
      <ul className="space-y-2">
        {jcsOnRoute.map(jc => (
          <li key={jc.id} className="flex justify-between text-sm">
            <span className="font-medium">{jc.name}</span>
            <span className="text-gray-600 dark:text-gray-400">{jc.position_on_route}% position</span>
          </li>
        ))}
      </ul>
    </div>

    <div className="bg-white dark:bg-gray-800 p-4 rounded-lg border border-gray-200 dark:border-gray-700">
      <h4 className="font-semibold text-gray-900 dark:text-white mb-3">Cable Segments</h4>
      <ul className="space-y-2">
        {projectedSegments.map(segment => (
          <li key={segment.id} className="flex justify-between text-sm">
            <span>
              {segment.start_point_type === 'node' ? 'N' : 'JC'}-{segment.start_point_id}  
              {segment.end_point_type === 'node' ? 'N' : 'JC'}-{segment.end_point_id}
            </span>
            <span className="text-gray-600 dark:text-gray-400">{segment.distance_km} km</span>
          </li>
        ))}
      </ul>
    </div>
  </div>

  {projectedSplices.length > 0 && (
    <div className="bg-white dark:bg-gray-800 p-4 rounded-lg border border-gray-200 dark:border-gray-700">
      <h4 className="font-semibold text-gray-900 dark:text-white mb-3">Splice Summary</h4>
      <div className="grid grid-cols-3 gap-4 text-sm">
        <div className="text-center">
          <div className="text-2xl font-bold text-green-600 dark:text-green-400">
            {projectedSplices.filter(s => s.status === 'active').length}
          </div>
          <div className="text-gray-600 dark:text-gray-400">Active</div>
        </div>
        <div className="text-center">
          <div className="text-2xl font-bold text-blue-600 dark:text-blue-400">
            {projectedSplices.filter(s => s.status === 'spare').length}
          </div>
          <div className="text-gray-600 dark:text-gray-400">Spare</div>
        </div>
        <div className="text-center">
          <div className="text-2xl font-bold text-red-600 dark:text-red-400">
            {projectedSplices.filter(s => s.status === 'faulty').length}
          </div>
          <div className="text-gray-600 dark:text-gray-400">Faulty</div>
        </div>
      </div>
    </div>
  )}
</div>
) : projectedSegments.length > 0 ? (
<div className="overflow-x-auto">
  <table className="min-w-full divide-y divide-gray-200 dark:divide-gray-700">
    <thead className="bg-gray-50 dark:bg-gray-800">
      <tr>
        <th className="px-4 py-3 text-left text-xs font-medium text-gray-500 dark:text-gray-400 uppercase tracking-wider">Segment</th>
        <th className="px-4 py-3 text-left text-xs font-medium text-gray-500 dark:text-gray-400 uppercase tracking-wider">Path</th>
        <th className="px-4 py-3 text-left text-xs font-medium text-gray-500 dark:text-gray-400 uppercase tracking-wider">Distance</th>
        <th className="px-4 py-3 text-left text-xs font-medium text-gray-500 dark:text-gray-400 uppercase tracking-wider">Fibers</th>
        <th className="px-4 py-3 text-left text-xs font-medium text-gray-500 dark:text-gray-400 uppercase tracking-wider">Status</th>
      </tr>
    </thead>
    <tbody className="bg-white dark:bg-gray-900 divide-y divide-gray-200 dark:divide-gray-700">
      {projectedSegments.map((segment) => (
        <tr key={segment.id} className="hover:bg-gray-50 dark:hover:bg-gray-800">
          <td className="px-4 py-3 whitespace-nowrap text-sm font-medium text-gray-900 dark:text-white">
            #{segment.segment_order}
          </td>
          <td className="px-4 py-3 whitespace-nowrap text-sm text-gray-500 dark:text-gray-400">
            {segment.start_point_type === 'node' ? 'N' : 'JC'}-{segment.start_point_id}  
            {segment.end_point_type === 'node' ? 'N' : 'JC'}-{segment.end_point_id}
          </td>
          <td className="px-4 py-3 whitespace-nowrap text-sm text-gray-500 dark:text-gray-400">
            {segment.distance_km} km
          </td>
          <td className="px-4 py-3 whitespace-nowrap text-sm text-gray-500 dark:text-gray-400">
            {segment.fiber_count}f
          </td>
          <td className="px-4 py-3 whitespace-nowrap text-sm text-gray-500 dark:text-gray-400">
            <span className={`px-2 py-1 rounded text-xs ${
              segment.is_active ? 'bg-green-100 text-green-800 dark:bg-green-900 dark:text-green-200' : 'bg-gray-100 text-gray-800 dark:bg-gray-700 dark:text-gray-200'
            }`}>
              {segment.is_active ? 'Active' : 'Inactive'}
            </span>
          </td>
        </tr>
      ))}
    </tbody>
  </table>
</div>
) : (
<div className="bg-gray-50 dark:bg-gray-800 p-8 rounded-lg text-center">
  <div className="text-gray-500 dark:text-gray-400 mb-4">
    <svg className="mx-auto h-12 w-12" fill="none" stroke="currentColor" viewBox="0 0 24 24">
      <path strokeLinecap="round" strokeLinejoin="round" strokeWidth="1" d="M9.172 16.172a4 4 0 015.656 0M9 10h.01M15 10h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z" />
    </svg>
  </div>
  <h4 className="text-lg font-medium text-gray-900 dark:text-white mb-1">
    No Segments Projected
  </h4>
  <p className="text-sm text-gray-500 dark:text-gray-400">
    Add junction closures to the route to generate cable segments.
  </p>
</div>
)}
</div>
</div>
)}
</div>
);
};

export default RouteEvolutionManager;
```

<!-- path: components/ofc/OfcStats.tsx -->
```typescript
// app/dashboard/employees/components/EmployeeStats.tsx
interface OfcStatsProps {
    total: number;
    active: number;
    inactive: number;
  }
  
  export const OfcStats = ({ total, active, inactive }: OfcStatsProps) => {
    return (
      <div className="mt-6 flex items-center justify-between text-sm text-gray-600 dark:text-gray-400">
        <span>
          Showing {total} ofc cable{total !== 1 ? "s" : ""}
        </span>
        <span>
          {active} active, {inactive} inactive
        </span>
      </div>
    );
  };
```

<!-- path: components/ofc/OfcForm/constants/ofcFormConfig.ts -->
```typescript
// components/ofc/OfcForm/constants/ofcFormConfig.ts
export const OFC_FORM_CONFIG = {
  CAPACITY_OPTIONS: [
    { value: '2', label: '2' },
    { value: '4', label: '4' },
    { value: '6', label: '6' },
    { value: '12', label: '12' },
    { value: '24', label: '24' },
    { value: '48', label: '48' },
    { value: '96', label: '96' },
    { value: '144', label: '144' },
    { value: '288', label: '288' },
    { value: '576', label: '576' },
    { value: '864', label: '864' },
    { value: '1728', label: '1728' },
  ],

  ALLOWED_NODE_TYPES: [
    'Transmission Nodes',
    'Joint / Splice Point',
    'Base Transceiver Station',
    'Backhaul Hub / Block HQ',
    'Customer Premises',
    'Gram Panchayat',
  ],

  NODES_FETCH_LIMIT: 1000,
  CACHE_TIME: 5 * 60 * 1000, // 5 minutes
} as const;

```

<!-- path: components/ofc/OfcForm/MaintenanceSection.tsx -->
```typescript
// components/OfcForm/MaintenanceSection.tsx
import React from 'react';
import { Settings } from 'lucide-react';
import { Control, FieldErrors } from 'react-hook-form';
import {
  FormSearchableSelect,
  FormTextarea,
} from '@/components/common/form/FormControls';
import { Option } from '@/components/common/ui/select/SearchableSelect';
import FormSection from './FormSection';
import { Ofc_cablesInsertSchema } from '@/schemas/zod-schemas';

interface MaintenanceSectionProps {
  control: Control<Ofc_cablesInsertSchema>;
  errors: FieldErrors<Ofc_cablesInsertSchema>;
  maintenanceTerminalOptions: Option[];
}

const MaintenanceSection: React.FC<MaintenanceSectionProps> = ({
  control,
  errors,
  maintenanceTerminalOptions,
}) => (
  <FormSection
    title="Maintenance Information"
    icon={Settings}
    iconColor="text-orange-600"
  >
    <div className="grid grid-cols-1 gap-6">
      <FormSearchableSelect
        name="maintenance_terminal_id"
        label="Maintenance Terminal"
        control={control}
        options={maintenanceTerminalOptions}
        error={errors.maintenance_terminal_id}
        placeholder="Select maintenance terminal"
        searchPlaceholder="Search maintenance terminals..."
      />

      <FormTextarea
        name="remark"
        label="Additional Notes"
        control={control}
        error={errors.remark}
        placeholder="Enter any maintenance notes, installation details, or other relevant information..."
      />
    </div>
  </FormSection>
);

export default MaintenanceSection;

```

<!-- path: components/ofc/OfcForm/RouteConfigurationSection.tsx -->
```typescript
// components/OfcForm/RouteConfigurationSection.tsx
import React from 'react';
import { Zap } from 'lucide-react';
import { Control, FieldErrors } from 'react-hook-form';
import { FormSearchableSelect } from '@/components/common/form/FormControls';
import { Label } from '@/components/common/ui/label/Label';
import { Option } from '@/components/common/ui/select/SearchableSelect';
import FormSection from './FormSection';
import { Ofc_cablesInsertSchema } from '@/schemas/zod-schemas';

interface RouteConfigurationSectionProps {
  control: Control<Ofc_cablesInsertSchema>;
  errors: FieldErrors<Ofc_cablesInsertSchema>;
  startingNodeOptions: Option[];
  endingNodeOptions: Option[];
  routeName: string;
}

const RouteConfigurationSection: React.FC<RouteConfigurationSectionProps> = ({
  control,
  errors,
  startingNodeOptions,
  endingNodeOptions,
  routeName,
}) => {
  // console.log('startingNodeOptions', startingNodeOptions);
  // console.log('endingNodeOptions', endingNodeOptions);
  // console.log('control', control);

  return (
    <FormSection
      title="Route Configuration"
      icon={Zap}
      iconColor="text-blue-600"
    >
      <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
        <FormSearchableSelect
          name="sn_id"
          label="Starting Node"
          control={control}
          options={startingNodeOptions}
          error={errors.sn_id}
          placeholder="Select starting node"
          searchPlaceholder="Search starting nodes..."
          aria-describedby="sn-id-help"
        />
        <div id="sn-id-help" className="sr-only">
          Select the starting point for this fiber optic cable route
        </div>

        <FormSearchableSelect
          name="en_id"
          label="Ending Node"
          control={control}
          options={endingNodeOptions}
          error={errors.en_id}
          placeholder="Select ending node"
          searchPlaceholder="Search ending nodes..."
          aria-describedby="en-id-help"
        />
        <div id="en-id-help" className="sr-only">
          Select the ending point for this fiber optic cable route
        </div>
      </div>

      {routeName && (
        <div className="mt-6 space-y-2">
          <Label className="text-gray-700 dark:text-gray-300 font-medium">
            Generated Route Name
          </Label>
          <div className="bg-blue-50 dark:bg-blue-900/20 border border-blue-200 dark:border-blue-700 rounded-md px-3 py-2">
            <span className="text-blue-900 dark:text-blue-100 font-mono text-sm">
              {routeName}
            </span>
          </div>
        </div>
      )}
    </FormSection>
  );
};

export default RouteConfigurationSection;

```

<!-- path: components/ofc/OfcForm/FormSection.tsx -->
```typescript
// components/OfcForm/FormSection.tsx
import React from "react";
import { LucideIcon } from "lucide-react";

interface FormSectionProps {
  title: string;
  icon: LucideIcon;
  iconColor: string;
  children: React.ReactNode;
}

const FormSection: React.FC<FormSectionProps> = ({
  title,
  icon: Icon,
  iconColor,
  children,
}) => (
  <div className="bg-gray-50 dark:bg-gray-800/50 rounded-lg p-6 border dark:border-gray-700">
    <h3 className="text-lg font-semibold text-gray-900 dark:text-white mb-4 flex items-center space-x-2">
      <Icon className={`w-5 h-5 ${iconColor}`} />
      <span>{title}</span>
    </h3>
    {children}
  </div>
);

export default FormSection;
```

<!-- path: components/ofc/OfcForm/hooks/useOfcFormData.ts -->
```typescript
// components/ofc/OfcForm/hooks/useOfcFormData.ts
'use client';

import { useEffect, useMemo, useRef } from 'react';
import { useForm } from 'react-hook-form';
import { zodResolver } from '@hookform/resolvers/zod';
import isEqual from 'lodash.isequal';
import { OfcCablesWithRelations } from '@/app/dashboard/ofc/page';
import {
  Ofc_cablesInsertSchema,
  ofc_cablesInsertSchema,
} from '@/schemas/zod-schemas';

export const useOfcFormData = (ofcCable?: OfcCablesWithRelations) => {
  const isEdit = Boolean(ofcCable);

  const defaultValues = useMemo(
    () => ({
      sn_id: '',
      en_id: '',
      route_name: '',
      ofc_type_id: '',
      capacity: 0,
      current_rkm: null,
      transnet_rkm: null,
      transnet_id: null,
      asset_no: null,
      maintenance_terminal_id: null,
      remark: null,
      status: true,
    }),
    []
  );

  const form = useForm<Ofc_cablesInsertSchema>({
    resolver: zodResolver(ofc_cablesInsertSchema),
    mode: 'onChange',
    defaultValues,
  });

  // Reset form when ofcCable changes or when switching from edit to create mode
  useEffect(() => {
    if (isEdit && ofcCable) {
      form.reset({
        sn_id: ofcCable.sn_id || '',
        en_id: ofcCable.en_id || '',
        route_name: ofcCable.route_name || '',
        ofc_type_id: ofcCable.ofc_type_id || '',
        capacity: ofcCable.capacity || 0,
        current_rkm: ofcCable.current_rkm || 0,
        transnet_rkm: ofcCable.transnet_rkm || 0,
        transnet_id: ofcCable.transnet_id || '',
        asset_no: ofcCable.asset_no || '',
        maintenance_terminal_id: ofcCable.maintenance_terminal_id || '',
        remark: ofcCable.remark || '',
        status: ofcCable.status ?? true,
      });
    } else if (!isEdit) {
      // Reset to default values when not in edit mode
      form.reset(defaultValues);
    }
  }, [isEdit, ofcCable, form, defaultValues]);

  // Create a stable reference to the ofcCable data
  const ofcCableData = useMemo(() => {
    if (!isEdit || !ofcCable) return null;
    const data = {
      sn_id: ofcCable.sn_id || '',
      en_id: ofcCable.en_id || '',
      route_name: ofcCable.route_name || '',
      ofc_type_id: ofcCable.ofc_type_id || '',
      capacity: ofcCable.capacity || 0,
      current_rkm: ofcCable.current_rkm || 0,
      transnet_rkm: ofcCable.transnet_rkm || 0,
      transnet_id: ofcCable.transnet_id || '',
      asset_no: ofcCable.asset_no || '',
      maintenance_terminal_id: ofcCable.maintenance_terminal_id || '',
      remark: ofcCable.remark || '',
      status: ofcCable.status ?? true,
    };
    return data;
  }, [isEdit, ofcCable]);

  // Track previous data to prevent unnecessary resets
  const prevOfcCableData = useRef(ofcCableData);
  const prevDefaultValues = useRef(defaultValues);
  const isInitialMount = useRef(true);

  // Reset form when ofcCable changes
  useEffect(() => {
    // Skip if this is the initial mount and we're in edit mode
    if (isInitialMount.current && isEdit) {
      isInitialMount.current = false;
      return;
    }

    // Skip if nothing has changed
    if (
      isEqual(prevOfcCableData.current, ofcCableData) &&
      isEqual(prevDefaultValues.current, defaultValues)
    ) {
      return;
    }

    // Update refs
    prevOfcCableData.current = ofcCableData;
    prevDefaultValues.current = defaultValues;

    if (ofcCableData) {
      // In edit mode, use the existing data
      form.reset(
        {
          ...ofcCableData,
          route_name: ofcCable?.route_name || '',
        },
        {
          keepDirty: true,
          keepErrors: true,
        }
      );
    } else {
      // In add mode, use default values
      form.reset(
        {
          ...defaultValues,
          route_name: '',
        },
        {
          keepDirty: true,
          keepErrors: true,
        }
      );
    }
  }, [ofcCableData, form, defaultValues, ofcCable?.route_name, isEdit]);

  return { form, isEdit };
};

```

<!-- path: components/ofc/OfcForm/hooks/useCapacityInference.ts -->
```typescript
'use client';

// components/ofc/OfcForm/hooks/useCapacityInference.ts
import { useEffect, useRef, useState } from 'react';
import { Option } from '@/components/common/ui/select/SearchableSelect';
import { UseFormSetValue, Path, PathValue } from 'react-hook-form';
import { Ofc_cablesInsertSchema } from '@/schemas/zod-schemas';

interface UseCapacityInferenceProps<T extends Ofc_cablesInsertSchema> {
  currentOfcTypeId: string;
  ofcTypeOptions: Option[];
  setValue: UseFormSetValue<T>;
}

export const useCapacityInference = <T extends Ofc_cablesInsertSchema>({
  currentOfcTypeId,
  ofcTypeOptions,
  setValue,
}: UseCapacityInferenceProps<T>) => {
  const [isCapacityLocked, setIsCapacityLocked] = useState(false);
  const lastProcessedTypeId = useRef<string | null>(null);

  useEffect(() => {
    // Skip if we've already processed this OFC type ID
    if (lastProcessedTypeId.current === currentOfcTypeId) {
      return;
    }

    if (!currentOfcTypeId) {
      setIsCapacityLocked(false);
      lastProcessedTypeId.current = null;
      return;
    }

    const selectedOption = ofcTypeOptions.find(
      (opt) => opt.value === currentOfcTypeId
    );
    if (!selectedOption) {
      setIsCapacityLocked(false);
      lastProcessedTypeId.current = null;
      return;
    }

    const match = selectedOption.label.match(/(\d+)\s*F/i);
    if (match) {
      const inferredCapacity = parseInt(match[1], 10);
      // Only update if the value has changed
      setValue(
        'capacity' as Path<T>,
        inferredCapacity as unknown as PathValue<T, Path<T>>,
        {
          shouldValidate: true,
          shouldDirty: true,
          shouldTouch: true,
        }
      );
      setIsCapacityLocked(true);
      lastProcessedTypeId.current = currentOfcTypeId;
    } else {
      setIsCapacityLocked(false);
      lastProcessedTypeId.current = null;
    }
  }, [currentOfcTypeId, ofcTypeOptions, setValue]);

  return { isCapacityLocked };
};

```

<!-- path: components/ofc/OfcForm/hooks/useRouteGeneration.ts -->
```typescript
'use client';

// components/ofc/OfcForm/hooks/useRouteGeneration.ts
import { useEffect, useMemo, useRef } from 'react';
import { Filters, useTableQuery } from '@/hooks/database';
import { createClient } from '@/utils/supabase/client';
import { UseFormSetValue, FieldValues, Path, PathValue } from 'react-hook-form';

interface UseRouteGenerationProps<T extends FieldValues> {
  startingNodeId: string | null;
  endingNodeId: string | null;
  nodesData: Array<{ id: string; name: string }> | undefined;
  isEdit: boolean;
  setValue: UseFormSetValue<T>;
}

export const useRouteGeneration = <T extends FieldValues>({
  startingNodeId,
  endingNodeId,
  nodesData,
  isEdit,
  setValue,
}: UseRouteGenerationProps<T>) => {
  // Use refs to track previous values and prevent unnecessary updates
  const prevStartingNodeId = useRef<string | null>(null);
  const prevEndingNodeId = useRef<string | null>(null);
  const prevIsEdit = useRef<boolean>(isEdit);
  const isInitialMount = useRef(true);
  const supabase = createClient();

  const serverFilters = useMemo(() => {
    if (!startingNodeId || !endingNodeId) {
      return null; // Return null instead of empty object
    }

    const f: Filters = {
      or: `and(sn_id.eq."${startingNodeId}",en_id.eq."${endingNodeId}"),and(sn_id.eq."${endingNodeId}",en_id.eq."${startingNodeId}")`,
    };
    return f;
  }, [startingNodeId, endingNodeId]);
  // Fetch existing routes between selected nodes
  const { data: existingRoutes, isLoading: existingRoutesLoading } =
    useTableQuery(supabase, 'ofc_cables', {
      filters: serverFilters || {}, // Use empty object as fallback
      columns: 'id, route_name',
      includeCount: true,
      enabled: Boolean(startingNodeId && endingNodeId && serverFilters), // More explicit enabled condition
      staleTime: 30000, // 30 seconds cache
    });

  // console.log('Existing Routes:', existingRoutes);
  // console.log('Starting Node ID:', startingNodeId);
  // console.log('Ending Node ID:', endingNodeId);

  const routeData = useMemo(() => {
    const routes = existingRoutes || [];
    const routeCount = Array.isArray(routes) ? routes.length : 0;
    const nextRouteNumber = routeCount + 1;

    return {
      existingRoutes: routes.map(
        (route: unknown) => (route as { route_name: string }).route_name
      ),
      routeCount,
      nextRouteNumber,
    };
  }, [existingRoutes]);

  // Auto-generate route name for new cables
  useEffect(() => {
    // Skip if this is the initial mount and we're in edit mode
    if (isInitialMount.current) {
      if (isEdit) {
        isInitialMount.current = false;
        return;
      }
      isInitialMount.current = false;
    }

    // Skip if nothing has changed
    if (
      startingNodeId === prevStartingNodeId.current &&
      endingNodeId === prevEndingNodeId.current &&
      isEdit === prevIsEdit.current
    ) {
      return;
    }

    // Get current values before updating refs
    const prevStart = prevStartingNodeId.current;
    const prevEnd = prevEndingNodeId.current;
    const prevEdit = prevIsEdit.current;

    // Update refs with current values
    prevStartingNodeId.current = startingNodeId;
    prevEndingNodeId.current = endingNodeId;
    prevIsEdit.current = isEdit;

    // Skip if we're in edit mode and the route name is already set
    if (isEdit && startingNodeId && endingNodeId) {
      return;
    }

    // Only proceed if we have both nodes selected and we're not in edit mode
    if (!startingNodeId || !endingNodeId || isEdit) {
      // Only clear if we're not in the middle of a node change
      if ((!startingNodeId || !endingNodeId) && !existingRoutesLoading) {
        setValue('route_name' as Path<T>, '' as PathValue<T, Path<T>>, {
          shouldValidate: true,
          shouldDirty: true,
        });
      }
      return;
    }

    const startingNodeName = nodesData?.find(
      (node) => node.id === startingNodeId
    )?.name;
    const endingNodeName = nodesData?.find(
      (node) => node.id === endingNodeId
    )?.name;

    if (startingNodeName && endingNodeName) {
      // Only update if the nodes have actually changed
      if (
        prevStart !== startingNodeId ||
        prevEnd !== endingNodeId ||
        prevEdit !== isEdit
      ) {
        const routeName = `${startingNodeName}${endingNodeName}_${routeData.nextRouteNumber}`;
        setValue('route_name' as Path<T>, routeName as PathValue<T, Path<T>>, {
          shouldValidate: true,
          shouldDirty: true,
        });
      }
    } else if (!existingRoutesLoading) {
      setValue('route_name' as Path<T>, '' as PathValue<T, Path<T>>, {
        shouldValidate: true,
        shouldDirty: true,
      });
    }
  }, [
    startingNodeId,
    endingNodeId,
    routeData.nextRouteNumber,
    isEdit,
    setValue,
    nodesData,
    existingRoutesLoading,
  ]);

  return {
    ...routeData,
    isLoading: existingRoutesLoading,
  };
};

```

<!-- path: components/ofc/OfcForm/OfcForm.tsx -->
```typescript
// Main OfcForm component
import React, { useMemo } from 'react';
import { Option } from '@/components/common/ui/select/SearchableSelect';
import { usePagedNodesComplete, useTableQuery } from '@/hooks/database';
import { createClient } from '@/utils/supabase/client';
import { Modal } from '@/components/common/ui';
import { FormCard } from '@/components/common/form/FormCard';
import { useOfcFormData } from './hooks/useOfcFormData';
import { OFC_FORM_CONFIG } from '@/components/ofc/OfcForm/constants/ofcFormConfig';
import { useRouteGeneration } from '@/components/ofc/OfcForm/hooks/useRouteGeneration';
import { useCapacityInference } from '@/components/ofc/OfcForm/hooks/useCapacityInference';
import LoadingOverlay from '@/components/ofc/OfcForm/LoadingOverlay';
import ExistingRoutesAlert from '@/components/ofc/OfcForm/ExistingRoutesAlert';
import RouteConfigurationSection from '@/components/ofc/OfcForm/RouteConfigurationSection';
import CableSpecificationsSection from '@/components/ofc/OfcForm/CableSpecificationsSection';
import MaintenanceSection from '@/components/ofc/OfcForm/MaintenanceSection';
import { PathValue } from 'react-hook-form';
import { OfcCablesWithRelations } from '@/app/dashboard/ofc/page';
import {
  Ofc_cablesInsertSchema,
  Ofc_cablesRowSchema,
} from '@/schemas/zod-schemas';

interface OfcFormProps {
  ofcCable?: OfcCablesWithRelations;
  onSubmit: (data: Ofc_cablesInsertSchema) => void;
  onClose: () => void;
  pageLoading: boolean;
  isOpen: boolean;
}

const OfcForm: React.FC<OfcFormProps> = ({
  ofcCable,
  onSubmit,
  onClose,
  pageLoading,
  isOpen,
}) => {
  const supabase = createClient();
  const { form, isEdit } = useOfcFormData(ofcCable);
  const {
    handleSubmit,
    control,
    register,
    setValue,
    watch,
    formState: { errors },
  } = form;

  // Watch critical form values
  const startingNodeId = watch('sn_id');
  const endingNodeId = watch('en_id');
  const routeName = watch('route_name');
  const currentOfcTypeId = watch('ofc_type_id');

  // Data fetching with optimized queries
  const { data: nodesData, isLoading: nodesLoading } = usePagedNodesComplete(
    supabase,
    {
      filters: {
        status: true,
        or: [
          `node_type_name IN ('${OFC_FORM_CONFIG.ALLOWED_NODE_TYPES.join(
            "','"
          )}')`,
        ],
      },
      limit: OFC_FORM_CONFIG.NODES_FETCH_LIMIT,
    }
  );

  const { data: ofcTypesData, isLoading: ofcTypesLoading } = useTableQuery(
    supabase,
    'lookup_types',
    {
      filters: {
        category: { operator: 'eq', value: 'OFC_TYPES' },
        name: { operator: 'neq', value: 'DEFAULT' },
      },
      orderBy: [{ column: 'name', ascending: true }],
      columns: 'id, name',
      staleTime: OFC_FORM_CONFIG.CACHE_TIME,
    }
  );

  const {
    data: maintenanceTerminalsData,
    isLoading: maintenanceTerminalsLoading,
  } = useTableQuery(supabase, 'maintenance_areas', {
    filters: { status: true },
    orderBy: [{ column: 'name', ascending: true }],
    columns: 'id, name',
    staleTime: OFC_FORM_CONFIG.CACHE_TIME,
  });

  // Custom hooks for complex logic
  // Create a type-safe wrapper for setValue
  const setValueWithType = <K extends keyof Ofc_cablesInsertSchema>(
    name: K,
    value: Ofc_cablesInsertSchema[K],
    options?: { shouldValidate?: boolean }
  ) => {
    setValue(name, value as PathValue<Ofc_cablesInsertSchema, K>, options);
  };

  const { existingRoutes, isLoading: routeGenerationLoading } =
    useRouteGeneration<Ofc_cablesRowSchema>({
      startingNodeId,
      endingNodeId,
      nodesData: nodesData ?? undefined,
      isEdit,
      setValue: setValueWithType,
    });

  const { isCapacityLocked } = useCapacityInference<Ofc_cablesInsertSchema>({
    currentOfcTypeId,
    ofcTypeOptions:
      ofcTypesData?.map((type) => ({ value: type.id, label: type.name })) || [],
    setValue: setValueWithType,
  });

  // Memoized options to prevent unnecessary re-renders
  const nodeOptions = useMemo(
    (): Option[] =>
      nodesData?.map((node) => ({
        value: String(node.id),
        label: node.name,
      })) || [],
    [nodesData]
  );

  const startingNodeOptions = useMemo(
    () => nodeOptions.filter((option) => option.value !== endingNodeId),
    [nodeOptions, endingNodeId]
  );

  const endingNodeOptions = useMemo(
    () => nodeOptions.filter((option) => option.value !== startingNodeId),
    [nodeOptions, startingNodeId]
  );

  const ofcTypeOptions = useMemo(
    (): Option[] =>
      ofcTypesData?.map((type) => ({ value: type.id, label: type.name })) || [],
    [ofcTypesData]
  );

  const maintenanceTerminalOptions = useMemo(
    (): Option[] =>
      maintenanceTerminalsData?.map((terminal) => ({
        value: terminal.id,
        label: terminal.name,
      })) || [],
    [maintenanceTerminalsData]
  );

  // Loading state aggregation
  const isLoading =
    nodesLoading ||
    ofcTypesLoading ||
    maintenanceTerminalsLoading ||
    pageLoading ||
    routeGenerationLoading;

  const onValidSubmit = (data: Ofc_cablesInsertSchema) => {
    onSubmit(data as Ofc_cablesInsertSchema);
  };

  return (
    <Modal
      isOpen={isOpen}
      onClose={onClose}
      visible={false}
      className="h-screen w-screen transparent bg-gray-700 rounded-2xl"
    >
      <FormCard
        key={isEdit ? ofcCable?.id ?? 'edit' : 'new'}
        title={isEdit ? 'Edit Optical Fiber Cable' : 'Add Optical Fiber Cable'}
        subtitle={
          isEdit
            ? 'Update the cable details below'
            : 'Fill in the Optical Fiber Cable details below'
        }
        isLoading={isLoading}
        onCancel={onClose}
        onSubmit={handleSubmit(onValidSubmit)}
        submitText={
          isEdit ? 'Update Optical Fiber Cable' : 'Create Optical Fiber Cable'
        }
        standalone
      >
        <div className="p-6 relative">
          {isLoading && <LoadingOverlay />}

          <ExistingRoutesAlert routes={existingRoutes} />

          <div className="space-y-8">
            <RouteConfigurationSection
              control={control}
              errors={errors}
              startingNodeOptions={startingNodeOptions}
              endingNodeOptions={endingNodeOptions}
              routeName={routeName}
            />

            <CableSpecificationsSection
              control={control}
              register={register}
              errors={errors}
              setValue={setValue}
              watch={watch}
              ofcTypeOptions={ofcTypeOptions}
              isCapacityLocked={isCapacityLocked}
            />

            <MaintenanceSection
              control={control}
              errors={errors}
              maintenanceTerminalOptions={maintenanceTerminalOptions}
            />
          </div>
        </div>
      </FormCard>
    </Modal>
  );
};

export default OfcForm;

```

<!-- path: components/ofc/OfcForm/types/ofcForm.types.ts -->
```typescript
// types/ofcForm.types.ts
export interface FormLoadingState {
    nodes: boolean;
    ofcTypes: boolean;
    maintenanceTerminals: boolean;
    routeGeneration: boolean;
    form: boolean;
  }
  
  export interface NodeOption {
    id: string;
    name: string;
    nodeType: string;
    status: boolean;
  }
  
  export interface ValidationResult {
    isValid: boolean;
    errors: Record<string, string>;
    warnings?: Record<string, string>;
  }
```

<!-- path: components/ofc/OfcForm/CableSpecificationsSection.tsx -->
```typescript
// components/OfcForm/CableSpecificationsSection.tsx
import React from 'react';
import { FileText } from 'lucide-react';
import {
  Control,
  FieldErrors,
  UseFormRegister,
  UseFormSetValue,
  UseFormWatch,
} from 'react-hook-form';
import {
  FormInput,
  FormSearchableSelect,
  FormDateInput,
} from '@/components/common/form/FormControls';
import { Switch } from '@/components/common/ui/switch/Switch';
import { Label } from '@/components/common/ui/label/Label';
import { Option } from '@/components/common/ui/select/SearchableSelect';
import { OFC_FORM_CONFIG } from '@/components/ofc/OfcForm/constants/ofcFormConfig';
import FormSection from './FormSection';
import { Ofc_cablesInsertSchema } from '@/schemas/zod-schemas';

interface CableSpecificationsSectionProps {
  control: Control<Ofc_cablesInsertSchema>;
  register: UseFormRegister<Ofc_cablesInsertSchema>;
  errors: FieldErrors<Ofc_cablesInsertSchema>;
  setValue: UseFormSetValue<Ofc_cablesInsertSchema>;
  watch: UseFormWatch<Ofc_cablesInsertSchema>;
  ofcTypeOptions: Option[];
  isCapacityLocked: boolean;
}

const CableSpecificationsSection: React.FC<CableSpecificationsSectionProps> = ({
  control,
  register,
  errors,
  setValue,
  watch,
  ofcTypeOptions,
  isCapacityLocked,
}) => {
  const currentStatus = watch('status');

  return (
    <FormSection
      title="Cable Specifications"
      icon={FileText}
      iconColor="text-green-600"
    >
      <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6">
        <FormInput
          name="asset_no"
          label="Asset Number"
          register={register}
          error={errors.asset_no}
          placeholder="Enter asset number"
        />

        <FormSearchableSelect
          name="ofc_type_id"
          label="OFC Type"
          control={control}
          options={ofcTypeOptions}
          error={errors.ofc_type_id}
          placeholder="Select OFC type"
          searchPlaceholder="Search OFC types..."
        />

        <div className="space-y-2">
          {isCapacityLocked ? (
            <FormInput
              name="capacity"
              label="Capacity"
              register={register}
              error={errors.capacity}
              placeholder="Capacity will be set from OFC type"
              type="number"
              disabled
            />
          ) : (
            <FormSearchableSelect
              name="capacity"
              control={control}
              label="Capacity"
              error={errors.capacity}
              placeholder="Select capacity"
              searchPlaceholder="Search capacities..."
              options={OFC_FORM_CONFIG.CAPACITY_OPTIONS as unknown as Option[]}
            />
          )}
          {isCapacityLocked && (
            <p className="text-xs text-gray-500 dark:text-gray-400 mt-1">
              Capacity inferred from selected OFC type and locked.
            </p>
          )}
        </div>
      </div>

      <div className="grid grid-cols-1 md:grid-cols-2 gap-6 mt-6">
        <FormInput
          name="current_rkm"
          label="Current RKM (km)"
          register={register}
          error={errors.current_rkm}
          placeholder="Enter current RKM"
          type="number"
          step="0.01"
        />

        <FormInput
          name="transnet_rkm"
          label="Transnet RKM (km)"
          register={register}
          error={errors.transnet_rkm}
          placeholder="Enter transnet RKM"
          type="number"
          step="0.01"
        />
      </div>

      <div className="grid grid-cols-1 md:grid-cols-2 gap-6 mt-6">
        <FormInput
          name="transnet_id"
          label="Transnet ID"
          register={register}
          error={errors.transnet_id}
          placeholder="Enter transnet ID"
        />

        <FormDateInput
          name="commissioned_on"
          label="Commissioned Date"
          control={control}
          error={errors.commissioned_on}
          placeholder="Select commissioned date"
        />
      </div>

      <div className="flex items-center space-x-3 pt-6">
        <Switch
          id="status"
          checked={currentStatus ?? true}
          onChange={(checked: boolean) => setValue('status', checked)}
          className="dark:bg-gray-600"
        />
        <Label
          htmlFor="status"
          className="text-gray-700 dark:text-gray-300 font-medium"
        >
          <span
            className={`inline-flex items-center px-2.5 py-0.5 rounded-full text-xs font-medium ${
              currentStatus
                ? 'bg-green-100 text-green-800 dark:bg-green-900/20 dark:text-green-300'
                : 'bg-red-100 text-red-800 dark:bg-red-900/20 dark:text-red-300'
            }`}
          >
            {currentStatus ? 'Active' : 'Inactive'}
          </span>
        </Label>
      </div>
    </FormSection>
  );
};

export default CableSpecificationsSection;

```

<!-- path: components/ofc/OfcForm/ExistingRoutesAlert.tsx -->
```typescript
// components/OfcForm/ExistingRoutesAlert.tsx
import React from "react";
import { AlertTriangle } from "lucide-react";

interface ExistingRoutesAlertProps {
  routes: string[];
}

const ExistingRoutesAlert: React.FC<ExistingRoutesAlertProps> = ({ routes }) => {
  if (!routes.length) return null;

  return (
    <div className="mb-6 bg-amber-50 dark:bg-amber-900/20 border border-amber-200 dark:border-amber-700 rounded-lg p-4">
      <div className="flex items-start space-x-3">
        <AlertTriangle className="w-5 h-5 text-amber-600 dark:text-amber-400 mt-0.5 flex-shrink-0" />
        <div className="flex-1">
          <h4 className="text-sm font-medium text-amber-800 dark:text-amber-200">
            Existing Routes Found
          </h4>
          <p className="text-sm text-amber-700 dark:text-amber-300 mt-1">
            {routes.length} cable route{routes.length > 1 ? "s" : ""} already exist between these nodes:
          </p>
          <ul className="mt-2 space-y-1 max-h-20 overflow-y-auto">
            {routes.map((route, index) => (
              <li
                key={index}
                className="text-sm text-amber-700 dark:text-amber-300 flex items-center space-x-2"
              >
                <span className="w-1.5 h-1.5 bg-amber-400 rounded-full flex-shrink-0" />
                <span className="font-mono truncate">{route}</span>
              </li>
            ))}
          </ul>
        </div>
      </div>
    </div>
  );
};

export default ExistingRoutesAlert;
```

<!-- path: components/ofc/OfcForm/LoadingOverlay.tsx -->
```typescript

// components/OfcForm/LoadingOverlay.tsx
import React from "react";
import { ButtonSpinner } from "@/components/common/ui/LoadingSpinner";

interface LoadingOverlayProps {
  message?: string;
}

const LoadingOverlay: React.FC<LoadingOverlayProps> = ({ 
  message = "Loading form data..." 
}) => (
  <div className="absolute inset-0 bg-white/80 dark:bg-gray-900/80 backdrop-blur-sm flex items-center justify-center z-10 rounded-lg">
    <div className="flex items-center space-x-3 bg-white dark:bg-gray-800 rounded-lg px-6 py-4 shadow-lg border dark:border-gray-700">
      <ButtonSpinner size="sm" />
      <span className="text-gray-600 dark:text-gray-300">
        {message}
      </span>
    </div>
  </div>
);

export default LoadingOverlay;
```

<!-- path: components/outdated/OutdatedBrowserModal.tsx -->
```typescript

// components/outdated/OutdatedBrowserModal.tsx
import React from 'react'

interface OutdatedBrowserModalProps {
  handleCloseModal: () => void;
}

const OutdatedBrowserModal: React.FC<OutdatedBrowserModalProps> = ({ handleCloseModal }) => {
  return (
    <>
    <div className="modal-overlay" id="browserModal">
          <div className="modal-content">
            <h2 className="modal-title"> Outdated or Unsupported Browser</h2>
            <p className="modal-text">
              Your browser is outdated or missing critical features. Some
              functionality may not work properly.
            </p>

            <div className="recommendation-box">
              <h3 className="recommendation-title">Recommended browsers:</h3>
              <ul className="browser-list">
                <li>Google Chrome 110+</li>
                <li>Mozilla Firefox 100+</li>
                <li>Microsoft Edge 110+</li>
                <li>Safari 15+</li>
              </ul>
            </div>

            <div className="button-container">
              <a
                href="https://www.google.com/chrome/"
                target="_blank"
                rel="noopener noreferrer"
                className="download-button chrome-button"
              >
                Download Chrome
              </a>
              <a
                href="https://www.mozilla.org/firefox/new/"
                target="_blank"
                rel="noopener noreferrer"
                className="download-button firefox-button"
              >
                Download Firefox
              </a>
              <button onClick={handleCloseModal} className="continue-button">
                Continue Anyway
              </button>
            </div>
          </div>
        </div>
    </>
  )
}

export default OutdatedBrowserModal
```

<!-- path: components/pwa/offline-status.tsx -->
```typescript
'use client'
 
import { useState, useEffect } from 'react'
import { MdWifiOff, MdWifi } from 'react-icons/md'
 
export default function OfflineStatus() {
  const [isOnline, setIsOnline] = useState(true)
  const [wasOffline, setWasOffline] = useState(false)
 
  useEffect(() => {
    const handleOnline = () => {
      setIsOnline(true)
      if (wasOffline) {
        // Show "Back online" message briefly
        setTimeout(() => setWasOffline(false), 3000)
      }
    }
 
    const handleOffline = () => {
      setIsOnline(false)
      setWasOffline(true)
    }
 
    window.addEventListener('online', handleOnline)
    window.addEventListener('offline', handleOffline)
 
    // Check initial status
    setIsOnline(navigator.onLine)
 
    return () => {
      window.removeEventListener('online', handleOnline)
      window.removeEventListener('offline', handleOffline)
    }
  }, [wasOffline])
 
  // Show offline message
  if (!isOnline) {
    return (
      <div className="fixed top-4 left-4 right-4 bg-red-500 text-white p-3 rounded-lg shadow-lg z-50">
        <div className="flex items-center space-x-2">
          <MdWifiOff className="h-5 w-5" />
          <span className="text-sm font-medium">You&apos;re offline</span>
        </div>
      </div>
    )
  }
 
  // Show "back online" message briefly
  if (isOnline && wasOffline) {
    return (
      <div className="fixed top-4 left-4 right-4 bg-green-500 text-white p-3 rounded-lg shadow-lg z-50">
        <div className="flex items-center space-x-2">
          <MdWifi className="h-5 w-5" />
          <span className="text-sm font-medium">Back online</span>
        </div>
      </div>
    )
  }
 
  return null
}
```

<!-- path: components/pwa/pwa-install-prompt.tsx -->
```typescript
'use client'
 
import { useState, useEffect } from 'react'
import { MdClose, MdDownload } from 'react-icons/md'
import { Button } from '../common/ui/Button'
 
interface BeforeInstallPromptEvent extends Event {
  readonly platforms: string[]
  readonly userChoice: Promise<{
    outcome: 'accepted' | 'dismissed'
    platform: string
  }>
  prompt(): Promise<void>
}
 
export default function PWAInstallPrompt() {
  const [deferredPrompt, setDeferredPrompt] = useState<BeforeInstallPromptEvent | null>(null)
  const [showInstallPrompt, setShowInstallPrompt] = useState(false)
  const [isInstalled, setIsInstalled] = useState(false)
 
  useEffect(() => {
    // Check if app is already installed
    if (window.matchMedia('(display-mode: standalone)').matches) {
      setIsInstalled(true)
      return
    }
 
    // Listen for beforeinstallprompt event
    const handler = (e: Event) => {
      e.preventDefault()
      setDeferredPrompt(e as BeforeInstallPromptEvent)
      setShowInstallPrompt(true)
    }
 
    window.addEventListener('beforeinstallprompt', handler)
 
    // Listen for app installed event
    window.addEventListener('appinstalled', () => {
      setIsInstalled(true)
      setShowInstallPrompt(false)
    })
 
    return () => {
      window.removeEventListener('beforeinstallprompt', handler)
    }
  }, [])
 
  const handleInstallClick = async () => {
    if (!deferredPrompt) return
 
    deferredPrompt.prompt()
    const { outcome } = await deferredPrompt.userChoice
    
    if (outcome === 'accepted') {
      setDeferredPrompt(null)
      setShowInstallPrompt(false)
    }
  }
 
  const handleDismiss = () => {
    setShowInstallPrompt(false)
    setDeferredPrompt(null)
  }
 
  if (isInstalled || !showInstallPrompt) return null
 
  return (
    <div className="fixed bottom-4 left-4 right-4 bg-white dark:bg-gray-800 border border-gray-200 dark:border-gray-700 rounded-lg shadow-lg p-4 z-50">
      <div className="flex items-center justify-between">
        <div className="flex items-center space-x-3">
          <MdDownload className="h-6 w-6 text-blue-600" />
          <div>
            <h3 className="font-semibold text-sm">Install App</h3>
            <p className="text-xs text-gray-600 dark:text-gray-400">
              Install this app for a better experience
            </p>
          </div>
        </div>
        <div className="flex items-center space-x-2">
          <Button
            size="sm"
            onClick={handleInstallClick}
            className="bg-blue-600 hover:bg-blue-700"
          >
            Install
          </Button>
          <Button
            size="sm"
            variant="ghost"
            onClick={handleDismiss}
          >
            <MdClose className="h-4 w-4" />
          </Button>
        </div>
      </div>
    </div>
  )
}
```

<!-- path: components/table/TableFilterPanel.tsx -->
```typescript
// @/components/table/TableFilterPanel.tsx
import React, { useState, useEffect } from "react";
import { Column } from "@/hooks/database/excel-queries/excel-helpers";
import { AuthTableOrViewName, Row, Filters } from "@/hooks/database";
import { useDebounce } from "@/hooks/useDebounce";
import { DEFAULTS } from "@/config/constants";

interface TableFilterPanelProps<T extends AuthTableOrViewName> {
  columns: Column<Row<T>>[];
  filters: Filters;
  setFilters: React.Dispatch<React.SetStateAction<Filters>>;
  showFilters: boolean;
  filterable: boolean;
}

const DebouncedInput = ({ value, onChange, placeholder, className }: { value: string; onChange: (value: string) => void; placeholder: string; className: string; }) => {
    const [internalValue, setInternalValue] = useState(value);
    const debouncedValue = useDebounce(internalValue, DEFAULTS.DEBOUNCE_DELAY);

    useEffect(() => {
        onChange(debouncedValue);
    }, [debouncedValue, onChange]);

    useEffect(() => {
        setInternalValue(value);
    }, [value]);

    return (
        <input
            type='text'
            value={internalValue}
            onChange={(e) => setInternalValue(e.target.value)}
            placeholder={placeholder}
            className={className}
        />
    );
};

export function TableFilterPanel<T extends AuthTableOrViewName>({
  columns,
  filters,
  setFilters,
  showFilters,
  filterable,
}: TableFilterPanelProps<T>) {
  if (!showFilters || !filterable) return null;

  return (
    <div className='mt-4 grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 gap-3 p-3 bg-gray-50 dark:bg-gray-700/50 rounded-lg'>
      {columns
        .filter((col) => col.filterable)
        .map((column) => (
          <div key={column.key} className='flex flex-col gap-1'>
            <label className='text-xs font-medium text-gray-700 dark:text-gray-300'>{column.title}</label>
            {column.filterOptions ? (
              <select
                value={String(filters[column.dataIndex] ?? '')}
                onChange={(e) => setFilters({ ...filters, [column.dataIndex]: e.target.value })}
                className='px-3 py-1.5 text-sm border border-gray-300 dark:border-gray-600 rounded bg-white dark:bg-gray-700 text-gray-900 dark:text-white'
              >
                <option value=''>All</option>
                {column.filterOptions.map((option) => (
                  <option key={String(option.value)} value={String(option.value)}>
                    {option.label}
                  </option>
                ))}
              </select>
            ) : (
              <DebouncedInput
                value={typeof filters[column.dataIndex] === 'string' ? (filters[column.dataIndex] as string) : ''}
                onChange={(value) => setFilters(prev => ({ ...prev, [column.dataIndex]: value }))}
                placeholder={`Filter ${column.title.toLowerCase()}...`}
                className='px-3 py-1.5 text-sm border border-gray-300 dark:border-gray-600 rounded bg-white dark:bg-gray-700 text-gray-900 dark:text-white placeholder-gray-500 dark:placeholder-gray-400'
              />
            )}
          </div>
        ))}
      {Object.keys(filters).length > 0 && (
        <div className='flex items-end'>
          <button 
            onClick={() => setFilters({})} 
            className='px-3 py-1.5 text-sm text-red-600 dark:text-red-400 hover:bg-red-50 dark:hover:bg-red-900/20 rounded transition-colors'
          >
            Clear All
          </button>
        </div>
      )}
    </div>
  );
}
```

<!-- path: components/table/action-helpers.ts -->
```typescript
import React from "react";
import {
  FiEdit2,
  FiTrash2,
  FiToggleLeft,
  FiToggleRight,
  FiEye,
} from "react-icons/fi";
import { RecordWithId } from "@/hooks/useCrudManager";

type ActionableRecord = RecordWithId & {
  status?: boolean | string | null; // Allow both boolean and string status
};

// Define a flexible TableAction type that can work with any record type
export interface TableAction<T = unknown> {
  key: string;
  label: string;
  icon?: React.ReactNode;
  getIcon?: (record: T) => React.ReactNode;
  onClick: (record: T, index?: number) => void;
  variant?: 'primary' | 'secondary' | 'danger' | 'success';
  disabled?: boolean | ((record: T) => boolean);
  hidden?: boolean | ((record: T) => boolean);
  // Additional properties that might be used by the DataTable
  [key: string]: unknown;
}

// Defines the shape of the handlers that a page component will provide.
// The helper is now generic over `V`, which represents the data type in the table row (e.g., UserProfileData)
interface StandardActionHandlers<V extends ActionableRecord> {
  onView?: (record: V) => void;
  onEdit?: (record: V) => void;
  onToggleStatus?: (record: V) => void;
  onDelete?: (record: V) => void;

  canEdit?: (record: V) => boolean;
  canDelete?: (record: V) => boolean;
}
/**
 * Creates a standardized array of TableAction objects for CRUD operations.
 * This ensures all tables have consistent icons, labels, variants, and behaviors.
 * @param handlers - An object containing the onClick handlers and optional logic for the actions.
 * @returns An array of TableAction<T> objects.
 */
export function createStandardActions<V extends ActionableRecord>({
  onView,
  onEdit,
  onToggleStatus,
  onDelete,
  canEdit = () => true, // By default, all actions are enabled
  canDelete = () => true,
}: StandardActionHandlers<V>): TableAction<V>[] {
  const actions: TableAction<V>[] = [];

  // Narrower type guard: only treat records with a boolean `status` as toggle-able
  const hasBooleanStatus = (record: V): record is V & { status: boolean } =>
    typeof (record as unknown as V)?.status === "boolean";

  // --- Toggle Status Actions (Activate/Deactivate) ---
  if (onToggleStatus) {
    actions.push({
      key: "toggleStatus",
      label: "Toggle Status",
      getIcon: (record: V) => 
        React.createElement(record.status ? FiToggleRight : FiToggleLeft, { 
          className: `w-4 h-4 ${record.status ? 'text-green-500' : 'text-gray-400'}`,
          size: 20
        }),
      variant: 'secondary',
      onClick: (record) => onToggleStatus(record),
      hidden: (record) => !hasBooleanStatus(record)
    });
  }

  // --- View Action ---
  if (onView) {
    actions.push({
      key: "view",
      label: "View Details",
      icon: React.createElement(FiEye),
      onClick: (record) => onView(record),
      variant: "secondary",
    });
  }

  // --- Edit Action ---
  if (onEdit) {
    actions.push({
      key: "edit",
      label: "Edit",
      icon: React.createElement(FiEdit2),
      onClick: (record) => onEdit(record),
      variant: "primary",
      disabled: (record) => !canEdit(record),
    });
  }

  // --- Delete Action ---
  if (onDelete) {
    actions.push({
      key: "delete",
      label: "Delete",
      icon: React.createElement(FiTrash2),
      onClick: (record) => onDelete(record),
      variant: "danger",
      disabled: (record) => !canDelete(record),
    });
  }

  return actions;
}

```

<!-- path: components/table/TableColumnSelector.tsx -->
```typescript
// @/components/table/TableColumnSelector.tsx
import React, { useEffect, useRef } from "react";
import { Column } from "@/hooks/database/excel-queries/excel-helpers";
import { AuthTableOrViewName, Row } from "@/hooks/database";

interface TableColumnSelectorProps<T extends AuthTableOrViewName> {
  columns: Column<Row<T>>[];
  visibleColumns: string[];
  setVisibleColumns: (columns: string[]) => void;
  showColumnSelector: boolean;
  setShowColumnSelector: (show: boolean) => void;
}

export function TableColumnSelector<T extends AuthTableOrViewName>({
  columns,
  visibleColumns,
  setVisibleColumns,
  showColumnSelector,
  setShowColumnSelector,
}: TableColumnSelectorProps<T>) {
  const containerRef = useRef<HTMLDivElement>(null);

  useEffect(() => {
    function handleClickOutside(e: MouseEvent) {
      const el = containerRef.current;
      if (el && !el.contains(e.target as Node)) {
        setShowColumnSelector(false);
      }
    }
    if (showColumnSelector) {
      document.addEventListener('mousedown', handleClickOutside, false);
    }
    return () => {
      document.removeEventListener('mousedown', handleClickOutside, false);
    };
  }, [showColumnSelector, setShowColumnSelector]);

  if (!showColumnSelector) return null;

  return (
    <>
      {/* Dropdown content; positioning handled by parent wrapper */}
      <div
        className='mt-2 w-64 bg-white dark:bg-gray-800 border border-gray-200 dark:border-gray-700 rounded-lg shadow-lg'
        onClick={(e) => e.stopPropagation()}
        onMouseDown={(e) => e.stopPropagation()}
        onPointerDown={(e) => e.stopPropagation()}
        ref={containerRef}
      >
        <div className='p-3 border-b border-gray-200 dark:border-gray-700'>
          <h4 className='font-medium text-gray-900 dark:text-white'>Show/Hide Columns</h4>
        </div>
        <div className='p-2 max-h-64 overflow-y-auto'>
          {columns.map((column) => (
            <label
              key={column.key}
              className='flex items-center gap-2 p-2 hover:bg-gray-50 dark:hover:bg-gray-700 rounded cursor-pointer'
              onMouseDown={(e) => e.preventDefault()}
              onClick={(e) => e.stopPropagation()}
            >
              <input
                type='checkbox'
                checked={visibleColumns.includes(column.key)}
                onClick={(e) => e.stopPropagation()}
                onChange={(e) => {
                  setVisibleColumns(e.target.checked ? [...visibleColumns, column.key] : visibleColumns.filter((k) => k !== column.key));
                }}
                className='rounded border-gray-300 text-blue-600 focus:ring-blue-500'
              />
              <span className='text-sm text-gray-700 dark:text-gray-300'>{column.title}</span>
            </label>
          ))}
        </div>
      </div>
      {/* Click outside handled via document listener */}
    </>
  );
}
```

<!-- path: components/table/TablePagination.tsx -->
```typescript
// @/components/table/TablePagination.tsx
import React from "react";
import { FiChevronLeft, FiChevronRight, FiChevronsLeft, FiChevronsRight } from "react-icons/fi";
import { TablePaginationProps } from "@/components/table/datatable-types";
import { DEFAULTS } from "@/config/constants";



export function TablePagination({ pagination, bordered }: TablePaginationProps) {
  if (!pagination || pagination.total <= 0) return null;

  return (
    <div className={`px-4 py-3 ${bordered ? "border-t border-gray-200 dark:border-gray-700" : ""} flex flex-col sm:flex-row items-center justify-between gap-4`}>
      <div className='flex items-center gap-4 text-sm text-gray-700 dark:text-gray-300'>
        <span>
          Showing {(pagination.current - 1) * pagination.pageSize + 1} to {Math.min(pagination.current * pagination.pageSize, pagination.total)} of {pagination.total} results
        </span>
        {pagination.showSizeChanger && (
          <select
            value={pagination.pageSize}
            onChange={(e) => pagination.onChange(1, Number(e.target.value))}
            className='px-2 py-1 border border-gray-300 dark:border-gray-600 rounded bg-white dark:bg-gray-700'
          >
            {(pagination.pageSizeOptions || DEFAULTS.PAGE_SIZE_OPTIONS).map((size) => (
              <option key={size} value={size}>
                {size} per page
              </option>
            ))}
          </select>
        )}
      </div>
      <div className='flex items-center gap-2'>
        <button
          onClick={() => pagination.onChange(1, pagination.pageSize)}
          disabled={pagination.current === 1}
          className='p-2 border border-gray-300 dark:border-gray-600 rounded hover:bg-gray-50 dark:hover:bg-gray-700 disabled:opacity-50 disabled:cursor-not-allowed'
        >
          <FiChevronsLeft size={16} />
        </button>
        <button
          onClick={() => pagination.onChange(pagination.current - 1, pagination.pageSize)}
          disabled={pagination.current === 1}
          className='p-2 border border-gray-300 dark:border-gray-600 rounded hover:bg-gray-50 dark:hover:bg-gray-700 disabled:opacity-50 disabled:cursor-not-allowed'
        >
          <FiChevronLeft size={16} />
        </button>
        <span className='px-4 py-2 text-sm text-gray-700 dark:text-gray-300'>
          Page {pagination.current} of {Math.ceil(pagination.total / pagination.pageSize)}
        </span>
        <button
          onClick={() => pagination.onChange(pagination.current + 1, pagination.pageSize)}
          disabled={pagination.current >= Math.ceil(pagination.total / pagination.pageSize)}
          className='p-2 border border-gray-300 dark:border-gray-600 rounded hover:bg-gray-50 dark:hover:bg-gray-700 disabled:opacity-50 disabled:cursor-not-allowed'
        >
          <FiChevronRight size={16} />
        </button>
        <button
          onClick={() => pagination.onChange(Math.ceil(pagination.total / pagination.pageSize), pagination.pageSize)}
          disabled={pagination.current >= Math.ceil(pagination.total / pagination.pageSize)}
          className='p-2 border border-gray-300 dark:border-gray-600 rounded hover:bg-gray-50 dark:hover:bg-gray-700 disabled:opacity-50 disabled:cursor-not-allowed'
        >
          <FiChevronsRight size={16} />
        </button>
      </div>
    </div>
  );
}
```

<!-- path: components/table/TableHeader.tsx -->
```typescript
// @/components/table/TableHeader.tsx
import React from "react";
import { FiArrowUp, FiArrowDown } from "react-icons/fi";
import { DataTableProps, SortConfig } from "@/components/table/datatable-types";
import { AuthTableOrViewName, Row } from "@/hooks/database";
import { Column } from "@/hooks/database/excel-queries/excel-helpers";
import { TruncateTooltip } from "@/components/common/TruncateTooltip";

interface TableHeaderProps<T extends AuthTableOrViewName>
  extends Pick<
    DataTableProps<T>,
    "columns" | "selectable" | "sortable" | "bordered" | "density" | "actions"
  > {
  visibleColumns: Column<Row<T>>[];
  hasActions: boolean;
  sortConfig: SortConfig<Row<T>> | null;
  onSort: (key: keyof Row<T> & string) => void;
  onSelectAll: (selected: boolean) => void;
  allSelected: boolean;
  hasData: boolean;
}


const densityClasses = {
  compact: "py-1 px-2 sm:px-3",
  default: "py-2 px-3 sm:py-3 sm:px-4",
  comfortable: "py-3 px-4 sm:py-4 sm:px-6",
};

function TableHeaderBase<
  T extends AuthTableOrViewName
>({
  visibleColumns,
  selectable,
  sortable,
  bordered,
  density,
  hasActions,
  sortConfig,
  onSort,
  onSelectAll,
  allSelected,
  hasData,
}: TableHeaderProps<T>) {
  return (
    <thead className="bg-gray-50 dark:bg-gray-700 sticky top-0 z-10">
      <tr>
        {selectable && (
          <th
            className={`w-12 px-2 sm:px-4 py-2 sm:py-3 text-left whitespace-nowrap overflow-hidden ${
              bordered
                ? "border-b border-r border-gray-200 dark:border-gray-700"
                : ""
            }`}
            style={{ width: 48, minWidth: 48, maxWidth: 48 }}
          >
            <input
              type="checkbox"
              checked={allSelected && hasData}
              onChange={(e) => onSelectAll(e.target.checked)}
              className="rounded border-gray-300 text-blue-600 focus:ring-blue-500"
              aria-label="Select all rows"
            />
          </th>
        )}
        {hasActions && (
          <th
            className={`w-32 text-center whitespace-nowrap overflow-hidden ${
              densityClasses[density ?? "default"]
            } text-xs font-medium text-gray-500 dark:text-gray-300 uppercase tracking-wider ${
              bordered ? "border-b border-gray-200 dark:border-gray-700" : ""
            }`}
            style={{ width: 128, minWidth: 128, maxWidth: 128 }}
          >
            <span className="hidden sm:inline">Actions</span>
            <span className="sm:hidden"></span>
          </th>
        )}
        {visibleColumns.map((column, index) => (
          <th
            key={column.key}
            className={`${
              densityClasses[density ?? "default"]
            } text-left text-xs font-medium text-gray-500 dark:text-gray-300 uppercase tracking-wider whitespace-nowrap ${
              column.sortable && sortable
                ? "cursor-pointer hover:bg-gray-100 dark:hover:bg-gray-600"
                : ""
            } ${
              column.align === "center"
                ? "text-center"
                : column.align === "right"
                ? "text-right"
                : ""
            } ${
              bordered
                ? `border-b ${
                    index < visibleColumns.length - 1 || hasActions
                      ? "border-r"
                      : ""
                  } border-gray-200 dark:border-gray-700`
                : ""
            }`}
            style={{
              width: column.width,
              minWidth: column.width ? undefined : "100px",
              maxWidth: "350px"
            }}
            onClick={() =>
              column.sortable &&
              sortable &&
              onSort(column.dataIndex as keyof Row<T> & string)
            }
          >
            <div className="flex items-center gap-1 sm:gap-2 min-w-0">
              <div className="min-w-0 flex-1">
                <TruncateTooltip
                  text={column.title}
                  id={`header-${column.key}`}
                  className="text-xs sm:text-sm"
                />
              </div>

              {column.sortable && sortable && (
                <div className="flex flex-col flex-shrink-0" aria-hidden="true">
                  <FiArrowUp
                    size={10}
                    className={`sm:size-3 ${
                      sortConfig?.key === column.dataIndex &&
                      sortConfig.direction === "asc"
                        ? "text-blue-600 dark:text-blue-400"
                        : "text-gray-300 dark:text-gray-600"
                    }`}
                  />
                  <FiArrowDown
                    size={10}
                    className={`-mt-0.5 sm:size-3 sm:-mt-1 ${
                      sortConfig?.key === column.dataIndex &&
                      sortConfig.direction === "desc"
                        ? "text-blue-600 dark:text-blue-400"
                        : "text-gray-300 dark:text-gray-600"
                    }`}
                  />
                </div>
              )}
            </div>
          </th>
        ))}
      </tr>
    </thead>
  );
}

export const TableHeader = React.memo(TableHeaderBase) as <T extends AuthTableOrViewName>(
  props: TableHeaderProps<T>
) => React.ReactElement;

```

<!-- path: components/table/TableBody.tsx -->
```typescript
// @/components/table/TableBody.tsx
import React, { useRef, useEffect } from "react";
import { FiEdit3, FiCheck, FiX } from "react-icons/fi";
import { DataTableProps, TableAction } from "@/components/table/datatable-types";
import { AuthTableOrViewName, Row } from "@/hooks/database";
import { Column } from "@/hooks/database/excel-queries/excel-helpers";
import { TruncateTooltip } from "@/components/common/TruncateTooltip";
import { TableSkeleton } from "@/components/common/ui/table/TableSkeleton";
 

// Define a type for your row that guarantees a unique identifier
type DataRow<T extends AuthTableOrViewName> = Row<T> & { id: string | number };

interface TableBodyProps<T extends AuthTableOrViewName> extends Pick<DataTableProps<T>, "columns" | "selectable" | "bordered" | "density" | "striped" | "hoverable" | "loading" | "emptyText"> {
  actions?: TableAction<T>[];
  processedData: DataRow<T>[];
  visibleColumns: Column<Row<T>>[];
  hasActions: boolean;
  selectedRows: DataRow<T>[];
  editingCell: { rowIndex: number; columnKey: string } | null;
  editValue: string;
  setEditValue: (value: string) => void;
  onRowSelect: (record: DataRow<T>, selected: boolean) => void;
  onCellEdit: (record: DataRow<T>, column: Column<Row<T>>, rowIndex: number) => void;
  saveCellEdit: () => void;
  cancelCellEdit: () => void;
  isLoading: boolean;
}

interface TableRowProps<T extends AuthTableOrViewName> extends Omit<TableBodyProps<T>, 'processedData' | 'loading' | 'emptyText'> {
    record: DataRow<T>;
    rowIndex: number;
    isSelected: boolean;
}

const densityClasses = { compact: "py-1 px-3", default: "py-3 px-4", comfortable: "py-4 px-6" };

// Base Table Row component (generic). We'll memoize it below with a type assertion to preserve generics.
function TableRowBase<T extends AuthTableOrViewName>({
    record,
    rowIndex,
    isSelected,
    visibleColumns,
    selectable,
    bordered,
    density,
    actions,
    hasActions,
    striped,
    hoverable,
    selectedRows,
    editingCell,
    editValue,
    setEditValue,
    onRowSelect,
    onCellEdit,
    saveCellEdit,
    cancelCellEdit,
    // isLoading,
}: TableRowProps<T>) {
    const editInputRef = useRef<HTMLInputElement>(null);

    useEffect(() => {
        if (editingCell && editingCell.rowIndex === rowIndex) {
            editInputRef.current?.focus();
            editInputRef.current?.select();
        }
    }, [editingCell, rowIndex]);

    // Loading UI is handled at the TableBodyBase level.
    
    return (
        <tr
          className={`${striped && rowIndex % 2 === 1 ? "bg-gray-50/50 dark:bg-gray-700/25" : ""} ${hoverable ? "hover:bg-gray-50 dark:hover:bg-gray-700/50" : ""} ${
            isSelected ? "bg-blue-50 dark:bg-blue-900/20" : ""
          } transition-colors`}>
          {selectable && (
            <td className={`w-12 px-4 py-3 whitespace-nowrap overflow-hidden ${bordered ? `${rowIndex < selectedRows.length - 1 ? "border-b" : ""} border-r border-gray-200 dark:border-gray-700` : ""}`}
                style={{ width: 48, minWidth: 48, maxWidth: 48 }}>
              <input type='checkbox' checked={isSelected} onChange={(e) => onRowSelect(record, e.target.checked)} className='rounded border-gray-300 text-blue-600 focus:ring-blue-500' aria-label={`Select row ${rowIndex + 1}`} />
            </td>
          )}
          {hasActions && (
            <td className={`w-32 ${densityClasses[density ?? "default"]} text-right whitespace-nowrap overflow-hidden ${bordered ? `${rowIndex < selectedRows.length - 1 ? "border-b" : ""} border-gray-200 dark:border-gray-700` : ""}`}
                style={{ width: 128, minWidth: 128, maxWidth: 128 }}>
              <div className='flex items-center justify-end gap-1'>
                {actions?.map((action) => {
                  const isHidden = typeof action.hidden === 'function' ? action.hidden(record) : action.hidden;
                  if (isHidden) return null;
                  
                  const isDisabled = typeof action.disabled === 'function' ? action.disabled(record) : action.disabled;
                  const variants = {
                    primary: "text-blue-600 hover:text-blue-700 dark:text-blue-400 dark:hover:text-blue-300",
                    secondary: "text-gray-600 hover:text-gray-700 dark:text-gray-400 dark:hover:text-gray-300",
                    danger: "text-red-600 hover:text-red-700 dark:text-red-400 dark:hover:text-red-300",
                    success: "text-green-600 hover:text-green-700 dark:text-green-400 dark:hover:text-green-300",
                  };
                  
                  const icon = action.getIcon ? action.getIcon(record) : action.icon;
                  const variant = action.variant || 'secondary';
                  
                  return (
                    <button
                      key={action.key}
                      onClick={() => !isDisabled && action.onClick(record, rowIndex)}
                      disabled={isDisabled}
                      className={`p-1 rounded transition-colors ${isDisabled ? "opacity-50 cursor-not-allowed" : variants[variant]}`}
                      title={action.label}
                    >
                      {icon}
                    </button>
                  );
                })}
              </div>
            </td>
          )}
          {visibleColumns.map((column, colIndex) => (
            <td
              key={column.key}
              className={`${densityClasses[density ?? "default"]} text-sm text-gray-900 dark:text-white whitespace-nowrap ${column.align === "center" ? "text-center" : column.align === "right" ? "text-right" : ""} ${
                column.editable ? "cursor-pointer hover:bg-gray-100 dark:hover:bg-gray-600/50" : ""
              } ${bordered ? `${rowIndex < selectedRows.length - 1 ? "border-b" : ""} ${colIndex < visibleColumns.length - 1 || hasActions ? "border-r" : ""} border-gray-200 dark:border-gray-700` : ""} overflow-hidden`}
              style={{
                width: column.width,
                minWidth: column.width ? undefined : "100px",
                maxWidth: "350px"
              }}
              onClick={() => column.editable && onCellEdit(record, column, rowIndex)}>
              {editingCell?.rowIndex === rowIndex && editingCell?.columnKey === column.key ? (
                <div className='flex items-center gap-2'>
                  <input
                    ref={editInputRef}
                    type='text'
                    value={editValue}
                    onChange={(e) => setEditValue(e.target.value)}
                    onKeyDown={(e) => {
                      if (e.key === "Enter") saveCellEdit();
                      if (e.key === "Escape") cancelCellEdit();
                    }}
                    className='flex-1 px-2 py-1 text-sm border border-blue-500 rounded bg-white dark:bg-gray-700 focus:outline-none focus:ring-2 focus:ring-blue-500'
                  />
                  <button onClick={saveCellEdit} className='p-1 text-green-600 hover:text-green-700' aria-label="Save cell edit">
                    <FiCheck size={14} />
                  </button>
                  <button onClick={cancelCellEdit} className='p-1 text-red-600 hover:text-red-700' aria-label="Cancel cell edit">
                    <FiX size={14} />
                  </button>
                </div>
              ) : (
                <div className='flex items-center gap-2 group min-w-0'>
                  {column.render ? (
                    column.render(
                      record[column.dataIndex as keyof DataRow<T>],
                      record,
                      rowIndex
                    )
                  ) : (
                    <TruncateTooltip
                      text={String(record[column.dataIndex as keyof DataRow<T>] ?? "")}
                      className="text-sm"
                    />
                  )}
                  {column.editable && <FiEdit3 size={12} className='opacity-0 group-hover:opacity-50 text-gray-400' />}
                </div>
              )}
            </td>
          ))}
        </tr>
    );
}

// Memoized Table Row component for performance optimization (preserve generics via assertion)
const MemoizedTableRow = React.memo(TableRowBase) as <T extends AuthTableOrViewName>(
  props: TableRowProps<T>
) => React.ReactElement;

// Base TableBody component (generic). We'll memoize with a type assertion below to preserve generics.
function TableBodyBase<T extends AuthTableOrViewName>({
  processedData,
  visibleColumns,
  loading,
  emptyText,
  ...rest
}: TableBodyProps<T>) {

  if (loading) {
    return (
      <tbody>
        <tr>
          <td colSpan={visibleColumns.length + (rest.selectable ? 1 : 0) + (rest.hasActions ? 1 : 0)} className={rest.bordered ? "border-b border-gray-200 dark:border-gray-700" : ""}>
            <div className='py-6'>
              <TableSkeleton
                rows={processedData.length || 5}
                columns={visibleColumns.length + (rest.selectable ? 1 : 0) + (rest.hasActions ? 1 : 0)}
                showHeader={false}
              />
            </div>
          </td>
        </tr>
      </tbody>
    );
  }

  if (processedData.length === 0) {
    return (
      <tbody>
        <tr>
          <td colSpan={visibleColumns.length + (rest.selectable ? 1 : 0) + (rest.hasActions ? 1 : 0)} className={rest.bordered ? "border-b border-gray-200 dark:border-gray-700" : ""}>
            <div className='text-center py-12'>
              <div className='text-gray-400 dark:text-gray-500 text-lg mb-2'></div>
              <p className='text-gray-500 dark:text-gray-400'>{emptyText}</p>
            </div>
          </td>
        </tr>
      </tbody>
    );
  }

  const selectedRowIds = new Set(rest.selectedRows.map(r => (r as DataRow<T>).id));

  return (
    <tbody className={`bg-white dark:bg-gray-800 ${rest.striped && !rest.bordered ? "divide-y divide-gray-200 dark:divide-gray-700" : ""}`}>
      {processedData.map((record, rowIndex) => (
        <MemoizedTableRow
            key={record.id} // IMPORTANT: Use a stable, unique ID
            record={record}
            rowIndex={rowIndex}
            visibleColumns={visibleColumns}
            isSelected={selectedRowIds.has(record.id)}
            {...rest}
        />
      ))}
    </tbody>
  );
}

export const TableBody = React.memo(TableBodyBase) as <T extends AuthTableOrViewName>(
  props: TableBodyProps<T>
) => React.ReactElement;
```

<!-- path: components/table/TableToolbar.tsx -->
```typescript
// @/components/table/TableToolbar.tsx
import React, { useState, useEffect, useRef } from "react";
import {
  FiSearch,
  FiFilter,
  FiDownload,
  FiRefreshCw,
  FiEye,
  FiChevronDown,
} from "react-icons/fi";
import { DataTableProps } from "@/components/table/datatable-types";
import { Column } from "@/hooks/database/excel-queries/excel-helpers";
import { Row } from "@/hooks/database";
import { TableColumnSelector } from "./TableColumnSelector";
import { AuthTableOrViewName } from "@/hooks/database";
import { useDebounce } from "@/hooks/useDebounce";
import { DEFAULTS } from "@/config/constants";

interface TableToolbarProps<T extends AuthTableOrViewName>
  extends Pick<
    DataTableProps<T>,
    | "searchable"
    | "filterable"
    | "exportable"
    | "refreshable"
    | "title"
    | "customToolbar"
    | "onRefresh"
    | "loading"
  > {
  searchQuery: string;
  setSearchQuery: (query: string) => void;
  onSearchChange?: (query: string) => void;
  showFilters: boolean;
  setShowFilters: (show: boolean) => void;
  showColumnSelector: boolean;
  setShowColumnSelector: (show: boolean) => void;
  showColumnsToggle?: boolean;
  columns: Column<Row<T>>[];
  visibleColumns: string[];
  setVisibleColumns: (cols: string[]) => void;
  onExport: () => void;
  isExporting: boolean;
}

export function TableToolbar<T extends AuthTableOrViewName>({
  title,
  searchable,
  filterable,
  exportable,
  refreshable,
  customToolbar,
  searchQuery,
  setSearchQuery,
  onSearchChange,
  showFilters,
  setShowFilters,
  showColumnSelector,
  setShowColumnSelector,
  showColumnsToggle,
  columns,
  visibleColumns,
  setVisibleColumns,
  onRefresh,
  onExport,
  loading,
  isExporting,
}: TableToolbarProps<T>) {
  const [internalSearchQuery, setInternalSearchQuery] = useState(searchQuery);
  const debouncedSearchQuery = useDebounce(internalSearchQuery, DEFAULTS.DEBOUNCE_DELAY);
  const setSearchQueryRef = useRef(setSearchQuery);
  const onSearchChangeRef = useRef(onSearchChange);

  // Keep refs in sync with latest props without retriggering the search effect
  useEffect(() => {
    setSearchQueryRef.current = setSearchQuery;
  }, [setSearchQuery]);
  useEffect(() => {
    onSearchChangeRef.current = onSearchChange;
  }, [onSearchChange]);

  // Only react to content changes, not function identity changes
  useEffect(() => {
    setSearchQueryRef.current(debouncedSearchQuery);
    onSearchChangeRef.current?.(debouncedSearchQuery);
  }, [debouncedSearchQuery]);

  useEffect(() => {
    setInternalSearchQuery(searchQuery);
  }, [searchQuery]);

  return (
    <div className="p-3 sm:p-4 border-b border-gray-200 dark:border-gray-700">
      {title && (
        <h3 className="text-lg sm:text-xl font-semibold text-gray-900 dark:text-white mb-3 sm:mb-4">
          {title}
        </h3>
      )}

      <div className="space-y-3 sm:space-y-0 sm:flex sm:justify-between sm:items-center">
        {customToolbar ? (
          <div className="w-full">{customToolbar}</div>
        ) : (
          <div className="flex flex-col gap-2 sm:gap-3 sm:flex-row sm:items-center sm:justify-between w-full">
            <div className="flex flex-col gap-2 sm:flex-row sm:items-center sm:flex-1 sm:gap-3">
              {searchable && (
                <div className="relative flex-1 sm:max-w-sm">
                  <FiSearch className="absolute left-3 top-1/2 transform -translate-y-1/2 text-gray-400 text-sm sm:text-base" />
                  <input
                    type="text"
                    placeholder="Search..."
                    value={internalSearchQuery}
                    onChange={(e) => setInternalSearchQuery(e.target.value)}
                    className="w-full pl-9 sm:pl-10 pr-4 py-2 text-sm sm:text-base border border-gray-300 dark:border-gray-600 rounded-lg bg-white dark:bg-gray-700 text-gray-900 dark:text-white placeholder-gray-500 dark:placeholder-gray-400 focus:ring-2 focus:ring-blue-500 focus:border-blue-500"
                  />
                </div>
              )}
              {filterable && (
                <button
                  onClick={() => setShowFilters(!showFilters)}
                  className={`flex items-center justify-center gap-2 px-3 py-2 text-sm sm:text-base border rounded-lg transition-colors min-w-0 ${
                    showFilters
                      ? "border-blue-300 bg-blue-50 text-blue-700 dark:border-blue-600 dark:bg-blue-900/50 dark:text-blue-300"
                      : "border-gray-300 dark:border-gray-600 hover:bg-gray-50 dark:hover:bg-gray-700 text-gray-700 dark:text-gray-300"
                  }`}
                >
                  <FiFilter size={14} className="sm:w-4 sm:h-4" />
                  <span className="hidden sm:inline">Filters</span>
                  <span className="sm:hidden">Filter</span>
                </button>
              )}
            </div>
          </div>
        )}

        {/* Right-side controls should be available even when customToolbar is used */}
        <div className="flex w-full sm:w-auto sm:flex-none items-center gap-2 sm:gap-3 justify-end mt-1 sm:mt-0 ml-auto">
          {(showColumnsToggle || (!customToolbar && true)) && (
            <div className="relative">
              <button
                onClick={() => setShowColumnSelector(!showColumnSelector)}
                className="flex items-center justify-center gap-2 px-3 py-2 text-sm border border-gray-300 dark:border-gray-600 rounded-lg hover:bg-gray-50 dark:hover:bg-gray-700 text-gray-700 dark:text-gray-300"
                aria-label="Show/Hide Columns"
              >
                <FiEye size={14} className="sm:w-4 sm:h-4" />
                <span className="hidden sm:inline">Columns</span>
                <FiChevronDown size={12} className="sm:w-3.5 sm:h-3.5" />
              </button>
              <div className="absolute right-0 top-full z-50">
                <TableColumnSelector
                  columns={columns.filter((c) => !c.hidden)}
                  visibleColumns={visibleColumns}
                  setVisibleColumns={setVisibleColumns}
                  showColumnSelector={showColumnSelector}
                  setShowColumnSelector={setShowColumnSelector}
                />
              </div>
            </div>
          )}

          {refreshable && onRefresh && (
            <button
              onClick={onRefresh}
              disabled={loading}
              className="p-2 border border-gray-300 dark:border-gray-600 rounded-lg hover:bg-gray-50 dark:hover:bg-gray-700 text-gray-700 dark:text-gray-300 disabled:opacity-50 flex-shrink-0"
              aria-label="Refresh data"
            >
              <FiRefreshCw
                size={14}
                className={`${loading ? "animate-spin" : ""}`}
              />
            </button>
          )}

          {exportable && (
            <button
              onClick={onExport}
              disabled={isExporting}
              className="flex items-center justify-center gap-2 px-3 py-2 text-sm bg-green-600 hover:bg-green-700 disabled:bg-green-400 text-white rounded-lg transition-colors"
            >
              <FiDownload size={14} />
              <span className="hidden sm:inline">
                {isExporting ? "Exporting..." : "Export"}
              </span>
            </button>
          )}
        </div>
      </div>
    </div>
  );
}

```

<!-- path: components/table/index.ts -->
```typescript
export * from "./DataTable";
export * from "./TableHeader";
export * from "./TableBody";
export * from "./TablePagination";
export * from "./TableColumnSelector";
export * from "./TableFilterPanel";
export * from "./TableToolbar";
export * from "./datatable-types";
```

<!-- path: components/table/DataTable.tsx -->
```typescript
// @/components/table/DataTable.tsx
import React, { useMemo, useCallback, useEffect, useReducer } from 'react';
import { createClient } from '@/utils/supabase/client';
import {
  useTableExcelDownload,
  useRPCExcelDownload,
} from '@/hooks/database/excel-queries';
import {
  TableToolbar,
  TableHeader,
  TableBody,
  TablePagination,
  TableFilterPanel,
} from './';
import { DataTableProps, SortConfig } from '@/components/table/datatable-types';
import { AuthTableOrViewName, Row, Filters } from '@/hooks/database';
import {
  Column,
  DownloadOptions,
  RPCConfig,
} from '@/hooks/database/excel-queries/excel-helpers';
import { cn } from '@/lib/utils';

// Define a type for your row that guarantees a unique identifier
type DataRow<T extends AuthTableOrViewName> = Row<T> & { id: string | number };

// --- State Management with useReducer ---

type TableState<T extends AuthTableOrViewName> = {
  searchQuery: string;
  sortConfig: SortConfig<Row<T>> | null;
  filters: Filters;
  selectedRows: DataRow<T>[];
  visibleColumns: string[];
  editingCell: { rowIndex: number; columnKey: string } | null;
  editValue: string;
  showColumnSelector: boolean;
  showFilters: boolean;
};

// Base action type that works with any row type
type BaseTableAction<R> =
  | { type: 'SET_SEARCH_QUERY'; payload: string }
  | { type: 'SET_SELECTED_ROWS'; payload: R[] }
  | { type: 'SET_VISIBLE_COLUMNS'; payload: string[] }
  | {
      type: 'START_EDIT_CELL';
      payload: { rowIndex: number; columnKey: string; value: string };
    }
  | { type: 'SET_EDIT_VALUE'; payload: string }
  | { type: 'CANCEL_EDIT' }
  | { type: 'TOGGLE_COLUMN_SELECTOR'; payload?: boolean }
  | { type: 'TOGGLE_FILTERS'; payload?: boolean };

// Table-specific action type that extends the base with table-aware actions
type TableAction<T extends AuthTableOrViewName> =
  | BaseTableAction<DataRow<T>>
  | { type: 'SET_SORT_CONFIG'; payload: SortConfig<Row<T>> | null }
  | { type: 'SET_FILTERS'; payload: Filters };

function tableReducer<T extends AuthTableOrViewName>(
  state: TableState<T>,
  action: TableAction<T> | BaseTableAction<DataRow<T>>
): TableState<T> {
  switch (action.type) {
    case 'SET_SEARCH_QUERY':
      return { ...state, searchQuery: action.payload };
    case 'SET_SORT_CONFIG':
      return { ...state, sortConfig: action.payload };
    case 'SET_FILTERS':
      return { ...state, filters: action.payload };
    case 'SET_SELECTED_ROWS':
      return { ...state, selectedRows: action.payload };
    case 'SET_VISIBLE_COLUMNS':
      return { ...state, visibleColumns: action.payload };
    case 'START_EDIT_CELL':
      return {
        ...state,
        editingCell: {
          rowIndex: action.payload.rowIndex,
          columnKey: action.payload.columnKey,
        },
        editValue: action.payload.value,
      };
    case 'SET_EDIT_VALUE':
      return { ...state, editValue: action.payload };
    case 'CANCEL_EDIT':
      return { ...state, editingCell: null, editValue: '' };
    case 'TOGGLE_COLUMN_SELECTOR':
      return {
        ...state,
        showColumnSelector: action.payload ?? !state.showColumnSelector,
      };
    case 'TOGGLE_FILTERS':
      return { ...state, showFilters: action.payload ?? !state.showFilters };
    default:
      return state;
  }
}

export function DataTable<T extends AuthTableOrViewName>({
  data = [],
  tableName,
  columns,
  loading = false,
  pagination,
  actions = [],
  searchable = true,
  serverSearch = false,
  filterable = true,
  sortable = true,
  selectable = false,
  exportable = false,
  refreshable = false,
  density = 'default',
  bordered = true,
  striped = true,
  hoverable = true,
  className = '',
  emptyText = 'No data available',
  title,
  onRefresh,
  onExport,
  onRowSelect,
  onCellEdit,
  customToolbar,
  showColumnSelector: showColumnSelectorProp,
  showColumnsToggle,
  exportOptions,
  onSearchChange,
}: DataTableProps<T>): React.ReactElement {
  const initialState: TableState<T> = {
    searchQuery: '',
    sortConfig: null,
    filters: {},
    selectedRows: [],
    visibleColumns: columns.map((col) => col.key),
    editingCell: null,
    editValue: '',
    showColumnSelector: !!showColumnSelectorProp,
    showFilters: false,
  };

  const [state, dispatch] = useReducer(tableReducer, initialState);
  const {
    searchQuery,
    sortConfig,
    filters,
    selectedRows,
    visibleColumns,
    editingCell,
    editValue,
    showColumnSelector,
    showFilters,
  } = state;

  const supabase = createClient();

  useEffect(() => {
    if (typeof showColumnSelectorProp === 'boolean') {
      dispatch({
        type: 'TOGGLE_COLUMN_SELECTOR',
        payload: showColumnSelectorProp,
      });
    }
  }, [showColumnSelectorProp]);

  useEffect(() => {
    if (!filterable) {
      dispatch({ type: 'SET_FILTERS', payload: {} });
    }
  }, [filterable]);

  // (Excel download hooks remain the same)
  const tableExcelDownload = useTableExcelDownload<T>(supabase, tableName, {
    showToasts: true,
  });
  const rpcExcelDownload = useRPCExcelDownload<T>(supabase, {
    showToasts: true,
  });

  const processedData = useMemo(() => {
    let filteredData = [...data] as DataRow<T>[];

    if (searchQuery && searchable && !serverSearch) {
      const q = searchQuery.toLowerCase();
      filteredData = filteredData.filter((item) =>
        columns.some((column) => {
          if (column.searchable === false) return false;
          const value = item[column.dataIndex as keyof typeof item];
          return String(value ?? '')
            .toLowerCase()
            .includes(q);
        })
      );
    }

    if (filterable && Object.keys(filters).length > 0) {
      Object.entries(filters).forEach(([key, value]) => {
        if (value !== undefined && value !== '') {
          filteredData = filteredData.filter((item) =>
            String(item[key as keyof DataRow<T>] ?? '')
              .toLowerCase()
              .includes(String(value).toLowerCase())
          );
        }
      });
    }

    if (sortConfig && sortable) {
      filteredData.sort((a, b) => {
        const aValue = a[sortConfig.key];
        const bValue = b[sortConfig.key];
        if (aValue === null || aValue === undefined) return 1;
        if (bValue === null || bValue === undefined) return -1;
        if (typeof aValue === 'string' && typeof bValue === 'string') {
          return sortConfig.direction === 'asc'
            ? aValue.localeCompare(bValue)
            : bValue.localeCompare(aValue);
        }
        return sortConfig.direction === 'asc'
          ? aValue > bValue
            ? 1
            : -1
          : aValue < bValue
          ? 1
          : -1;
      });
    }

    return filteredData;
  }, [
    data,
    searchQuery,
    filters,
    sortConfig,
    columns,
    searchable,
    sortable,
    filterable,
    serverSearch,
  ]);

  const handleSort = useCallback(
    (columnKey: keyof Row<T> & string) => {
      if (!sortable) return;
      const direction =
        sortConfig?.key === columnKey && sortConfig.direction === 'asc'
          ? 'desc'
          : 'asc';
      if (sortConfig?.key === columnKey && sortConfig.direction === 'desc') {
        dispatch({ type: 'SET_SORT_CONFIG', payload: null });
      } else {
        dispatch({
          type: 'SET_SORT_CONFIG',
          payload: { key: columnKey, direction },
        });
      }
    },
    [sortable, sortConfig]
  );

  const handleRowSelect = useCallback(
    (record: DataRow<T>, selected: boolean) => {
      const newSelection = selected
        ? [...selectedRows, record]
        : selectedRows.filter((row) => row.id !== record.id);
      dispatch({ type: 'SET_SELECTED_ROWS', payload: newSelection });
      onRowSelect?.(newSelection);
    },
    [selectedRows, onRowSelect]
  );

  const handleSelectAll = useCallback(
    (selected: boolean) => {
      const newSelection = selected ? [...processedData] : [];
      dispatch({ type: 'SET_SELECTED_ROWS', payload: newSelection });
      onRowSelect?.(newSelection);
    },
    [processedData, onRowSelect]
  );

  const handleCellEdit = useCallback(
    (record: DataRow<T>, column: Column<Row<T>>, rowIndex: number) => {
      if (!column.editable) return;
      dispatch({
        type: 'START_EDIT_CELL',
        payload: {
          rowIndex,
          columnKey: column.key,
          value: String(record[column.dataIndex as keyof DataRow<T>] ?? ''),
        },
      });
    },
    []
  );

  const saveCellEdit = useCallback(() => {
    if (!editingCell) return;
    const record = processedData[editingCell.rowIndex];
    const column = columns.find((col) => col.key === editingCell.columnKey);
    if (column && onCellEdit) {
      onCellEdit(record, column, editValue);
    }
    dispatch({ type: 'CANCEL_EDIT' });
  }, [editingCell, processedData, columns, onCellEdit, editValue]);

  const cancelCellEdit = useCallback(
    () => dispatch({ type: 'CANCEL_EDIT' }),
    []
  );

  const visibleColumnsData = useMemo<Column<Row<T>>[]>(
    () =>
      columns.filter((col) => visibleColumns.includes(col.key) && !col.hidden),
    [columns, visibleColumns]
  );

  const setSearchQueryCb = useCallback((query: string) => {
    dispatch({ type: 'SET_SEARCH_QUERY', payload: query });
  }, []);

  const handleExport = useCallback(async () => {
    // 1) If a custom export handler is provided by the parent, use it
    if (onExport) {
      await onExport(
        processedData as Row<T>[],
        visibleColumnsData as Column<Row<T>>[]
      );
      return;
    }

    // 2) Build export options: prefer explicit options, else use current visible columns and filters
    const columnsToExport = (exportOptions?.columns ??
      visibleColumnsData) as Column<Row<T>>[];
    const mergedFilters = exportOptions?.includeFilters
      ? { ...filters, ...(exportOptions?.filters ?? {}) }
      : exportOptions?.filters;

    const baseOptions: Omit<DownloadOptions<T>, 'rpcConfig'> = {
      fileName: exportOptions?.fileName,
      sheetName: exportOptions?.sheetName,
      maxRows: exportOptions?.maxRows,
      customStyles: exportOptions?.customStyles,
      columns: columnsToExport,
      filters: mergedFilters,
    };

    try {
      // 3) Use RPC-based download if rpcConfig is provided; otherwise, table/view download
      if (exportOptions?.rpcConfig) {
        const rpcOptions: DownloadOptions<T> & { rpcConfig: RPCConfig } = {
          ...baseOptions,
          rpcConfig: exportOptions.rpcConfig,
        };
        await rpcExcelDownload.mutateAsync(rpcOptions);
      } else {
        await tableExcelDownload.mutateAsync(baseOptions);
      }
    } catch (err) {
      // 4) Optional CSV fallback using currently processed rows
      if (exportOptions?.fallbackToCsv) {
        try {
          const headers = columnsToExport.map((c) => c.title).join(',');
          const keys = columnsToExport.map(
            (c) => c.dataIndex as keyof Row<T> & string
          );
          const rows = (processedData as Row<T>[])?.map((r) =>
            keys
              .map((k) => {
                const v = (r as Row<T>)[k] as unknown;
                if (v === null || v === undefined) return '';
                const s = String(v).replace(/"/g, '""');
                return `"${s}"`;
              })
              .join(',')
          );
          const csv = [headers, ...(rows || [])].join('\n');
          const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
          const link = document.createElement('a');
          const csvName =
            (exportOptions?.fileName?.replace(/\.xlsx$/i, '') || 'export') +
            '.csv';
          link.href = URL.createObjectURL(blob);
          link.download = csvName;
          document.body.appendChild(link);
          link.click();
          document.body.removeChild(link);
          URL.revokeObjectURL(link.href);
        } catch {
          // If CSV fallback also fails, rethrow original error
          throw err;
        }
      } else {
        throw err;
      }
    }
  }, [
    onExport,
    processedData,
    visibleColumnsData,
    exportOptions,
    filters,
    tableExcelDownload,
    rpcExcelDownload,
  ]);
  const hasActions = actions.length > 0;
  const isExporting =
    tableExcelDownload.isPending || rpcExcelDownload.isPending;

  return (
    <div 
      className={cn(
        "flex flex-col bg-white dark:bg-gray-800 rounded-lg max-h-[calc(100vh-250px)]", 
        bordered ? "border border-gray-200 dark:border-gray-700" : "shadow-md", 
        className
      )}
    >
      {/* Section 1: Toolbar and Filters (Non-scrolling) */}
      <div className="flex-shrink-0">
      <TableToolbar
        title={title}
        searchable={searchable}
        filterable={filterable}
        exportable={exportable}
        refreshable={refreshable}
        customToolbar={customToolbar}
        searchQuery={searchQuery}
        setSearchQuery={setSearchQueryCb}
        onSearchChange={onSearchChange}
        showFilters={showFilters}
        setShowFilters={() => dispatch({ type: 'TOGGLE_FILTERS' })}
        showColumnSelector={showColumnSelector}
        setShowColumnSelector={(show) =>
          dispatch({ type: 'TOGGLE_COLUMN_SELECTOR', payload: show })
        }
        showColumnsToggle={showColumnsToggle}
        columns={columns}
        visibleColumns={visibleColumns}
        setVisibleColumns={(cols: string[]) =>
          dispatch({ type: 'SET_VISIBLE_COLUMNS', payload: cols })
        }
        onRefresh={onRefresh}
        onExport={handleExport}
        loading={loading}
        isExporting={isExporting}
      />

      <TableFilterPanel
        columns={columns}
        filters={filters}
        setFilters={(f) =>
          dispatch({
            type: 'SET_FILTERS',
            payload:
              typeof f === 'function'
                ? (f as (prev: Filters) => Filters)(filters)
                : f,
          })
        }
        showFilters={showFilters}
        filterable={filterable}
      />
      </div>

      {/* Section 2: Scrollable Table Area */}
      <div className='flex-1 w-full overflow-auto min-h-0'>
        <table className={`min-w-full  w-full table-auto sm:table-fixed ${bordered ? "border-separate border-spacing-0" : ""}`}>
            <TableHeader
              columns={columns}
              visibleColumns={visibleColumnsData}
              selectable={selectable}
              sortable={sortable}
              bordered={bordered}
              density={density}
              actions={actions}
              hasActions={hasActions}
              sortConfig={sortConfig}
              onSort={handleSort}
              onSelectAll={handleSelectAll}
              allSelected={
                processedData.length > 0 &&
                selectedRows.length === processedData.length
              }
              hasData={processedData.length > 0}
            />
            <TableBody
              columns={columns}
              processedData={processedData}
              visibleColumns={visibleColumnsData}
              selectable={selectable}
              bordered={bordered}
              density={density}
              actions={actions}
              hasActions={hasActions}
              striped={striped}
              hoverable={hoverable}
              loading={loading}
              emptyText={emptyText}
              selectedRows={selectedRows}
              editingCell={editingCell}
              editValue={editValue}
              setEditValue={(value) =>
                dispatch({ type: 'SET_EDIT_VALUE', payload: value })
              }
              onRowSelect={handleRowSelect}
              onCellEdit={handleCellEdit}
              saveCellEdit={saveCellEdit}
              cancelCellEdit={cancelCellEdit}
              isLoading={loading}
            />
          </table>
      </div>

      {/* Section 3: Pagination (Non-scrolling) */}
      <div className="flex-shrink-0">
        <TablePagination pagination={pagination} bordered={bordered} />
      </div>
    </div>
  );
}

```

<!-- path: components/table/datatable-types.ts -->
```typescript
// @/components/table/types.ts
import { AuthTableOrViewName, Row, Filters } from "@/hooks/database";
import { Column, RPCConfig, ExcelStyles } from "@/hooks/database/excel-queries/excel-helpers";

export interface TableAction<T extends AuthTableOrViewName> {
  key: string;
  label: string;
  icon?: React.ReactNode;
  getIcon?: (record: Row<T>) => React.ReactNode;
  onClick: (record: Row<T>, index?: number) => void;
  variant?: "primary" | "secondary" | "danger" | "success";
  disabled?: boolean | ((record: Row<T>) => boolean);
  hidden?: boolean | ((record: Row<T>) => boolean);
  [key: string]: unknown;
}

export interface DownloadOptions<T extends AuthTableOrViewName> {
  fileName?: string;
  filters?: Filters;
  columns?: Column<Row<T>>[];
  sheetName?: string;
  maxRows?: number;
  customStyles?: ExcelStyles;
  rpcConfig?: RPCConfig;
}

export interface DataTableProps<T extends AuthTableOrViewName> {
  data: Row<T>[];
  tableName: T;
  columns: Column<Row<T>>[];
  loading?: boolean;
  showColumnSelector?: boolean;
  // Controls visibility of the Columns toggle button in the toolbar
  showColumnsToggle?: boolean;
  pagination?: {
    current: number;
    pageSize: number;
    total: number;
    showSizeChanger?: boolean;
    pageSizeOptions?: number[];
    onChange: (page: number, pageSize: number) => void;
  };
  actions?: TableAction<T>[];
  searchable?: boolean;
  // If true, DataTable will not perform client-side search and will delegate to parent via onSearchChange
  serverSearch?: boolean;
  filterable?: boolean;
  sortable?: boolean;
  selectable?: boolean;
  exportable?: boolean;
  refreshable?: boolean;
  density?: "compact" | "default" | "comfortable";
  bordered?: boolean;
  striped?: boolean;
  hoverable?: boolean;
  className?: string;
  emptyText?: string;
  title?: string;
  onRefresh?: () => void;
  // Called when the search query changes; useful for server-side search or fetching more rows
  onSearchChange?: (query: string) => void;
  onExport?: (data: Row<T>[], columns: Column<Row<T>>[]) => void | Promise<void>;
  onRowSelect?: (selectedRows: Row<T>[]) => void;
  onCellEdit?: (record: Row<T>, column: Column<Row<T>>, newValue: string) => void;
  customToolbar?: React.ReactNode;
  exportOptions?: {
    fileName?: string;
    sheetName?: string;
    includeFilters?: boolean;
    maxRows?: number;
    rpcConfig?: RPCConfig;
    fallbackToCsv?: boolean;
  } & Omit<DownloadOptions<T>, "rpcConfig">;
}

export type SortDirection = "asc" | "desc";
export interface SortConfig<T> {
  key: keyof T & string;
  direction: SortDirection;
}

export type TablePaginationProps = Pick<DataTableProps<AuthTableOrViewName>, 'pagination' | 'bordered'>;

```

<!-- path: components/bsnl/NewAllocationModal.tsx -->
```typescript
"use client"

import React, { useState, useEffect, useMemo } from 'react';
import { X, Route, GitBranch, Plus, Trash2, Network, Shield, ChevronsRight, CornerDownRight, Circle } from 'lucide-react';

// --- 1. TYPE DEFINITIONS ---
interface FiberNode { id: string; name: string; type: 'OFC' | 'JC' | 'END_POINT'; }
interface OFCCable { id: string; name: string; startNode: string; endNode: string; fiberCount: number; fiberAllocations: FiberAllocation[]; }
interface FiberAllocation { fiberNumber: number; systemId: string; status: 'active' | 'standby'; }
interface FiberRoutePath { nodeId: string; ofcId: string; fiberNumber: number; action: 'terminate' | 'pass_through' | 'tap'; }
interface NetworkSystem { id: string; name: string; startNode: string; }
type AllocationTopology = 'p2p-unprotected' | 'p2p-protected' | 'ring' | 'tap-spur';

// --- 2. COMPREHENSIVE MOCK DATA ---
export const mockData = {
  nodes: [
    { id: 'POP_A', name: 'POP A (Central Office)', type: 'OFC' },
    { id: 'POP_B', name: 'POP B (Regional Hub)', type: 'OFC' },
    { id: 'POP_C', name: 'POP C (City Exchange)', type: 'OFC' },
    { id: 'POP_D', name: 'POP D (North Sub-station)', type: 'OFC' },
    { id: 'CUST_XYZ', name: 'Customer XYZ Corp', type: 'END_POINT' },
    { id: 'CUST_ABC', name: 'Customer ABC Inc', type: 'END_POINT' },
  ] as FiberNode[],
  ofcCables: [
    { id: 'ofc_ab_west', name: 'OFC A-B (West Route)', startNode: 'POP_A', endNode: 'POP_B', fiberCount: 48, fiberAllocations: [{ fiberNumber: 1, systemId: 'SYS_001', status: 'active' }, { fiberNumber: 2, systemId: 'SYS_001', status: 'active' }] },
    { id: 'ofc_ab_east', name: 'OFC A-B (East Route - Diverse)', startNode: 'POP_A', endNode: 'POP_B', fiberCount: 24, fiberAllocations: [] },
    { id: 'ofc_bc', name: 'OFC B-C', startNode: 'POP_B', endNode: 'POP_C', fiberCount: 24, fiberAllocations: [] },
    { id: 'ofc_cd', name: 'OFC C-D', startNode: 'POP_C', endNode: 'POP_D', fiberCount: 12, fiberAllocations: [] },
    { id: 'ofc_da', name: 'OFC D-A', startNode: 'POP_D', endNode: 'POP_A', fiberCount: 12, fiberAllocations: [] },
    { id: 'ofc_b_cust_xyz', name: 'Spur to Customer XYZ', startNode: 'POP_B', endNode: 'CUST_XYZ', fiberCount: 12, fiberAllocations: [] },
    { id: 'ofc_b_cust_abc', name: 'Spur to Customer ABC', startNode: 'POP_B', endNode: 'CUST_ABC', fiberCount: 12, fiberAllocations: [] },
  ] as OFCCable[],
  systems: [
    { id: 'sys_101', name: 'P2P_Leased_Line_Unprotected', startNode: 'POP_A' },
    { id: 'sys_102', name: 'P2P_Backbone_Protected', startNode: 'POP_A' },
    { id: 'sys_103', name: 'METRO_RING_01', startNode: 'POP_A' },
    { id: 'sys_104', name: 'ACCESS_NETWORK_B', startNode: 'POP_A' },
  ] as NetworkSystem[],
};

// --- 3. REUSABLE PATH BUILDER COMPONENT ---
interface PathBuilderProps {
  path: FiberRoutePath[];
  onPathChange: (newPath: FiberRoutePath[]) => void;
  startNodeId: string;
  nodes: FiberNode[];
  cables: OFCCable[];
  allAllocatedFibers: Set<string>; // Format: "ofcId-fiberNumber"
}

function PathBuilder({ path, onPathChange, startNodeId, nodes, cables, allAllocatedFibers }: PathBuilderProps) {
  const [nextCableId, setNextCableId] = useState('');
  const [nextFiber1, setNextFiber1] = useState('');
  const [nextFiber2, setNextFiber2] = useState('');
  const [nextAction, setNextAction] = useState<'pass_through' | 'terminate'>('pass_through');

  const lastNodeIdInPath = useMemo(() => {
    if (path.length === 0) return startNodeId;
    const lastStep = path[path.length - 1];
    const lastCable = cables.find(c => c.id === lastStep.ofcId);
    return lastCable?.startNode === lastStep.nodeId ? lastCable.endNode : lastCable.startNode;
  }, [path, startNodeId, cables]);

  const availableCables = useMemo(() => cables.filter(c => c.startNode === lastNodeIdInPath || c.endNode === lastNodeIdInPath), [cables, lastNodeIdInPath]);

  const availableFibers = useMemo(() => {
    const cable = cables.find(c => c.id === nextCableId);
    if (!cable) return [];
    const available = [];
    for (let i = 1; i <= cable.fiberCount; i++) {
      if (!allAllocatedFibers.has(`${cable.id}-${i}`)) available.push(i);
    }
    return available;
  }, [cables, nextCableId, allAllocatedFibers]);

  const handleAddStep = () => {
    if (!nextCableId || !nextFiber1 || !nextFiber2 || !lastNodeIdInPath || nextFiber1 === nextFiber2) return;
    const newSteps = [
      { nodeId: lastNodeIdInPath, ofcId: nextCableId, fiberNumber: parseInt(nextFiber1), action: nextAction },
      { nodeId: lastNodeIdInPath, ofcId: nextCableId, fiberNumber: parseInt(nextFiber2), action: nextAction }
    ];
    onPathChange([...path, ...newSteps]);
    setNextCableId(''); setNextFiber1(''); setNextFiber2(''); setNextAction('pass_through');
  };

  const handleRemoveLastStep = () => onPathChange(path.slice(0, -2));
  const getNodeName = (id: string) => nodes.find(n => n.id === id)?.name || 'Unknown';

  return (
    <div className="space-y-4">
      {path.filter((_, i) => i % 2 === 0).map((step, pairIndex) => {
        const fiber2 = path[pairIndex * 2 + 1];
        const cable = cables.find(c => c.id === step.ofcId);
        return (<div key={pairIndex} className="flex items-center bg-gray-50 p-2 rounded"><div className="w-6 h-6 flex items-center justify-center bg-blue-100 text-blue-700 rounded-full text-xs font-bold mr-3">{pairIndex + 1}</div><div className="flex-1 text-sm"><span className="font-medium">{getNodeName(step.nodeId)}</span><span className="text-gray-500 mx-1"></span><span>{cable?.name}</span><span className="font-bold text-blue-600 ml-2">F{step.fiberNumber}/{fiber2.fiberNumber}</span><span className="ml-3 px-2 py-0.5 text-xs bg-gray-200 rounded-full">{step.action.replace('_', ' ')}</span></div>{pairIndex === Math.floor(path.length / 2) - 1 && (<button onClick={handleRemoveLastStep} className="p-1 text-gray-400 hover:text-red-500"><Trash2 className="h-4 w-4" /></button>)}</div>)
      })}
      {path.length === 0 && <p className="text-sm text-gray-500 text-center py-2">Path starts at <span className='font-semibold'>{getNodeName(startNodeId)}</span>.</p>}
      <div className="border-t pt-4">
        <p className="text-sm font-medium text-gray-600 mb-2">Add Step (from {getNodeName(lastNodeIdInPath!)})</p>
        <div className="grid grid-cols-1 md:grid-cols-5 gap-4 items-end"><div className="md:col-span-2"><label className="block text-xs font-medium text-gray-700 mb-1">OFC Cable</label><select value={nextCableId} onChange={e => { setNextCableId(e.target.value); setNextFiber1(''); setNextFiber2(''); }} className="w-full border border-gray-300 rounded-md p-2 text-sm"><option value="" disabled>Select cable...</option>{availableCables.map(c => <option key={c.id} value={c.id}>{c.name}</option>)}</select></div><div><label className="block text-xs font-medium text-gray-700 mb-1">Fiber A (Tx)</label><select value={nextFiber1} onChange={e => setNextFiber1(e.target.value)} className="w-full border border-gray-300 rounded-md p-2 text-sm" disabled={!nextCableId}><option value="" disabled>...</option>{availableFibers.filter(f => f.toString() !== nextFiber2).map(f => <option key={f} value={f}>{f}</option>)}</select></div><div><label className="block text-xs font-medium text-gray-700 mb-1">Fiber B (Rx)</label><select value={nextFiber2} onChange={e => setNextFiber2(e.target.value)} className="w-full border border-gray-300 rounded-md p-2 text-sm" disabled={!nextCableId}><option value="" disabled>...</option>{availableFibers.filter(f => f.toString() !== nextFiber1).map(f => <option key={f} value={f}>{f}</option>)}</select></div><div><label className="block text-xs font-medium text-gray-700 mb-1">Action</label><select value={nextAction} onChange={e => setNextAction(e.target.value as any)} className="w-full border border-gray-300 rounded-md p-2 text-sm"><option value="pass_through">Pass Through</option><option value="terminate">Terminate</option></select></div></div><button onClick={handleAddStep} className="mt-4 w-full flex items-center justify-center px-4 py-2 border border-dashed border-gray-300 text-sm font-medium rounded-md text-gray-700 hover:bg-gray-50"><Plus className="h-4 w-4 mr-2" />Add Fiber Pair</button>
      </div>
    </div>
  );
}

// --- 4. THE MULTI-TOPOLOGY WIZARD MODAL ---
interface AdvancedAllocationModalProps { isOpen: boolean; onClose: () => void; onSave: (data: any) => void; systems: NetworkSystem[]; nodes: FiberNode[]; cables: OFCCable[]; }

function AdvancedAllocationModal({ isOpen, onClose, onSave, systems, nodes, cables }: AdvancedAllocationModalProps) {
  const [step, setStep] = useState(1);
  const [selectedSystemId, setSelectedSystemId] = useState('');
  const [topology, setTopology] = useState<AllocationTopology>('p2p-unprotected');
  const [paths, setPaths] = useState<{ working: FiberRoutePath[], protection: FiberRoutePath[], taps: { [key: string]: FiberRoutePath[] } }>({ working: [], protection: [], taps: {} });
  const [error, setError] = useState<string | null>(null);

  const selectedSystem = useMemo(() => systems.find(s => s.id === selectedSystemId), [systems, selectedSystemId]);

  const allAllocatedFibers = useMemo(() => {
    const allocated = new Set<string>();
    cables.forEach(c => c.fiberAllocations.forEach(a => allocated.add(`${c.id}-${a.fiberNumber}`)));
    paths.working.forEach(p => allocated.add(`${p.ofcId}-${p.fiberNumber}`));
    paths.protection.forEach(p => allocated.add(`${p.ofcId}-${p.fiberNumber}`));
    Object.values(paths.taps).flat().forEach(p => allocated.add(`${p.ofcId}-${p.fiberNumber}`));
    return allocated;
  }, [cables, paths]);

  const resetState = () => {
    setStep(1); setSelectedSystemId(''); setTopology('p2p-unprotected'); setPaths({ working: [], protection: [], taps: {} }); setError(null);
  };

  const handleClose = () => { resetState(); onClose(); };

  const handleSave = () => {
    setError(null);
    // Add topology-specific validation
    if (topology.startsWith('p2p') && paths.working[paths.working.length - 1]?.action !== 'terminate') { setError("Working path must terminate."); return; }
    if (topology === 'p2p-protected' && paths.protection[paths.protection.length - 1]?.action !== 'terminate') { setError("Protection path must terminate."); return; }
    // More validation can be added for ring, tap, etc.
    onSave({ systemId: selectedSystemId, topology, paths });
    handleClose();
  };

  if (!isOpen) return null;
  const renderStep = () => {
    switch (step) {
      case 1: // System and Topology Selection
        return (<div className="space-y-6"><h3 className="text-lg font-medium text-gray-800">1. Basic Setup</h3><div className="grid grid-cols-1 md:grid-cols-2 gap-6"><div><label className="block text-sm font-medium text-gray-700 mb-1">Select System</label><select value={selectedSystemId} onChange={e => setSelectedSystemId(e.target.value)} className="w-full border border-gray-300 rounded-md p-2"><option value="" disabled>Choose a system...</option>{systems.map(s => <option key={s.id} value={s.id}>{s.name}</option>)}</select></div><div><label className="block text-sm font-medium text-gray-700 mb-1">Select Allocation Topology</label><select value={topology} onChange={e => setTopology(e.target.value as any)} className="w-full border border-gray-300 rounded-md p-2"><option value="p2p-unprotected">Point-to-Point (Unprotected)</option><option value="p2p-protected">Point-to-Point (Protected)</option><option value="ring">Protected Ring</option><option value="tap-spur">Tap / Spur (Point-to-Multipoint)</option></select></div></div></div>);
      case 2: // Path Building
        return (<div className="space-y-6"><h3 className="text-lg font-medium text-gray-800">2. Build Fiber Paths</h3>
          { (topology === 'p2p-unprotected' || topology === 'p2p-protected') && <div className="border rounded-lg"><div className="p-3 bg-gray-50 border-b font-medium text-gray-700">Working Path</div><div className="p-4"><PathBuilder path={paths.working} onPathChange={p => setPaths(c => ({ ...c, working: p }))} startNodeId={selectedSystem!.startNode} {...{ nodes, cables, allAllocatedFibers }} /></div></div> }
          { topology === 'p2p-protected' && <div className="border rounded-lg"><div className="p-3 bg-gray-50 border-b font-medium text-gray-700">Protection Path (Diverse Route)</div><div className="p-4"><PathBuilder path={paths.protection} onPathChange={p => setPaths(c => ({ ...c, protection: p }))} startNodeId={selectedSystem!.startNode} {...{ nodes, cables, allAllocatedFibers }} /></div></div> }
          { topology === 'ring' && <div className="border rounded-lg"><div className="p-3 bg-gray-50 border-b font-medium text-gray-700">Ring Path (must start and end at {selectedSystem?.startNode})</div><div className="p-4"><PathBuilder path={paths.working} onPathChange={p => setPaths(c => ({ ...c, working: p }))} startNodeId={selectedSystem!.startNode} {...{ nodes, cables, allAllocatedFibers }} /></div></div> }
          { topology === 'tap-spur' && <div><div className="border rounded-lg mb-4"><div className="p-3 bg-gray-50 border-b font-medium text-gray-700">Trunk Path</div><div className="p-4"><PathBuilder path={paths.working} onPathChange={p => setPaths(c => ({ ...c, working: p }))} startNodeId={selectedSystem!.startNode} {...{ nodes, cables, allAllocatedFibers }} /></div></div><div className="text-center text-gray-500 text-sm">Tap/Spur path building is a complex feature for a future update.</div></div> }
        </div>);
      default: return null;
    }
  };

  return (<div className="fixed inset-0 bg-black bg-opacity-60 flex items-center justify-center z-50 p-4"><div className="bg-white rounded-lg shadow-xl w-full max-w-4xl max-h-[90vh] flex flex-col"><div className="flex justify-between items-center p-4 border-b"><div className="flex items-center"><GitBranch className="h-6 w-6 text-green-600 mr-3" /><h2 className="text-xl font-semibold text-gray-800">Multi-Topology Allocation Wizard (Step {step}/2)</h2></div><button onClick={handleClose} className="p-1 rounded-full hover:bg-gray-200"><X className="h-5 w-5 text-gray-500" /></button></div><div className="p-6 overflow-y-auto">{renderStep()}{error && <p className="mt-4 text-sm text-red-600 text-center animate-pulse">{error}</p>}</div><div className="flex justify-between items-center p-4 border-t bg-gray-50"><button onClick={handleClose} className="px-4 py-2 text-sm font-medium text-gray-700 bg-white border border-gray-300 rounded-md hover:bg-gray-50">Cancel</button><div className="space-x-3">{step > 1 && <button onClick={() => setStep(s => s - 1)} className="px-4 py-2 text-sm font-medium text-gray-700 bg-white border border-gray-300 rounded-md hover:bg-gray-50">Back</button>}{step < 2 ? <button onClick={() => setStep(s => s + 1)} disabled={!selectedSystemId} className="px-4 py-2 text-sm font-medium text-white bg-blue-600 rounded-md hover:bg-blue-700 disabled:bg-gray-400">Next</button> : <button onClick={handleSave} className="px-4 py-2 text-sm font-medium text-white bg-green-600 rounded-md hover:bg-green-700">Create Allocation</button>}</div></div></div></div>);
}

export default AdvancedAllocationModal;

// // --- 5. EXAMPLE PARENT COMPONENT TO DEMONSTRATE USAGE ---
// export default function AdvancedFiberAllocationPage() {
//   const [isModalOpen, setIsModalOpen] = useState(false);
//   const handleSaveAllocation = (data: any) => { console.log("New Allocation to be Saved:", data); alert(`Allocation for system "${data.systemId}" prepared. See console for details.`); };
//   return (<div className="min-h-screen bg-gray-100 p-8"><header className="bg-white shadow rounded-lg mb-8"><div className="max-w-7xl mx-auto p-4 sm:px-6 lg:px-8 flex justify-between items-center"><div className="flex items-center"><Network className="h-8 w-8 text-blue-600 mr-3" /><div><h1 className="text-xl font-bold text-gray-900">Advanced Fiber Allocation</h1><p className="text-sm text-gray-500">Create Point-to-Point, Ring, and Protected fiber routes.</p></div></div><button onClick={() => setIsModalOpen(true)} className="px-4 py-2 bg-green-600 text-white rounded-lg hover:bg-green-700 flex items-center shadow-sm"><Plus className="h-4 w-4 mr-2" />New Allocation</button></div></header><main className="text-center bg-white p-10 rounded-lg shadow"><h2 className="text-lg font-medium text-gray-700">Dashboard Content</h2><p className="mt-2 text-gray-500">Click the "New Allocation" button to launch the multi-topology wizard.</p></main><AdvancedAllocationModal isOpen={isModalOpen} onClose={() => setIsModalOpen(false)} onSave={handleSaveAllocation} {...mockData} /></div>);
// }
```

<!-- path: components/systems/CreatePathModal.tsx -->
```typescript
"use client";

import { useForm, Controller } from "react-hook-form";
import { zodResolver } from "@hookform/resolvers/zod";
import { logicalFiberPathSchema } from "@/schemas";
import { z } from "zod";
import { useTableInsert, useTableQuery } from "@/hooks/database";
import { createClient } from "@/utils/supabase/client";
import { Modal } from "../common/ui/Modal";
import { Button } from "../common/ui/Button";
import { Input } from "../common/ui/Input";
import { SearchableSelect } from "../common/ui/select/SearchableSelect";
import { toast } from "sonner";
import { Row } from "@/hooks/database";

interface Props {
  isOpen: boolean;
  onClose: () => void;
  system: Row<'systems'>;
  onPathCreated: () => void;
}

const createPathFormSchema = logicalFiberPathSchema.pick({
  path_name: true,
  path_type_id: true,
  destination_system_id: true,
  remark: true,
});
type CreatePathForm = z.infer<typeof createPathFormSchema>;

export function CreatePathModal({ isOpen, onClose, system, onPathCreated }: Props) {
  const supabase = createClient();
  const { control, handleSubmit, register, formState: { errors, isSubmitting } } = useForm<CreatePathForm>({
    resolver: zodResolver(createPathFormSchema),
  });

  const { data: fetchedPathTypes } = useTableQuery(supabase, 'lookup_types', { filters: { category: 'OFC_PATH_TYPE'} });
  const pathTypes = fetchedPathTypes?.filter(pt => pt.name !== "DEFAULT");
  const { data: systems } = useTableQuery(supabase, 'systems', { filters: { id: { operator: 'neq', value: system.id } } });
console.log(pathTypes);

  const { mutate: createPath } = useTableInsert(supabase, 'logical_fiber_paths', {
    onSuccess: () => {
      toast.success("Logical path created successfully.");
      onPathCreated();
      onClose();
    },
    onError: (err) => toast.error(`Failed to create path: ${err.message}`),
  });

  const onSubmit = (formData: CreatePathForm) => {
    createPath({
      ...formData,
      source_system_id: system.id,
    });
  };

  return (
    <Modal isOpen={isOpen} onClose={onClose} title="Create New Logical Path" visible={false}
      className="h-screen w-screen transparent bg-gray-700 rounded-2xl">
      <form onSubmit={handleSubmit(onSubmit)} className="space-y-4">
        <div>
          <label className="block text-sm font-medium mb-1">Path Name*</label>
          <Input {...register("path_name")} placeholder="e.g., Primary Ring to Site B" />
          {errors.path_name && <p className="text-red-500 text-xs mt-1">{errors.path_name.message}</p>}
        </div>

        <Controller
          name="path_type_id"
          control={control}
          render={({ field }) => (
            <SearchableSelect
              label="Path Type"
              options={pathTypes?.map(pt => ({ value: pt.id, label: pt.name })) || []}
              value={field.value || ""}
              onChange={val => field.onChange(val)}
              placeholder="Select path type..."
            />
          )}
        />
        
        <Controller
          name="destination_system_id"
          control={control}
          render={({ field }) => (
            <SearchableSelect
              label="Destination System"
              options={systems?.map(s => ({ value: s.id, label: s.system_name || s.id })) || []}
              value={field.value || ""}
              onChange={val => field.onChange(val)}
              placeholder="Select destination system..."
            />
          )}
        />
        
        <div>
          <label className="block text-sm font-medium mb-1">Remarks</label>
          <textarea {...register("remark")} className="w-full rounded-md border-gray-300 dark:bg-gray-700" rows={3} />
        </div>

        <div className="flex justify-end gap-2 pt-4">
          <Button type="button" variant="outline" onClick={onClose} disabled={isSubmitting}>Cancel</Button>
          <Button type="submit" disabled={isSubmitting}>
            {isSubmitting ? "Creating..." : "Create Path"}
          </Button>
        </div>
      </form>
    </Modal>
  );
}
```

<!-- path: components/systems/PathSegmentList.tsx -->
```typescript
"use client";

import { Row } from "@/hooks/database";
import { DndContext, closestCenter, PointerSensor, useSensor, useSensors, DragEndEvent } from '@dnd-kit/core';
import { SortableContext, useSortable, verticalListSortingStrategy } from '@dnd-kit/sortable';
import { CSS } from '@dnd-kit/utilities';
import { Button } from "../common/ui/Button";
import { FiTrash2, FiMove } from "react-icons/fi";

interface SortableItemProps {
    segment: Row<'v_system_ring_paths_detailed'>;
    onDelete: () => void;
}

function SortableSegmentItem({ segment, onDelete }: SortableItemProps) {
    const { attributes, listeners, setNodeRef, transform, transition } = useSortable({ id: segment.id || '' });
    const style = { transform: CSS.Transform.toString(transform), transition };

    return (
        <li ref={setNodeRef} style={style} className="mb-6 ml-6 flex items-center gap-4">
             <span className="absolute flex items-center justify-center w-8 h-8 bg-blue-100 rounded-full -left-4 ring-8 ring-white dark:ring-gray-800 dark:bg-blue-900">
                {segment.path_order}
            </span>
            <div className="flex-1 p-3 bg-gray-50 dark:bg-gray-700 rounded-lg border dark:border-gray-600">
                <h4 className="font-semibold text-gray-900 dark:text-white">{segment.route_name}</h4>
                <p className="text-sm text-gray-500 dark:text-gray-400">
                    {segment.start_node_name}  {segment.end_node_name}
                </p>
            </div>
            <div className="flex items-center gap-2">
                <Button variant="ghost" size="sm" onClick={onDelete} className="text-red-500 hover:bg-red-100 dark:hover:bg-red-900/50">
                    <FiTrash2 />
                </Button>
                <Button variant="ghost" size="sm" {...attributes} {...listeners} className="cursor-grab active:cursor-grabbing">
                    <FiMove />
                </Button>
            </div>
        </li>
    );
}

interface ListProps {
    segments: Row<'v_system_ring_paths_detailed'>[];
    onDragEnd: (event: DragEndEvent) => void;
    onDelete: (id: string) => void;
}

export function PathSegmentList({ segments, onDragEnd, onDelete }: ListProps) {
    const sensors = useSensors(useSensor(PointerSensor, {
      activationConstraint: {
        distance: 8,
      },
    }));

    return (
        <DndContext sensors={sensors} collisionDetection={closestCenter} onDragEnd={onDragEnd}>
            <SortableContext items={segments.map(s => s.id || '')} strategy={verticalListSortingStrategy}>
                <ol className="relative border-l border-gray-200 dark:border-gray-700 ml-4">
                    {segments.map(segment => (
                        <SortableSegmentItem
                            key={segment.id}
                            segment={segment}
                            onDelete={() => onDelete(segment.id || '')}
                        />
                    ))}
                </ol>
            </SortableContext>
        </DndContext>
    );
}
```

<!-- path: components/systems/SystemRingPath.tsx -->
```typescript
"use client";

import { useState } from "react";
import { createClient } from "@/utils/supabase/client";
import { useTableQuery } from "@/hooks/database";
import { Button } from "@/components/common/ui/Button";
import { FiPlus } from "react-icons/fi";
import { Row } from "@/hooks/database";
import { useSystemPath } from "@/hooks/database/path-queries";
import { useDeletePathSegment, useReorderPathSegments } from "@/hooks/database/path-mutations";
import { DragEndEvent } from "@dnd-kit/core";

// Import all child components
import { CreatePathModal } from "./CreatePathModal";
import { AddSegmentModal } from "./AddSegmentModal";
import { PathSegmentList } from "./PathSegmentList";
import { FiberProvisioning } from "./FiberProvisioning";
import { LoadingSpinner } from "../common/ui";

interface Props {
  system: Row<'systems'> & { node: Row<'nodes'> | null };
}

export function SystemRingPath({ system }: Props) {
  const supabase = createClient();
  const [isAddSegmentModalOpen, setIsAddSegmentModalOpen] = useState(false);
  const [isCreatePathModalOpen, setIsCreatePathModalOpen] = useState(false);

  // --- Data Fetching ---
  const { data: logicalPathData, refetch: refetchLogicalPath, isLoading: isLoadingPath } = useTableQuery(supabase, 'logical_fiber_paths', {
    filters: { source_system_id: system.id },
    limit: 1
  });
  const path = logicalPathData?.[0];

  const { data: pathSegments, isLoading: isLoadingSegments, refetch: refetchSegments } = useSystemPath(path?.id || null);

  const deleteSegmentMutation = useDeletePathSegment();
  const reorderSegmentsMutation = useReorderPathSegments();

  const handleDragEnd = (event: DragEndEvent) => {
    const { active, over } = event;
    if (over && active.id !== over.id && pathSegments && path) {
      const oldIndex = pathSegments.findIndex(s => s.id === active.id);
      const newIndex = pathSegments.findIndex(s => s.id === over.id);

      const reorderedSegments = Array.from(pathSegments);
      const [movedItem] = reorderedSegments.splice(oldIndex, 1);
      reorderedSegments.splice(newIndex, 0, movedItem);

      const newSegmentIds = reorderedSegments.map(s => s.id);
      reorderSegmentsMutation.mutate({ pathId: path.id, segmentIds: newSegmentIds });
    }
  };

  const handleDeleteSegment = (segmentId: string) => {
    if (window.confirm("Are you sure you want to remove this segment from the path?") && path) {
      deleteSegmentMutation.mutate({ segmentId, pathId: path.id });
    }
  };

  // --- Render Logic ---
  if (isLoadingPath) {
    return <div className="p-4 text-center"><LoadingSpinner text="Loading path information..." /></div>;
  }

  return (
    <div className="bg-white dark:bg-gray-800 rounded-lg shadow-md border dark:border-gray-700">
      <div className="p-4 border-b dark:border-gray-700 flex justify-between items-center">
        <h3 className="text-xl font-semibold">Ring Path Builder</h3>
        {!path ? (
            <Button onClick={() => setIsCreatePathModalOpen(true)}>Initialize Path</Button>
        ) : (
            <Button onClick={() => setIsAddSegmentModalOpen(true)} leftIcon={<FiPlus />}>Add Segment</Button>
        )}
      </div>

      <div className="p-4">
        {isLoadingSegments ? (
          <p>Loading path segments...</p>
        ) : (!pathSegments || pathSegments.length === 0) ? (
            <p className="text-gray-500 text-center py-8">
                {path ? "No segments defined. Click 'Add Segment' to begin building the physical path." : "Initialize a logical path to start."}
            </p>
        ) : (
          <PathSegmentList
            segments={pathSegments}
            onDragEnd={handleDragEnd}
            onDelete={handleDeleteSegment}
          />
        )}
      </div>

      {/* Provisioning Section - Renders only when there is a path AND segments */}
      {path && pathSegments && pathSegments.length > 0 && (
        <FiberProvisioning
          logicalPath={path}
        />
      )}
      
      {/* Modals */}
      {isAddSegmentModalOpen && path && system.node && (
        <AddSegmentModal
          isOpen={isAddSegmentModalOpen}
          onClose={() => setIsAddSegmentModalOpen(false)}
          logicalPathId={path.id}
          sourceNodeId={system.node.id}
          currentSegments={pathSegments || []}
          onSegmentAdded={() => {
            refetchSegments();
            setIsAddSegmentModalOpen(false);
          }}
        />
      )}
      {isCreatePathModalOpen && (
          <CreatePathModal 
            isOpen={isCreatePathModalOpen}
            onClose={() => setIsCreatePathModalOpen(false)}
            system={system}
            onPathCreated={refetchLogicalPath}
          />
      )}
    </div>
  );
}
```

<!-- path: components/systems/AddSegmentModal.tsx -->
```typescript
"use client";

import { useAvailablePathSegments } from "@/hooks/database/path-queries";
import { Modal } from "../common/ui/Modal";
import { useState } from "react";

import { Button } from "../common/ui/Button";
import { useTableInsert } from "@/hooks/database";
import { createClient } from "@/utils/supabase/client";
import { toast } from "sonner";
import { Row } from "@/hooks/database";

interface Props {
  isOpen: boolean;
  onClose: () => void;
  logicalPathId: string;
  sourceNodeId: string;
  currentSegments: Row<'v_system_ring_paths_detailed'>[];
  onSegmentAdded: () => void;
}

export function AddSegmentModal({ isOpen, onClose, logicalPathId, sourceNodeId, currentSegments, onSegmentAdded }: Props) {
  const [selectedCableId, setSelectedCableId] = useState<string | null>(null);
  const supabase = createClient();
  
  const { data: availableCables, isLoading } = useAvailablePathSegments(sourceNodeId, currentSegments);

  console.log(availableCables);

  const { mutate: addSegment, isPending } = useTableInsert(supabase, 'logical_path_segments', {
    onSuccess: () => {
        toast.success("Segment added to path!");
        onSegmentAdded();
    },
    onError: (err) => toast.error(`Failed to add segment: ${err.message}`)
  });

  const handleAdd = () => {
    if (!selectedCableId) {
        toast.error("Please select a cable segment.");
        return;
    }
    addSegment({
        logical_path_id: logicalPathId,
        ofc_cable_id: selectedCableId,
        path_order: (currentSegments.length || 0) + 1,
    });
  };

  return (
    <Modal isOpen={isOpen} onClose={onClose} title="Add Next Path Segment">
      <div className="space-y-4">
        <label htmlFor="cable-select" className="block text-sm font-medium text-gray-700 dark:text-gray-300">
          Available Cables
        </label>
        {isLoading && <p>Loading available cables...</p>}
        {!isLoading && (!availableCables || availableCables.length === 0) && (
            <p className="text-gray-500">No further connecting cables found from the last node in the path.</p>
        )}
        {availableCables && availableCables.length > 0 && (
            <select
                id="cable-select"
                className="w-full rounded-md border-gray-300 dark:border-gray-600 dark:bg-gray-700 dark:text-white"
                value={selectedCableId || ""}
                onChange={(e) => setSelectedCableId(e.target.value)}
            >
                <option value="" disabled>Select a cable...</option>
                {availableCables?.map((cable) => (
                    <option key={cable.id} value={cable.id}>
                        {cable.route_name} ({cable.sn?.name || 'N/A'}  {cable.en?.name || 'N/A'})
                    </option>
                ))}
            </select>
        )}
        <div className="flex justify-end gap-2 pt-4">
            <Button variant="outline" onClick={onClose} disabled={isPending}>Cancel</Button>
            <Button onClick={handleAdd} disabled={isPending || !selectedCableId}>
                {isPending ? "Adding..." : "Add to Path"}
            </Button>
        </div>
      </div>
    </Modal>
  );
}
```

<!-- path: components/systems/system-modal.tsx -->
```typescript
'use client';

import { FC, useCallback, useEffect, useMemo, useState } from 'react';
import { toast } from 'sonner';
import {
  useGetLookupTypesByCategory,
  useTableQuery,
  useTableInsert,
  useTableUpdate,
} from '@/hooks/database';
import { createClient } from '@/utils/supabase/client';
import { SystemFormData, systemFormSchema } from '@/schemas';
import { useForm } from 'react-hook-form';
import { zodResolver } from '@hookform/resolvers/zod';
import z from 'zod';
import { Modal } from '@/components/common/ui';
import {
  FormCard,
  FormDateInput,
  FormInput,
  FormIPAddressInput,
  FormSearchableSelect,
  FormSwitch,
  FormTextarea,
} from '@/components/common/form';
import { Option } from '@/components/common/ui/select/SearchableSelect';
import { SystemRowsWithCountWithRelations } from '@/types/view-row-types';

interface SystemModalProps {
  isOpen: boolean;
  onClose: () => void;
  rowData: SystemRowsWithCountWithRelations | null;
  refetch: () => void;
}

export const SystemModal: FC<SystemModalProps> = ({
  isOpen,
  onClose,
  rowData,
  refetch,
}) => {
  const supabase = createClient();
  const [isProcessing, setIsProcessing] = useState(false);

  // Fetch data for dropdowns
  const { data: systemTypes = [], isLoading: isLoadingSystemTypes } =
    useGetLookupTypesByCategory(supabase, 'SYSTEM_TYPES');

  // Filter out DEFAULT system type
  const filteredSystemTypes = useMemo(() => {
    return systemTypes.filter((type) => type.name !== 'DEFAULT');
  }, [systemTypes]);

  const { data: nodes = [], isLoading: isLoadingNodes } = useTableQuery(
    supabase,
    'nodes',
    {
      columns: 'id, name',
      orderBy: [{ column: 'name' }],
    }
  );

  const {
    data: maintenanceTerminals = [],
    isLoading: isLoadingMaintenanceTerminals,
  } = useTableQuery(supabase, 'maintenance_areas', {
    columns: 'id, name',
    orderBy: [{ column: 'name' }],
  });
  const isLoading =
    isLoadingSystemTypes || isLoadingNodes || isLoadingMaintenanceTerminals;
  const systemTypesOptions: Option[] = useMemo(
    () =>
      filteredSystemTypes.map((t) => ({ value: String(t.id), label: t.code })),
    [filteredSystemTypes]
  );

  const nodesOptions: Option[] = useMemo(
    () => nodes.map((n) => ({ value: String(n.id), label: n.name })),
    [nodes]
  );

  const maintenanceTerminalsOptions: Option[] = useMemo(
    () =>
      maintenanceTerminals.map((t) => ({ value: String(t.id), label: t.name })),
    [maintenanceTerminals]
  );

  const {
    register,
    handleSubmit,
    formState: { errors, isSubmitting },
    reset,
    control,
    setValue,
  } = useForm<SystemFormData>({
    resolver: zodResolver(systemFormSchema),
    defaultValues: {
      system_name: null,
      system_type_id: '',
      node_id: '',
      maintenance_terminal_id: null,
      ip_address: '',
      commissioned_on: null,
      remark: null,
      status: true,
    },
  });

  // Reset form when modal opens or rowData changes
  useEffect(() => {
    if (!isOpen) {
      // Reset form when closing
      reset({
        system_name: null,
        system_type_id: '',
        node_id: '',
        maintenance_terminal_id: null,
        s_no: null,
        ip_address: '',
        commissioned_on: null,
        remark: null,
        status: true,
      });
      return;
    }

    // Wait for options to load before populating
    if (isLoading) {
      return;
    }

    if (rowData) {
      console.log('Raw rowData:', rowData); // Debug log

      // Cast rowData to access the joined fields that aren't in the base type
      const extendedRowData = rowData as SystemRowsWithCountWithRelations;

      // Find IDs by matching names/codes from the related data
      const findSystemTypeId = () => {
        if (rowData.system_type_id) return String(rowData.system_type_id);
        if (extendedRowData.system_type_code) {
          const matchedType = systemTypesOptions.find(
            (option) => option.label === extendedRowData.system_type_code
          );
          return matchedType ? matchedType.value : '';
        }
        return '';
      };

      const findNodeId = () => {
        if (rowData.node_id) return String(rowData.node_id);
        if (extendedRowData.node_name) {
          const matchedNode = nodesOptions.find(
            (option) => option.label === extendedRowData.node_name
          );
          return matchedNode ? matchedNode.value : '';
        }
        return '';
      };

      const findMaintenanceTerminalId = () => {
        if (rowData.maintenance_terminal_id)
          return String(rowData.maintenance_terminal_id);
        if (extendedRowData.system_maintenance_terminal_name) {
          const matchedTerminal = maintenanceTerminalsOptions.find(
            (option) =>
              option.label === extendedRowData.system_maintenance_terminal_name
          );
          return matchedTerminal ? matchedTerminal.value : '';
        }
        return '';
      };

      // Prepare form values - ensure all IDs are strings and handle null/undefined
      const formValues = {
        system_name: rowData.system_name || null,
        system_type_id: findSystemTypeId(),
        node_id: findNodeId(),
        maintenance_terminal_id: findMaintenanceTerminalId(),
        s_no: rowData.s_no || null,
        ip_address: rowData.ip_address?.toString() || '', // Let the form handle the value
        commissioned_on: rowData.commissioned_on
          ? new Date(rowData.commissioned_on)
          : null,
        remark: rowData.remark || null,
        status: rowData.status ?? true,
      };

      console.log('Populating form with:', formValues);
      console.log('Available options:', {
        systemTypesOptions,
        nodesOptions,
        maintenanceTerminalsOptions,
      });

      // Reset form with values
      reset(formValues);
    } else {
      // Reset to default values for new record
      reset({
        system_name: null,
        system_type_id: '',
        node_id: '',
        maintenance_terminal_id: null,
        s_no: null,
        ip_address: '',
        commissioned_on: null,
        remark: null,
        status: true,
      });
    }
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [isOpen, rowData, reset, setValue, isLoading]);

  // Data mutations
  const onMutationSuccess = () => {
    refetch();
    onClose();
  };

  const createSystemMutation = useTableInsert(supabase, 'systems', {
    onSuccess: onMutationSuccess,
  });
  const updateSystemMutation = useTableUpdate(supabase, 'systems', {
    onSuccess: onMutationSuccess,
  });

  // FIXED: Simplified onValidSubmit - removed nested onSuccess callbacks
  const onValidSubmit = useCallback(
    async (formData: SystemFormData) => {
      if (isProcessing) return; // Prevent multiple submissions

      setIsProcessing(true);
      try {
        // Transform the form data according to the schema
        const transformedData = systemFormSchema.safeParse(formData);

        if (!transformedData.success) {
          console.error('Form validation error:', transformedData.error);
          toast.error('Validation failed. Please check the form for errors.');
          return;
        }

        // Ensure we're passing a plain object, not an array
        const dataToSubmit = { ...transformedData.data };

        if (rowData) {
          // For updates
          updateSystemMutation.mutate({
            id: rowData.id as string,
            data: dataToSubmit,
          });
        } else {
          // For new records - ensure we're passing a single object, not an array
          createSystemMutation.mutate(dataToSubmit);
        }
      } catch (error) {
        console.error('Form validation error:', error);
        if (error instanceof z.ZodError) {
          toast.error('Validation failed. Please check the form for errors.');
        } else {
          toast.error('An unexpected error occurred. Please try again.');
        }
      } finally {
        setIsProcessing(false);
      }
    },
    [isProcessing, rowData, updateSystemMutation, createSystemMutation]
  );

  const submitting =
    createSystemMutation.isPending ||
    updateSystemMutation.isPending ||
    isSubmitting;

  if (!isOpen) {
    return null;
  }

  return (
    <Modal
      isOpen={isOpen}
      onClose={onClose}
      title={rowData ? 'Edit System' : 'Add System'}
      visible={false}
      className="h-screen w-screen transparent bg-gray-700 rounded-2xl"
    >
      {/* Form */}
      <FormCard
        onSubmit={handleSubmit(onValidSubmit)}
        heightClass="min-h-calc(90vh - 200px)"
        title={rowData ? 'Edit System' : 'Add System'}
        onCancel={onClose}
        isLoading={isLoading}
        disableSubmit={submitting}
        standalone
      >
        <FormInput
          name="system_name"
          label="System Name"
          type="text"
          required
          register={register}
          error={errors.system_name}
        />

        <div className="form-group">
          <label className="block text-sm font-medium text-gray-700 mb-1">
            System Type <span className="text-red-500">*</span>
          </label>
          <FormSearchableSelect
            name="system_type_id"
            label=""
            control={control}
            options={systemTypesOptions}
            required
            error={errors.system_type_id}
          />
        </div>

        <div className="form-group">
          <label className="block text-sm font-medium text-gray-700 mb-1">
            Node / Location <span className="text-red-500">*</span>
          </label>
          <FormSearchableSelect
            name="node_id"
            label=""
            control={control}
            options={nodesOptions}
            required
            error={errors.node_id}
          />
        </div>

        <FormDateInput
          name="commissioned_on"
          label="Commissioned On"
          control={control}
          error={errors.commissioned_on}
        />

        <FormIPAddressInput
          name="ip_address"
          label="IP Address"
          control={control}
          error={errors.ip_address}
          placeholder="Enter IPv4 address (e.g., 192.168.1.1)"
          allowIPv4={true}
          allowIPv6={false}
        />

        <FormInput
          name="s_no"
          label="Serial Number"
          type="text"
          required
          register={register}
          error={errors.s_no}
        />

        <div className="form-group">
          <label className="block text-sm font-medium text-gray-700 mb-1">
            Maintenance Terminal <span className="text-red-500">*</span>
          </label>
          <FormSearchableSelect
            name="maintenance_terminal_id"
            label=""
            control={control}
            options={maintenanceTerminalsOptions}
            required
            error={errors.maintenance_terminal_id}
          />
        </div>

        <FormSwitch
          name="status"
          label="Status"
          control={control}
          error={errors.status}
          className="my-2"
        />

        <FormTextarea
          name="remark"
          label="Remark"
          control={control}
          error={errors.remark}
        />
      </FormCard>
    </Modal>
  );
};

```

<!-- path: components/systems/FiberProvisioning.tsx -->
```typescript
"use client";

import React, { useState, useMemo } from "react";
import { useAvailableFibers } from "@/hooks/database/path-queries";
import { useProvisionRingPath } from "@/hooks/database/path-mutations"; // <-- Use the new, correct hook
import { Button } from "../common/ui/Button";
import { toast } from "sonner";
import { FiZap } from "react-icons/fi";

interface Props {
  pathName: string;
  systemId: string;
  physicalPathId: string;
}

export function FiberProvisioning({ pathName, systemId, physicalPathId }: Props) {
  const [workingFiber, setWorkingFiber] = useState<string>("");
  const [protectionFiber, setProtectionFiber] = useState<string>("");
  
  const { data: availableFibers, isLoading, isError, error } = useAvailableFibers(physicalPathId);
  const provisionMutation = useProvisionRingPath();

  const fiberOptions = useMemo(() => {
    if (!Array.isArray(availableFibers)) return [];
    return availableFibers.map(fiber => (
      <option key={fiber.fiber_no} value={fiber.fiber_no}>
        Fiber #{fiber.fiber_no}
      </option>
    ));
  }, [availableFibers]);

  const protectionFiberOptions = useMemo(() => {
    if (!Array.isArray(availableFibers)) return [];
    return availableFibers
      .filter(f => f.fiber_no.toString() !== workingFiber)
      .map(fiber => (
        <option key={`p-${fiber.fiber_no}`} value={fiber.fiber_no}>
          Fiber #{fiber.fiber_no}
        </option>
      ));
  }, [availableFibers, workingFiber]);

  const handleProvision = () => {
    if (!workingFiber || !protectionFiber) {
      toast.error("Please select both a working and a protection fiber.");
      return;
    }
    if (workingFiber === protectionFiber) {
      toast.error("Working and protection fibers cannot be the same.");
      return;
    }
    
    // Call the mutation with the full, correct set of variables
    provisionMutation.mutate({
      systemId: systemId,
      pathName: pathName,
      workingFiber: parseInt(workingFiber, 10),
      protectionFiber: parseInt(protectionFiber, 10),
      physicalPathId: physicalPathId,
    });
  };

  const renderContent = () => {
    if (isLoading) {
      return <p className="text-sm text-gray-500 animate-pulse">Checking fiber continuity...</p>;
    }
    if (isError) {
      return <p className="text-sm text-red-500">Error checking available fibers: {error.message}</p>;
    }
    if (availableFibers && availableFibers.length >= 2) {
      return (
        <div className="grid grid-cols-1 md:grid-cols-3 gap-4 items-end">
          <div>
            <label className="block text-sm font-medium mb-1 dark:text-gray-300">Working Fiber</label>
            <select
              value={workingFiber}
              onChange={(e) => setWorkingFiber(e.target.value)}
              className="w-full rounded-md border-gray-300 dark:bg-gray-700 dark:border-gray-600"
            >
              <option value="" disabled>Select fiber...</option>
              {fiberOptions}
            </select>
          </div>
          <div>
            <label className="block text-sm font-medium mb-1 dark:text-gray-300">Protection Fiber</label>
            <select
              value={protectionFiber}
              onChange={(e) => setProtectionFiber(e.target.value)}
              disabled={!workingFiber}
              className="w-full rounded-md border-gray-300 dark:bg-gray-700 disabled:opacity-50 dark:border-gray-600"
            >
              <option value="" disabled>Select fiber...</option>
              {protectionFiberOptions}
            </select>
          </div>
          <Button
            onClick={handleProvision}
            disabled={!workingFiber || !protectionFiber || provisionMutation.isPending}
          >
            {provisionMutation.isPending ? "Provisioning..." : "Provision Path"}
          </Button>
        </div>
      );
    }
    return (
      <p className="text-sm text-gray-500 dark:text-gray-400">
        Not enough available fibers for a protected path. At least 2 continuous fibers are required.
      </p>
    );
  };

  return (
    <div className="mt-6 p-4 bg-gray-50 dark:bg-gray-800/50 border border-dashed dark:border-gray-700 rounded-lg">
      <h4 className="text-lg font-semibold flex items-center gap-2 mb-3 dark:text-white">
        <FiZap className="text-yellow-500" />
        Provision Protected Ring Service
      </h4>
      {renderContent()}
    </div>
  );
}
```

<!-- path: components/nodes/NodesFilters.tsx -->
```typescript
"use client";

import { useState, useEffect, memo } from "react";
import { useDebounce } from "use-debounce";
import { FiSearch } from "react-icons/fi";
import { Input } from "@/components/common/ui/Input";
import { SearchableSelect, Option } from "@/components/common/ui/select/SearchableSelect";
import { DEFAULTS } from "@/config/constants";

interface NodesFiltersProps {
  searchQuery: string;
  onSearchChange: (value: string) => void;
  nodeTypes: Array<{ id: string; name: string }>;
  selectedNodeType?: string;
  onNodeTypeChange: (value: string | null) => void;
}

const NodesFiltersComponent = memo(({
  searchQuery,
  onSearchChange,
  nodeTypes,
  selectedNodeType = "",
  onNodeTypeChange
}: NodesFiltersProps) => {
  const [internalSearch, setInternalSearch] = useState(searchQuery);
  const [debouncedSearch] = useDebounce(internalSearch, DEFAULTS.DEBOUNCE_DELAY); 
  // Effect to call the parent's onSearchChange only when the debounced value changes
  useEffect(() => {
    onSearchChange(debouncedSearch);
  }, [debouncedSearch, onSearchChange]);

  // Effect to sync the internal state if the parent's state changes
  useEffect(() => {
    setInternalSearch(searchQuery);
  }, [searchQuery]);

  const nodeTypeOptions: Option[] = (nodeTypes || []).map((nt) => ({ value: nt.id, label: nt.name }));

  return (
    <div className='w-full'>
      <div className='flex flex-col sm:flex-row gap-3 sm:items-center sm:justify-start'>
        <div className='relative flex-1 sm:max-w-md lg:max-w-xl'>
          <Input
            type='text'
            placeholder='Search nodes...'
            value={internalSearch} // Use internal state
            onChange={(e) => setInternalSearch(e.target.value)} // Update internal state
            leftIcon={<FiSearch className="text-gray-400 dark:text-gray-500" />}
            clearable={true}
            onClear={() => setInternalSearch("")} // Clear internal state
            className="dark:bg-gray-800 dark:border-gray-700 dark:text-white dark:placeholder-gray-400"
          />
        </div>
        <div className='w-full sm:w-64'>
          <SearchableSelect
            options={nodeTypeOptions}
            value={selectedNodeType}
            onChange={(v) => onNodeTypeChange(v)}
            placeholder='Filter by node type'
            searchPlaceholder='Search node types...'
            clearable={true}
          />
        </div>
      </div>
    </div>
  );
});

NodesFiltersComponent.displayName = "NodesFilters";
export const NodesFilters = NodesFiltersComponent;
```

<!-- path: components/nodes/nodes_types.ts -->
```typescript
import { Database, TablesInsert } from "@/types/supabase-types";

// Base Node type from database
export type Node = Database["public"]["Tables"]["nodes"]["Row"];
export type NodeInsert = TablesInsert<"nodes">;

// Node with relations for display purposes
export interface NodeWithRelations extends Node {
  node_type: NodeType | null;
  ring?: Ring | null;
  maintenance_terminal?: MaintenanceTerminal | null;
}

// Supporting types
export interface NodeType {
  id: string;
  name: string;
  category: string;
  code?: string | null;
}

export interface Ring {
  id: string;
  name: string;
  code?: string | null;
}

export interface MaintenanceTerminal {
  id: string;
  name: string;
  code?: string | null;
}

export interface NodesFilters {
  status?: string;
  nodeType?: string;
}

export interface NodesPagination {
  current: number;
  pageSize: number;
  total: number;
}

```

<!-- path: components/nodes/NodeFormModal.tsx -->
```typescript
'use client';

import React, { useCallback, useEffect, useMemo } from 'react';
import { Modal } from '@/components/common/ui/Modal';
import { createClient } from '@/utils/supabase/client';
import {
  useTableInsert,
  useTableUpdate,
  useTableQuery,
} from '@/hooks/database';
import { useForm } from 'react-hook-form';
import { zodResolver } from '@hookform/resolvers/zod';
import { FormCard } from '@/components/common/form/FormCard';
import {
  FormInput,
  FormSearchableSelect,
  FormSwitch,
  FormTextarea,
} from '@/components/common/form/FormControls';
import { Option } from '@/components/common/ui/select/SearchableSelect';
import {
  NodesInsertSchema,
  nodesInsertSchema,
  NodesRowSchema,
  NodesUpdateSchema,
} from '@/schemas/zod-schemas';

interface NodeFormModalProps {
  isOpen: boolean;
  onClose: () => void;
  editingNode?: NodesRowSchema | null;
  onCreated?: (node: NodesRowSchema) => void;
  onUpdated?: (node: NodesRowSchema) => void;
}

export function NodeFormModal({
  isOpen,
  onClose,
  editingNode,
  onCreated,
  onUpdated,
}: NodeFormModalProps) {
  const {
    register,
    handleSubmit,
    formState: { errors, isSubmitting },
    reset,
    control,
  } = useForm({
    resolver: zodResolver(nodesInsertSchema),
    defaultValues: {
      name: '',
      node_type_id: null,
      latitude: null,
      longitude: null,
      maintenance_terminal_id: null,
      remark: null,
      status: true,
    },
  });

  const supabase = createClient();
  const { mutate: insertNode, isPending: creating } = useTableInsert(
    supabase,
    'nodes'
  );
  const { mutate: updateNode, isPending: updating } = useTableUpdate(
    supabase,
    'nodes'
  );

  const isEdit = useMemo(() => Boolean(editingNode), [editingNode]);

  // Fetch node types, rings, and maintenance areas
  const { data: nodeTypes = [] } = useTableQuery(supabase, 'lookup_types', {
    filters: {
      category: { operator: 'eq', value: 'NODE_TYPES' },
      name: { operator: 'neq', value: 'DEFAULT' },
    },
    orderBy: [{ column: 'name', ascending: true }],
  });
  const { data: maintenanceAreas = [] } = useTableQuery(
    supabase,
    'maintenance_areas',
    {
      filters: { status: { operator: 'eq', value: true } },
      orderBy: [{ column: 'name', ascending: true }],
    }
  );

  useEffect(() => {
    if (!isOpen) return;
    if (editingNode) {
      reset({
        name: editingNode.name ?? '',
        node_type_id: editingNode.node_type_id ?? null,
        latitude: editingNode.latitude,
        longitude: editingNode.longitude,
        maintenance_terminal_id: editingNode.maintenance_terminal_id ?? null,
        remark:
          typeof editingNode.remark === 'string' ? editingNode.remark : null,
        status: editingNode.status ?? true,
      });
    } else {
      reset({
        name: '',
        node_type_id: null,
        latitude: null,
        longitude: null,
        maintenance_terminal_id: null,
        remark: null,
        status: true,
      });
    }
  }, [isOpen, editingNode, reset]);

  const handleClose = useCallback(() => {
    if (creating || updating) return;
    onClose();
  }, [creating, updating, onClose]);

  const onValidSubmit = useCallback(
    (formData: NodesInsertSchema) => {
      const cleanNumber = (val: unknown) =>
        typeof val === 'number' && !Number.isNaN(val) ? val : null;

      const submitData = {
        name: formData.name.trim(),
        node_type_id: formData.node_type_id,
        latitude: cleanNumber(formData.latitude),
        longitude: cleanNumber(formData.longitude),
        maintenance_terminal_id: formData.maintenance_terminal_id,
        remark: formData.remark,
        status: formData.status,
      };

      if (isEdit && editingNode) {
        updateNode(
          {
            id: editingNode.id,
            data: submitData as Partial<NodesUpdateSchema>,
          },
          {
            onSuccess: (data: unknown) => {
              onUpdated?.(Array.isArray(data) ? data[0] : data);
              onClose();
            },
          }
        );
      } else {
        insertNode(submitData as NodesInsertSchema, {
          onSuccess: (data: unknown) => {
            onCreated?.(Array.isArray(data) ? data[0] : data);
            onClose();
          },
        });
      }
    },
    [isEdit, editingNode, updateNode, insertNode, onUpdated, onCreated, onClose]
  );

  const submitting = creating || updating || isSubmitting;

  return (
    <Modal
      isOpen={isOpen}
      onClose={handleClose}
      title={''}
      size="full"
      visible={false}
      className="h-screen w-screen transparent bg-gray-700 rounded-2xl"
    >
      <FormCard
        title={isEdit ? 'Edit Node' : 'Add Node'}
        onSubmit={handleSubmit(onValidSubmit)}
        onCancel={handleClose}
        standalone
      >
        {/* Name */}
        <FormInput
          name="name"
          label="Node Name"
          register={register}
          error={errors.name}
          disabled={submitting}
          className="dark:bg-gray-900 dark:text-gray-100"
        />

        {/* Node Type */}
        <FormSearchableSelect
          name="node_type_id"
          label="Node Type"
          control={control}
          options={nodeTypes.map(
            (type) =>
              ({
                value: type.id,
                label: type.name,
              } as Option)
          )}
          error={errors.node_type_id}
          disabled={submitting}
          className="dark:bg-gray-900 dark:text-gray-100"
        />

        {/* Maintenance Terminal */}
        <FormSearchableSelect
          name="maintenance_terminal_id"
          label="Maintenance Terminal"
          control={control}
          options={maintenanceAreas.map(
            (mt) =>
              ({
                value: mt.id,
                label: mt.name,
              } as Option)
          )}
          error={errors.maintenance_terminal_id}
          disabled={submitting}
          className="dark:bg-gray-900 dark:text-gray-100"
        />

        {/* Coordinates */}
        <FormInput
          name="latitude"
          label="Latitude"
          register={register}
          error={errors.latitude}
          disabled={submitting}
          type="number"
          className="dark:bg-gray-900 dark:text-gray-100"
        />

        <FormInput
          name="longitude"
          label="Longitude"
          register={register}
          error={errors.longitude}
          disabled={submitting}
          type="number"
          className="dark:bg-gray-900 dark:text-gray-100"
        />

        {/* Remark */}
        <FormTextarea
          name="remark"
          label="Remark"
          control={control}
          error={errors.remark}
          disabled={submitting}
          className="dark:bg-gray-900 dark:text-gray-100"
        />

        {/* Status */}
        <FormSwitch
          name="status"
          label="Status"
          control={control}
          error={errors.status}
          className="dark:bg-gray-900 dark:text-gray-100"
        />
      </FormCard>
    </Modal>
  );
}

```

<!-- path: components/nodes/index.ts -->
```typescript

```

<!-- path: components/users/UserFilters.tsx -->
```typescript
import { motion } from "framer-motion";
import { FiSearch, FiX, FiFilter, FiChevronDown, FiChevronUp } from "react-icons/fi";
import { UserRole } from "@/types/user-roles";

interface UserFiltersProps {
  searchQuery: string;
  roleFilter: string;
  statusFilter: string;
  emailVerificationFilter: string;
  showFilters: boolean;
  onSearchChange: (value: string) => void;
  onRoleFilterChange: (value: string) => void;
  onStatusFilterChange: (value: string) => void;
  onEmailVerificationFilterChange: (value: string) => void;
  onToggleFilters: () => void;
  onClearFilters: () => void;
}

export function UserFilters({
  searchQuery,
  roleFilter,
  statusFilter,
  emailVerificationFilter,
  showFilters,
  onSearchChange,
  onRoleFilterChange,
  onStatusFilterChange,
  onEmailVerificationFilterChange,
  onToggleFilters,
  onClearFilters,
}: UserFiltersProps) {
  const hasActiveFilters = !!(searchQuery || roleFilter || statusFilter || emailVerificationFilter);
  const activeFilterCount = [roleFilter, statusFilter, emailVerificationFilter].filter(Boolean).length;

  return (
    <div className="space-y-3 sm:space-y-4 w-full">
      {/* Search and Controls Row */}
      <div className="flex flex-col space-y-3 sm:space-y-0 sm:flex-row sm:gap-3 sm:justify-between sm:items-center">
        {/* Search Input */}
        <div className="flex-1 sm:max-w-md lg:max-w-xl">
          <div className="relative">
            <FiSearch className="absolute left-3 top-1/2 transform -translate-y-1/2 text-gray-400 w-4 h-4 sm:w-5 sm:h-5" />
            <input
              type="text"
              placeholder="Search users..."
              value={searchQuery}
              onChange={(e) => onSearchChange(e.target.value)}
              className="w-full pl-9 sm:pl-10 pr-4 py-2.5 sm:py-2 text-sm sm:text-base border border-gray-300 dark:border-gray-600 rounded-lg bg-white dark:bg-gray-700 text-gray-900 dark:text-white placeholder-gray-500 dark:placeholder-gray-400 focus:ring-2 focus:ring-blue-500 focus:border-blue-500 transition-colors"
            />
          </div>
        </div>

        {/* Filter and Clear Buttons */}
        <div className="flex gap-2 sm:gap-3">
          <button
            onClick={onToggleFilters}
            className={`flex items-center gap-2 px-3 sm:px-4 py-2.5 sm:py-2 border rounded-lg font-medium text-sm sm:text-base transition-all duration-200 flex-1 sm:flex-none justify-center sm:justify-start ${
              showFilters || activeFilterCount > 0
                ? "border-blue-500 bg-blue-50 text-blue-700 dark:border-blue-400 dark:bg-blue-900/30 dark:text-blue-300 shadow-sm"
                : "border-gray-300 dark:border-gray-600 hover:bg-gray-50 dark:hover:bg-gray-700 text-gray-700 dark:text-gray-300 hover:border-gray-400"
            }`}
          >
            <FiFilter size={16} className="w-4 h-4 sm:w-4 sm:h-4" />
            <span className="hidden sm:inline">Filters</span>
            <span className="sm:hidden">Filter</span>
            {showFilters ? (
              <FiChevronUp size={14} className="w-3 h-3 sm:w-3.5 sm:h-3.5" />
            ) : (
              <FiChevronDown size={14} className="w-3 h-3 sm:w-3.5 sm:h-3.5" />
            )}
            {activeFilterCount > 0 && (
              <span className="bg-blue-600 text-white text-xs rounded-full px-1.5 sm:px-2 py-0.5 font-semibold min-w-[18px] sm:min-w-[20px] text-center leading-none">
                {activeFilterCount}
              </span>
            )}
          </button>

          {hasActiveFilters && (
            <button
              onClick={onClearFilters}
              className="flex items-center gap-2 px-3 sm:px-4 py-2.5 sm:py-2 text-sm sm:text-base text-red-600 hover:bg-red-50 dark:hover:bg-red-900/20 rounded-lg transition-colors font-medium border border-transparent hover:border-red-200 flex-shrink-0"
            >
              <FiX className="w-4 h-4" />
              <span className="hidden sm:inline">Clear All</span>
              <span className="sm:hidden">Clear</span>
            </button>
          )}
        </div>
      </div>

      {/* Collapsible Filter Panel */}
      {showFilters && (
        <motion.div
          initial={{ opacity: 0, height: 0 }}
          animate={{ opacity: 1, height: "auto" }}
          exit={{ opacity: 0, height: 0 }}
          transition={{ duration: 0.2, ease: "easeInOut" }}
          className="overflow-hidden"
        >
          <div className="p-3 sm:p-4 bg-gray-50 dark:bg-gray-800/50 rounded-lg border border-gray-200 dark:border-gray-600">
            {/* Mobile: Stack all filters, Desktop: Grid layout */}
            <div className="space-y-4 sm:space-y-0 sm:grid sm:grid-cols-2 lg:grid-cols-3 sm:gap-4">
              {/* Role Filter */}
              <div className="space-y-2">
                <label className="block text-sm font-medium text-gray-700 dark:text-gray-300">
                  Filter by Role
                </label>
                <select
                  value={roleFilter}
                  onChange={(e) => onRoleFilterChange(e.target.value)}
                  className="w-full px-3 py-2.5 sm:py-2 text-sm sm:text-base border border-gray-300 dark:border-gray-600 rounded-lg bg-white dark:bg-gray-700 text-gray-900 dark:text-white focus:ring-2 focus:ring-blue-500 focus:border-blue-500 transition-colors"
                >
                  <option value="">All Roles</option>
                  {Object.values(UserRole).map((role) => (
                    <option key={role} value={role}>
                      {role.replace(/_/g, " ").replace(/\b\w/g, (l) => l.toUpperCase())}
                    </option>
                  ))}
                </select>
              </div>

              {/* Status Filter */}
              <div className="space-y-2">
                <label className="block text-sm font-medium text-gray-700 dark:text-gray-300">
                  Filter by Status
                </label>
                <select
                  value={statusFilter}
                  onChange={(e) => onStatusFilterChange(e.target.value)}
                  className="w-full px-3 py-2.5 sm:py-2 text-sm sm:text-base border border-gray-300 dark:border-gray-600 rounded-lg bg-white dark:bg-gray-700 text-gray-900 dark:text-white focus:ring-2 focus:ring-blue-500 focus:border-blue-500 transition-colors"
                >
                  <option value="">All Status</option>
                  <option value="active">Active</option>
                  <option value="inactive">Inactive</option>
                  <option value="suspended">Suspended</option>
                  <option value="pending">Pending</option>
                </select>
              </div>

              {/* Email Verification Filter */}
              <div className="space-y-2">
                <label className="block text-sm font-medium text-gray-700 dark:text-gray-300">
                  Email Status
                </label>
                <select
                  value={emailVerificationFilter}
                  onChange={(e) => onEmailVerificationFilterChange(e.target.value)}
                  className="w-full px-3 py-2.5 sm:py-2 text-sm sm:text-base border border-gray-300 dark:border-gray-600 rounded-lg bg-white dark:bg-gray-700 text-gray-900 dark:text-white focus:ring-2 focus:ring-blue-500 focus:border-blue-500 transition-colors"
                >
                  <option value="">All</option>
                  <option value="verified">Verified</option>
                  <option value="unverified">Unverified</option>
                </select>
              </div>
            </div>

            {/* Mobile: Show clear filters button inside panel */}
            {hasActiveFilters && (
              <div className="mt-4 pt-3 border-t border-gray-200 dark:border-gray-600 sm:hidden">
                <button
                  onClick={onClearFilters}
                  className="w-full flex items-center justify-center gap-2 px-4 py-2.5 text-sm text-red-600 hover:bg-red-50 dark:hover:bg-red-900/20 rounded-lg transition-colors font-medium border border-red-200 dark:border-red-800"
                >
                  <FiX className="w-4 h-4" />
                  Clear All Filters
                </button>
              </div>
            )}
          </div>
        </motion.div>
      )}
    </div>
  );
}
```

<!-- path: components/users/BulkActions.tsx -->
```typescript
import { motion } from "framer-motion";
import { FiTrash2 } from "react-icons/fi";
import { UserRole } from "@/types/user-roles";

interface BulkActionsProps {
  selectedCount: number;
  isSuperAdmin: boolean;
  isOperationLoading: boolean;
  onBulkDelete: () => void;
  onBulkUpdateRole: (role: string) => void;
  onBulkUpdateStatus: (status: string) => void;
  onClearSelection: () => void;
}

export function BulkActions({
  selectedCount,
  isSuperAdmin,
  isOperationLoading,
  onBulkDelete,
  onBulkUpdateRole,
  onBulkUpdateStatus,
  onClearSelection,
}: BulkActionsProps) {
  if (selectedCount === 0) return null;

  return (
    <motion.div 
      initial={{ opacity: 0, y: -8 }} 
      animate={{ opacity: 1, y: 0 }} 
      className="bg-blue-50 dark:bg-blue-900/20 border border-blue-200 dark:border-blue-800 rounded-lg p-4 mb-6"
    >
      <div className="flex items-center justify-between">
        <p className="text-blue-900 dark:text-blue-200">
          {selectedCount} user(s) selected
        </p>
        <div className="flex items-center gap-3">
          <select
            onChange={(e) => e.target.value && onBulkUpdateRole(e.target.value)}
            defaultValue=""
            className="text-sm border rounded px-2 py-1 bg-white dark:bg-gray-800 dark:border-gray-700 dark:text-gray-200"
            disabled={isOperationLoading}
          >
            <option value="">Set Role</option>
            {Object.values(UserRole).map((role) => (
              <option key={role} value={role}>
                {role.replace("_", " ").toUpperCase()}
              </option>
            ))}
          </select>
          <select
            onChange={(e) => e.target.value && onBulkUpdateStatus(e.target.value)}
            defaultValue=""
            className="text-sm border rounded px-2 py-1 bg-white dark:bg-gray-800 dark:border-gray-700 dark:text-gray-200"
            disabled={isOperationLoading}
          >
            <option value="">Set Status</option>
            <option value="active">Active</option>
            <option value="inactive">Inactive</option>
            <option value="suspended">Suspended</option>
            <option value="pending">Pending</option>
          </select>
          {isSuperAdmin && (
            <button
              onClick={onBulkDelete}
              disabled={isOperationLoading}
              className="bg-red-600 dark:bg-red-700 text-white px-3 py-1 rounded hover:bg-red-700 dark:hover:bg-red-800 text-sm disabled:opacity-50"
            >
              <FiTrash2 className="inline mr-1" /> Delete
            </button>
          )}
          <button
            onClick={onClearSelection}
            className="text-gray-500 dark:text-gray-400 hover:text-gray-700 dark:hover:text-gray-300 text-sm"
          >
            Cancel
          </button>
        </div>
      </div>
    </motion.div>
  );
}
```

<!-- path: components/users/user-types.ts -->
```typescript
import { Database } from "@/types/supabase-types";
import { Row } from "@/hooks/database";

export type UserProfileRow = Row<"v_user_profiles_extended">;

// Define a type for the user data row directly from the auto-generated Supabase types.
// This ensures type safety and that the type is always in sync with the database view.
export type UserProfileData = Database["public"]["Views"]["v_user_profiles_extended"]["Row"];
```

<!-- path: components/users/UserProfileEditModal.tsx -->
```typescript
'use client';

import React, { useEffect } from 'react';
import { FiShield } from 'react-icons/fi';
import {
  useAdminUpdateUserProfile,
  useGetMyRole,
  useIsSuperAdmin,
} from '@/hooks/useAdminUsers';
import { toast } from 'sonner';
import { UserRole } from '@/types/user-roles';
import Image from 'next/image';
import { useForm, Controller } from 'react-hook-form';
import { zodResolver } from '@hookform/resolvers/zod';
import { FormInput, FormDateInput } from '../common/form/FormControls'; // Import your new controls
import { Input, Label, Modal } from '@/components/common/ui';
import { FormCard } from '@/components/common/form/FormCard';
import {
  user_profilesInsertSchema,
  User_profilesInsertSchema,
  User_profilesRowSchema,
} from '@/schemas/zod-schemas';

interface UserProfileEditProps {
  user: User_profilesRowSchema | null;
  onClose: () => void;
  onSave?: () => void; // Optional callback for when save is successful
  isOpen: boolean;
}

// Helper to safely parse JSON-like data
const toObject = (val: unknown): Record<string, unknown> => {
  if (!val) return {};
  if (typeof val === 'object') return val as Record<string, unknown>;
  return {};
};

const UserProfileEditModal: React.FC<UserProfileEditProps> = ({
  isOpen,
  user,
  onClose,
  onSave,
}) => {
  // === React Hook Form Setup ===
  const {
    register,
    handleSubmit,
    formState: { errors, isSubmitting, isDirty },
    reset,
    control,
    watch,
  } = useForm<User_profilesInsertSchema>({
    resolver: zodResolver(user_profilesInsertSchema),
    // Initialize with empty defaults. We will populate it with an effect.
    defaultValues: {
      first_name: user?.first_name,
      last_name: user?.last_name,
      avatar_url: user?.avatar_url,
      phone_number: user?.phone_number,
      date_of_birth: user?.date_of_birth,
      address: user?.address ? toObject(user.address) : {},
      preferences: user?.preferences ? toObject(user.preferences) : {},
      role: user?.role,
      designation: user?.designation,
      status: user?.status,
    },
  });

  useEffect(() => {
    if (!isOpen) return;
    if (user) {
      reset({
        first_name: user?.first_name,
        last_name: user?.last_name,
        avatar_url: user?.avatar_url,
        phone_number: user?.phone_number,
        date_of_birth: user?.date_of_birth,
        address: user?.address ? toObject(user.address) : {},
        preferences: user?.preferences ? toObject(user.preferences) : {},
        role: user?.role,
        designation: user?.designation,
        status: user?.status,
      });
    } else {
      // If the modal is opened for a new user, reset to blank fields
      reset({
        first_name: '',
        last_name: '',
        avatar_url: null,
        phone_number: null,
        date_of_birth: null,
        address: null,
        preferences: null,
        role: UserRole.VIEWER,
        designation: null,
        status: 'inactive',
      });
    }
  }, [isOpen, reset, user]);

  // Watch the avatar_url for live preview
  const avatarUrl = watch('avatar_url');

  // === Data Fetching and Mutation Hooks ===
  const { data: currentUserRole } = useGetMyRole();
  const { data: isSuperAdmin } = useIsSuperAdmin();
  const updateProfile = useAdminUpdateUserProfile();

  // === Form Submission Handler ===
  const onValidSubmit = async (data: User_profilesInsertSchema) => {
    if (!isDirty) {
      toast.info('No changes to save.');
      onClose();
      return;
    }

    // Create the update payload only with changed fields
    const updateParams: { user_id: string; [key: string]: unknown } = {
      user_id: user?.id || '',
    };

    (Object.keys(data) as Array<keyof User_profilesInsertSchema>).forEach(
      (key) => {
        if (
          JSON.stringify(data[key]) !==
          JSON.stringify((user as User_profilesInsertSchema)[key])
        ) {
          // Special handling for date to ensure correct format
          if (key === 'date_of_birth' && data.date_of_birth) {
            updateParams[`update_${key}`] = data.date_of_birth;
          } else {
            updateParams[`update_${key}`] = data[key];
          }
        }
      }
    );

    try {
      await updateProfile.mutateAsync(updateParams);
      onSave?.(); // Call the parent's onSave to trigger refetch
    } catch (error) {
      // The hook itself will show a toast error message
      console.error('Update failed:', error);
    }
    onClose();
  };


  return (
    <Modal isOpen={isOpen} onClose={onClose} title="Edit User Profile" size="full" visible={false}
      className="h-screen w-screen transparent bg-gray-700 rounded-2xl">
      <FormCard
        onSubmit={handleSubmit(onValidSubmit)}
        isLoading={isSubmitting}
        title="Edit User Profile"
        onCancel={onClose}
      >
        <div className="p-6 space-y-6">
          {/* Profile Image & URL */}
          <div className="flex items-center gap-4">
            <Image
              src={avatarUrl || '/default-avatar.png'}
              alt="Profile"
              width={64}
              height={64}
              className="w-16 h-16 rounded-full object-cover bg-gray-200"
            />
            <div className="flex-1">
              <FormInput
                name="avatar_url"
                label="Avatar URL"
                register={register}
                error={errors.avatar_url}
                placeholder="https://example.com/avatar.jpg"
              />
            </div>
          </div>

          {/* Name */}
          <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
            <FormInput
              name="first_name"
              label="First Name"
              register={register}
              error={errors.first_name}
              required
            />
            <FormInput
              name="last_name"
              label="Last Name"
              register={register}
              error={errors.last_name}
              required
            />
          </div>

          {/* Contact */}
          <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
            <FormInput
              name="phone_number"
              label="Phone Number"
              register={register}
              error={errors.phone_number}
              type="tel"
            />
            <FormDateInput
              name="date_of_birth"
              label="Date of Birth"
              control={control}
              error={errors.date_of_birth}
              placeholder="YYYY-MM-DD"
              pickerProps={{
                maxDate: new Date(),
                dateFormat: 'yyyy-MM-dd',
                showMonthDropdown: true,
                showYearDropdown: true,
                yearDropdownItemNumber: 100,
                scrollableYearDropdown: true,
                withPortal: true,
                popperPlacement: 'bottom-start',
              }}
            />
          </div>

          {/* Designation */}
          <FormInput
            name="designation"
            label="Designation"
            register={register}
            error={errors.designation}
            placeholder="e.g., Senior Engineer"
          />

          {/* *** THE FIX IS HERE: Use Controller for Address Fields *** */}
          <div>
            <Label>Address</Label>
            <div className="grid grid-cols-1 md:grid-cols-2 gap-4 mt-1">
              <Controller
                name="address.street"
                control={control}
                render={({ field }) => (
                  <Input
                    {...field}
                    value={field.value || ''}
                    placeholder="Street Address"
                    error={(errors.address as any)?.street?.message}
                  />
                )}
              />
              <Controller
                name="address.city"
                control={control}
                render={({ field }) => (
                  <Input
                    {...field}
                    value={field.value || ''}
                    placeholder="City"
                    error={(errors.address as any)?.city?.message}
                  />
                )}
              />
              <Controller
                name="address.state"
                control={control}
                render={({ field }) => (
                  <Input
                    {...field}
                    value={field.value || ''}
                    placeholder="State/Province"
                    error={(errors.address as any)?.state?.message}
                  />
                )}
              />
              <Controller
                name="address.zip_code"
                control={control}
                render={({ field }) => (
                  <Input
                    {...field}
                    value={field.value || ''}
                    placeholder="ZIP/Postal Code"
                    error={(errors.address as any)?.zip_code?.message}
                  />
                )}
              />
            </div>
          </div>
          {/* Users Preferences */}
          <div>
            <Label>Preferences</Label>
            <div className="grid grid-cols-1 md:grid-cols-2 gap-4 mt-1">
              <Label>Language</Label>
              <select
                id="language"
                {...register('preferences.language')}
                className="w-full mt-1 px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-lg dark:bg-gray-700 dark:text-white"
              >
                <option value="en">English</option>
              </select>
            </div>
          </div>

          {(isSuperAdmin || currentUserRole === 'admin') && (
            <div className="border-t border-gray-200 dark:border-gray-700 pt-6">
              <h3 className="text-lg font-medium text-gray-900 dark:text-white mb-4 flex items-center gap-2">
                <FiShield className="text-orange-500" /> Administrative Settings
              </h3>
              <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
                <div>
                  <Label htmlFor="role" required>
                    Role
                  </Label>
                  <select
                    id="role"
                    {...register('role')}
                    className="w-full mt-1 px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-lg dark:bg-gray-700 dark:text-white"
                  >
                    {Object.values(UserRole).map((role) => (
                      <option key={role} value={role}>
                        {role.replace(/_/g, ' ').toUpperCase()}
                      </option>
                    ))}
                  </select>
                </div>
                <div>
                  <Label htmlFor="status" required>
                    Status
                  </Label>
                  <select
                    id="status"
                    {...register('status')}
                    className="w-full mt-1 px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-lg dark:bg-gray-700 dark:text-white"
                  >
                    <option value="active">Active</option>
                    <option value="inactive">Inactive</option>
                    <option value="suspended">Suspended</option>
                  </select>
                </div>
              </div>
            </div>
          )}
        </div>
      </FormCard>
    </Modal>
  );
};

export default UserProfileEditModal;

```

<!-- path: components/users/UserCreateModal.tsx -->
```typescript
import React from 'react';
import { Button } from '@/components/common/ui/Button';
import { Input } from '@/components/common/ui/Input';
import { useForm, Controller, useFormContext, type FieldValues, type UseFormReturn } from 'react-hook-form';
import { z } from 'zod';
import { zodResolver } from '@hookform/resolvers/zod';
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from '@/components/common/ui/select/Select';
import { Modal } from '@/components/common/ui/Modal/Modal';
import { FormCard, FormInput } from '@/components/common/form';
import { v4 as uuidv4 } from 'uuid';

const userSchema = z.object({
  id: z.string().uuid().optional(),
  email: z.email('Please enter a valid email address'),
  password: z.string().min(8, 'Password must be at least 8 characters'),
  first_name: z.string().min(1, 'First name is required'),
  last_name: z.string().min(1, 'Last name is required'),
  role: z.string().min(1, 'Role is required'),
  email_confirm: z.boolean().catch(false), //  ensures boolean
});

type UserFormData = z.infer<typeof userSchema>;

interface UserCreateModalProps {
  isOpen: boolean;
  onClose: () => void;
  onCreate: (data: UserFormData) => Promise<void>;
  isLoading: boolean;
}

export function UserCreateModal({
  isOpen,
  onClose,
  onCreate,
  isLoading,
}: UserCreateModalProps) {
  const form = useForm<UserFormData>({
    resolver: zodResolver(userSchema),
    defaultValues: {
      id: '',
      email: '',
      password: '',
      first_name: '',
      last_name: '',
      role: 'viewer',
      email_confirm: false, //  always boolean
    },
  });

  const {
    register,
    handleSubmit,
    control,
    formState: { errors, isDirty, isValid },
    reset,
  } = form;

  const onValidSubmit = async (data: UserFormData) => {
    try {
      // Auto-generate UUID if not provided
      const payload = {
        ...data,
        id: data.id && data.id.trim() !== '' ? data.id : uuidv4(),
      };

      await onCreate(payload);
      reset();
      onClose();
    } catch (error: any) {
      console.error('Error creating user:', error);
    }
  };

  return (
    <Modal isOpen={isOpen} onClose={onClose} title="Create New User" visible={false}
      className="h-screen w-screen transparent bg-gray-700 rounded-2xl">
      <FormCard
        title="Create New User"
        onCancel={onClose}
        onSubmit={handleSubmit(onValidSubmit)}
        isLoading={isLoading}
      >
        <div className="space-y-4">
          {/* Optional ID */}
          <FormInput
            name="id"
            label="User ID (optional)"
            placeholder="Leave blank to auto-generate"
            register={register}
            error={errors.id}
          />

          <div className="grid grid-cols-2 gap-4">
            <FormInput
              name="first_name"
              label="First Name"
              register={register}
              error={errors.first_name}
              required
            />
            <FormInput
              name="last_name"
              label="Last Name"
              register={register}
              error={errors.last_name}
              required
            />
          </div>

          <FormInput
            name="email"
            placeholder="user@example.com"
            label="Email"
            error={errors.email}
            register={register}
            required
          />

          <FormInput
            name="password"
            type="password"
            placeholder=""
            label="Password"
            error={errors.password}
            register={register}
            required
          />

          {/* Role Select with Controller */}
          <Controller
            control={control}
            name="role"
            defaultValue="viewer" //  add this
            render={({ field }) => (
              <div>
                <label className="block text-sm font-medium mb-1">Role</label>
                <Select onValueChange={field.onChange} value={field.value}>
                  <SelectTrigger>
                    <SelectValue placeholder="Select a role" />
                  </SelectTrigger>
                  <SelectContent>
                    <SelectItem value="viewer">Viewer</SelectItem>
                    <SelectItem value="admin">Admin</SelectItem>
                    <SelectItem value="maan_admin">MAAN Admin</SelectItem>
                    <SelectItem value="sdh_admin">SDH Admin</SelectItem>
                    <SelectItem value="vmux_admin">VMUX Admin</SelectItem>
                    <SelectItem value="mng_admin">MNG Admin</SelectItem>
                  </SelectContent>
                </Select>
                {errors.role && (
                  <p className="text-sm text-red-500 mt-1">
                    {errors.role.message}
                  </p>
                )}
              </div>
            )}
          />

          {/* Email Confirm Checkbox */}
          <Controller
            control={control}
            name="email_confirm"
            defaultValue={false} //  add this
            render={({ field }) => (
              <label className="flex items-center space-x-2">
                <input
                  type="checkbox"
                  checked={field.value}
                  onChange={(e) => field.onChange(e.target.checked)}
                  className="h-4 w-4"
                />
                <span className="text-sm">Confirm Email Immediately</span>
              </label>
            )}
          />
        </div>
      </FormCard>
    </Modal>
  );
}

```

<!-- path: components/employee/employee-types.ts -->
```typescript
// app/dashboard/employees/types.ts
import {
  Employee_designationsInsertSchema,
  EmployeesInsertSchema,
  Maintenance_areasInsertSchema,
} from '@/schemas/zod-schemas';

export type EmployeeWithRelations = EmployeesInsertSchema & {
  maintenance_areas: Maintenance_areasInsertSchema | null;
  employee_designations: Employee_designationsInsertSchema | null;
};

```

<!-- path: components/employee/EmployeeFilters.tsx -->
```typescript
'use client';

import React, { memo, useState, useEffect } from 'react';
import { FiFilter, FiSearch } from 'react-icons/fi';
import { SearchableSelect } from '@/components/common/ui/select/SearchableSelect';
import { Filters, Row } from '@/hooks/database';
import { useDebounce } from 'use-debounce'; // <-- IMPORT useDebounce
import { DEFAULTS } from '@/config/constants';
import {
  Employee_designationsRowSchema,
  Maintenance_areasRowSchema,
} from '@/schemas/zod-schemas';

interface EmployeeFiltersProps {
  searchQuery: string; // This prop is now used to set the initial value
  filters: Filters;
  showFilters: boolean;
  designations: Employee_designationsRowSchema[];
  maintenanceAreas: Maintenance_areasRowSchema[];
  onSearchChange: (value: string) => void;
  onFilterToggle: () => void;
  onDesignationChange: (value: string) => void;
  onStatusChange: (value: 'true' | 'false' | '') => void;
  onMaintenanceAreaChange: (value: string) => void;
}

const EmployeeFiltersComponent = memo(
  ({
    searchQuery,
    filters,
    showFilters,
    designations,
    maintenanceAreas,
    onSearchChange,
    onFilterToggle,
    onDesignationChange,
    onStatusChange,
    onMaintenanceAreaChange,
  }: EmployeeFiltersProps) => {
    // --- DEBOUNCING LOGIC ---
    const [internalSearch, setInternalSearch] = useState(searchQuery);
    const [debouncedSearch] = useDebounce(
      internalSearch,
      DEFAULTS.DEBOUNCE_DELAY
    );

    // Effect to call the parent's onSearchChange only when the debounced value changes
    useEffect(() => {
      onSearchChange(debouncedSearch);
    }, [debouncedSearch, onSearchChange]);

    // Effect to sync the internal state if the parent's state changes (e.g., from a "clear all" button)
    useEffect(() => {
      setInternalSearch(searchQuery);
    }, [searchQuery]);
    // --- END DEBOUNCING LOGIC ---

    return (
      <div className="mb-6 rounded-lg border bg-white p-4 shadow-sm dark:border-gray-700 dark:bg-gray-800">
        <div className="flex flex-col items-start justify-between gap-4 sm:flex-row sm:items-center">
          <div className="flex flex-1 flex-col gap-3 sm:flex-row">
            <div className="relative">
              <FiSearch className="absolute top-1/2 left-3 h-4 w-4 -translate-y-1/2 transform text-gray-400 dark:text-gray-500" />
              <input
                type="text"
                placeholder="Search employees..."
                value={internalSearch} // <-- Use internal state for immediate input feedback
                onChange={(e) => setInternalSearch(e.target.value)} // <-- Update internal state on every keystroke
                onKeyDown={(e) => e.stopPropagation()}
                className="w-full rounded-md border border-gray-300 py-2 pr-4 pl-10 focus:ring-2 focus:ring-blue-500 focus:outline-none dark:border-gray-600 dark:bg-gray-700 dark:text-white dark:focus:ring-blue-600 sm:w-80"
              />
            </div>
            <button
              type="button"
              onClick={onFilterToggle}
              className={`flex items-center gap-2 rounded-md border px-3 py-2 transition-colors ${
                showFilters
                  ? 'border-blue-200 bg-blue-50 text-blue-700 dark:border-blue-800 dark:bg-blue-900/50 dark:text-blue-200'
                  : 'border-gray-300 bg-white text-gray-700 hover:bg-gray-50 dark:border-gray-600 dark:bg-gray-700 dark:text-gray-300 dark:hover:bg-gray-600'
              }`}
            >
              <FiFilter className="h-4 w-4" />
              Filters
            </button>
          </div>
        </div>

        {showFilters && (
          <div className="mt-4 grid grid-cols-1 gap-3 border-t pt-4 dark:border-gray-700 sm:grid-cols-3">
            <SearchableSelect
              options={designations.map((d) => ({
                value: d.id,
                label: d.name,
              }))}
              value={filters.employee_designation_id as string}
              onChange={(v) => onDesignationChange(v ?? '')}
              placeholder="All Designations"
              searchPlaceholder="Search designations..."
              clearable={true}
            />
            <select
              value={filters.status as string}
              onChange={(e) =>
                onStatusChange(e.target.value as 'true' | 'false')
              }
              className="rounded-md border border-gray-300 px-3 py-2 focus:ring-2 focus:ring-blue-500 focus:outline-none dark:border-gray-600 dark:bg-gray-700 dark:text-white dark:focus:ring-blue-600"
            >
              <option value="">All Status</option>
              <option value="true">Active</option>
              <option value="false">Inactive</option>
            </select>
            <SearchableSelect
              options={maintenanceAreas.map((area) => ({
                value: area.id,
                label: `${area.name}${area.code ? ` (${area.code})` : ''}`,
              }))}
              value={filters.maintenance_terminal_id as string}
              onChange={(v) => onMaintenanceAreaChange(v ?? '')}
              placeholder="All Maintenance Areas"
              searchPlaceholder="Search areas..."
              clearable={true}
            />
          </div>
        )}
      </div>
    );
  }
);

EmployeeFiltersComponent.displayName = 'EmployeeFilters';
export default EmployeeFiltersComponent;

```

<!-- path: components/employee/EmployeeTableActions.tsx -->
```typescript
import { FiEdit, FiTrash2, FiToggleRight, FiEye } from "react-icons/fi";
import { TableAction } from "@/components/table/datatable-types";
import { Row } from "@/hooks/database";

interface EmployeeTableActionsProps {
  onView: (employeeId: string) => void;
  onEdit: (employeeId: string) => void;
  onToggleStatus: (record: Row<"employees">) => void;
  onDelete: (employeeId: string, displayName?: string) => void;
}

export const getEmployeeTableActions = ({
  onView,
  onEdit,
  onToggleStatus,
  onDelete,
}: EmployeeTableActionsProps): TableAction<"employees">[] => [
  {
    key: "view",
    label: "View",
    icon: <FiEye className='w-4 h-4' />,
    onClick: (record) => onView(record.id || ""),
    variant: "primary",
  },
  {
    key: "toggle",
    label: "Toggle Status",
    icon: <FiToggleRight className='w-4 h-4' />,
    onClick: (record) => onToggleStatus(record),
    variant: "secondary",
  },
  {
    key: "edit",
    label: "Edit",
    icon: <FiEdit className='w-4 h-4' />,
    onClick: (record) => onEdit(record.id || ""),
    variant: "primary",
  },
  {
    key: "delete",
    label: "Delete",
    icon: <FiTrash2 className='w-4 h-4' />,
    onClick: (record) => onDelete(record.id || "", String(record.employee_name || "this employee")),
    variant: "danger",
  },
];

```

<!-- path: components/employee/EmployeeDetailsModal.tsx -->
```typescript
import { motion } from "framer-motion";
import { FiX, FiMail, FiPhone, FiUser, FiBriefcase, FiCalendar, FiEdit3 } from "react-icons/fi";
import { createClient } from "@/utils/supabase/client";
import { useTableRecord } from "@/hooks/database";
import { Employee_designationsRowSchema, EmployeesRowSchema } from "@/schemas/zod-schemas";

type Props = {
  employeeId: string;
  onClose: () => void;
  onEdit: () => void;
};

const formatDate = (dateString: string | null | undefined) => {
  if (!dateString) return "Not provided";
  try {
    return new Date(dateString).toLocaleDateString("en-US", {
      year: "numeric",
      month: "long",
      day: "numeric",
    });
  } catch {
    return "Invalid date";
  }
};

const EmployeeDetailsModal = ({ employeeId, onClose, onEdit }: Props) => {
  const supabase = createClient();

  const { data: employee, isLoading, isError, error } = useTableRecord(
    supabase,
    "employees",
    employeeId,
    {
      columns: "*, employee_designations(name), maintenance_areas(name)",
    }
  );

  if (isLoading) {
    return (
      <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50">
        <div className="bg-white p-8 rounded-lg shadow-xl max-w-md w-full mx-4">
          <div className="animate-spin rounded-full h-8 w-8 border-b-2 border-blue-600 mx-auto mb-4" />
          <p className="text-gray-700 text-center">Loading employee details...</p>
        </div>
      </div>
    );
  }

  if (isError || !employee) {
    return (
      <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50">
        <div className="bg-white p-8 rounded-lg shadow-xl max-w-md w-full mx-4 text-center">
          <div className="text-red-500 text-5xl mb-4"></div>
          <h3 className="text-lg font-medium text-gray-900 mb-2">
            {isError ? "Error Loading Employee" : "Employee Not Found"}
          </h3>
          {isError && error && (
            <p className="text-sm text-gray-600 mb-4">{error.message}</p>
          )}
          <button
            onClick={onClose}
            className="bg-gray-600 text-white px-4 py-2 rounded-lg hover:bg-gray-700 transition-colors"
          >
            Close
          </button>
        </div>
      </div>
    );
  }

  const statusBadge = employee.status ? (
    <span className="rounded-full bg-green-100 px-2 py-0.5 text-xs font-medium text-green-800">
      Active
    </span>
  ) : (
    <span className="rounded-full bg-red-100 px-2 py-0.5 text-xs font-medium text-red-800">
      Inactive
    </span>
  );

  return (
    <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 p-4">
      <motion.div
        initial={{ opacity: 0, scale: 0.95 }}
        animate={{ opacity: 1, scale: 1 }}
        exit={{ opacity: 0, scale: 0.95 }}
        className="bg-white dark:bg-gray-800 rounded-lg shadow-xl max-w-2xl w-full max-h-[90vh] overflow-hidden"
      >
        {/* Header */}
        <div className="px-6 py-4 border-b border-gray-200 dark:border-gray-700 flex items-center justify-between bg-gray-50 dark:bg-gray-900/30">
          <div>
            <h2 className="text-xl font-semibold text-gray-900 dark:text-white">
              {employee.employee_name || "Unnamed Employee"}
            </h2>
            <div className="flex items-center gap-2 text-sm text-gray-500 dark:text-gray-400 mt-1">
              {statusBadge}
              {employee.employee_pers_no && <span> {employee.employee_pers_no}</span>}
            </div>
          </div>
          <button
            onClick={onClose}
            className="text-gray-400 hover:text-gray-600 dark:hover:text-gray-200 p-2 rounded-full hover:bg-gray-100 dark:hover:bg-gray-700 transition-colors"
            aria-label="Close modal"
          >
            <FiX size={20} />
          </button>
        </div>

        {/* Content */}
        <div className="p-6 overflow-y-auto max-h-[calc(90vh-140px)] space-y-6">
          {/* Contact Info */}
          <div>
            <h3 className="text-lg font-medium text-gray-900 dark:text-white mb-3 flex items-center gap-2">
              <FiUser className="text-blue-600" />
              Personal & Contact
            </h3>
            <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
              <div>
                <label className="text-sm font-medium text-gray-500 dark:text-gray-400 block mb-1">Email</label>
                <div className="flex items-center gap-2 text-gray-900 dark:text-gray-100">
                  <FiMail className="text-gray-400" />
                  <span>{employee.employee_email || "Not provided"}</span>
                </div>
              </div>
              <div>
                <label className="text-sm font-medium text-gray-500 dark:text-gray-400 block mb-1">Phone</label>
                <div className="flex items-center gap-2 text-gray-900 dark:text-gray-100">
                  <FiPhone className="text-gray-400" />
                  <span>{employee.employee_contact || "Not provided"}</span>
                </div>
              </div>
            </div>
          </div>

          {/* Job Info */}
          <div>
            <h3 className="text-lg font-medium text-gray-900 dark:text-white mb-3 flex items-center gap-2">
              <FiBriefcase className="text-green-600" />
              Job Information
            </h3>
            <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
              <div>
                <label className="text-sm font-medium text-gray-500 dark:text-gray-400 block mb-1">Designation</label>
                <div className="text-gray-900 dark:text-gray-100">{(employee as EmployeesRowSchema & { employee_designations: Employee_designationsRowSchema })?.employee_designations?.name || "Not set"}</div>
              </div>
              <div>
                <label className="text-sm font-medium text-gray-500 dark:text-gray-400 block mb-1">Maintenance Area</label>
                <div className="text-gray-900 dark:text-gray-100">{(employee as  EmployeesRowSchema & { maintenance_areas: Employee_designationsRowSchema })?.maintenance_areas?.name || "Not set"}</div>
              </div>
            </div>
          </div>

          {/* Meta */}
          <div>
            <h3 className="text-lg font-medium text-gray-900 dark:text-white mb-3 flex items-center gap-2">
              <FiCalendar className="text-purple-600" />
              Dates
            </h3>
            <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
              <div>
                <label className="text-sm font-medium text-gray-500 dark:text-gray-400 block mb-1">Created</label>
                <div className="text-gray-900 dark:text-gray-100">{formatDate(employee.created_at as unknown as string)}</div>
              </div>
              <div>
                <label className="text-sm font-medium text-gray-500 dark:text-gray-400 block mb-1">Updated</label>
                <div className="text-gray-900 dark:text-gray-100">{formatDate(employee.updated_at as unknown as string)}</div>
              </div>
            </div>
          </div>
        </div>

        {/* Footer */}
        <div className="px-6 py-4 border-t border-gray-200 dark:border-gray-700 flex items-center justify-end gap-3 bg-gray-50 dark:bg-gray-900/30">
          <button
            onClick={onClose}
            className="px-4 py-2 text-gray-700 dark:text-gray-200 bg-white dark:bg-gray-800 border border-gray-300 dark:border-gray-600 rounded-lg hover:bg-gray-50 dark:hover:bg-gray-700 transition-colors"
          >
            Close
          </button>
          <button
            onClick={onEdit}
            className="flex items-center gap-2 px-4 py-2 bg-blue-600 text-white rounded-lg hover:bg-blue-700 transition-colors"
          >
            <FiEdit3 size={16} />
            Edit Employee
          </button>
        </div>
      </motion.div>
    </div>
  );
};

export default EmployeeDetailsModal;

```

<!-- path: components/employee/EmployeeStats.tsx -->
```typescript
// app/dashboard/employees/components/EmployeeStats.tsx
interface EmployeeStatsProps {
    total: number;
    active: number;
    inactive: number;
  }
  
  export const EmployeeStats = ({ total, active, inactive }: EmployeeStatsProps) => {
    return (
      <div className="mt-6 flex items-center justify-between text-sm text-gray-600 dark:text-gray-400">
        <span>
          Showing {total} employee{total !== 1 ? "s" : ""}
        </span>
        <span>
          {active} active, {inactive} inactive
        </span>
      </div>
    );
  };
```

<!-- path: components/employee/BulkActions.tsx -->
```typescript
import { FiTrash2 } from "react-icons/fi";

interface BulkActionsProps {
  selectedCount: number;
  isOperationLoading?: boolean;
  onBulkDelete: () => void;
  onBulkUpdateStatus: (status: "active" | "inactive") => void;
  onClearSelection: () => void;
}

export function BulkActions({
  selectedCount,
  isOperationLoading = false,
  onBulkDelete,
  onBulkUpdateStatus,
  onClearSelection,
}: BulkActionsProps) {
  if (selectedCount === 0) return null;

  return (
    <div className="bg-blue-50 border border-blue-200 rounded-lg p-4 mb-6 
                   dark:bg-blue-900/20 dark:border-blue-700/50">
      <div className="flex items-center justify-between flex-wrap gap-3">
        <p className="text-blue-900 dark:text-blue-100">
          {selectedCount} employee(s) selected
        </p>
        <div className="flex items-center gap-3">
          <select
            onChange={(e) => {
              const v = e.target.value as "active" | "inactive" | "";
              if (v) onBulkUpdateStatus(v);
            }}
            defaultValue=""
            className="text-sm border rounded px-2 py-1 
                      bg-white text-gray-900 border-gray-300
                      dark:bg-gray-700 dark:text-gray-100 dark:border-gray-600
                      disabled:opacity-50"
            disabled={isOperationLoading}
          >
            <option value="">Set Status</option>
            <option value="active">Active</option>
            <option value="inactive">Inactive</option>
          </select>
          <button
            onClick={onBulkDelete}
            disabled={isOperationLoading}
            className="bg-red-600 text-white px-3 py-1 rounded hover:bg-red-700 
                      dark:bg-red-700 dark:hover:bg-red-800
                      text-sm disabled:opacity-50"
          >
            <FiTrash2 className="inline mr-1" /> Delete
          </button>
          <button 
            onClick={onClearSelection} 
            className="text-gray-500 hover:text-gray-700 
                      dark:text-gray-400 dark:hover:text-gray-300
                      text-sm"
          >
            Cancel
          </button>
        </div>
      </div>
    </div>
  );
}
```

<!-- path: components/employee/EmployeeForm.tsx -->
```typescript
import { useForm } from 'react-hook-form';
import { zodResolver } from '@hookform/resolvers/zod';
import { Option } from '@/components/common/ui/select/SearchableSelect';
import { EmployeeWithRelations } from './employee-types';
import {
  FormDateInput,
  FormInput,
  FormSearchableSelect,
  FormTextarea,
} from '@/components/common/form/FormControls';
import { Modal } from '@/components/common/ui';
import { FormCard } from '@/components/common/form';
import { useEffect } from 'react';
import {
  Employee_designationsRowSchema,
  employeesInsertSchema,
  EmployeesInsertSchema,
  Maintenance_areasRowSchema,
} from '@/schemas/zod-schemas';

interface EmployeeFormProps {
  isOpen: boolean;
  onClose: () => void;
  employee?: EmployeeWithRelations | null;
  onSubmit: (data: EmployeesInsertSchema) => void;
  onCancel: () => void;
  isLoading: boolean;
  designations: Employee_designationsRowSchema[];
  maintenanceAreas: Maintenance_areasRowSchema[];
}

const EmployeeForm = ({
  isOpen,
  onClose,
  employee,
  onSubmit,
  isLoading,
  designations,
  maintenanceAreas,
}: EmployeeFormProps) => {
  const {
    control,
    handleSubmit,
    register,
    formState: { errors },
    reset,
  } = useForm<EmployeesInsertSchema>({
    resolver: zodResolver(employeesInsertSchema),
    defaultValues: {
      employee_name: employee?.employee_name,
      employee_pers_no: employee?.employee_pers_no,
      employee_designation_id: employee?.employee_designation_id,
      employee_contact: employee?.employee_contact,
      employee_email: employee?.employee_email,
      employee_dob: employee?.employee_dob,
      employee_doj: employee?.employee_doj,
      employee_addr: employee?.employee_addr,
      maintenance_terminal_id: employee?.maintenance_terminal_id,
      remark: employee?.remark,
    },
  });

  useEffect(() => {
    if (employee) {
      const defaultValues = {
        employee_name: employee?.employee_name,
        employee_pers_no: employee?.employee_pers_no,
        employee_designation_id: employee?.employee_designation_id,
        employee_contact: employee?.employee_contact,
        employee_email: employee?.employee_email,
        employee_dob: employee?.employee_dob,
        employee_doj: employee?.employee_doj,
        employee_addr: employee?.employee_addr,
        maintenance_terminal_id: employee?.maintenance_terminal_id,
        remark: employee?.remark,
      };
      reset(defaultValues);
    } else {
      reset({
        employee_name: '',
        employee_pers_no: null,
        employee_designation_id: null,
        employee_contact: null,
        employee_email: null,
        employee_dob: null,
        employee_doj: null,
        employee_addr: null,
        maintenance_terminal_id: null,
        remark: null,
      });
    }
  }, [employee, reset]);

  const designationOptions: Option[] = designations.map((d) => ({
    value: d.id,
    label: d.name,
  }));

  const maintenanceAreaOptions: Option[] = maintenanceAreas.map((area) => ({
    value: area.id,
    label: `${area.name}${area.code ? ` (${area.code})` : ''}`,
  }));

  const handleClose = () => {
    onClose();
  };

  const onValidFormSubmit = (data: EmployeesInsertSchema) => {
    onSubmit(data);
  };

  const loading = isLoading;

  return (
    <Modal
      isOpen={isOpen}
      onClose={handleClose}
      title={''}
      size="full"
      visible={false}
      className="h-screen w-screen transparent bg-gray-700 rounded-2xl"
    >
      <FormCard
        title={employee ? 'Edit Employee' : 'Add New Employee'}
        onSubmit={handleSubmit(onValidFormSubmit)}
        onCancel={handleClose}
        isLoading={loading}
        disableSubmit={loading}
        standalone
      >
        <div className="space-y-4">
          <div className="grid grid-cols-1 gap-4 md:grid-cols-2">
            <FormInput
              name="employee_name"
              label="Employee Name"
              id="employee_name"
              register={register}
              error={errors.employee_name}
              required
              placeholder="Enter employee name"
            />
            <FormInput
              name="employee_pers_no"
              label="Personnel Number"
              id="employee_pers_no"
              register={register}
              error={errors.employee_pers_no}
              placeholder="Enter personnel number"
            />
            <FormSearchableSelect
              name="employee_designation_id"
              label="Designation"
              control={control}
              options={designationOptions}
              error={errors.employee_designation_id}
              placeholder="Select designation"
              searchPlaceholder="Search designations..."
            />
            <FormInput
              name="employee_contact"
              label="Contact Number"
              id="employee_contact"
              register={register}
              error={errors.employee_contact}
              type="tel"
              placeholder="Enter contact number"
            />
            <FormInput
              name="employee_email"
              label="Email Address"
              id="employee_email"
              register={register}
              error={errors.employee_email}
              type="email"
              placeholder="Enter email address"
            />
            <FormDateInput
              name="employee_dob"
              label="Date of Birth"
              control={control}
              error={errors.employee_dob}
              placeholder="Select date of birth"
            />
            <FormDateInput
              name="employee_doj"
              label="Date of Joining"
              control={control}
              error={errors.employee_doj}
              placeholder="Select date of joining"
            />
            <FormSearchableSelect
              name="maintenance_terminal_id"
              label="Maintenance Area"
              control={control}
              options={maintenanceAreaOptions}
              error={errors.maintenance_terminal_id}
              placeholder="Select maintenance area"
              searchPlaceholder="Search maintenance areas..."
            />
          </div>

          <FormTextarea
            name="employee_addr"
            label="Address"
            id="employee_addr"
            control={control}
            error={errors.employee_addr}
            rows={3}
            placeholder="Enter address"
          />

          <FormTextarea
            name="remark"
            label="Remarks"
            id="remark"
            control={control}
            error={errors.remark}
            rows={2}
            placeholder="Enter remarks"
          />
        </div>
      </FormCard>
    </Modal>
  );
};

export default EmployeeForm;

```

<!-- path: components/employee/EmployeeTableColumns.tsx -->
```typescript
import { Column } from '@/hooks/database/excel-queries/excel-helpers';
import { Row } from '@/hooks/database';
import { StatusBadge } from '@/components/common/ui/badges/StatusBadge';

// Columns for employees table using DataTable component
// Note: We type columns against Row<"employees">; relation fields are accessed via custom render using any casts.
type LookupOptions = {
  designationMap?: Record<string, string>;
  areaMap?: Record<string, string>;
};

export const getEmployeeTableColumns = (
  options?: LookupOptions
): Column<Row<'employees'>>[] => [
  {
    title: 'Employee',
    dataIndex: 'employee_name',
    key: 'employee_name',
    width: 220,
    searchable: true,
    render: (_, record: Row<'employees'>) => (
      <div className="min-w-[180px]">
        <div className="font-medium text-gray-900 dark:text-white">
          {record.employee_name || ''}
        </div>
        {record.employee_pers_no && (
          <div className="text-xs text-gray-500 dark:text-gray-400">
            ID: {record.employee_pers_no}
          </div>
        )}
      </div>
    ),
  },
  {
    title: 'Contact',
    dataIndex: 'employee_contact',
    key: 'contact',
    width: 220,
    searchable: true,
    render: (_, record: Row<'employees'>) => (
      <div className="space-y-1">
        {record.employee_contact && (
          <div className="text-sm text-gray-700 dark:text-gray-300">
            {record.employee_contact}
          </div>
        )}
      </div>
    ),
  },
  {
    title: 'Email',
    dataIndex: 'employee_contact',
    key: 'email',
    width: 220,
    searchable: true,
    render: (_, record: Row<'employees'>) => (
      <div className="space-y-1">
        {record.employee_email && (
          <div className="text-sm text-gray-700 dark:text-gray-300">
            {record.employee_email}
          </div>
        )}
      </div>
    ),
  },
  {
    title: 'Designation',
    dataIndex: 'employee_designation_id',
    key: 'designation',
    width: 180,
    render: (_, record: Row<'employees'>) => {
      const id = record?.employee_designation_id as unknown as string | null;
      return (id && options?.designationMap?.[id]) || 'Not set';
    },
  },
  {
    title: 'Maintenance Area',
    dataIndex: 'maintenance_terminal_id',
    key: 'maintenance_area',
    width: 200,
    render: (_, record: Row<'employees'>) => {
      const id = record?.maintenance_terminal_id as unknown as string | null;
      return (id && options?.areaMap?.[id]) || 'Not set';
    },
  },
  {
    title: 'Address',
    dataIndex: 'employee_addr',
    key: 'employee_addr',
    width: 300,
  },
  {
    title: 'Status',
    dataIndex: 'status',
    key: 'status',
    width: 120,
    render: (value: unknown) => <StatusBadge status={!!value} />,
  },
  // {
  //   title: "Created",
  //   dataIndex: "created_at",
  //   key: "created_at",
  //   width: 180,
  //   render: (value: string | null) => (value ? formatDate(value, { format: "dd/mm/yyyy" }) : ""),
  // },
  // {
  //   title: "Updated",
  //   dataIndex: "updated_at",
  //   key: "updated_at",
  //   width: 180,
  //   render: (value: string | null) => (value ? formatDate(value, { format: "dd/mm/yyyy" }) : ""),
  // },
];

```

<!-- path: types/error-types.ts -->
```typescript
export type DetailedError = Error & { details?: unknown };

export function hasDetails(error: unknown): error is DetailedError {
  return typeof error === "object" && error !== null && "details" in error;
}
```

<!-- path: types/pollyfills.d.ts -->
```typescript
declare module 'core-js/stable';
declare module 'regenerator-runtime/runtime';
declare module 'whatwg-fetch';
declare module 'intersection-observer';
declare module 'url-polyfill';
```

<!-- path: types/supabase-types.ts -->
```typescript
export type Json =
  | string
  | number
  | boolean
  | null
  | { [key: string]: Json | undefined }
  | Json[]

export type Database = {
  // Allows to automatically instantiate createClient with right options
  // instead of createClient<Database, { PostgrestVersion: 'XX' }>(URL, KEY)
  __InternalSupabase: {
    PostgrestVersion: "13.0.4"
  }
  auth: {
    Tables: {
      audit_log_entries: {
        Row: {
          created_at: string | null
          id: string
          instance_id: string | null
          ip_address: string
          payload: Json | null
        }
        Insert: {
          created_at?: string | null
          id: string
          instance_id?: string | null
          ip_address?: string
          payload?: Json | null
        }
        Update: {
          created_at?: string | null
          id?: string
          instance_id?: string | null
          ip_address?: string
          payload?: Json | null
        }
        Relationships: []
      }
      flow_state: {
        Row: {
          auth_code: string
          auth_code_issued_at: string | null
          authentication_method: string
          code_challenge: string
          code_challenge_method: Database["auth"]["Enums"]["code_challenge_method"]
          created_at: string | null
          id: string
          provider_access_token: string | null
          provider_refresh_token: string | null
          provider_type: string
          updated_at: string | null
          user_id: string | null
        }
        Insert: {
          auth_code: string
          auth_code_issued_at?: string | null
          authentication_method: string
          code_challenge: string
          code_challenge_method: Database["auth"]["Enums"]["code_challenge_method"]
          created_at?: string | null
          id: string
          provider_access_token?: string | null
          provider_refresh_token?: string | null
          provider_type: string
          updated_at?: string | null
          user_id?: string | null
        }
        Update: {
          auth_code?: string
          auth_code_issued_at?: string | null
          authentication_method?: string
          code_challenge?: string
          code_challenge_method?: Database["auth"]["Enums"]["code_challenge_method"]
          created_at?: string | null
          id?: string
          provider_access_token?: string | null
          provider_refresh_token?: string | null
          provider_type?: string
          updated_at?: string | null
          user_id?: string | null
        }
        Relationships: []
      }
      identities: {
        Row: {
          created_at: string | null
          email: string | null
          id: string
          identity_data: Json
          last_sign_in_at: string | null
          provider: string
          provider_id: string
          updated_at: string | null
          user_id: string
        }
        Insert: {
          created_at?: string | null
          email?: string | null
          id?: string
          identity_data: Json
          last_sign_in_at?: string | null
          provider: string
          provider_id: string
          updated_at?: string | null
          user_id: string
        }
        Update: {
          created_at?: string | null
          email?: string | null
          id?: string
          identity_data?: Json
          last_sign_in_at?: string | null
          provider?: string
          provider_id?: string
          updated_at?: string | null
          user_id?: string
        }
        Relationships: [
          {
            foreignKeyName: "identities_user_id_fkey"
            columns: ["user_id"]
            isOneToOne: false
            referencedRelation: "users"
            referencedColumns: ["id"]
          },
        ]
      }
      instances: {
        Row: {
          created_at: string | null
          id: string
          raw_base_config: string | null
          updated_at: string | null
          uuid: string | null
        }
        Insert: {
          created_at?: string | null
          id: string
          raw_base_config?: string | null
          updated_at?: string | null
          uuid?: string | null
        }
        Update: {
          created_at?: string | null
          id?: string
          raw_base_config?: string | null
          updated_at?: string | null
          uuid?: string | null
        }
        Relationships: []
      }
      mfa_amr_claims: {
        Row: {
          authentication_method: string
          created_at: string
          id: string
          session_id: string
          updated_at: string
        }
        Insert: {
          authentication_method: string
          created_at: string
          id: string
          session_id: string
          updated_at: string
        }
        Update: {
          authentication_method?: string
          created_at?: string
          id?: string
          session_id?: string
          updated_at?: string
        }
        Relationships: [
          {
            foreignKeyName: "mfa_amr_claims_session_id_fkey"
            columns: ["session_id"]
            isOneToOne: false
            referencedRelation: "sessions"
            referencedColumns: ["id"]
          },
        ]
      }
      mfa_challenges: {
        Row: {
          created_at: string
          factor_id: string
          id: string
          ip_address: unknown
          otp_code: string | null
          verified_at: string | null
          web_authn_session_data: Json | null
        }
        Insert: {
          created_at: string
          factor_id: string
          id: string
          ip_address: unknown
          otp_code?: string | null
          verified_at?: string | null
          web_authn_session_data?: Json | null
        }
        Update: {
          created_at?: string
          factor_id?: string
          id?: string
          ip_address?: unknown
          otp_code?: string | null
          verified_at?: string | null
          web_authn_session_data?: Json | null
        }
        Relationships: [
          {
            foreignKeyName: "mfa_challenges_auth_factor_id_fkey"
            columns: ["factor_id"]
            isOneToOne: false
            referencedRelation: "mfa_factors"
            referencedColumns: ["id"]
          },
        ]
      }
      mfa_factors: {
        Row: {
          created_at: string
          factor_type: Database["auth"]["Enums"]["factor_type"]
          friendly_name: string | null
          id: string
          last_challenged_at: string | null
          phone: string | null
          secret: string | null
          status: Database["auth"]["Enums"]["factor_status"]
          updated_at: string
          user_id: string
          web_authn_aaguid: string | null
          web_authn_credential: Json | null
        }
        Insert: {
          created_at: string
          factor_type: Database["auth"]["Enums"]["factor_type"]
          friendly_name?: string | null
          id: string
          last_challenged_at?: string | null
          phone?: string | null
          secret?: string | null
          status: Database["auth"]["Enums"]["factor_status"]
          updated_at: string
          user_id: string
          web_authn_aaguid?: string | null
          web_authn_credential?: Json | null
        }
        Update: {
          created_at?: string
          factor_type?: Database["auth"]["Enums"]["factor_type"]
          friendly_name?: string | null
          id?: string
          last_challenged_at?: string | null
          phone?: string | null
          secret?: string | null
          status?: Database["auth"]["Enums"]["factor_status"]
          updated_at?: string
          user_id?: string
          web_authn_aaguid?: string | null
          web_authn_credential?: Json | null
        }
        Relationships: [
          {
            foreignKeyName: "mfa_factors_user_id_fkey"
            columns: ["user_id"]
            isOneToOne: false
            referencedRelation: "users"
            referencedColumns: ["id"]
          },
        ]
      }
      oauth_clients: {
        Row: {
          client_id: string
          client_name: string | null
          client_secret_hash: string
          client_uri: string | null
          created_at: string
          deleted_at: string | null
          grant_types: string
          id: string
          logo_uri: string | null
          redirect_uris: string
          registration_type: Database["auth"]["Enums"]["oauth_registration_type"]
          updated_at: string
        }
        Insert: {
          client_id: string
          client_name?: string | null
          client_secret_hash: string
          client_uri?: string | null
          created_at?: string
          deleted_at?: string | null
          grant_types: string
          id: string
          logo_uri?: string | null
          redirect_uris: string
          registration_type: Database["auth"]["Enums"]["oauth_registration_type"]
          updated_at?: string
        }
        Update: {
          client_id?: string
          client_name?: string | null
          client_secret_hash?: string
          client_uri?: string | null
          created_at?: string
          deleted_at?: string | null
          grant_types?: string
          id?: string
          logo_uri?: string | null
          redirect_uris?: string
          registration_type?: Database["auth"]["Enums"]["oauth_registration_type"]
          updated_at?: string
        }
        Relationships: []
      }
      one_time_tokens: {
        Row: {
          created_at: string
          id: string
          relates_to: string
          token_hash: string
          token_type: Database["auth"]["Enums"]["one_time_token_type"]
          updated_at: string
          user_id: string
        }
        Insert: {
          created_at?: string
          id: string
          relates_to: string
          token_hash: string
          token_type: Database["auth"]["Enums"]["one_time_token_type"]
          updated_at?: string
          user_id: string
        }
        Update: {
          created_at?: string
          id?: string
          relates_to?: string
          token_hash?: string
          token_type?: Database["auth"]["Enums"]["one_time_token_type"]
          updated_at?: string
          user_id?: string
        }
        Relationships: [
          {
            foreignKeyName: "one_time_tokens_user_id_fkey"
            columns: ["user_id"]
            isOneToOne: false
            referencedRelation: "users"
            referencedColumns: ["id"]
          },
        ]
      }
      refresh_tokens: {
        Row: {
          created_at: string | null
          id: number
          instance_id: string | null
          parent: string | null
          revoked: boolean | null
          session_id: string | null
          token: string | null
          updated_at: string | null
          user_id: string | null
        }
        Insert: {
          created_at?: string | null
          id?: number
          instance_id?: string | null
          parent?: string | null
          revoked?: boolean | null
          session_id?: string | null
          token?: string | null
          updated_at?: string | null
          user_id?: string | null
        }
        Update: {
          created_at?: string | null
          id?: number
          instance_id?: string | null
          parent?: string | null
          revoked?: boolean | null
          session_id?: string | null
          token?: string | null
          updated_at?: string | null
          user_id?: string | null
        }
        Relationships: [
          {
            foreignKeyName: "refresh_tokens_session_id_fkey"
            columns: ["session_id"]
            isOneToOne: false
            referencedRelation: "sessions"
            referencedColumns: ["id"]
          },
        ]
      }
      saml_providers: {
        Row: {
          attribute_mapping: Json | null
          created_at: string | null
          entity_id: string
          id: string
          metadata_url: string | null
          metadata_xml: string
          name_id_format: string | null
          sso_provider_id: string
          updated_at: string | null
        }
        Insert: {
          attribute_mapping?: Json | null
          created_at?: string | null
          entity_id: string
          id: string
          metadata_url?: string | null
          metadata_xml: string
          name_id_format?: string | null
          sso_provider_id: string
          updated_at?: string | null
        }
        Update: {
          attribute_mapping?: Json | null
          created_at?: string | null
          entity_id?: string
          id?: string
          metadata_url?: string | null
          metadata_xml?: string
          name_id_format?: string | null
          sso_provider_id?: string
          updated_at?: string | null
        }
        Relationships: [
          {
            foreignKeyName: "saml_providers_sso_provider_id_fkey"
            columns: ["sso_provider_id"]
            isOneToOne: false
            referencedRelation: "sso_providers"
            referencedColumns: ["id"]
          },
        ]
      }
      saml_relay_states: {
        Row: {
          created_at: string | null
          flow_state_id: string | null
          for_email: string | null
          id: string
          redirect_to: string | null
          request_id: string
          sso_provider_id: string
          updated_at: string | null
        }
        Insert: {
          created_at?: string | null
          flow_state_id?: string | null
          for_email?: string | null
          id: string
          redirect_to?: string | null
          request_id: string
          sso_provider_id: string
          updated_at?: string | null
        }
        Update: {
          created_at?: string | null
          flow_state_id?: string | null
          for_email?: string | null
          id?: string
          redirect_to?: string | null
          request_id?: string
          sso_provider_id?: string
          updated_at?: string | null
        }
        Relationships: [
          {
            foreignKeyName: "saml_relay_states_flow_state_id_fkey"
            columns: ["flow_state_id"]
            isOneToOne: false
            referencedRelation: "flow_state"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "saml_relay_states_sso_provider_id_fkey"
            columns: ["sso_provider_id"]
            isOneToOne: false
            referencedRelation: "sso_providers"
            referencedColumns: ["id"]
          },
        ]
      }
      schema_migrations: {
        Row: {
          version: string
        }
        Insert: {
          version: string
        }
        Update: {
          version?: string
        }
        Relationships: []
      }
      sessions: {
        Row: {
          aal: Database["auth"]["Enums"]["aal_level"] | null
          created_at: string | null
          factor_id: string | null
          id: string
          ip: unknown | null
          not_after: string | null
          refreshed_at: string | null
          tag: string | null
          updated_at: string | null
          user_agent: string | null
          user_id: string
        }
        Insert: {
          aal?: Database["auth"]["Enums"]["aal_level"] | null
          created_at?: string | null
          factor_id?: string | null
          id: string
          ip?: unknown | null
          not_after?: string | null
          refreshed_at?: string | null
          tag?: string | null
          updated_at?: string | null
          user_agent?: string | null
          user_id: string
        }
        Update: {
          aal?: Database["auth"]["Enums"]["aal_level"] | null
          created_at?: string | null
          factor_id?: string | null
          id?: string
          ip?: unknown | null
          not_after?: string | null
          refreshed_at?: string | null
          tag?: string | null
          updated_at?: string | null
          user_agent?: string | null
          user_id?: string
        }
        Relationships: [
          {
            foreignKeyName: "sessions_user_id_fkey"
            columns: ["user_id"]
            isOneToOne: false
            referencedRelation: "users"
            referencedColumns: ["id"]
          },
        ]
      }
      sso_domains: {
        Row: {
          created_at: string | null
          domain: string
          id: string
          sso_provider_id: string
          updated_at: string | null
        }
        Insert: {
          created_at?: string | null
          domain: string
          id: string
          sso_provider_id: string
          updated_at?: string | null
        }
        Update: {
          created_at?: string | null
          domain?: string
          id?: string
          sso_provider_id?: string
          updated_at?: string | null
        }
        Relationships: [
          {
            foreignKeyName: "sso_domains_sso_provider_id_fkey"
            columns: ["sso_provider_id"]
            isOneToOne: false
            referencedRelation: "sso_providers"
            referencedColumns: ["id"]
          },
        ]
      }
      sso_providers: {
        Row: {
          created_at: string | null
          disabled: boolean | null
          id: string
          resource_id: string | null
          updated_at: string | null
        }
        Insert: {
          created_at?: string | null
          disabled?: boolean | null
          id: string
          resource_id?: string | null
          updated_at?: string | null
        }
        Update: {
          created_at?: string | null
          disabled?: boolean | null
          id?: string
          resource_id?: string | null
          updated_at?: string | null
        }
        Relationships: []
      }
      users: {
        Row: {
          aud: string | null
          banned_until: string | null
          confirmation_sent_at: string | null
          confirmation_token: string | null
          confirmed_at: string | null
          created_at: string | null
          deleted_at: string | null
          email: string | null
          email_change: string | null
          email_change_confirm_status: number | null
          email_change_sent_at: string | null
          email_change_token_current: string | null
          email_change_token_new: string | null
          email_confirmed_at: string | null
          encrypted_password: string | null
          id: string
          instance_id: string | null
          invited_at: string | null
          is_anonymous: boolean
          is_sso_user: boolean
          is_super_admin: boolean | null
          last_sign_in_at: string | null
          phone: string | null
          phone_change: string | null
          phone_change_sent_at: string | null
          phone_change_token: string | null
          phone_confirmed_at: string | null
          raw_app_meta_data: Json | null
          raw_user_meta_data: Json | null
          reauthentication_sent_at: string | null
          reauthentication_token: string | null
          recovery_sent_at: string | null
          recovery_token: string | null
          role: string | null
          updated_at: string | null
        }
        Insert: {
          aud?: string | null
          banned_until?: string | null
          confirmation_sent_at?: string | null
          confirmation_token?: string | null
          confirmed_at?: string | null
          created_at?: string | null
          deleted_at?: string | null
          email?: string | null
          email_change?: string | null
          email_change_confirm_status?: number | null
          email_change_sent_at?: string | null
          email_change_token_current?: string | null
          email_change_token_new?: string | null
          email_confirmed_at?: string | null
          encrypted_password?: string | null
          id: string
          instance_id?: string | null
          invited_at?: string | null
          is_anonymous?: boolean
          is_sso_user?: boolean
          is_super_admin?: boolean | null
          last_sign_in_at?: string | null
          phone?: string | null
          phone_change?: string | null
          phone_change_sent_at?: string | null
          phone_change_token?: string | null
          phone_confirmed_at?: string | null
          raw_app_meta_data?: Json | null
          raw_user_meta_data?: Json | null
          reauthentication_sent_at?: string | null
          reauthentication_token?: string | null
          recovery_sent_at?: string | null
          recovery_token?: string | null
          role?: string | null
          updated_at?: string | null
        }
        Update: {
          aud?: string | null
          banned_until?: string | null
          confirmation_sent_at?: string | null
          confirmation_token?: string | null
          confirmed_at?: string | null
          created_at?: string | null
          deleted_at?: string | null
          email?: string | null
          email_change?: string | null
          email_change_confirm_status?: number | null
          email_change_sent_at?: string | null
          email_change_token_current?: string | null
          email_change_token_new?: string | null
          email_confirmed_at?: string | null
          encrypted_password?: string | null
          id?: string
          instance_id?: string | null
          invited_at?: string | null
          is_anonymous?: boolean
          is_sso_user?: boolean
          is_super_admin?: boolean | null
          last_sign_in_at?: string | null
          phone?: string | null
          phone_change?: string | null
          phone_change_sent_at?: string | null
          phone_change_token?: string | null
          phone_confirmed_at?: string | null
          raw_app_meta_data?: Json | null
          raw_user_meta_data?: Json | null
          reauthentication_sent_at?: string | null
          reauthentication_token?: string | null
          recovery_sent_at?: string | null
          recovery_token?: string | null
          role?: string | null
          updated_at?: string | null
        }
        Relationships: []
      }
    }
    Views: {
      [_ in never]: never
    }
    Functions: {
      email: {
        Args: Record<PropertyKey, never>
        Returns: string
      }
      jwt: {
        Args: Record<PropertyKey, never>
        Returns: Json
      }
      role: {
        Args: Record<PropertyKey, never>
        Returns: string
      }
      uid: {
        Args: Record<PropertyKey, never>
        Returns: string
      }
    }
    Enums: {
      aal_level: "aal1" | "aal2" | "aal3"
      code_challenge_method: "s256" | "plain"
      factor_status: "unverified" | "verified"
      factor_type: "totp" | "webauthn" | "phone"
      oauth_registration_type: "dynamic" | "manual"
      one_time_token_type:
        | "confirmation_token"
        | "reauthentication_token"
        | "recovery_token"
        | "email_change_token_new"
        | "email_change_token_current"
        | "phone_change_token"
    }
    CompositeTypes: {
      [_ in never]: never
    }
  }
  public: {
    Tables: {
      cable_segments: {
        Row: {
          created_at: string | null
          distance_km: number
          end_node_id: string
          end_node_type: string
          fiber_count: number
          id: string
          original_cable_id: string
          segment_order: number
          start_node_id: string
          start_node_type: string
          updated_at: string | null
        }
        Insert: {
          created_at?: string | null
          distance_km: number
          end_node_id: string
          end_node_type: string
          fiber_count: number
          id?: string
          original_cable_id: string
          segment_order: number
          start_node_id: string
          start_node_type: string
          updated_at?: string | null
        }
        Update: {
          created_at?: string | null
          distance_km?: number
          end_node_id?: string
          end_node_type?: string
          fiber_count?: number
          id?: string
          original_cable_id?: string
          segment_order?: number
          start_node_id?: string
          start_node_type?: string
          updated_at?: string | null
        }
        Relationships: [
          {
            foreignKeyName: "cable_segments_original_cable_id_fkey"
            columns: ["original_cable_id"]
            isOneToOne: false
            referencedRelation: "ofc_cables"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "cable_segments_original_cable_id_fkey"
            columns: ["original_cable_id"]
            isOneToOne: false
            referencedRelation: "v_ofc_cables_complete"
            referencedColumns: ["id"]
          },
        ]
      }
      employee_designations: {
        Row: {
          created_at: string | null
          id: string
          name: string
          parent_id: string | null
          status: boolean | null
          updated_at: string | null
        }
        Insert: {
          created_at?: string | null
          id?: string
          name: string
          parent_id?: string | null
          status?: boolean | null
          updated_at?: string | null
        }
        Update: {
          created_at?: string | null
          id?: string
          name?: string
          parent_id?: string | null
          status?: boolean | null
          updated_at?: string | null
        }
        Relationships: [
          {
            foreignKeyName: "employee_designations_parent_id_fkey"
            columns: ["parent_id"]
            isOneToOne: false
            referencedRelation: "employee_designations"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "employee_designations_parent_id_fkey"
            columns: ["parent_id"]
            isOneToOne: false
            referencedRelation: "v_employee_designations_with_count"
            referencedColumns: ["id"]
          },
        ]
      }
      employees: {
        Row: {
          created_at: string | null
          employee_addr: string | null
          employee_contact: string | null
          employee_designation_id: string | null
          employee_dob: string | null
          employee_doj: string | null
          employee_email: string | null
          employee_name: string
          employee_pers_no: string | null
          id: string
          maintenance_terminal_id: string | null
          remark: string | null
          status: boolean | null
          updated_at: string | null
        }
        Insert: {
          created_at?: string | null
          employee_addr?: string | null
          employee_contact?: string | null
          employee_designation_id?: string | null
          employee_dob?: string | null
          employee_doj?: string | null
          employee_email?: string | null
          employee_name: string
          employee_pers_no?: string | null
          id?: string
          maintenance_terminal_id?: string | null
          remark?: string | null
          status?: boolean | null
          updated_at?: string | null
        }
        Update: {
          created_at?: string | null
          employee_addr?: string | null
          employee_contact?: string | null
          employee_designation_id?: string | null
          employee_dob?: string | null
          employee_doj?: string | null
          employee_email?: string | null
          employee_name?: string
          employee_pers_no?: string | null
          id?: string
          maintenance_terminal_id?: string | null
          remark?: string | null
          status?: boolean | null
          updated_at?: string | null
        }
        Relationships: [
          {
            foreignKeyName: "employees_employee_designation_id_fkey"
            columns: ["employee_designation_id"]
            isOneToOne: false
            referencedRelation: "employee_designations"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "employees_employee_designation_id_fkey"
            columns: ["employee_designation_id"]
            isOneToOne: false
            referencedRelation: "v_employee_designations_with_count"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "employees_maintenance_terminal_id_fkey"
            columns: ["maintenance_terminal_id"]
            isOneToOne: false
            referencedRelation: "maintenance_areas"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "employees_maintenance_terminal_id_fkey"
            columns: ["maintenance_terminal_id"]
            isOneToOne: false
            referencedRelation: "v_maintenance_areas_with_count"
            referencedColumns: ["id"]
          },
        ]
      }
      fiber_splices: {
        Row: {
          created_at: string | null
          id: string
          incoming_cable_id: string
          incoming_fiber_no: number
          jc_id: string
          logical_path_id: string | null
          loss_db: number | null
          otdr_length_km: number | null
          outgoing_cable_id: string | null
          outgoing_fiber_no: number | null
          splice_type: string
          status: string
          updated_at: string | null
        }
        Insert: {
          created_at?: string | null
          id?: string
          incoming_cable_id: string
          incoming_fiber_no: number
          jc_id: string
          logical_path_id?: string | null
          loss_db?: number | null
          otdr_length_km?: number | null
          outgoing_cable_id?: string | null
          outgoing_fiber_no?: number | null
          splice_type?: string
          status?: string
          updated_at?: string | null
        }
        Update: {
          created_at?: string | null
          id?: string
          incoming_cable_id?: string
          incoming_fiber_no?: number
          jc_id?: string
          logical_path_id?: string | null
          loss_db?: number | null
          otdr_length_km?: number | null
          outgoing_cable_id?: string | null
          outgoing_fiber_no?: number | null
          splice_type?: string
          status?: string
          updated_at?: string | null
        }
        Relationships: [
          {
            foreignKeyName: "fiber_splices_incoming_cable_id_fkey"
            columns: ["incoming_cable_id"]
            isOneToOne: false
            referencedRelation: "ofc_cables"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "fiber_splices_incoming_cable_id_fkey"
            columns: ["incoming_cable_id"]
            isOneToOne: false
            referencedRelation: "v_ofc_cables_complete"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "fiber_splices_jc_id_fkey"
            columns: ["jc_id"]
            isOneToOne: false
            referencedRelation: "junction_closures"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "fiber_splices_jc_id_fkey"
            columns: ["jc_id"]
            isOneToOne: false
            referencedRelation: "v_junction_closures_complete"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "fiber_splices_logical_path_id_fkey"
            columns: ["logical_path_id"]
            isOneToOne: false
            referencedRelation: "logical_fiber_paths"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "fiber_splices_outgoing_cable_id_fkey"
            columns: ["outgoing_cable_id"]
            isOneToOne: false
            referencedRelation: "ofc_cables"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "fiber_splices_outgoing_cable_id_fkey"
            columns: ["outgoing_cable_id"]
            isOneToOne: false
            referencedRelation: "v_ofc_cables_complete"
            referencedColumns: ["id"]
          },
        ]
      }
      files: {
        Row: {
          file_name: string
          file_route: string
          file_size: string
          file_type: string
          file_url: string
          folder_id: string | null
          id: string
          uploaded_at: string | null
          user_id: string
        }
        Insert: {
          file_name: string
          file_route: string
          file_size: string
          file_type: string
          file_url: string
          folder_id?: string | null
          id?: string
          uploaded_at?: string | null
          user_id: string
        }
        Update: {
          file_name?: string
          file_route?: string
          file_size?: string
          file_type?: string
          file_url?: string
          folder_id?: string | null
          id?: string
          uploaded_at?: string | null
          user_id?: string
        }
        Relationships: [
          {
            foreignKeyName: "files_folder_id_fkey"
            columns: ["folder_id"]
            isOneToOne: false
            referencedRelation: "folders"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "files_user_id_fkey"
            columns: ["user_id"]
            isOneToOne: false
            referencedRelation: "v_user_profiles_extended"
            referencedColumns: ["id"]
          },
        ]
      }
      folders: {
        Row: {
          created_at: string | null
          id: string
          name: string
          user_id: string
        }
        Insert: {
          created_at?: string | null
          id?: string
          name: string
          user_id: string
        }
        Update: {
          created_at?: string | null
          id?: string
          name?: string
          user_id?: string
        }
        Relationships: [
          {
            foreignKeyName: "folders_user_id_fkey"
            columns: ["user_id"]
            isOneToOne: false
            referencedRelation: "v_user_profiles_extended"
            referencedColumns: ["id"]
          },
        ]
      }
      junction_closures: {
        Row: {
          created_at: string | null
          id: string
          node_id: string
          ofc_cable_id: string
          position_km: number | null
          updated_at: string | null
        }
        Insert: {
          created_at?: string | null
          id?: string
          node_id: string
          ofc_cable_id: string
          position_km?: number | null
          updated_at?: string | null
        }
        Update: {
          created_at?: string | null
          id?: string
          node_id?: string
          ofc_cable_id?: string
          position_km?: number | null
          updated_at?: string | null
        }
        Relationships: [
          {
            foreignKeyName: "junction_closures_node_id_fkey"
            columns: ["node_id"]
            isOneToOne: false
            referencedRelation: "nodes"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "junction_closures_node_id_fkey"
            columns: ["node_id"]
            isOneToOne: false
            referencedRelation: "v_nodes_complete"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "junction_closures_ofc_cable_id_fkey"
            columns: ["ofc_cable_id"]
            isOneToOne: false
            referencedRelation: "ofc_cables"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "junction_closures_ofc_cable_id_fkey"
            columns: ["ofc_cable_id"]
            isOneToOne: false
            referencedRelation: "v_ofc_cables_complete"
            referencedColumns: ["id"]
          },
        ]
      }
      logical_fiber_paths: {
        Row: {
          bandwidth_gbps: number | null
          commissioned_date: string | null
          created_at: string | null
          destination_port: string | null
          destination_system_id: string | null
          id: string
          operational_status_id: string | null
          path_name: string | null
          path_role: string
          path_type_id: string | null
          remark: string | null
          service_type: string | null
          source_port: string | null
          source_system_id: string | null
          total_distance_km: number | null
          total_loss_db: number | null
          updated_at: string | null
          wavelength_nm: number | null
          working_path_id: string | null
        }
        Insert: {
          bandwidth_gbps?: number | null
          commissioned_date?: string | null
          created_at?: string | null
          destination_port?: string | null
          destination_system_id?: string | null
          id?: string
          operational_status_id?: string | null
          path_name?: string | null
          path_role?: string
          path_type_id?: string | null
          remark?: string | null
          service_type?: string | null
          source_port?: string | null
          source_system_id?: string | null
          total_distance_km?: number | null
          total_loss_db?: number | null
          updated_at?: string | null
          wavelength_nm?: number | null
          working_path_id?: string | null
        }
        Update: {
          bandwidth_gbps?: number | null
          commissioned_date?: string | null
          created_at?: string | null
          destination_port?: string | null
          destination_system_id?: string | null
          id?: string
          operational_status_id?: string | null
          path_name?: string | null
          path_role?: string
          path_type_id?: string | null
          remark?: string | null
          service_type?: string | null
          source_port?: string | null
          source_system_id?: string | null
          total_distance_km?: number | null
          total_loss_db?: number | null
          updated_at?: string | null
          wavelength_nm?: number | null
          working_path_id?: string | null
        }
        Relationships: [
          {
            foreignKeyName: "logical_fiber_paths_operational_status_id_fkey"
            columns: ["operational_status_id"]
            isOneToOne: false
            referencedRelation: "lookup_types"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "logical_fiber_paths_operational_status_id_fkey"
            columns: ["operational_status_id"]
            isOneToOne: false
            referencedRelation: "v_lookup_types_with_count"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "logical_fiber_paths_path_type_id_fkey"
            columns: ["path_type_id"]
            isOneToOne: false
            referencedRelation: "lookup_types"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "logical_fiber_paths_path_type_id_fkey"
            columns: ["path_type_id"]
            isOneToOne: false
            referencedRelation: "v_lookup_types_with_count"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "logical_fiber_paths_working_path_id_fkey"
            columns: ["working_path_id"]
            isOneToOne: false
            referencedRelation: "logical_fiber_paths"
            referencedColumns: ["id"]
          },
        ]
      }
      lookup_types: {
        Row: {
          category: string
          code: string | null
          created_at: string | null
          description: string | null
          id: string
          is_system_default: boolean | null
          name: string
          sort_order: number | null
          status: boolean | null
          updated_at: string | null
        }
        Insert: {
          category: string
          code?: string | null
          created_at?: string | null
          description?: string | null
          id?: string
          is_system_default?: boolean | null
          name: string
          sort_order?: number | null
          status?: boolean | null
          updated_at?: string | null
        }
        Update: {
          category?: string
          code?: string | null
          created_at?: string | null
          description?: string | null
          id?: string
          is_system_default?: boolean | null
          name?: string
          sort_order?: number | null
          status?: boolean | null
          updated_at?: string | null
        }
        Relationships: []
      }
      maintenance_areas: {
        Row: {
          address: string | null
          area_type_id: string | null
          code: string | null
          contact_number: string | null
          contact_person: string | null
          created_at: string | null
          email: string | null
          id: string
          latitude: number | null
          longitude: number | null
          name: string
          parent_id: string | null
          status: boolean | null
          updated_at: string | null
        }
        Insert: {
          address?: string | null
          area_type_id?: string | null
          code?: string | null
          contact_number?: string | null
          contact_person?: string | null
          created_at?: string | null
          email?: string | null
          id?: string
          latitude?: number | null
          longitude?: number | null
          name: string
          parent_id?: string | null
          status?: boolean | null
          updated_at?: string | null
        }
        Update: {
          address?: string | null
          area_type_id?: string | null
          code?: string | null
          contact_number?: string | null
          contact_person?: string | null
          created_at?: string | null
          email?: string | null
          id?: string
          latitude?: number | null
          longitude?: number | null
          name?: string
          parent_id?: string | null
          status?: boolean | null
          updated_at?: string | null
        }
        Relationships: [
          {
            foreignKeyName: "maintenance_areas_area_type_id_fkey"
            columns: ["area_type_id"]
            isOneToOne: false
            referencedRelation: "lookup_types"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "maintenance_areas_area_type_id_fkey"
            columns: ["area_type_id"]
            isOneToOne: false
            referencedRelation: "v_lookup_types_with_count"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "maintenance_areas_parent_id_fkey"
            columns: ["parent_id"]
            isOneToOne: false
            referencedRelation: "maintenance_areas"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "maintenance_areas_parent_id_fkey"
            columns: ["parent_id"]
            isOneToOne: false
            referencedRelation: "v_maintenance_areas_with_count"
            referencedColumns: ["id"]
          },
        ]
      }
      management_ports: {
        Row: {
          commissioned_on: string | null
          created_at: string | null
          id: string
          name: string | null
          node_id: string | null
          port_no: string
          remark: string | null
          status: boolean | null
          system_id: string | null
          updated_at: string | null
        }
        Insert: {
          commissioned_on?: string | null
          created_at?: string | null
          id?: string
          name?: string | null
          node_id?: string | null
          port_no: string
          remark?: string | null
          status?: boolean | null
          system_id?: string | null
          updated_at?: string | null
        }
        Update: {
          commissioned_on?: string | null
          created_at?: string | null
          id?: string
          name?: string | null
          node_id?: string | null
          port_no?: string
          remark?: string | null
          status?: boolean | null
          system_id?: string | null
          updated_at?: string | null
        }
        Relationships: [
          {
            foreignKeyName: "management_ports_node_id_fkey"
            columns: ["node_id"]
            isOneToOne: false
            referencedRelation: "nodes"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "management_ports_node_id_fkey"
            columns: ["node_id"]
            isOneToOne: false
            referencedRelation: "v_nodes_complete"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "management_ports_system_id_fkey"
            columns: ["system_id"]
            isOneToOne: false
            referencedRelation: "systems"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "management_ports_system_id_fkey"
            columns: ["system_id"]
            isOneToOne: false
            referencedRelation: "v_systems_complete"
            referencedColumns: ["id"]
          },
        ]
      }
      nodes: {
        Row: {
          created_at: string | null
          id: string
          latitude: number | null
          longitude: number | null
          maintenance_terminal_id: string | null
          name: string
          node_type_id: string | null
          remark: string | null
          status: boolean | null
          updated_at: string | null
        }
        Insert: {
          created_at?: string | null
          id?: string
          latitude?: number | null
          longitude?: number | null
          maintenance_terminal_id?: string | null
          name: string
          node_type_id?: string | null
          remark?: string | null
          status?: boolean | null
          updated_at?: string | null
        }
        Update: {
          created_at?: string | null
          id?: string
          latitude?: number | null
          longitude?: number | null
          maintenance_terminal_id?: string | null
          name?: string
          node_type_id?: string | null
          remark?: string | null
          status?: boolean | null
          updated_at?: string | null
        }
        Relationships: [
          {
            foreignKeyName: "nodes_maintenance_terminal_id_fkey"
            columns: ["maintenance_terminal_id"]
            isOneToOne: false
            referencedRelation: "maintenance_areas"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "nodes_maintenance_terminal_id_fkey"
            columns: ["maintenance_terminal_id"]
            isOneToOne: false
            referencedRelation: "v_maintenance_areas_with_count"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "nodes_node_type_id_fkey"
            columns: ["node_type_id"]
            isOneToOne: false
            referencedRelation: "lookup_types"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "nodes_node_type_id_fkey"
            columns: ["node_type_id"]
            isOneToOne: false
            referencedRelation: "v_lookup_types_with_count"
            referencedColumns: ["id"]
          },
        ]
      }
      ofc_cables: {
        Row: {
          asset_no: string | null
          capacity: number
          commissioned_on: string | null
          created_at: string | null
          current_rkm: number | null
          en_id: string
          id: string
          maintenance_terminal_id: string | null
          ofc_owner_id: string
          ofc_type_id: string
          remark: string | null
          route_name: string
          sn_id: string
          status: boolean | null
          transnet_id: string | null
          transnet_rkm: number | null
          updated_at: string | null
        }
        Insert: {
          asset_no?: string | null
          capacity: number
          commissioned_on?: string | null
          created_at?: string | null
          current_rkm?: number | null
          en_id: string
          id?: string
          maintenance_terminal_id?: string | null
          ofc_owner_id: string
          ofc_type_id: string
          remark?: string | null
          route_name: string
          sn_id: string
          status?: boolean | null
          transnet_id?: string | null
          transnet_rkm?: number | null
          updated_at?: string | null
        }
        Update: {
          asset_no?: string | null
          capacity?: number
          commissioned_on?: string | null
          created_at?: string | null
          current_rkm?: number | null
          en_id?: string
          id?: string
          maintenance_terminal_id?: string | null
          ofc_owner_id?: string
          ofc_type_id?: string
          remark?: string | null
          route_name?: string
          sn_id?: string
          status?: boolean | null
          transnet_id?: string | null
          transnet_rkm?: number | null
          updated_at?: string | null
        }
        Relationships: [
          {
            foreignKeyName: "ofc_cables_en_id_fkey"
            columns: ["en_id"]
            isOneToOne: false
            referencedRelation: "nodes"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "ofc_cables_en_id_fkey"
            columns: ["en_id"]
            isOneToOne: false
            referencedRelation: "v_nodes_complete"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "ofc_cables_maintenance_terminal_id_fkey"
            columns: ["maintenance_terminal_id"]
            isOneToOne: false
            referencedRelation: "maintenance_areas"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "ofc_cables_maintenance_terminal_id_fkey"
            columns: ["maintenance_terminal_id"]
            isOneToOne: false
            referencedRelation: "v_maintenance_areas_with_count"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "ofc_cables_ofc_owner_id_fkey"
            columns: ["ofc_owner_id"]
            isOneToOne: false
            referencedRelation: "lookup_types"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "ofc_cables_ofc_owner_id_fkey"
            columns: ["ofc_owner_id"]
            isOneToOne: false
            referencedRelation: "v_lookup_types_with_count"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "ofc_cables_ofc_type_id_fkey"
            columns: ["ofc_type_id"]
            isOneToOne: false
            referencedRelation: "lookup_types"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "ofc_cables_ofc_type_id_fkey"
            columns: ["ofc_type_id"]
            isOneToOne: false
            referencedRelation: "v_lookup_types_with_count"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "ofc_cables_sn_id_fkey"
            columns: ["sn_id"]
            isOneToOne: false
            referencedRelation: "nodes"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "ofc_cables_sn_id_fkey"
            columns: ["sn_id"]
            isOneToOne: false
            referencedRelation: "v_nodes_complete"
            referencedColumns: ["id"]
          },
        ]
      }
      ofc_connections: {
        Row: {
          connection_category: string
          connection_type: string
          created_at: string | null
          destination_port: string | null
          en_dom: string | null
          en_power_dbm: number | null
          fiber_no_en: number
          fiber_no_sn: number
          fiber_role: string | null
          id: string
          logical_path_id: string | null
          ofc_id: string
          otdr_distance_en_km: number | null
          otdr_distance_sn_km: number | null
          path_segment_order: number | null
          remark: string | null
          route_loss_db: number | null
          sn_dom: string | null
          sn_power_dbm: number | null
          source_port: string | null
          status: boolean | null
          system_id: string | null
          updated_at: string | null
        }
        Insert: {
          connection_category?: string
          connection_type?: string
          created_at?: string | null
          destination_port?: string | null
          en_dom?: string | null
          en_power_dbm?: number | null
          fiber_no_en: number
          fiber_no_sn: number
          fiber_role?: string | null
          id?: string
          logical_path_id?: string | null
          ofc_id: string
          otdr_distance_en_km?: number | null
          otdr_distance_sn_km?: number | null
          path_segment_order?: number | null
          remark?: string | null
          route_loss_db?: number | null
          sn_dom?: string | null
          sn_power_dbm?: number | null
          source_port?: string | null
          status?: boolean | null
          system_id?: string | null
          updated_at?: string | null
        }
        Update: {
          connection_category?: string
          connection_type?: string
          created_at?: string | null
          destination_port?: string | null
          en_dom?: string | null
          en_power_dbm?: number | null
          fiber_no_en?: number
          fiber_no_sn?: number
          fiber_role?: string | null
          id?: string
          logical_path_id?: string | null
          ofc_id?: string
          otdr_distance_en_km?: number | null
          otdr_distance_sn_km?: number | null
          path_segment_order?: number | null
          remark?: string | null
          route_loss_db?: number | null
          sn_dom?: string | null
          sn_power_dbm?: number | null
          source_port?: string | null
          status?: boolean | null
          system_id?: string | null
          updated_at?: string | null
        }
        Relationships: [
          {
            foreignKeyName: "fk_connection_type"
            columns: ["connection_category", "connection_type"]
            isOneToOne: false
            referencedRelation: "lookup_types"
            referencedColumns: ["category", "name"]
          },
          {
            foreignKeyName: "fk_connection_type"
            columns: ["connection_category", "connection_type"]
            isOneToOne: false
            referencedRelation: "v_lookup_types_with_count"
            referencedColumns: ["category", "name"]
          },
          {
            foreignKeyName: "fk_connection_type"
            columns: ["connection_category", "connection_type"]
            isOneToOne: false
            referencedRelation: "v_maintenance_areas_with_count"
            referencedColumns: [
              "maintenance_area_type_category",
              "maintenance_area_type_name",
            ]
          },
          {
            foreignKeyName: "fk_connection_type"
            columns: ["connection_category", "connection_type"]
            isOneToOne: false
            referencedRelation: "v_rings_with_count"
            referencedColumns: ["ring_type_category", "ring_type_name"]
          },
          {
            foreignKeyName: "fk_connection_type"
            columns: ["connection_category", "connection_type"]
            isOneToOne: false
            referencedRelation: "v_systems_complete"
            referencedColumns: ["system_category", "system_type_name"]
          },
          {
            foreignKeyName: "ofc_connections_ofc_id_fkey"
            columns: ["ofc_id"]
            isOneToOne: false
            referencedRelation: "ofc_cables"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "ofc_connections_ofc_id_fkey"
            columns: ["ofc_id"]
            isOneToOne: false
            referencedRelation: "v_ofc_cables_complete"
            referencedColumns: ["id"]
          },
        ]
      }
      ring_based_systems: {
        Row: {
          maintenance_area_id: string | null
          ring_id: string | null
          system_id: string
        }
        Insert: {
          maintenance_area_id?: string | null
          ring_id?: string | null
          system_id: string
        }
        Update: {
          maintenance_area_id?: string | null
          ring_id?: string | null
          system_id?: string
        }
        Relationships: [
          {
            foreignKeyName: "ring_based_systems_maintenance_area_id_fkey"
            columns: ["maintenance_area_id"]
            isOneToOne: false
            referencedRelation: "maintenance_areas"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "ring_based_systems_maintenance_area_id_fkey"
            columns: ["maintenance_area_id"]
            isOneToOne: false
            referencedRelation: "v_maintenance_areas_with_count"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "ring_based_systems_ring_id_fkey"
            columns: ["ring_id"]
            isOneToOne: false
            referencedRelation: "rings"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "ring_based_systems_ring_id_fkey"
            columns: ["ring_id"]
            isOneToOne: false
            referencedRelation: "v_rings_with_count"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "ring_based_systems_system_id_fkey"
            columns: ["system_id"]
            isOneToOne: true
            referencedRelation: "systems"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "ring_based_systems_system_id_fkey"
            columns: ["system_id"]
            isOneToOne: true
            referencedRelation: "v_systems_complete"
            referencedColumns: ["id"]
          },
        ]
      }
      rings: {
        Row: {
          created_at: string | null
          description: string | null
          id: string
          maintenance_terminal_id: string | null
          name: string
          ring_type_id: string | null
          status: boolean | null
          total_nodes: number | null
          updated_at: string | null
        }
        Insert: {
          created_at?: string | null
          description?: string | null
          id?: string
          maintenance_terminal_id?: string | null
          name: string
          ring_type_id?: string | null
          status?: boolean | null
          total_nodes?: number | null
          updated_at?: string | null
        }
        Update: {
          created_at?: string | null
          description?: string | null
          id?: string
          maintenance_terminal_id?: string | null
          name?: string
          ring_type_id?: string | null
          status?: boolean | null
          total_nodes?: number | null
          updated_at?: string | null
        }
        Relationships: [
          {
            foreignKeyName: "rings_maintenance_terminal_id_fkey"
            columns: ["maintenance_terminal_id"]
            isOneToOne: false
            referencedRelation: "maintenance_areas"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "rings_maintenance_terminal_id_fkey"
            columns: ["maintenance_terminal_id"]
            isOneToOne: false
            referencedRelation: "v_maintenance_areas_with_count"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "rings_ring_type_id_fkey"
            columns: ["ring_type_id"]
            isOneToOne: false
            referencedRelation: "lookup_types"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "rings_ring_type_id_fkey"
            columns: ["ring_type_id"]
            isOneToOne: false
            referencedRelation: "v_lookup_types_with_count"
            referencedColumns: ["id"]
          },
        ]
      }
      sdh_connections: {
        Row: {
          a_customer: string | null
          a_slot: string | null
          b_customer: string | null
          b_slot: string | null
          carrier: string | null
          stm_no: string | null
          system_connection_id: string
        }
        Insert: {
          a_customer?: string | null
          a_slot?: string | null
          b_customer?: string | null
          b_slot?: string | null
          carrier?: string | null
          stm_no?: string | null
          system_connection_id: string
        }
        Update: {
          a_customer?: string | null
          a_slot?: string | null
          b_customer?: string | null
          b_slot?: string | null
          carrier?: string | null
          stm_no?: string | null
          system_connection_id?: string
        }
        Relationships: [
          {
            foreignKeyName: "sdh_connections_system_connection_id_fkey"
            columns: ["system_connection_id"]
            isOneToOne: true
            referencedRelation: "system_connections"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "sdh_connections_system_connection_id_fkey"
            columns: ["system_connection_id"]
            isOneToOne: true
            referencedRelation: "v_system_connections_complete"
            referencedColumns: ["id"]
          },
        ]
      }
      sdh_node_associations: {
        Row: {
          id: string
          node_id: string
          node_ip: unknown | null
          node_position: string | null
          sdh_system_id: string
        }
        Insert: {
          id?: string
          node_id: string
          node_ip?: unknown | null
          node_position?: string | null
          sdh_system_id: string
        }
        Update: {
          id?: string
          node_id?: string
          node_ip?: unknown | null
          node_position?: string | null
          sdh_system_id?: string
        }
        Relationships: [
          {
            foreignKeyName: "sdh_node_associations_node_id_fkey"
            columns: ["node_id"]
            isOneToOne: false
            referencedRelation: "nodes"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "sdh_node_associations_node_id_fkey"
            columns: ["node_id"]
            isOneToOne: false
            referencedRelation: "v_nodes_complete"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "sdh_node_associations_sdh_system_id_fkey"
            columns: ["sdh_system_id"]
            isOneToOne: false
            referencedRelation: "sdh_systems"
            referencedColumns: ["system_id"]
          },
        ]
      }
      sdh_systems: {
        Row: {
          gne: string | null
          make: string | null
          system_id: string
        }
        Insert: {
          gne?: string | null
          make?: string | null
          system_id: string
        }
        Update: {
          gne?: string | null
          make?: string | null
          system_id?: string
        }
        Relationships: [
          {
            foreignKeyName: "sdh_systems_system_id_fkey"
            columns: ["system_id"]
            isOneToOne: true
            referencedRelation: "systems"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "sdh_systems_system_id_fkey"
            columns: ["system_id"]
            isOneToOne: true
            referencedRelation: "v_systems_complete"
            referencedColumns: ["id"]
          },
        ]
      }
      sfp_based_connections: {
        Row: {
          bandwidth_allocated_mbps: number | null
          customer_name: string | null
          fiber_in: number | null
          fiber_out: number | null
          sfp_capacity: string | null
          sfp_port: string | null
          sfp_serial_no: string | null
          sfp_type_id: string | null
          system_connection_id: string
        }
        Insert: {
          bandwidth_allocated_mbps?: number | null
          customer_name?: string | null
          fiber_in?: number | null
          fiber_out?: number | null
          sfp_capacity?: string | null
          sfp_port?: string | null
          sfp_serial_no?: string | null
          sfp_type_id?: string | null
          system_connection_id: string
        }
        Update: {
          bandwidth_allocated_mbps?: number | null
          customer_name?: string | null
          fiber_in?: number | null
          fiber_out?: number | null
          sfp_capacity?: string | null
          sfp_port?: string | null
          sfp_serial_no?: string | null
          sfp_type_id?: string | null
          system_connection_id?: string
        }
        Relationships: [
          {
            foreignKeyName: "sfp_based_connections_sfp_type_id_fkey"
            columns: ["sfp_type_id"]
            isOneToOne: false
            referencedRelation: "lookup_types"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "sfp_based_connections_sfp_type_id_fkey"
            columns: ["sfp_type_id"]
            isOneToOne: false
            referencedRelation: "v_lookup_types_with_count"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "sfp_based_connections_system_connection_id_fkey"
            columns: ["system_connection_id"]
            isOneToOne: true
            referencedRelation: "system_connections"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "sfp_based_connections_system_connection_id_fkey"
            columns: ["system_connection_id"]
            isOneToOne: true
            referencedRelation: "v_system_connections_complete"
            referencedColumns: ["id"]
          },
        ]
      }
      system_connections: {
        Row: {
          bandwidth_mbps: number | null
          commissioned_on: string | null
          connected_system_id: string | null
          created_at: string | null
          en_id: string | null
          en_interface: string | null
          en_ip: unknown | null
          id: string
          media_type_id: string | null
          remark: string | null
          sn_id: string | null
          sn_interface: string | null
          sn_ip: unknown | null
          status: boolean | null
          system_id: string
          updated_at: string | null
          vlan: string | null
        }
        Insert: {
          bandwidth_mbps?: number | null
          commissioned_on?: string | null
          connected_system_id?: string | null
          created_at?: string | null
          en_id?: string | null
          en_interface?: string | null
          en_ip?: unknown | null
          id?: string
          media_type_id?: string | null
          remark?: string | null
          sn_id?: string | null
          sn_interface?: string | null
          sn_ip?: unknown | null
          status?: boolean | null
          system_id: string
          updated_at?: string | null
          vlan?: string | null
        }
        Update: {
          bandwidth_mbps?: number | null
          commissioned_on?: string | null
          connected_system_id?: string | null
          created_at?: string | null
          en_id?: string | null
          en_interface?: string | null
          en_ip?: unknown | null
          id?: string
          media_type_id?: string | null
          remark?: string | null
          sn_id?: string | null
          sn_interface?: string | null
          sn_ip?: unknown | null
          status?: boolean | null
          system_id?: string
          updated_at?: string | null
          vlan?: string | null
        }
        Relationships: [
          {
            foreignKeyName: "system_connections_connected_system_id_fkey"
            columns: ["connected_system_id"]
            isOneToOne: false
            referencedRelation: "systems"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "system_connections_connected_system_id_fkey"
            columns: ["connected_system_id"]
            isOneToOne: false
            referencedRelation: "v_systems_complete"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "system_connections_en_id_fkey"
            columns: ["en_id"]
            isOneToOne: false
            referencedRelation: "systems"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "system_connections_en_id_fkey"
            columns: ["en_id"]
            isOneToOne: false
            referencedRelation: "v_systems_complete"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "system_connections_media_type_id_fkey"
            columns: ["media_type_id"]
            isOneToOne: false
            referencedRelation: "lookup_types"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "system_connections_media_type_id_fkey"
            columns: ["media_type_id"]
            isOneToOne: false
            referencedRelation: "v_lookup_types_with_count"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "system_connections_sn_id_fkey"
            columns: ["sn_id"]
            isOneToOne: false
            referencedRelation: "systems"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "system_connections_sn_id_fkey"
            columns: ["sn_id"]
            isOneToOne: false
            referencedRelation: "v_systems_complete"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "system_connections_system_id_fkey"
            columns: ["system_id"]
            isOneToOne: false
            referencedRelation: "systems"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "system_connections_system_id_fkey"
            columns: ["system_id"]
            isOneToOne: false
            referencedRelation: "v_systems_complete"
            referencedColumns: ["id"]
          },
        ]
      }
      systems: {
        Row: {
          commissioned_on: string | null
          created_at: string | null
          id: string
          ip_address: unknown | null
          maintenance_terminal_id: string | null
          node_id: string
          remark: string | null
          s_no: string | null
          status: boolean | null
          system_name: string | null
          system_type_id: string
          updated_at: string | null
        }
        Insert: {
          commissioned_on?: string | null
          created_at?: string | null
          id?: string
          ip_address?: unknown | null
          maintenance_terminal_id?: string | null
          node_id: string
          remark?: string | null
          s_no?: string | null
          status?: boolean | null
          system_name?: string | null
          system_type_id: string
          updated_at?: string | null
        }
        Update: {
          commissioned_on?: string | null
          created_at?: string | null
          id?: string
          ip_address?: unknown | null
          maintenance_terminal_id?: string | null
          node_id?: string
          remark?: string | null
          s_no?: string | null
          status?: boolean | null
          system_name?: string | null
          system_type_id?: string
          updated_at?: string | null
        }
        Relationships: [
          {
            foreignKeyName: "systems_maintenance_terminal_id_fkey"
            columns: ["maintenance_terminal_id"]
            isOneToOne: false
            referencedRelation: "maintenance_areas"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "systems_maintenance_terminal_id_fkey"
            columns: ["maintenance_terminal_id"]
            isOneToOne: false
            referencedRelation: "v_maintenance_areas_with_count"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "systems_node_id_fkey"
            columns: ["node_id"]
            isOneToOne: false
            referencedRelation: "nodes"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "systems_node_id_fkey"
            columns: ["node_id"]
            isOneToOne: false
            referencedRelation: "v_nodes_complete"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "systems_system_type_id_fkey"
            columns: ["system_type_id"]
            isOneToOne: false
            referencedRelation: "lookup_types"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "systems_system_type_id_fkey"
            columns: ["system_type_id"]
            isOneToOne: false
            referencedRelation: "v_lookup_types_with_count"
            referencedColumns: ["id"]
          },
        ]
      }
      user_profiles: {
        Row: {
          address: Json | null
          avatar_url: string | null
          created_at: string | null
          date_of_birth: string | null
          designation: string | null
          first_name: string
          id: string
          last_name: string
          phone_number: string | null
          preferences: Json | null
          role: string | null
          status: string | null
          updated_at: string | null
        }
        Insert: {
          address?: Json | null
          avatar_url?: string | null
          created_at?: string | null
          date_of_birth?: string | null
          designation?: string | null
          first_name: string
          id: string
          last_name: string
          phone_number?: string | null
          preferences?: Json | null
          role?: string | null
          status?: string | null
          updated_at?: string | null
        }
        Update: {
          address?: Json | null
          avatar_url?: string | null
          created_at?: string | null
          date_of_birth?: string | null
          designation?: string | null
          first_name?: string
          id?: string
          last_name?: string
          phone_number?: string | null
          preferences?: Json | null
          role?: string | null
          status?: string | null
          updated_at?: string | null
        }
        Relationships: [
          {
            foreignKeyName: "user_profiles_id_fkey"
            columns: ["id"]
            isOneToOne: true
            referencedRelation: "v_user_profiles_extended"
            referencedColumns: ["id"]
          },
        ]
      }
      vmux_connections: {
        Row: {
          c_code: string | null
          channel: string | null
          subscriber: string | null
          system_connection_id: string
          tk: string | null
        }
        Insert: {
          c_code?: string | null
          channel?: string | null
          subscriber?: string | null
          system_connection_id: string
          tk?: string | null
        }
        Update: {
          c_code?: string | null
          channel?: string | null
          subscriber?: string | null
          system_connection_id?: string
          tk?: string | null
        }
        Relationships: [
          {
            foreignKeyName: "vmux_connections_system_connection_id_fkey"
            columns: ["system_connection_id"]
            isOneToOne: true
            referencedRelation: "system_connections"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "vmux_connections_system_connection_id_fkey"
            columns: ["system_connection_id"]
            isOneToOne: true
            referencedRelation: "v_system_connections_complete"
            referencedColumns: ["id"]
          },
        ]
      }
      vmux_systems: {
        Row: {
          system_id: string
          vm_id: string | null
        }
        Insert: {
          system_id: string
          vm_id?: string | null
        }
        Update: {
          system_id?: string
          vm_id?: string | null
        }
        Relationships: [
          {
            foreignKeyName: "vmux_systems_system_id_fkey"
            columns: ["system_id"]
            isOneToOne: true
            referencedRelation: "systems"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "vmux_systems_system_id_fkey"
            columns: ["system_id"]
            isOneToOne: true
            referencedRelation: "v_systems_complete"
            referencedColumns: ["id"]
          },
        ]
      }
    }
    Views: {
      v_employee_designations_with_count: {
        Row: {
          active_count: number | null
          created_at: string | null
          id: string | null
          inactive_count: number | null
          name: string | null
          parent_id: string | null
          status: boolean | null
          total_count: number | null
          updated_at: string | null
        }
        Relationships: [
          {
            foreignKeyName: "employee_designations_parent_id_fkey"
            columns: ["parent_id"]
            isOneToOne: false
            referencedRelation: "employee_designations"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "employee_designations_parent_id_fkey"
            columns: ["parent_id"]
            isOneToOne: false
            referencedRelation: "v_employee_designations_with_count"
            referencedColumns: ["id"]
          },
        ]
      }
      v_employees_with_count: {
        Row: {
          active_count: number | null
          created_at: string | null
          employee_addr: string | null
          employee_contact: string | null
          employee_designation_id: string | null
          employee_designation_name: string | null
          employee_dob: string | null
          employee_doj: string | null
          employee_email: string | null
          employee_name: string | null
          employee_pers_no: string | null
          id: string | null
          inactive_count: number | null
          maintenance_terminal_id: string | null
          remark: string | null
          status: boolean | null
          total_count: number | null
          updated_at: string | null
        }
        Relationships: [
          {
            foreignKeyName: "employees_employee_designation_id_fkey"
            columns: ["employee_designation_id"]
            isOneToOne: false
            referencedRelation: "employee_designations"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "employees_employee_designation_id_fkey"
            columns: ["employee_designation_id"]
            isOneToOne: false
            referencedRelation: "v_employee_designations_with_count"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "employees_maintenance_terminal_id_fkey"
            columns: ["maintenance_terminal_id"]
            isOneToOne: false
            referencedRelation: "maintenance_areas"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "employees_maintenance_terminal_id_fkey"
            columns: ["maintenance_terminal_id"]
            isOneToOne: false
            referencedRelation: "v_maintenance_areas_with_count"
            referencedColumns: ["id"]
          },
        ]
      }
      v_junction_closures_complete: {
        Row: {
          id: string | null
          latitude: number | null
          longitude: number | null
          name: string | null
          node_id: string | null
          ofc_cable_id: string | null
          position_km: number | null
        }
        Relationships: [
          {
            foreignKeyName: "junction_closures_node_id_fkey"
            columns: ["node_id"]
            isOneToOne: false
            referencedRelation: "nodes"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "junction_closures_node_id_fkey"
            columns: ["node_id"]
            isOneToOne: false
            referencedRelation: "v_nodes_complete"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "junction_closures_ofc_cable_id_fkey"
            columns: ["ofc_cable_id"]
            isOneToOne: false
            referencedRelation: "ofc_cables"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "junction_closures_ofc_cable_id_fkey"
            columns: ["ofc_cable_id"]
            isOneToOne: false
            referencedRelation: "v_ofc_cables_complete"
            referencedColumns: ["id"]
          },
        ]
      }
      v_lookup_types_with_count: {
        Row: {
          active_count: number | null
          category: string | null
          code: string | null
          created_at: string | null
          description: string | null
          id: string | null
          inactive_count: number | null
          is_system_default: boolean | null
          name: string | null
          sort_order: number | null
          status: boolean | null
          total_count: number | null
          updated_at: string | null
        }
        Relationships: []
      }
      v_maintenance_areas_with_count: {
        Row: {
          active_count: number | null
          address: string | null
          area_type_id: string | null
          code: string | null
          contact_number: string | null
          contact_person: string | null
          created_at: string | null
          email: string | null
          id: string | null
          inactive_count: number | null
          latitude: number | null
          longitude: number | null
          maintenance_area_type_category: string | null
          maintenance_area_type_code: string | null
          maintenance_area_type_created_at: string | null
          maintenance_area_type_is_system_default: boolean | null
          maintenance_area_type_name: string | null
          maintenance_area_type_sort_order: number | null
          maintenance_area_type_status: boolean | null
          maintenance_area_type_updated_at: string | null
          name: string | null
          parent_id: string | null
          status: boolean | null
          total_count: number | null
          updated_at: string | null
        }
        Relationships: [
          {
            foreignKeyName: "maintenance_areas_area_type_id_fkey"
            columns: ["area_type_id"]
            isOneToOne: false
            referencedRelation: "lookup_types"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "maintenance_areas_area_type_id_fkey"
            columns: ["area_type_id"]
            isOneToOne: false
            referencedRelation: "v_lookup_types_with_count"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "maintenance_areas_parent_id_fkey"
            columns: ["parent_id"]
            isOneToOne: false
            referencedRelation: "maintenance_areas"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "maintenance_areas_parent_id_fkey"
            columns: ["parent_id"]
            isOneToOne: false
            referencedRelation: "v_maintenance_areas_with_count"
            referencedColumns: ["id"]
          },
        ]
      }
      v_nodes_complete: {
        Row: {
          active_count: number | null
          created_at: string | null
          id: string | null
          inactive_count: number | null
          latitude: number | null
          longitude: number | null
          maintenance_area_code: string | null
          maintenance_area_name: string | null
          maintenance_area_type_name: string | null
          maintenance_terminal_id: string | null
          name: string | null
          node_type_code: string | null
          node_type_id: string | null
          node_type_name: string | null
          remark: string | null
          status: boolean | null
          total_count: number | null
          updated_at: string | null
        }
        Relationships: [
          {
            foreignKeyName: "nodes_maintenance_terminal_id_fkey"
            columns: ["maintenance_terminal_id"]
            isOneToOne: false
            referencedRelation: "maintenance_areas"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "nodes_maintenance_terminal_id_fkey"
            columns: ["maintenance_terminal_id"]
            isOneToOne: false
            referencedRelation: "v_maintenance_areas_with_count"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "nodes_node_type_id_fkey"
            columns: ["node_type_id"]
            isOneToOne: false
            referencedRelation: "lookup_types"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "nodes_node_type_id_fkey"
            columns: ["node_type_id"]
            isOneToOne: false
            referencedRelation: "v_lookup_types_with_count"
            referencedColumns: ["id"]
          },
        ]
      }
      v_ofc_cables_complete: {
        Row: {
          active_count: number | null
          asset_no: string | null
          capacity: number | null
          commissioned_on: string | null
          created_at: string | null
          current_rkm: number | null
          en_id: string | null
          en_name: string | null
          id: string | null
          inactive_count: number | null
          maintenance_area_code: string | null
          maintenance_area_name: string | null
          maintenance_terminal_id: string | null
          ofc_owner_code: string | null
          ofc_owner_id: string | null
          ofc_owner_name: string | null
          ofc_type_code: string | null
          ofc_type_id: string | null
          ofc_type_name: string | null
          remark: string | null
          route_name: string | null
          sn_id: string | null
          sn_name: string | null
          status: boolean | null
          total_count: number | null
          transnet_id: string | null
          transnet_rkm: number | null
          updated_at: string | null
        }
        Relationships: [
          {
            foreignKeyName: "ofc_cables_en_id_fkey"
            columns: ["en_id"]
            isOneToOne: false
            referencedRelation: "nodes"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "ofc_cables_en_id_fkey"
            columns: ["en_id"]
            isOneToOne: false
            referencedRelation: "v_nodes_complete"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "ofc_cables_maintenance_terminal_id_fkey"
            columns: ["maintenance_terminal_id"]
            isOneToOne: false
            referencedRelation: "maintenance_areas"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "ofc_cables_maintenance_terminal_id_fkey"
            columns: ["maintenance_terminal_id"]
            isOneToOne: false
            referencedRelation: "v_maintenance_areas_with_count"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "ofc_cables_ofc_owner_id_fkey"
            columns: ["ofc_owner_id"]
            isOneToOne: false
            referencedRelation: "lookup_types"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "ofc_cables_ofc_owner_id_fkey"
            columns: ["ofc_owner_id"]
            isOneToOne: false
            referencedRelation: "v_lookup_types_with_count"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "ofc_cables_ofc_type_id_fkey"
            columns: ["ofc_type_id"]
            isOneToOne: false
            referencedRelation: "lookup_types"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "ofc_cables_ofc_type_id_fkey"
            columns: ["ofc_type_id"]
            isOneToOne: false
            referencedRelation: "v_lookup_types_with_count"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "ofc_cables_sn_id_fkey"
            columns: ["sn_id"]
            isOneToOne: false
            referencedRelation: "nodes"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "ofc_cables_sn_id_fkey"
            columns: ["sn_id"]
            isOneToOne: false
            referencedRelation: "v_nodes_complete"
            referencedColumns: ["id"]
          },
        ]
      }
      v_ofc_connections_complete: {
        Row: {
          active_count: number | null
          connection_category: string | null
          connection_type: string | null
          created_at: string | null
          destination_port: string | null
          en_dom: string | null
          en_id: string | null
          en_name: string | null
          en_power_dbm: number | null
          fiber_no_en: number | null
          fiber_no_sn: number | null
          fiber_role: string | null
          id: string | null
          inactive_count: number | null
          logical_path_id: string | null
          maintenance_area_name: string | null
          ofc_id: string | null
          ofc_route_name: string | null
          ofc_type_name: string | null
          otdr_distance_en_km: number | null
          otdr_distance_sn_km: number | null
          path_segment_order: number | null
          remark: string | null
          route_loss_db: number | null
          sn_dom: string | null
          sn_id: string | null
          sn_name: string | null
          sn_power_dbm: number | null
          source_port: string | null
          status: boolean | null
          system_id: string | null
          system_name: string | null
          total_count: number | null
          updated_at: string | null
        }
        Relationships: [
          {
            foreignKeyName: "fk_connection_type"
            columns: ["connection_category", "connection_type"]
            isOneToOne: false
            referencedRelation: "lookup_types"
            referencedColumns: ["category", "name"]
          },
          {
            foreignKeyName: "fk_connection_type"
            columns: ["connection_category", "connection_type"]
            isOneToOne: false
            referencedRelation: "v_lookup_types_with_count"
            referencedColumns: ["category", "name"]
          },
          {
            foreignKeyName: "fk_connection_type"
            columns: ["connection_category", "connection_type"]
            isOneToOne: false
            referencedRelation: "v_maintenance_areas_with_count"
            referencedColumns: [
              "maintenance_area_type_category",
              "maintenance_area_type_name",
            ]
          },
          {
            foreignKeyName: "fk_connection_type"
            columns: ["connection_category", "connection_type"]
            isOneToOne: false
            referencedRelation: "v_rings_with_count"
            referencedColumns: ["ring_type_category", "ring_type_name"]
          },
          {
            foreignKeyName: "fk_connection_type"
            columns: ["connection_category", "connection_type"]
            isOneToOne: false
            referencedRelation: "v_systems_complete"
            referencedColumns: ["system_category", "system_type_name"]
          },
          {
            foreignKeyName: "ofc_cables_en_id_fkey"
            columns: ["en_id"]
            isOneToOne: false
            referencedRelation: "nodes"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "ofc_cables_en_id_fkey"
            columns: ["en_id"]
            isOneToOne: false
            referencedRelation: "v_nodes_complete"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "ofc_cables_sn_id_fkey"
            columns: ["sn_id"]
            isOneToOne: false
            referencedRelation: "nodes"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "ofc_cables_sn_id_fkey"
            columns: ["sn_id"]
            isOneToOne: false
            referencedRelation: "v_nodes_complete"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "ofc_connections_ofc_id_fkey"
            columns: ["ofc_id"]
            isOneToOne: false
            referencedRelation: "ofc_cables"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "ofc_connections_ofc_id_fkey"
            columns: ["ofc_id"]
            isOneToOne: false
            referencedRelation: "v_ofc_cables_complete"
            referencedColumns: ["id"]
          },
        ]
      }
      v_rings_with_count: {
        Row: {
          active_count: number | null
          created_at: string | null
          description: string | null
          id: string | null
          inactive_count: number | null
          maintenance_area_area_type_id: string | null
          maintenance_area_code: string | null
          maintenance_area_contact_number: string | null
          maintenance_area_contact_person: string | null
          maintenance_area_created_at: string | null
          maintenance_area_email: string | null
          maintenance_area_latitude: number | null
          maintenance_area_longitude: number | null
          maintenance_area_name: string | null
          maintenance_area_parent_id: string | null
          maintenance_area_status: boolean | null
          maintenance_area_updated_at: string | null
          maintenance_terminal_id: string | null
          name: string | null
          ring_type_category: string | null
          ring_type_code: string | null
          ring_type_created_at: string | null
          ring_type_id: string | null
          ring_type_is_system_default: boolean | null
          ring_type_name: string | null
          ring_type_sort_order: number | null
          ring_type_status: boolean | null
          ring_type_updated_at: string | null
          status: boolean | null
          total_count: number | null
          total_nodes: number | null
          updated_at: string | null
        }
        Relationships: [
          {
            foreignKeyName: "maintenance_areas_area_type_id_fkey"
            columns: ["maintenance_area_area_type_id"]
            isOneToOne: false
            referencedRelation: "lookup_types"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "maintenance_areas_area_type_id_fkey"
            columns: ["maintenance_area_area_type_id"]
            isOneToOne: false
            referencedRelation: "v_lookup_types_with_count"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "maintenance_areas_parent_id_fkey"
            columns: ["maintenance_area_parent_id"]
            isOneToOne: false
            referencedRelation: "maintenance_areas"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "maintenance_areas_parent_id_fkey"
            columns: ["maintenance_area_parent_id"]
            isOneToOne: false
            referencedRelation: "v_maintenance_areas_with_count"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "rings_maintenance_terminal_id_fkey"
            columns: ["maintenance_terminal_id"]
            isOneToOne: false
            referencedRelation: "maintenance_areas"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "rings_maintenance_terminal_id_fkey"
            columns: ["maintenance_terminal_id"]
            isOneToOne: false
            referencedRelation: "v_maintenance_areas_with_count"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "rings_ring_type_id_fkey"
            columns: ["ring_type_id"]
            isOneToOne: false
            referencedRelation: "lookup_types"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "rings_ring_type_id_fkey"
            columns: ["ring_type_id"]
            isOneToOne: false
            referencedRelation: "v_lookup_types_with_count"
            referencedColumns: ["id"]
          },
        ]
      }
      v_system_connections_complete: {
        Row: {
          active_count: number | null
          bandwidth_allocated_mbps: number | null
          bandwidth_mbps: number | null
          commissioned_on: string | null
          connected_system_name: string | null
          connected_system_type_name: string | null
          created_at: string | null
          customer_name: string | null
          en_interface: string | null
          en_ip: unknown | null
          en_name: string | null
          en_node_name: string | null
          fiber_in: number | null
          fiber_out: number | null
          id: string | null
          inactive_count: number | null
          media_type_name: string | null
          remark: string | null
          sdh_a_customer: string | null
          sdh_a_slot: string | null
          sdh_b_customer: string | null
          sdh_b_slot: string | null
          sdh_carrier: string | null
          sdh_stm_no: string | null
          sfp_capacity: string | null
          sfp_port: string | null
          sfp_serial_no: string | null
          sfp_type_name: string | null
          sn_interface: string | null
          sn_ip: unknown | null
          sn_name: string | null
          sn_node_name: string | null
          status: boolean | null
          system_id: string | null
          system_name: string | null
          system_type_name: string | null
          total_count: number | null
          updated_at: string | null
          vlan: string | null
          vmux_c_code: string | null
          vmux_channel: string | null
          vmux_subscriber: string | null
          vmux_tk: string | null
        }
        Relationships: [
          {
            foreignKeyName: "system_connections_system_id_fkey"
            columns: ["system_id"]
            isOneToOne: false
            referencedRelation: "systems"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "system_connections_system_id_fkey"
            columns: ["system_id"]
            isOneToOne: false
            referencedRelation: "v_systems_complete"
            referencedColumns: ["id"]
          },
        ]
      }
      v_systems_complete: {
        Row: {
          active_count: number | null
          commissioned_on: string | null
          created_at: string | null
          id: string | null
          inactive_count: number | null
          ip_address: unknown | null
          latitude: number | null
          longitude: number | null
          maintenance_terminal_id: string | null
          node_id: string | null
          node_name: string | null
          remark: string | null
          ring_id: string | null
          ring_logical_area_name: string | null
          s_no: string | null
          sdh_gne: string | null
          sdh_make: string | null
          status: boolean | null
          system_category: string | null
          system_maintenance_terminal_name: string | null
          system_name: string | null
          system_type_code: string | null
          system_type_id: string | null
          system_type_name: string | null
          total_count: number | null
          updated_at: string | null
          vmux_vm_id: string | null
        }
        Relationships: [
          {
            foreignKeyName: "ring_based_systems_ring_id_fkey"
            columns: ["ring_id"]
            isOneToOne: false
            referencedRelation: "rings"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "ring_based_systems_ring_id_fkey"
            columns: ["ring_id"]
            isOneToOne: false
            referencedRelation: "v_rings_with_count"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "systems_maintenance_terminal_id_fkey"
            columns: ["maintenance_terminal_id"]
            isOneToOne: false
            referencedRelation: "maintenance_areas"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "systems_maintenance_terminal_id_fkey"
            columns: ["maintenance_terminal_id"]
            isOneToOne: false
            referencedRelation: "v_maintenance_areas_with_count"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "systems_node_id_fkey"
            columns: ["node_id"]
            isOneToOne: false
            referencedRelation: "nodes"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "systems_node_id_fkey"
            columns: ["node_id"]
            isOneToOne: false
            referencedRelation: "v_nodes_complete"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "systems_system_type_id_fkey"
            columns: ["system_type_id"]
            isOneToOne: false
            referencedRelation: "lookup_types"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "systems_system_type_id_fkey"
            columns: ["system_type_id"]
            isOneToOne: false
            referencedRelation: "v_lookup_types_with_count"
            referencedColumns: ["id"]
          },
        ]
      }
      v_user_profiles_extended: {
        Row: {
          account_age_days: number | null
          address: Json | null
          auth_updated_at: string | null
          avatar_url: string | null
          computed_status: string | null
          created_at: string | null
          date_of_birth: string | null
          designation: string | null
          email: string | null
          email_confirmed_at: string | null
          first_name: string | null
          full_name: string | null
          id: string | null
          is_email_verified: boolean | null
          is_phone_verified: boolean | null
          is_super_admin: boolean | null
          last_activity_period: string | null
          last_name: string | null
          last_sign_in_at: string | null
          phone_confirmed_at: string | null
          phone_number: string | null
          preferences: Json | null
          raw_app_meta_data: Json | null
          raw_user_meta_data: Json | null
          role: string | null
          status: string | null
          updated_at: string | null
        }
        Relationships: []
      }
    }
    Functions: {
      add_junction_closure: {
        Args:
          | { p_name: string; p_ofc_cable_id: string; p_position_km: number }
          | { p_node_id: string; p_ofc_cable_id: string; p_position_km: number }
        Returns: {
          created_at: string
          id: string
          node_id: string
          ofc_cable_id: string
          position_km: number
        }[]
      }
      add_lookup_type: {
        Args: {
          p_category: string
          p_code?: string
          p_description?: string
          p_name: string
          p_sort_order?: number
        }
        Returns: string
      }
      admin_bulk_delete_users: {
        Args: { user_ids: string[] }
        Returns: boolean
      }
      admin_bulk_update_role: {
        Args: { new_role: string; user_ids: string[] }
        Returns: boolean
      }
      admin_bulk_update_status: {
        Args: { new_status: string; user_ids: string[] }
        Returns: boolean
      }
      admin_get_all_users: {
        Args: {
          date_from?: string
          date_to?: string
          filter_role?: string
          filter_status?: string
          page_limit?: number
          page_offset?: number
          search_query?: string
        }
        Returns: {
          address: Json
          avatar_url: string
          created_at: string
          date_of_birth: string
          designation: string
          email: string
          first_name: string
          id: string
          is_email_verified: boolean
          last_name: string
          last_sign_in_at: string
          phone_number: string
          preferences: Json
          role: string
          status: string
          total_count: number
          updated_at: string
        }[]
      }
      admin_get_all_users_extended: {
        Args: {
          date_from?: string
          date_to?: string
          filter_activity?: string
          filter_role?: string
          filter_status?: string
          page_limit?: number
          page_offset?: number
          search_query?: string
        }
        Returns: {
          account_age_days: number
          active_count: number
          address: Json
          avatar_url: string
          computed_status: string
          created_at: string
          date_of_birth: string
          designation: string
          email: string
          first_name: string
          full_name: string
          id: string
          inactive_count: number
          is_email_verified: boolean
          is_super_admin: boolean
          last_activity_period: string
          last_name: string
          last_sign_in_at: string
          phone_number: string
          preferences: Json
          role: string
          status: string
          total_count: number
          updated_at: string
        }[]
      }
      admin_get_user_by_id: {
        Args: { user_id: string }
        Returns: {
          address: Json
          avatar_url: string
          created_at: string
          date_of_birth: string
          designation: string
          email: string
          first_name: string
          id: string
          is_email_verified: boolean
          last_name: string
          last_sign_in_at: string
          phone_number: string
          preferences: Json
          role: string
          status: string
          updated_at: string
        }[]
      }
      admin_update_user_profile: {
        Args: {
          update_address?: Json
          update_avatar_url?: string
          update_date_of_birth?: string
          update_designation?: string
          update_first_name?: string
          update_last_name?: string
          update_phone_number?: string
          update_preferences?: Json
          update_role?: string
          update_status?: string
          user_id: string
        }
        Returns: boolean
      }
      aggregate_query: {
        Args: {
          aggregation_options: Json
          filters?: Json
          order_by?: Json
          table_name: string
        }
        Returns: {
          result: Json
        }[]
      }
      apply_cross_joint_splicing: {
        Args: {
          p_fiber_mapping: Json
          p_incoming_segment_id: string
          p_jc_id: string
          p_outgoing_segment_id: string
        }
        Returns: number
      }
      apply_straight_joint_splicing: {
        Args: {
          p_incoming_segment_id: string
          p_jc_id: string
          p_outgoing_segment_id: string
        }
        Returns: number
      }
      build_where_clause: {
        Args: { p_alias?: string; p_filters: Json; p_view_name: string }
        Returns: string
      }
      bulk_update: {
        Args: { p_table_name: string; p_updates: Json }
        Returns: Json
      }
      column_exists: {
        Args: {
          p_column_name: string
          p_schema_name: string
          p_table_name: string
        }
        Returns: boolean
      }
      create_cable_segments_on_jc_add: {
        Args: { p_jc_id: string; p_ofc_cable_id: string }
        Returns: {
          distance_km: number
          end_node_id: string
          fiber_count: number
          segment_id: string
          segment_order: number
          start_node_id: string
        }[]
      }
      create_initial_fiber_connections: {
        Args: { p_segment_id: string }
        Returns: number
      }
      execute_sql: {
        Args: { sql_query: string }
        Returns: Json
      }
      get_dashboard_overview: {
        Args: Record<PropertyKey, never>
        Returns: Json
      }
      get_entity_counts: {
        Args: { p_entity_name: string; p_filters?: Json }
        Returns: {
          active_count: number
          inactive_count: number
          total_count: number
        }[]
      }
      get_fiber_path: {
        Args: {
          p_end_node_id: string
          p_fiber_number: number
          p_start_node_id: string
        }
        Returns: {
          connection_type: string
          distance_km: number
          end_node_id: string
          fiber_no_en: number
          fiber_no_sn: number
          segment_id: string
          segment_order: number
          start_node_id: string
        }[]
      }
      get_lookup_type_id: {
        Args: { p_category: string; p_name: string }
        Returns: string
      }
      get_lookup_types_by_category: {
        Args: { p_category: string }
        Returns: {
          code: string
          description: string
          id: string
          name: string
          sort_order: number
        }[]
      }
      get_my_role: {
        Args: Record<PropertyKey, never>
        Returns: string
      }
      get_my_user_details: {
        Args: Record<PropertyKey, never>
        Returns: {
          address: Json
          avatar_url: string
          created_at: string
          date_of_birth: string
          designation: string
          email: string
          first_name: string
          id: string
          is_email_verified: boolean
          is_super_admin: boolean
          last_name: string
          last_sign_in_at: string
          phone_number: string
          preferences: Json
          role: string
          updated_at: string
        }[]
      }
      get_paged_data: {
        Args: {
          p_filters?: Json
          p_limit: number
          p_offset: number
          p_order_by?: string
          p_order_dir?: string
          p_view_name: string
        }
        Returns: Json
      }
      get_paged_employee_designations_with_count: {
        Args: {
          p_filters?: Json
          p_limit: number
          p_offset: number
          p_order_by?: string
          p_order_dir?: string
        }
        Returns: {
          active_count: number
          id: string
          inactive_count: number
          name: string
          parent_id: string
          status: boolean
          total_count: number
        }[]
      }
      get_paged_employees_with_count: {
        Args: {
          p_filters?: Json
          p_limit: number
          p_offset: number
          p_order_by?: string
          p_order_dir?: string
        }
        Returns: {
          active_count: number
          employee_contact: string
          employee_designation_name: string
          employee_name: string
          employee_pers_no: string
          id: string
          inactive_count: number
          status: boolean
          total_count: number
        }[]
      }
      get_paged_lookup_types_with_count: {
        Args: {
          p_filters?: Json
          p_limit: number
          p_offset: number
          p_order_by?: string
          p_order_dir?: string
        }
        Returns: {
          active_count: number
          category: string
          code: string
          description: string
          id: string
          inactive_count: number
          name: string
          sort_order: number
          status: boolean
          total_count: number
        }[]
      }
      get_paged_maintenance_areas_with_count: {
        Args: {
          p_filters?: Json
          p_limit: number
          p_offset: number
          p_order_by?: string
          p_order_dir?: string
        }
        Returns: {
          active_count: number
          code: string
          contact_number: string
          contact_person: string
          id: string
          inactive_count: number
          maintenance_area_type_name: string
          name: string
          status: boolean
          total_count: number
        }[]
      }
      get_paged_nodes_complete: {
        Args: {
          p_filters?: Json
          p_limit: number
          p_offset: number
          p_order_by?: string
          p_order_dir?: string
        }
        Returns: {
          active_count: number
          created_at: string
          id: string
          inactive_count: number
          latitude: number
          longitude: number
          maintenance_area_name: string
          name: string
          node_type_name: string
          remark: string
          status: boolean
          total_count: number
          updated_at: string
        }[]
      }
      get_paged_ofc_cables_complete: {
        Args: {
          p_filters?: Json
          p_limit: number
          p_offset: number
          p_order_by?: string
          p_order_dir?: string
        }
        Returns: {
          active_count: number
          capacity: number
          commissioned_on: string
          current_rkm: number
          en_name: string
          id: string
          inactive_count: number
          maintenance_area_name: string
          ofc_owner_name: string
          ofc_type_name: string
          remark: string
          route_name: string
          sn_name: string
          status: boolean
          total_count: number
          updated_at: string
        }[]
      }
      get_paged_ofc_connections_complete: {
        Args: {
          p_filters?: Json
          p_limit: number
          p_offset: number
          p_order_by?: string
          p_order_dir?: string
        }
        Returns: {
          active_count: number
          en_name: string
          fiber_no_sn: number
          fiber_role: string
          id: string
          inactive_count: number
          ofc_route_name: string
          sn_name: string
          status: boolean
          system_name: string
          total_count: number
        }[]
      }
      get_paged_rings_with_count: {
        Args: {
          p_filters?: Json
          p_limit: number
          p_offset: number
          p_order_by?: string
          p_order_dir?: string
        }
        Returns: {
          active_count: number
          id: string
          inactive_count: number
          maintenance_area_name: string
          name: string
          ring_type_name: string
          status: boolean
          total_count: number
          total_nodes: number
        }[]
      }
      get_paged_system_connections_complete: {
        Args: {
          p_filters?: Json
          p_limit: number
          p_offset: number
          p_order_by?: string
          p_order_dir?: string
        }
        Returns: {
          active_count: number
          connected_system_name: string
          en_name: string
          en_node_name: string
          id: string
          inactive_count: number
          media_type_name: string
          sn_name: string
          sn_node_name: string
          status: boolean
          system_name: string
          system_type_name: string
          total_count: number
        }[]
      }
      get_paged_systems_complete: {
        Args: {
          p_filters?: Json
          p_limit: number
          p_offset: number
          p_order_by?: string
          p_order_dir?: string
        }
        Returns: {
          active_count: number
          id: string
          inactive_count: number
          ip_address: unknown
          node_name: string
          remark: string
          status: boolean
          system_name: string
          system_type_name: string
          total_count: number
        }[]
      }
      get_unique_values: {
        Args: {
          p_column_name: string
          p_filters?: Json
          p_limit_count?: number
          p_order_by?: Json
          p_table_name: string
        }
        Returns: {
          value: Json
        }[]
      }
      is_super_admin: {
        Args: Record<PropertyKey, never>
        Returns: boolean
      }
      log_user_activity: {
        Args: {
          p_action_type: string
          p_details?: string
          p_new_data?: Json
          p_old_data?: Json
          p_record_id?: string
          p_table_name?: string
        }
        Returns: undefined
      }
      update_fiber_connections_on_splice: {
        Args: {
          p_incoming_segment_id: string
          p_jc_id: string
          p_outgoing_segment_id: string
          p_splice_config: Json
        }
        Returns: number
      }
    }
    Enums: {
      [_ in never]: never
    }
    CompositeTypes: {
      splice_connection: {
        splice_id: string | null
        jc_id: string | null
        jc_name: string | null
        jc_position_km: number | null
        incoming_cable_id: string | null
        incoming_fiber_no: number | null
        outgoing_cable_id: string | null
        outgoing_fiber_no: number | null
        otdr_length_km: number | null
        loss_db: number | null
      }
    }
  }
}

type DatabaseWithoutInternals = Omit<Database, "__InternalSupabase">

type DefaultSchema = DatabaseWithoutInternals[Extract<keyof Database, "public">]

export type Tables<
  DefaultSchemaTableNameOrOptions extends
    | keyof (DefaultSchema["Tables"] & DefaultSchema["Views"])
    | { schema: keyof DatabaseWithoutInternals },
  TableName extends DefaultSchemaTableNameOrOptions extends {
    schema: keyof DatabaseWithoutInternals
  }
    ? keyof (DatabaseWithoutInternals[DefaultSchemaTableNameOrOptions["schema"]]["Tables"] &
        DatabaseWithoutInternals[DefaultSchemaTableNameOrOptions["schema"]]["Views"])
    : never = never,
> = DefaultSchemaTableNameOrOptions extends {
  schema: keyof DatabaseWithoutInternals
}
  ? (DatabaseWithoutInternals[DefaultSchemaTableNameOrOptions["schema"]]["Tables"] &
      DatabaseWithoutInternals[DefaultSchemaTableNameOrOptions["schema"]]["Views"])[TableName] extends {
      Row: infer R
    }
    ? R
    : never
  : DefaultSchemaTableNameOrOptions extends keyof (DefaultSchema["Tables"] &
        DefaultSchema["Views"])
    ? (DefaultSchema["Tables"] &
        DefaultSchema["Views"])[DefaultSchemaTableNameOrOptions] extends {
        Row: infer R
      }
      ? R
      : never
    : never

export type TablesInsert<
  DefaultSchemaTableNameOrOptions extends
    | keyof DefaultSchema["Tables"]
    | { schema: keyof DatabaseWithoutInternals },
  TableName extends DefaultSchemaTableNameOrOptions extends {
    schema: keyof DatabaseWithoutInternals
  }
    ? keyof DatabaseWithoutInternals[DefaultSchemaTableNameOrOptions["schema"]]["Tables"]
    : never = never,
> = DefaultSchemaTableNameOrOptions extends {
  schema: keyof DatabaseWithoutInternals
}
  ? DatabaseWithoutInternals[DefaultSchemaTableNameOrOptions["schema"]]["Tables"][TableName] extends {
      Insert: infer I
    }
    ? I
    : never
  : DefaultSchemaTableNameOrOptions extends keyof DefaultSchema["Tables"]
    ? DefaultSchema["Tables"][DefaultSchemaTableNameOrOptions] extends {
        Insert: infer I
      }
      ? I
      : never
    : never

export type TablesUpdate<
  DefaultSchemaTableNameOrOptions extends
    | keyof DefaultSchema["Tables"]
    | { schema: keyof DatabaseWithoutInternals },
  TableName extends DefaultSchemaTableNameOrOptions extends {
    schema: keyof DatabaseWithoutInternals
  }
    ? keyof DatabaseWithoutInternals[DefaultSchemaTableNameOrOptions["schema"]]["Tables"]
    : never = never,
> = DefaultSchemaTableNameOrOptions extends {
  schema: keyof DatabaseWithoutInternals
}
  ? DatabaseWithoutInternals[DefaultSchemaTableNameOrOptions["schema"]]["Tables"][TableName] extends {
      Update: infer U
    }
    ? U
    : never
  : DefaultSchemaTableNameOrOptions extends keyof DefaultSchema["Tables"]
    ? DefaultSchema["Tables"][DefaultSchemaTableNameOrOptions] extends {
        Update: infer U
      }
      ? U
      : never
    : never

export type Enums<
  DefaultSchemaEnumNameOrOptions extends
    | keyof DefaultSchema["Enums"]
    | { schema: keyof DatabaseWithoutInternals },
  EnumName extends DefaultSchemaEnumNameOrOptions extends {
    schema: keyof DatabaseWithoutInternals
  }
    ? keyof DatabaseWithoutInternals[DefaultSchemaEnumNameOrOptions["schema"]]["Enums"]
    : never = never,
> = DefaultSchemaEnumNameOrOptions extends {
  schema: keyof DatabaseWithoutInternals
}
  ? DatabaseWithoutInternals[DefaultSchemaEnumNameOrOptions["schema"]]["Enums"][EnumName]
  : DefaultSchemaEnumNameOrOptions extends keyof DefaultSchema["Enums"]
    ? DefaultSchema["Enums"][DefaultSchemaEnumNameOrOptions]
    : never

export type CompositeTypes<
  PublicCompositeTypeNameOrOptions extends
    | keyof DefaultSchema["CompositeTypes"]
    | { schema: keyof DatabaseWithoutInternals },
  CompositeTypeName extends PublicCompositeTypeNameOrOptions extends {
    schema: keyof DatabaseWithoutInternals
  }
    ? keyof DatabaseWithoutInternals[PublicCompositeTypeNameOrOptions["schema"]]["CompositeTypes"]
    : never = never,
> = PublicCompositeTypeNameOrOptions extends {
  schema: keyof DatabaseWithoutInternals
}
  ? DatabaseWithoutInternals[PublicCompositeTypeNameOrOptions["schema"]]["CompositeTypes"][CompositeTypeName]
  : PublicCompositeTypeNameOrOptions extends keyof DefaultSchema["CompositeTypes"]
    ? DefaultSchema["CompositeTypes"][PublicCompositeTypeNameOrOptions]
    : never

export const Constants = {
  auth: {
    Enums: {
      aal_level: ["aal1", "aal2", "aal3"],
      code_challenge_method: ["s256", "plain"],
      factor_status: ["unverified", "verified"],
      factor_type: ["totp", "webauthn", "phone"],
      oauth_registration_type: ["dynamic", "manual"],
      one_time_token_type: [
        "confirmation_token",
        "reauthentication_token",
        "recovery_token",
        "email_change_token_new",
        "email_change_token_current",
        "phone_change_token",
      ],
    },
  },
  public: {
    Enums: {},
  },
} as const

```

<!-- path: types/relational-row-types.ts -->
```typescript
import { Row } from "@/hooks/database";

export type RingRowsWithRelations = Row<'rings'> & {
  ring_type?: {
    id: string;
    code: string;
  } | null;
  maintenance_terminal?: {
    id: string;
    name: string;
  } | null;
};
  
  export type EmployeeDesignationRowsWithRelations = Row<'employee_designations'> & {
    parent?: {
      id: string;
      name: string;
    } | null;
  };
  
  export type EmployeeRowsWithRelations = Row<'employees'> & {
    employee_designation?: {
      id: string;
      name: string;
    } | null;
    maintenance_terminal?: {
      id: string;
      name: string;
    } | null;
  };
  
  export type FiberJointConnectionRowsWithRelations = Row<'fiber_joint_connections'> & {
    input_ofc_cable?: {
      id: string;
      route_name: string;
    } | null;
    fiber_joint?: {
      id: string;
      joint_name: string;
    } | null;
    logical_fiber_path?: {
      id: string;
      path_name: string;
    } | null;
    output_ofc_cable?: {
      id: string;
      route_name: string;
    } | null;
  };
  
  export type FiberJointRowsWithRelations = Row<'fiber_joints'> & {
    maintenance_area?: {
      id: string;
      name: string;
    } | null;
    node?: {
      id: string;
      name: string;
    } | null;
    joint_type_lookup?: {
      category: string;
      name: string;
    } | null;
  };
  
  export type LogicalFiberPathRowsWithRelations = Row<'logical_fiber_paths'> & {
    operational_status_lookup?: {
      category: string;
      name: string;
    } | null;
    path_type_lookup?: {
      category: string;
      name: string;
    } | null;
    destination_system?: {
      id: string;
      system_name: string;
    } | null;
    source_system?: {
      id: string;
      system_name: string;
    } | null;
  };
  
  
  export type MaintenanceAreaRowsWithRelations = Row<'maintenance_areas'> & {
    area_type?: {
      id: string;
      name: string;
    } | null;
    parent?: {
      id: string;
      name: string;
    } | null;
  };
  
  export type ManagementPortRowsWithRelations = Row<'management_ports'> & {
    node?: {
      id: string;
      name: string;
    } | null;
    system?: {
      id: string;
      system_name: string;
    } | null;
  };
  
  export type NodeRowsWithRelations = Row<'nodes'> & {
    maintenance_terminal?: {
      id: string;
      name: string;
    } | null;
    node_type?: {
      id: string;
      name: string;
    } | null;
  };
  
  export type OfcCableRowsWithRelations = Row<'ofc_cables'> & {
    en_node?: {
      id: string;
      name: string;
    } | null;
    maintenance_terminal?: {
      id: string;
      name: string;
    } | null;
    ofc_owner?: {
      id: string;
      name: string;
    } | null;
    ofc_type?: {
      id: string;
      name: string;
    } | null;
    sn_node?: {
      id: string;
      name: string;
    } | null;
  };
  
  export type OfcConnectionRowsWithRelations = Row<'ofc_connections'> & {
    connection_type_lookup?: {
      category: string;
      name: string;
    } | null;
    logical_fiber_path?: {
      id: string;
      path_name: string;
    } | null;
    system?: {
      id: string;
      system_name: string;
    } | null;
    ofc_cable?: {
      id: string;
      route_name: string;
    } | null;
  };
  
  export type SdhConnectionRowsWithRelations = Row<'sdh_connections'> & {
    system_connection?: {
      id: string;
    } | null;
  };
  
  export type SdhNodeAssociationRowsWithRelations = Row<'sdh_node_associations'> & {
    node?: {
      id: string;
      name: string;
    } | null;
    sdh_system?: {
      system_id: string;
    } | null;
  };
  
  export type SdhSystemRowsWithRelations = Row<'sdh_systems'> & {
    system?: {
      id: string;
    } | null;
  };
  
  export type SystemConnectionRowsWithRelations = Row<'system_connections'> & {
    connected_system?: {
      id: string;
      system_name: string;
    } | null;
    en_system?: {
      id: string;
      system_name: string;
    } | null;
    media_type?: {
      id: string;
      name: string;
    } | null;
    sn_system?: {
      id: string;
      system_name: string;
    } | null;
    system?: {
      id: string;
      system_name: string;
    } | null;
  };
  
  // In your types file, update the SystemRowsWithRelations type:
export type SystemRowsWithRelations = Row<'systems'> & {
  maintenance_terminal?: {
    id: string;
    name: string;
  } | null;
  node?: {
    id: string;
    name: string;
  } | null;
  system_type?: {
    id: string;
    name: string;
  } | null;
  // Add this to make commissioned_on required
  commissioned_on: Date | null;
} & {
  // This makes all fields from the base Row type required
  [K in keyof Row<'systems'>]: Row<'systems'>[K];
};
  
  export type UserActivityLogRowsWithRelations = Row<'user_activity_logs'> & {
    user_profile_extended?: {
      id: string;
    } | null;
  };
  
  export type UserProfileRowsWithRelations = Row<'user_profiles'> & {
    user_profile_extended?: {
      id: string;
    } | null;
  };
  
  export type VmuxConnectionRowsWithRelations = Row<'vmux_connections'> & {
    system_connection?: {
      id: string;
    } | null;
  };
  
  export type VmuxSystemRowsWithRelations = Row<'vmux_systems'> & {
    system?: {
      id: string;
    } | null;
  };
```

<!-- path: types/view-row-types.ts -->
```typescript
import { Row } from "@/hooks/database";

export type RingTypeRowsWithCount = Row<'v_rings_with_count'>
export type NodeRowsWithCount = Row<'v_nodes_complete'>
export type OfcCableRowsWithCount = Row<'v_ofc_cables_complete'>
export type OfcConnectionRowsWithCount = Row<'v_ofc_connections_complete'>
export type SystemConnectionRowsWithCount = Row<'v_system_connections_complete'>
export type SystemRowsWithCount = Row<'v_systems_complete'>
export type UserProfileRowsWithCount = Row<'v_user_profiles_extended'>
export type LookupTypeRowsWithCount = Row<'v_lookup_types_with_count'>
export type EmployeeDesignationRowsWithCount = Row<'v_employee_designations_with_count'>
export type MaintenanceAreaRowsWithCount = Row<'v_maintenance_areas_with_count'>
export type EmployeeRowsWithCount = Row<'v_employees_with_count'>

export type  SystemRowsWithCountWithRelations = Row<'v_systems_complete'> & {
    system_type?: {
        id: string;
        name: string;
    } | null;
    node?: {
        id: string;
        name: string;
    } | null;
    maintenance_terminal?: {
        id: string;
        name: string;
    } | null;
};

export type OfcConnectionRowsWithCountWithRelations = Row<'v_ofc_connections_complete'> & {
    connection_type_lookup?: {
        category: string;
        name: string;
    } | null;
    logical_fiber_path?: {
        id: string;
        path_name: string;
    } | null;
    system?: {
        id: string;
        system_name: string;
    } | null;
    ofc_cable?: {
        id: string;
        route_name: string;
    } | null;
};

    

```

<!-- path: types/flattened-types.ts -->
```typescript
// Auto-generated from types/supabase-types.ts

import type { Json, Database } from "@/types/supabase-types";

// ============= TABLES =============

export type AuthAudit_log_entriesRow = {
    created_at: string | null;
    id: string;
    instance_id: string | null;
    ip_address: string;
    payload: Json | null;
};

export type AuthAudit_log_entriesInsert = {
    created_at?: string | null;
    id: string;
    instance_id?: string | null;
    ip_address?: string;
    payload?: Json | null;
};

export type AuthAudit_log_entriesUpdate = {
    created_at?: string | null;
    id?: string;
    instance_id?: string | null;
    ip_address?: string;
    payload?: Json | null;
};

export type AuthFlow_stateRow = {
    auth_code: string;
    auth_code_issued_at: string | null;
    authentication_method: string;
    code_challenge: string;
    code_challenge_method: Database["auth"]["Enums"]["code_challenge_method"];
    created_at: string | null;
    id: string;
    provider_access_token: string | null;
    provider_refresh_token: string | null;
    provider_type: string;
    updated_at: string | null;
    user_id: string | null;
};

export type AuthFlow_stateInsert = {
    auth_code: string;
    auth_code_issued_at?: string | null;
    authentication_method: string;
    code_challenge: string;
    code_challenge_method: Database["auth"]["Enums"]["code_challenge_method"];
    created_at?: string | null;
    id: string;
    provider_access_token?: string | null;
    provider_refresh_token?: string | null;
    provider_type: string;
    updated_at?: string | null;
    user_id?: string | null;
};

export type AuthFlow_stateUpdate = {
    auth_code?: string;
    auth_code_issued_at?: string | null;
    authentication_method?: string;
    code_challenge?: string;
    code_challenge_method?: Database["auth"]["Enums"]["code_challenge_method"];
    created_at?: string | null;
    id?: string;
    provider_access_token?: string | null;
    provider_refresh_token?: string | null;
    provider_type?: string;
    updated_at?: string | null;
    user_id?: string | null;
};

export type AuthIdentitiesRow = {
    created_at: string | null;
    email: string | null;
    id: string;
    identity_data: Json;
    last_sign_in_at: string | null;
    provider: string;
    provider_id: string;
    updated_at: string | null;
    user_id: string;
};

export type AuthIdentitiesInsert = {
    created_at?: string | null;
    email?: string | null;
    id?: string;
    identity_data: Json;
    last_sign_in_at?: string | null;
    provider: string;
    provider_id: string;
    updated_at?: string | null;
    user_id: string;
};

export type AuthIdentitiesUpdate = {
    created_at?: string | null;
    email?: string | null;
    id?: string;
    identity_data?: Json;
    last_sign_in_at?: string | null;
    provider?: string;
    provider_id?: string;
    updated_at?: string | null;
    user_id?: string;
};

export type AuthInstancesRow = {
    created_at: string | null;
    id: string;
    raw_base_config: string | null;
    updated_at: string | null;
    uuid: string | null;
};

export type AuthInstancesInsert = {
    created_at?: string | null;
    id: string;
    raw_base_config?: string | null;
    updated_at?: string | null;
    uuid?: string | null;
};

export type AuthInstancesUpdate = {
    created_at?: string | null;
    id?: string;
    raw_base_config?: string | null;
    updated_at?: string | null;
    uuid?: string | null;
};

export type AuthMfa_amr_claimsRow = {
    authentication_method: string;
    created_at: string;
    id: string;
    session_id: string;
    updated_at: string;
};

export type AuthMfa_amr_claimsInsert = {
    authentication_method: string;
    created_at: string;
    id: string;
    session_id: string;
    updated_at: string;
};

export type AuthMfa_amr_claimsUpdate = {
    authentication_method?: string;
    created_at?: string;
    id?: string;
    session_id?: string;
    updated_at?: string;
};

export type AuthMfa_challengesRow = {
    created_at: string;
    factor_id: string;
    id: string;
    ip_address: unknown;
    otp_code: string | null;
    verified_at: string | null;
    web_authn_session_data: Json | null;
};

export type AuthMfa_challengesInsert = {
    created_at: string;
    factor_id: string;
    id: string;
    ip_address: unknown;
    otp_code?: string | null;
    verified_at?: string | null;
    web_authn_session_data?: Json | null;
};

export type AuthMfa_challengesUpdate = {
    created_at?: string;
    factor_id?: string;
    id?: string;
    ip_address?: unknown;
    otp_code?: string | null;
    verified_at?: string | null;
    web_authn_session_data?: Json | null;
};

export type AuthMfa_factorsRow = {
    created_at: string;
    factor_type: Database["auth"]["Enums"]["factor_type"];
    friendly_name: string | null;
    id: string;
    last_challenged_at: string | null;
    phone: string | null;
    secret: string | null;
    status: Database["auth"]["Enums"]["factor_status"];
    updated_at: string;
    user_id: string;
    web_authn_aaguid: string | null;
    web_authn_credential: Json | null;
};

export type AuthMfa_factorsInsert = {
    created_at: string;
    factor_type: Database["auth"]["Enums"]["factor_type"];
    friendly_name?: string | null;
    id: string;
    last_challenged_at?: string | null;
    phone?: string | null;
    secret?: string | null;
    status: Database["auth"]["Enums"]["factor_status"];
    updated_at: string;
    user_id: string;
    web_authn_aaguid?: string | null;
    web_authn_credential?: Json | null;
};

export type AuthMfa_factorsUpdate = {
    created_at?: string;
    factor_type?: Database["auth"]["Enums"]["factor_type"];
    friendly_name?: string | null;
    id?: string;
    last_challenged_at?: string | null;
    phone?: string | null;
    secret?: string | null;
    status?: Database["auth"]["Enums"]["factor_status"];
    updated_at?: string;
    user_id?: string;
    web_authn_aaguid?: string | null;
    web_authn_credential?: Json | null;
};

export type AuthOauth_clientsRow = {
    client_id: string;
    client_name: string | null;
    client_secret_hash: string;
    client_uri: string | null;
    created_at: string;
    deleted_at: string | null;
    grant_types: string;
    id: string;
    logo_uri: string | null;
    redirect_uris: string;
    registration_type: Database["auth"]["Enums"]["oauth_registration_type"];
    updated_at: string;
};

export type AuthOauth_clientsInsert = {
    client_id: string;
    client_name?: string | null;
    client_secret_hash: string;
    client_uri?: string | null;
    created_at?: string;
    deleted_at?: string | null;
    grant_types: string;
    id: string;
    logo_uri?: string | null;
    redirect_uris: string;
    registration_type: Database["auth"]["Enums"]["oauth_registration_type"];
    updated_at?: string;
};

export type AuthOauth_clientsUpdate = {
    client_id?: string;
    client_name?: string | null;
    client_secret_hash?: string;
    client_uri?: string | null;
    created_at?: string;
    deleted_at?: string | null;
    grant_types?: string;
    id?: string;
    logo_uri?: string | null;
    redirect_uris?: string;
    registration_type?: Database["auth"]["Enums"]["oauth_registration_type"];
    updated_at?: string;
};

export type AuthOne_time_tokensRow = {
    created_at: string;
    id: string;
    relates_to: string;
    token_hash: string;
    token_type: Database["auth"]["Enums"]["one_time_token_type"];
    updated_at: string;
    user_id: string;
};

export type AuthOne_time_tokensInsert = {
    created_at?: string;
    id: string;
    relates_to: string;
    token_hash: string;
    token_type: Database["auth"]["Enums"]["one_time_token_type"];
    updated_at?: string;
    user_id: string;
};

export type AuthOne_time_tokensUpdate = {
    created_at?: string;
    id?: string;
    relates_to?: string;
    token_hash?: string;
    token_type?: Database["auth"]["Enums"]["one_time_token_type"];
    updated_at?: string;
    user_id?: string;
};

export type AuthRefresh_tokensRow = {
    created_at: string | null;
    id: number;
    instance_id: string | null;
    parent: string | null;
    revoked: boolean | null;
    session_id: string | null;
    token: string | null;
    updated_at: string | null;
    user_id: string | null;
};

export type AuthRefresh_tokensInsert = {
    created_at?: string | null;
    id?: number;
    instance_id?: string | null;
    parent?: string | null;
    revoked?: boolean | null;
    session_id?: string | null;
    token?: string | null;
    updated_at?: string | null;
    user_id?: string | null;
};

export type AuthRefresh_tokensUpdate = {
    created_at?: string | null;
    id?: number;
    instance_id?: string | null;
    parent?: string | null;
    revoked?: boolean | null;
    session_id?: string | null;
    token?: string | null;
    updated_at?: string | null;
    user_id?: string | null;
};

export type AuthSaml_providersRow = {
    attribute_mapping: Json | null;
    created_at: string | null;
    entity_id: string;
    id: string;
    metadata_url: string | null;
    metadata_xml: string;
    name_id_format: string | null;
    sso_provider_id: string;
    updated_at: string | null;
};

export type AuthSaml_providersInsert = {
    attribute_mapping?: Json | null;
    created_at?: string | null;
    entity_id: string;
    id: string;
    metadata_url?: string | null;
    metadata_xml: string;
    name_id_format?: string | null;
    sso_provider_id: string;
    updated_at?: string | null;
};

export type AuthSaml_providersUpdate = {
    attribute_mapping?: Json | null;
    created_at?: string | null;
    entity_id?: string;
    id?: string;
    metadata_url?: string | null;
    metadata_xml?: string;
    name_id_format?: string | null;
    sso_provider_id?: string;
    updated_at?: string | null;
};

export type AuthSaml_relay_statesRow = {
    created_at: string | null;
    flow_state_id: string | null;
    for_email: string | null;
    id: string;
    redirect_to: string | null;
    request_id: string;
    sso_provider_id: string;
    updated_at: string | null;
};

export type AuthSaml_relay_statesInsert = {
    created_at?: string | null;
    flow_state_id?: string | null;
    for_email?: string | null;
    id: string;
    redirect_to?: string | null;
    request_id: string;
    sso_provider_id: string;
    updated_at?: string | null;
};

export type AuthSaml_relay_statesUpdate = {
    created_at?: string | null;
    flow_state_id?: string | null;
    for_email?: string | null;
    id?: string;
    redirect_to?: string | null;
    request_id?: string;
    sso_provider_id?: string;
    updated_at?: string | null;
};

export type AuthSchema_migrationsRow = {
    version: string;
};

export type AuthSchema_migrationsInsert = {
    version: string;
};

export type AuthSchema_migrationsUpdate = {
    version?: string;
};

export type AuthSessionsRow = {
    aal: Database["auth"]["Enums"]["aal_level"] | null;
    created_at: string | null;
    factor_id: string | null;
    id: string;
    ip: unknown | null;
    not_after: string | null;
    refreshed_at: string | null;
    tag: string | null;
    updated_at: string | null;
    user_agent: string | null;
    user_id: string;
};

export type AuthSessionsInsert = {
    aal?: Database["auth"]["Enums"]["aal_level"] | null;
    created_at?: string | null;
    factor_id?: string | null;
    id: string;
    ip?: unknown | null;
    not_after?: string | null;
    refreshed_at?: string | null;
    tag?: string | null;
    updated_at?: string | null;
    user_agent?: string | null;
    user_id: string;
};

export type AuthSessionsUpdate = {
    aal?: Database["auth"]["Enums"]["aal_level"] | null;
    created_at?: string | null;
    factor_id?: string | null;
    id?: string;
    ip?: unknown | null;
    not_after?: string | null;
    refreshed_at?: string | null;
    tag?: string | null;
    updated_at?: string | null;
    user_agent?: string | null;
    user_id?: string;
};

export type AuthSso_domainsRow = {
    created_at: string | null;
    domain: string;
    id: string;
    sso_provider_id: string;
    updated_at: string | null;
};

export type AuthSso_domainsInsert = {
    created_at?: string | null;
    domain: string;
    id: string;
    sso_provider_id: string;
    updated_at?: string | null;
};

export type AuthSso_domainsUpdate = {
    created_at?: string | null;
    domain?: string;
    id?: string;
    sso_provider_id?: string;
    updated_at?: string | null;
};

export type AuthSso_providersRow = {
    created_at: string | null;
    disabled: boolean | null;
    id: string;
    resource_id: string | null;
    updated_at: string | null;
};

export type AuthSso_providersInsert = {
    created_at?: string | null;
    disabled?: boolean | null;
    id: string;
    resource_id?: string | null;
    updated_at?: string | null;
};

export type AuthSso_providersUpdate = {
    created_at?: string | null;
    disabled?: boolean | null;
    id?: string;
    resource_id?: string | null;
    updated_at?: string | null;
};

export type AuthUsersRow = {
    aud: string | null;
    banned_until: string | null;
    confirmation_sent_at: string | null;
    confirmation_token: string | null;
    confirmed_at: string | null;
    created_at: string | null;
    deleted_at: string | null;
    email: string | null;
    email_change: string | null;
    email_change_confirm_status: number | null;
    email_change_sent_at: string | null;
    email_change_token_current: string | null;
    email_change_token_new: string | null;
    email_confirmed_at: string | null;
    encrypted_password: string | null;
    id: string;
    instance_id: string | null;
    invited_at: string | null;
    is_anonymous: boolean;
    is_sso_user: boolean;
    is_super_admin: boolean | null;
    last_sign_in_at: string | null;
    phone: string | null;
    phone_change: string | null;
    phone_change_sent_at: string | null;
    phone_change_token: string | null;
    phone_confirmed_at: string | null;
    raw_app_meta_data: Json | null;
    raw_user_meta_data: Json | null;
    reauthentication_sent_at: string | null;
    reauthentication_token: string | null;
    recovery_sent_at: string | null;
    recovery_token: string | null;
    role: string | null;
    updated_at: string | null;
};

export type AuthUsersInsert = {
    aud?: string | null;
    banned_until?: string | null;
    confirmation_sent_at?: string | null;
    confirmation_token?: string | null;
    confirmed_at?: string | null;
    created_at?: string | null;
    deleted_at?: string | null;
    email?: string | null;
    email_change?: string | null;
    email_change_confirm_status?: number | null;
    email_change_sent_at?: string | null;
    email_change_token_current?: string | null;
    email_change_token_new?: string | null;
    email_confirmed_at?: string | null;
    encrypted_password?: string | null;
    id: string;
    instance_id?: string | null;
    invited_at?: string | null;
    is_anonymous?: boolean;
    is_sso_user?: boolean;
    is_super_admin?: boolean | null;
    last_sign_in_at?: string | null;
    phone?: string | null;
    phone_change?: string | null;
    phone_change_sent_at?: string | null;
    phone_change_token?: string | null;
    phone_confirmed_at?: string | null;
    raw_app_meta_data?: Json | null;
    raw_user_meta_data?: Json | null;
    reauthentication_sent_at?: string | null;
    reauthentication_token?: string | null;
    recovery_sent_at?: string | null;
    recovery_token?: string | null;
    role?: string | null;
    updated_at?: string | null;
};

export type AuthUsersUpdate = {
    aud?: string | null;
    banned_until?: string | null;
    confirmation_sent_at?: string | null;
    confirmation_token?: string | null;
    confirmed_at?: string | null;
    created_at?: string | null;
    deleted_at?: string | null;
    email?: string | null;
    email_change?: string | null;
    email_change_confirm_status?: number | null;
    email_change_sent_at?: string | null;
    email_change_token_current?: string | null;
    email_change_token_new?: string | null;
    email_confirmed_at?: string | null;
    encrypted_password?: string | null;
    id?: string;
    instance_id?: string | null;
    invited_at?: string | null;
    is_anonymous?: boolean;
    is_sso_user?: boolean;
    is_super_admin?: boolean | null;
    last_sign_in_at?: string | null;
    phone?: string | null;
    phone_change?: string | null;
    phone_change_sent_at?: string | null;
    phone_change_token?: string | null;
    phone_confirmed_at?: string | null;
    raw_app_meta_data?: Json | null;
    raw_user_meta_data?: Json | null;
    reauthentication_sent_at?: string | null;
    reauthentication_token?: string | null;
    recovery_sent_at?: string | null;
    recovery_token?: string | null;
    role?: string | null;
    updated_at?: string | null;
};

export type Cable_segmentsRow = {
    created_at: string | null;
    distance_km: number;
    end_node_id: string;
    end_node_type: string;
    fiber_count: number;
    id: string;
    original_cable_id: string;
    segment_order: number;
    start_node_id: string;
    start_node_type: string;
    updated_at: string | null;
};

export type Cable_segmentsInsert = {
    created_at?: string | null;
    distance_km: number;
    end_node_id: string;
    end_node_type: string;
    fiber_count: number;
    id?: string;
    original_cable_id: string;
    segment_order: number;
    start_node_id: string;
    start_node_type: string;
    updated_at?: string | null;
};

export type Cable_segmentsUpdate = {
    created_at?: string | null;
    distance_km?: number;
    end_node_id?: string;
    end_node_type?: string;
    fiber_count?: number;
    id?: string;
    original_cable_id?: string;
    segment_order?: number;
    start_node_id?: string;
    start_node_type?: string;
    updated_at?: string | null;
};

export type Employee_designationsRow = {
    created_at: string | null;
    id: string;
    name: string;
    parent_id: string | null;
    status: boolean | null;
    updated_at: string | null;
};

export type Employee_designationsInsert = {
    created_at?: string | null;
    id?: string;
    name: string;
    parent_id?: string | null;
    status?: boolean | null;
    updated_at?: string | null;
};

export type Employee_designationsUpdate = {
    created_at?: string | null;
    id?: string;
    name?: string;
    parent_id?: string | null;
    status?: boolean | null;
    updated_at?: string | null;
};

export type EmployeesRow = {
    created_at: string | null;
    employee_addr: string | null;
    employee_contact: string | null;
    employee_designation_id: string | null;
    employee_dob: string | null;
    employee_doj: string | null;
    employee_email: string | null;
    employee_name: string;
    employee_pers_no: string | null;
    id: string;
    maintenance_terminal_id: string | null;
    remark: string | null;
    status: boolean | null;
    updated_at: string | null;
};

export type EmployeesInsert = {
    created_at?: string | null;
    employee_addr?: string | null;
    employee_contact?: string | null;
    employee_designation_id?: string | null;
    employee_dob?: string | null;
    employee_doj?: string | null;
    employee_email?: string | null;
    employee_name: string;
    employee_pers_no?: string | null;
    id?: string;
    maintenance_terminal_id?: string | null;
    remark?: string | null;
    status?: boolean | null;
    updated_at?: string | null;
};

export type EmployeesUpdate = {
    created_at?: string | null;
    employee_addr?: string | null;
    employee_contact?: string | null;
    employee_designation_id?: string | null;
    employee_dob?: string | null;
    employee_doj?: string | null;
    employee_email?: string | null;
    employee_name?: string;
    employee_pers_no?: string | null;
    id?: string;
    maintenance_terminal_id?: string | null;
    remark?: string | null;
    status?: boolean | null;
    updated_at?: string | null;
};

export type Fiber_splicesRow = {
    created_at: string | null;
    id: string;
    incoming_cable_id: string;
    incoming_fiber_no: number;
    jc_id: string;
    logical_path_id: string | null;
    loss_db: number | null;
    otdr_length_km: number | null;
    outgoing_cable_id: string | null;
    outgoing_fiber_no: number | null;
    splice_type: string;
    status: string;
    updated_at: string | null;
};

export type Fiber_splicesInsert = {
    created_at?: string | null;
    id?: string;
    incoming_cable_id: string;
    incoming_fiber_no: number;
    jc_id: string;
    logical_path_id?: string | null;
    loss_db?: number | null;
    otdr_length_km?: number | null;
    outgoing_cable_id?: string | null;
    outgoing_fiber_no?: number | null;
    splice_type?: string;
    status?: string;
    updated_at?: string | null;
};

export type Fiber_splicesUpdate = {
    created_at?: string | null;
    id?: string;
    incoming_cable_id?: string;
    incoming_fiber_no?: number;
    jc_id?: string;
    logical_path_id?: string | null;
    loss_db?: number | null;
    otdr_length_km?: number | null;
    outgoing_cable_id?: string | null;
    outgoing_fiber_no?: number | null;
    splice_type?: string;
    status?: string;
    updated_at?: string | null;
};

export type FilesRow = {
    file_name: string;
    file_route: string;
    file_size: string;
    file_type: string;
    file_url: string;
    folder_id: string | null;
    id: string;
    uploaded_at: string | null;
    user_id: string;
};

export type FilesInsert = {
    file_name: string;
    file_route: string;
    file_size: string;
    file_type: string;
    file_url: string;
    folder_id?: string | null;
    id?: string;
    uploaded_at?: string | null;
    user_id: string;
};

export type FilesUpdate = {
    file_name?: string;
    file_route?: string;
    file_size?: string;
    file_type?: string;
    file_url?: string;
    folder_id?: string | null;
    id?: string;
    uploaded_at?: string | null;
    user_id?: string;
};

export type FoldersRow = {
    created_at: string | null;
    id: string;
    name: string;
    user_id: string;
};

export type FoldersInsert = {
    created_at?: string | null;
    id?: string;
    name: string;
    user_id: string;
};

export type FoldersUpdate = {
    created_at?: string | null;
    id?: string;
    name?: string;
    user_id?: string;
};

export type Junction_closuresRow = {
    created_at: string | null;
    id: string;
    node_id: string;
    ofc_cable_id: string;
    position_km: number | null;
    updated_at: string | null;
};

export type Junction_closuresInsert = {
    created_at?: string | null;
    id?: string;
    node_id: string;
    ofc_cable_id: string;
    position_km?: number | null;
    updated_at?: string | null;
};

export type Junction_closuresUpdate = {
    created_at?: string | null;
    id?: string;
    node_id?: string;
    ofc_cable_id?: string;
    position_km?: number | null;
    updated_at?: string | null;
};

export type Logical_fiber_pathsRow = {
    bandwidth_gbps: number | null;
    commissioned_date: string | null;
    created_at: string | null;
    destination_port: string | null;
    destination_system_id: string | null;
    id: string;
    operational_status_id: string | null;
    path_name: string | null;
    path_role: string;
    path_type_id: string | null;
    remark: string | null;
    service_type: string | null;
    source_port: string | null;
    source_system_id: string | null;
    total_distance_km: number | null;
    total_loss_db: number | null;
    updated_at: string | null;
    wavelength_nm: number | null;
    working_path_id: string | null;
};

export type Logical_fiber_pathsInsert = {
    bandwidth_gbps?: number | null;
    commissioned_date?: string | null;
    created_at?: string | null;
    destination_port?: string | null;
    destination_system_id?: string | null;
    id?: string;
    operational_status_id?: string | null;
    path_name?: string | null;
    path_role?: string;
    path_type_id?: string | null;
    remark?: string | null;
    service_type?: string | null;
    source_port?: string | null;
    source_system_id?: string | null;
    total_distance_km?: number | null;
    total_loss_db?: number | null;
    updated_at?: string | null;
    wavelength_nm?: number | null;
    working_path_id?: string | null;
};

export type Logical_fiber_pathsUpdate = {
    bandwidth_gbps?: number | null;
    commissioned_date?: string | null;
    created_at?: string | null;
    destination_port?: string | null;
    destination_system_id?: string | null;
    id?: string;
    operational_status_id?: string | null;
    path_name?: string | null;
    path_role?: string;
    path_type_id?: string | null;
    remark?: string | null;
    service_type?: string | null;
    source_port?: string | null;
    source_system_id?: string | null;
    total_distance_km?: number | null;
    total_loss_db?: number | null;
    updated_at?: string | null;
    wavelength_nm?: number | null;
    working_path_id?: string | null;
};

export type Lookup_typesRow = {
    category: string;
    code: string | null;
    created_at: string | null;
    description: string | null;
    id: string;
    is_system_default: boolean | null;
    name: string;
    sort_order: number | null;
    status: boolean | null;
    updated_at: string | null;
};

export type Lookup_typesInsert = {
    category: string;
    code?: string | null;
    created_at?: string | null;
    description?: string | null;
    id?: string;
    is_system_default?: boolean | null;
    name: string;
    sort_order?: number | null;
    status?: boolean | null;
    updated_at?: string | null;
};

export type Lookup_typesUpdate = {
    category?: string;
    code?: string | null;
    created_at?: string | null;
    description?: string | null;
    id?: string;
    is_system_default?: boolean | null;
    name?: string;
    sort_order?: number | null;
    status?: boolean | null;
    updated_at?: string | null;
};

export type Maintenance_areasRow = {
    address: string | null;
    area_type_id: string | null;
    code: string | null;
    contact_number: string | null;
    contact_person: string | null;
    created_at: string | null;
    email: string | null;
    id: string;
    latitude: number | null;
    longitude: number | null;
    name: string;
    parent_id: string | null;
    status: boolean | null;
    updated_at: string | null;
};

export type Maintenance_areasInsert = {
    address?: string | null;
    area_type_id?: string | null;
    code?: string | null;
    contact_number?: string | null;
    contact_person?: string | null;
    created_at?: string | null;
    email?: string | null;
    id?: string;
    latitude?: number | null;
    longitude?: number | null;
    name: string;
    parent_id?: string | null;
    status?: boolean | null;
    updated_at?: string | null;
};

export type Maintenance_areasUpdate = {
    address?: string | null;
    area_type_id?: string | null;
    code?: string | null;
    contact_number?: string | null;
    contact_person?: string | null;
    created_at?: string | null;
    email?: string | null;
    id?: string;
    latitude?: number | null;
    longitude?: number | null;
    name?: string;
    parent_id?: string | null;
    status?: boolean | null;
    updated_at?: string | null;
};

export type Management_portsRow = {
    commissioned_on: string | null;
    created_at: string | null;
    id: string;
    name: string | null;
    node_id: string | null;
    port_no: string;
    remark: string | null;
    status: boolean | null;
    system_id: string | null;
    updated_at: string | null;
};

export type Management_portsInsert = {
    commissioned_on?: string | null;
    created_at?: string | null;
    id?: string;
    name?: string | null;
    node_id?: string | null;
    port_no: string;
    remark?: string | null;
    status?: boolean | null;
    system_id?: string | null;
    updated_at?: string | null;
};

export type Management_portsUpdate = {
    commissioned_on?: string | null;
    created_at?: string | null;
    id?: string;
    name?: string | null;
    node_id?: string | null;
    port_no?: string;
    remark?: string | null;
    status?: boolean | null;
    system_id?: string | null;
    updated_at?: string | null;
};

export type NodesRow = {
    created_at: string | null;
    id: string;
    latitude: number | null;
    longitude: number | null;
    maintenance_terminal_id: string | null;
    name: string;
    node_type_id: string | null;
    remark: string | null;
    status: boolean | null;
    updated_at: string | null;
};

export type NodesInsert = {
    created_at?: string | null;
    id?: string;
    latitude?: number | null;
    longitude?: number | null;
    maintenance_terminal_id?: string | null;
    name: string;
    node_type_id?: string | null;
    remark?: string | null;
    status?: boolean | null;
    updated_at?: string | null;
};

export type NodesUpdate = {
    created_at?: string | null;
    id?: string;
    latitude?: number | null;
    longitude?: number | null;
    maintenance_terminal_id?: string | null;
    name?: string;
    node_type_id?: string | null;
    remark?: string | null;
    status?: boolean | null;
    updated_at?: string | null;
};

export type Ofc_cablesRow = {
    asset_no: string | null;
    capacity: number;
    commissioned_on: string | null;
    created_at: string | null;
    current_rkm: number | null;
    en_id: string;
    id: string;
    maintenance_terminal_id: string | null;
    ofc_owner_id: string;
    ofc_type_id: string;
    remark: string | null;
    route_name: string;
    sn_id: string;
    status: boolean | null;
    transnet_id: string | null;
    transnet_rkm: number | null;
    updated_at: string | null;
};

export type Ofc_cablesInsert = {
    asset_no?: string | null;
    capacity: number;
    commissioned_on?: string | null;
    created_at?: string | null;
    current_rkm?: number | null;
    en_id: string;
    id?: string;
    maintenance_terminal_id?: string | null;
    ofc_owner_id: string;
    ofc_type_id: string;
    remark?: string | null;
    route_name: string;
    sn_id: string;
    status?: boolean | null;
    transnet_id?: string | null;
    transnet_rkm?: number | null;
    updated_at?: string | null;
};

export type Ofc_cablesUpdate = {
    asset_no?: string | null;
    capacity?: number;
    commissioned_on?: string | null;
    created_at?: string | null;
    current_rkm?: number | null;
    en_id?: string;
    id?: string;
    maintenance_terminal_id?: string | null;
    ofc_owner_id?: string;
    ofc_type_id?: string;
    remark?: string | null;
    route_name?: string;
    sn_id?: string;
    status?: boolean | null;
    transnet_id?: string | null;
    transnet_rkm?: number | null;
    updated_at?: string | null;
};

export type Ofc_connectionsRow = {
    connection_category: string;
    connection_type: string;
    created_at: string | null;
    destination_port: string | null;
    en_dom: string | null;
    en_power_dbm: number | null;
    fiber_no_en: number;
    fiber_no_sn: number;
    fiber_role: string | null;
    id: string;
    logical_path_id: string | null;
    ofc_id: string;
    otdr_distance_en_km: number | null;
    otdr_distance_sn_km: number | null;
    path_segment_order: number | null;
    remark: string | null;
    route_loss_db: number | null;
    sn_dom: string | null;
    sn_power_dbm: number | null;
    source_port: string | null;
    status: boolean | null;
    system_id: string | null;
    updated_at: string | null;
};

export type Ofc_connectionsInsert = {
    connection_category?: string;
    connection_type?: string;
    created_at?: string | null;
    destination_port?: string | null;
    en_dom?: string | null;
    en_power_dbm?: number | null;
    fiber_no_en: number;
    fiber_no_sn: number;
    fiber_role?: string | null;
    id?: string;
    logical_path_id?: string | null;
    ofc_id: string;
    otdr_distance_en_km?: number | null;
    otdr_distance_sn_km?: number | null;
    path_segment_order?: number | null;
    remark?: string | null;
    route_loss_db?: number | null;
    sn_dom?: string | null;
    sn_power_dbm?: number | null;
    source_port?: string | null;
    status?: boolean | null;
    system_id?: string | null;
    updated_at?: string | null;
};

export type Ofc_connectionsUpdate = {
    connection_category?: string;
    connection_type?: string;
    created_at?: string | null;
    destination_port?: string | null;
    en_dom?: string | null;
    en_power_dbm?: number | null;
    fiber_no_en?: number;
    fiber_no_sn?: number;
    fiber_role?: string | null;
    id?: string;
    logical_path_id?: string | null;
    ofc_id?: string;
    otdr_distance_en_km?: number | null;
    otdr_distance_sn_km?: number | null;
    path_segment_order?: number | null;
    remark?: string | null;
    route_loss_db?: number | null;
    sn_dom?: string | null;
    sn_power_dbm?: number | null;
    source_port?: string | null;
    status?: boolean | null;
    system_id?: string | null;
    updated_at?: string | null;
};

export type Ring_based_systemsRow = {
    maintenance_area_id: string | null;
    ring_id: string | null;
    system_id: string;
};

export type Ring_based_systemsInsert = {
    maintenance_area_id?: string | null;
    ring_id?: string | null;
    system_id: string;
};

export type Ring_based_systemsUpdate = {
    maintenance_area_id?: string | null;
    ring_id?: string | null;
    system_id?: string;
};

export type RingsRow = {
    created_at: string | null;
    description: string | null;
    id: string;
    maintenance_terminal_id: string | null;
    name: string;
    ring_type_id: string | null;
    status: boolean | null;
    total_nodes: number | null;
    updated_at: string | null;
};

export type RingsInsert = {
    created_at?: string | null;
    description?: string | null;
    id?: string;
    maintenance_terminal_id?: string | null;
    name: string;
    ring_type_id?: string | null;
    status?: boolean | null;
    total_nodes?: number | null;
    updated_at?: string | null;
};

export type RingsUpdate = {
    created_at?: string | null;
    description?: string | null;
    id?: string;
    maintenance_terminal_id?: string | null;
    name?: string;
    ring_type_id?: string | null;
    status?: boolean | null;
    total_nodes?: number | null;
    updated_at?: string | null;
};

export type Sdh_connectionsRow = {
    a_customer: string | null;
    a_slot: string | null;
    b_customer: string | null;
    b_slot: string | null;
    carrier: string | null;
    stm_no: string | null;
    system_connection_id: string;
};

export type Sdh_connectionsInsert = {
    a_customer?: string | null;
    a_slot?: string | null;
    b_customer?: string | null;
    b_slot?: string | null;
    carrier?: string | null;
    stm_no?: string | null;
    system_connection_id: string;
};

export type Sdh_connectionsUpdate = {
    a_customer?: string | null;
    a_slot?: string | null;
    b_customer?: string | null;
    b_slot?: string | null;
    carrier?: string | null;
    stm_no?: string | null;
    system_connection_id?: string;
};

export type Sdh_node_associationsRow = {
    id: string;
    node_id: string;
    node_ip: unknown | null;
    node_position: string | null;
    sdh_system_id: string;
};

export type Sdh_node_associationsInsert = {
    id?: string;
    node_id: string;
    node_ip?: unknown | null;
    node_position?: string | null;
    sdh_system_id: string;
};

export type Sdh_node_associationsUpdate = {
    id?: string;
    node_id?: string;
    node_ip?: unknown | null;
    node_position?: string | null;
    sdh_system_id?: string;
};

export type Sdh_systemsRow = {
    gne: string | null;
    make: string | null;
    system_id: string;
};

export type Sdh_systemsInsert = {
    gne?: string | null;
    make?: string | null;
    system_id: string;
};

export type Sdh_systemsUpdate = {
    gne?: string | null;
    make?: string | null;
    system_id?: string;
};

export type Sfp_based_connectionsRow = {
    bandwidth_allocated_mbps: number | null;
    customer_name: string | null;
    fiber_in: number | null;
    fiber_out: number | null;
    sfp_capacity: string | null;
    sfp_port: string | null;
    sfp_serial_no: string | null;
    sfp_type_id: string | null;
    system_connection_id: string;
};

export type Sfp_based_connectionsInsert = {
    bandwidth_allocated_mbps?: number | null;
    customer_name?: string | null;
    fiber_in?: number | null;
    fiber_out?: number | null;
    sfp_capacity?: string | null;
    sfp_port?: string | null;
    sfp_serial_no?: string | null;
    sfp_type_id?: string | null;
    system_connection_id: string;
};

export type Sfp_based_connectionsUpdate = {
    bandwidth_allocated_mbps?: number | null;
    customer_name?: string | null;
    fiber_in?: number | null;
    fiber_out?: number | null;
    sfp_capacity?: string | null;
    sfp_port?: string | null;
    sfp_serial_no?: string | null;
    sfp_type_id?: string | null;
    system_connection_id?: string;
};

export type System_connectionsRow = {
    bandwidth_mbps: number | null;
    commissioned_on: string | null;
    connected_system_id: string | null;
    created_at: string | null;
    en_id: string | null;
    en_interface: string | null;
    en_ip: unknown | null;
    id: string;
    media_type_id: string | null;
    remark: string | null;
    sn_id: string | null;
    sn_interface: string | null;
    sn_ip: unknown | null;
    status: boolean | null;
    system_id: string;
    updated_at: string | null;
    vlan: string | null;
};

export type System_connectionsInsert = {
    bandwidth_mbps?: number | null;
    commissioned_on?: string | null;
    connected_system_id?: string | null;
    created_at?: string | null;
    en_id?: string | null;
    en_interface?: string | null;
    en_ip?: unknown | null;
    id?: string;
    media_type_id?: string | null;
    remark?: string | null;
    sn_id?: string | null;
    sn_interface?: string | null;
    sn_ip?: unknown | null;
    status?: boolean | null;
    system_id: string;
    updated_at?: string | null;
    vlan?: string | null;
};

export type System_connectionsUpdate = {
    bandwidth_mbps?: number | null;
    commissioned_on?: string | null;
    connected_system_id?: string | null;
    created_at?: string | null;
    en_id?: string | null;
    en_interface?: string | null;
    en_ip?: unknown | null;
    id?: string;
    media_type_id?: string | null;
    remark?: string | null;
    sn_id?: string | null;
    sn_interface?: string | null;
    sn_ip?: unknown | null;
    status?: boolean | null;
    system_id?: string;
    updated_at?: string | null;
    vlan?: string | null;
};

export type SystemsRow = {
    commissioned_on: string | null;
    created_at: string | null;
    id: string;
    ip_address: unknown | null;
    maintenance_terminal_id: string | null;
    node_id: string;
    remark: string | null;
    s_no: string | null;
    status: boolean | null;
    system_name: string | null;
    system_type_id: string;
    updated_at: string | null;
};

export type SystemsInsert = {
    commissioned_on?: string | null;
    created_at?: string | null;
    id?: string;
    ip_address?: unknown | null;
    maintenance_terminal_id?: string | null;
    node_id: string;
    remark?: string | null;
    s_no?: string | null;
    status?: boolean | null;
    system_name?: string | null;
    system_type_id: string;
    updated_at?: string | null;
};

export type SystemsUpdate = {
    commissioned_on?: string | null;
    created_at?: string | null;
    id?: string;
    ip_address?: unknown | null;
    maintenance_terminal_id?: string | null;
    node_id?: string;
    remark?: string | null;
    s_no?: string | null;
    status?: boolean | null;
    system_name?: string | null;
    system_type_id?: string;
    updated_at?: string | null;
};

export type User_profilesRow = {
    address: Json | null;
    avatar_url: string | null;
    created_at: string | null;
    date_of_birth: string | null;
    designation: string | null;
    first_name: string;
    id: string;
    last_name: string;
    phone_number: string | null;
    preferences: Json | null;
    role: string | null;
    status: string | null;
    updated_at: string | null;
};

export type User_profilesInsert = {
    address?: Json | null;
    avatar_url?: string | null;
    created_at?: string | null;
    date_of_birth?: string | null;
    designation?: string | null;
    first_name: string;
    id: string;
    last_name: string;
    phone_number?: string | null;
    preferences?: Json | null;
    role?: string | null;
    status?: string | null;
    updated_at?: string | null;
};

export type User_profilesUpdate = {
    address?: Json | null;
    avatar_url?: string | null;
    created_at?: string | null;
    date_of_birth?: string | null;
    designation?: string | null;
    first_name?: string;
    id?: string;
    last_name?: string;
    phone_number?: string | null;
    preferences?: Json | null;
    role?: string | null;
    status?: string | null;
    updated_at?: string | null;
};

export type Vmux_connectionsRow = {
    c_code: string | null;
    channel: string | null;
    subscriber: string | null;
    system_connection_id: string;
    tk: string | null;
};

export type Vmux_connectionsInsert = {
    c_code?: string | null;
    channel?: string | null;
    subscriber?: string | null;
    system_connection_id: string;
    tk?: string | null;
};

export type Vmux_connectionsUpdate = {
    c_code?: string | null;
    channel?: string | null;
    subscriber?: string | null;
    system_connection_id?: string;
    tk?: string | null;
};

export type Vmux_systemsRow = {
    system_id: string;
    vm_id: string | null;
};

export type Vmux_systemsInsert = {
    system_id: string;
    vm_id?: string | null;
};

export type Vmux_systemsUpdate = {
    system_id?: string;
    vm_id?: string | null;
};

// ============= VIEWS =============

export type V_employee_designations_with_countRow = {
    active_count: number | null;
    created_at: string | null;
    id: string | null;
    inactive_count: number | null;
    name: string | null;
    parent_id: string | null;
    status: boolean | null;
    total_count: number | null;
    updated_at: string | null;
};

export type V_employees_with_countRow = {
    active_count: number | null;
    created_at: string | null;
    employee_addr: string | null;
    employee_contact: string | null;
    employee_designation_id: string | null;
    employee_designation_name: string | null;
    employee_dob: string | null;
    employee_doj: string | null;
    employee_email: string | null;
    employee_name: string | null;
    employee_pers_no: string | null;
    id: string | null;
    inactive_count: number | null;
    maintenance_terminal_id: string | null;
    remark: string | null;
    status: boolean | null;
    total_count: number | null;
    updated_at: string | null;
};

export type V_junction_closures_completeRow = {
    id: string | null;
    latitude: number | null;
    longitude: number | null;
    name: string | null;
    node_id: string | null;
    ofc_cable_id: string | null;
    position_km: number | null;
};

export type V_lookup_types_with_countRow = {
    active_count: number | null;
    category: string | null;
    code: string | null;
    created_at: string | null;
    description: string | null;
    id: string | null;
    inactive_count: number | null;
    is_system_default: boolean | null;
    name: string | null;
    sort_order: number | null;
    status: boolean | null;
    total_count: number | null;
    updated_at: string | null;
};

export type V_maintenance_areas_with_countRow = {
    active_count: number | null;
    address: string | null;
    area_type_id: string | null;
    code: string | null;
    contact_number: string | null;
    contact_person: string | null;
    created_at: string | null;
    email: string | null;
    id: string | null;
    inactive_count: number | null;
    latitude: number | null;
    longitude: number | null;
    maintenance_area_type_category: string | null;
    maintenance_area_type_code: string | null;
    maintenance_area_type_created_at: string | null;
    maintenance_area_type_is_system_default: boolean | null;
    maintenance_area_type_name: string | null;
    maintenance_area_type_sort_order: number | null;
    maintenance_area_type_status: boolean | null;
    maintenance_area_type_updated_at: string | null;
    name: string | null;
    parent_id: string | null;
    status: boolean | null;
    total_count: number | null;
    updated_at: string | null;
};

export type V_nodes_completeRow = {
    active_count: number | null;
    created_at: string | null;
    id: string | null;
    inactive_count: number | null;
    latitude: number | null;
    longitude: number | null;
    maintenance_area_code: string | null;
    maintenance_area_name: string | null;
    maintenance_area_type_name: string | null;
    maintenance_terminal_id: string | null;
    name: string | null;
    node_type_code: string | null;
    node_type_id: string | null;
    node_type_name: string | null;
    remark: string | null;
    status: boolean | null;
    total_count: number | null;
    updated_at: string | null;
};

export type V_ofc_cables_completeRow = {
    active_count: number | null;
    asset_no: string | null;
    capacity: number | null;
    commissioned_on: string | null;
    created_at: string | null;
    current_rkm: number | null;
    en_id: string | null;
    en_name: string | null;
    id: string | null;
    inactive_count: number | null;
    maintenance_area_code: string | null;
    maintenance_area_name: string | null;
    maintenance_terminal_id: string | null;
    ofc_owner_code: string | null;
    ofc_owner_id: string | null;
    ofc_owner_name: string | null;
    ofc_type_code: string | null;
    ofc_type_id: string | null;
    ofc_type_name: string | null;
    remark: string | null;
    route_name: string | null;
    sn_id: string | null;
    sn_name: string | null;
    status: boolean | null;
    total_count: number | null;
    transnet_id: string | null;
    transnet_rkm: number | null;
    updated_at: string | null;
};

export type V_ofc_connections_completeRow = {
    active_count: number | null;
    connection_category: string | null;
    connection_type: string | null;
    created_at: string | null;
    destination_port: string | null;
    en_dom: string | null;
    en_id: string | null;
    en_name: string | null;
    en_power_dbm: number | null;
    fiber_no_en: number | null;
    fiber_no_sn: number | null;
    fiber_role: string | null;
    id: string | null;
    inactive_count: number | null;
    logical_path_id: string | null;
    maintenance_area_name: string | null;
    ofc_id: string | null;
    ofc_route_name: string | null;
    ofc_type_name: string | null;
    otdr_distance_en_km: number | null;
    otdr_distance_sn_km: number | null;
    path_segment_order: number | null;
    remark: string | null;
    route_loss_db: number | null;
    sn_dom: string | null;
    sn_id: string | null;
    sn_name: string | null;
    sn_power_dbm: number | null;
    source_port: string | null;
    status: boolean | null;
    system_id: string | null;
    system_name: string | null;
    total_count: number | null;
    updated_at: string | null;
};

export type V_rings_with_countRow = {
    active_count: number | null;
    created_at: string | null;
    description: string | null;
    id: string | null;
    inactive_count: number | null;
    maintenance_area_area_type_id: string | null;
    maintenance_area_code: string | null;
    maintenance_area_contact_number: string | null;
    maintenance_area_contact_person: string | null;
    maintenance_area_created_at: string | null;
    maintenance_area_email: string | null;
    maintenance_area_latitude: number | null;
    maintenance_area_longitude: number | null;
    maintenance_area_name: string | null;
    maintenance_area_parent_id: string | null;
    maintenance_area_status: boolean | null;
    maintenance_area_updated_at: string | null;
    maintenance_terminal_id: string | null;
    name: string | null;
    ring_type_category: string | null;
    ring_type_code: string | null;
    ring_type_created_at: string | null;
    ring_type_id: string | null;
    ring_type_is_system_default: boolean | null;
    ring_type_name: string | null;
    ring_type_sort_order: number | null;
    ring_type_status: boolean | null;
    ring_type_updated_at: string | null;
    status: boolean | null;
    total_count: number | null;
    total_nodes: number | null;
    updated_at: string | null;
};

export type V_system_connections_completeRow = {
    active_count: number | null;
    bandwidth_allocated_mbps: number | null;
    bandwidth_mbps: number | null;
    commissioned_on: string | null;
    connected_system_name: string | null;
    connected_system_type_name: string | null;
    created_at: string | null;
    customer_name: string | null;
    en_interface: string | null;
    en_ip: unknown | null;
    en_name: string | null;
    en_node_name: string | null;
    fiber_in: number | null;
    fiber_out: number | null;
    id: string | null;
    inactive_count: number | null;
    media_type_name: string | null;
    remark: string | null;
    sdh_a_customer: string | null;
    sdh_a_slot: string | null;
    sdh_b_customer: string | null;
    sdh_b_slot: string | null;
    sdh_carrier: string | null;
    sdh_stm_no: string | null;
    sfp_capacity: string | null;
    sfp_port: string | null;
    sfp_serial_no: string | null;
    sfp_type_name: string | null;
    sn_interface: string | null;
    sn_ip: unknown | null;
    sn_name: string | null;
    sn_node_name: string | null;
    status: boolean | null;
    system_id: string | null;
    system_name: string | null;
    system_type_name: string | null;
    total_count: number | null;
    updated_at: string | null;
    vlan: string | null;
    vmux_c_code: string | null;
    vmux_channel: string | null;
    vmux_subscriber: string | null;
    vmux_tk: string | null;
};

export type V_systems_completeRow = {
    active_count: number | null;
    commissioned_on: string | null;
    created_at: string | null;
    id: string | null;
    inactive_count: number | null;
    ip_address: unknown | null;
    latitude: number | null;
    longitude: number | null;
    maintenance_terminal_id: string | null;
    node_id: string | null;
    node_name: string | null;
    remark: string | null;
    ring_id: string | null;
    ring_logical_area_name: string | null;
    s_no: string | null;
    sdh_gne: string | null;
    sdh_make: string | null;
    status: boolean | null;
    system_category: string | null;
    system_maintenance_terminal_name: string | null;
    system_name: string | null;
    system_type_code: string | null;
    system_type_id: string | null;
    system_type_name: string | null;
    total_count: number | null;
    updated_at: string | null;
    vmux_vm_id: string | null;
};

export type V_user_profiles_extendedRow = {
    account_age_days: number | null;
    address: Json | null;
    auth_updated_at: string | null;
    avatar_url: string | null;
    computed_status: string | null;
    created_at: string | null;
    date_of_birth: string | null;
    designation: string | null;
    email: string | null;
    email_confirmed_at: string | null;
    first_name: string | null;
    full_name: string | null;
    id: string | null;
    is_email_verified: boolean | null;
    is_phone_verified: boolean | null;
    is_super_admin: boolean | null;
    last_activity_period: string | null;
    last_name: string | null;
    last_sign_in_at: string | null;
    phone_confirmed_at: string | null;
    phone_number: string | null;
    preferences: Json | null;
    raw_app_meta_data: Json | null;
    raw_user_meta_data: Json | null;
    role: string | null;
    status: string | null;
    updated_at: string | null;
};

// ============= ENUMS =============

export type AuthAal_level = "aal1" | "aal2" | "aal3";

export type AuthCode_challenge_method = "s256" | "plain";

export type AuthFactor_status = "unverified" | "verified";

export type AuthFactor_type = "totp" | "webauthn" | "phone";

export type AuthOauth_registration_type = "dynamic" | "manual";

export type AuthOne_time_token_type = "confirmation_token" | "reauthentication_token" | "recovery_token" | "email_change_token_new" | "email_change_token_current" | "phone_change_token";


```

<!-- path: types/user-roles.ts -->
```typescript
// types/user-roles.ts

export enum UserRole {
    ADMIN = "admin",
    CPANADMIN = "cpan_admin",
    MAANADMIN = "maan_admin",
    SDHADMIN = "sdh_admin",
    VMUXADMIN = "vmux_admin",
    MNGADMIN = "mng_admin",
    VIEWER = "viewer",
    AUTHENTICATED = "authenticated",
    ANON = "anon",
}
```

<!-- path: lib/queryClient.ts -->
```typescript

// lib/queryClient.ts
import { QueryClient } from '@tanstack/react-query'

export const queryClient = new QueryClient({
  defaultOptions: {
    queries: {
      staleTime: 5 * 60 * 1000, // 5 minutes
      gcTime: 10 * 60 * 1000, // 10 minutes (formerly cacheTime)
      retry: (failureCount, error: Error) => {
        // Don't retry on 4xx errors
        if ('status' in error && typeof error.status === 'number' && error.status >= 400 && error.status < 500) {
          return false
        }
        return failureCount < 3
      },
      refetchOnWindowFocus: false,
    },
    mutations: {
      retry: 1,
    },
  },
})
```

<!-- path: lib/utils.ts -->
```typescript
import { clsx, type ClassValue } from "clsx"
import { twMerge } from "tailwind-merge"

export function cn(...inputs: ClassValue[]) {
  return twMerge(clsx(inputs))
}

```

<!-- path: app/terms/page.tsx -->
```typescript
// app/terms/page.tsx
import Terms from '@/components/auth/terms';

const TermsPage = () => {
 return (
 <Terms />
 );
};

export default TermsPage;
```

<!-- path: app/(auth)/login/page.tsx -->
```typescript
'use client';

import { useForm } from 'react-hook-form';
import { zodResolver } from '@hookform/resolvers/zod';
import Link from 'next/link';
import { useRouter, useSearchParams } from 'next/navigation';
import { useAuth } from '@/hooks/useAuth';
import OAuthProviders from '@/components/auth/OAuthProviders';
import { useEffect } from 'react';
import { toast } from 'sonner';
import { authUsersRowSchema } from '@/schemas/zod-schemas';
import z from 'zod';

export const loginSchema = authUsersRowSchema.pick({
  email: true,
  encrypted_password: true,
});

type LoginForm = z.infer<typeof loginSchema>;

export default function LoginPage() {
  const { authState, signIn } = useAuth();
  const router = useRouter();
  const searchParams = useSearchParams();
  const redirectTo = searchParams.get('redirectTo') || '/dashboard';
  const errorParam = searchParams.get('error');

  const {
    register,
    handleSubmit,
    formState: { errors, isSubmitting },
  } = useForm<LoginForm>({
    resolver: zodResolver(loginSchema),
    defaultValues: {
      email: '',
      encrypted_password: '',
    },
  });

  // Redirect if already authenticated
  useEffect(() => {
    if (authState === 'authenticated') {
      router.push('/dashboard');
    }
  }, [authState, router]);

  useEffect(() => {
    if (errorParam === 'oauth_failed') {
      toast.error('OAuth authentication failed. Please try again.');
    }
  }, [errorParam]);

  const onSubmit = async (data: LoginForm) => {
    const success = await signIn(
      data.email || '',
      data.encrypted_password || ''
    );
    if (success) {
      router.push(redirectTo);
    }
  };

  return (
    <div className="min-h-screen flex items-center justify-center bg-gray-50 dark:bg-gray-900 py-12 px-4 sm:px-6 lg:px-8">
      <div className="max-w-md w-full space-y-8">
        <div>
          <h2 className="mt-6 text-center text-3xl font-extrabold text-gray-900 dark:text-white font-family-heading">
            Sign in to your account
          </h2>
          <p className="mt-2 text-center text-sm text-gray-600 dark:text-gray-400">
            Or{' '}
            <Link
              href="/signup"
              className="font-medium text-blue-600 hover:text-blue-500 dark:text-blue-400 dark:hover:text-blue-300"
            >
              create a new account
            </Link>
          </p>
        </div>

        <div className="bg-white dark:bg-gray-800 py-8 px-6 shadow-lg rounded-lg">
          <OAuthProviders
            variant="login"
            providers={['google']}
            className="mb-6"
          />

          <form className="space-y-6" onSubmit={handleSubmit(onSubmit)}>
            <div>
              <label
                htmlFor="email"
                className="block text-sm font-medium text-gray-700 dark:text-gray-300"
              >
                Email address
              </label>
              <input
                id="email"
                type="email"
                autoComplete="email"
                {...register('email')}
                className="mt-1 block w-full px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-md shadow-sm focus:outline-none focus:ring-blue-500 focus:border-blue-500 dark:focus:ring-blue-400 dark:focus:border-blue-400 dark:bg-gray-700 dark:text-white"
                placeholder="Enter your email"
              />
              {errors.email && (
                <p className="text-red-500 text-sm">{errors.email.message}</p>
              )}
            </div>

            <div>
              <label
                htmlFor="password"
                className="block text-sm font-medium text-gray-700 dark:text-gray-300"
              >
                Password
              </label>
              <input
                id="password"
                type="password"
                autoComplete="current-password"
                {...register('encrypted_password')}
                className="mt-1 block w-full px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-md shadow-sm focus:outline-none focus:ring-blue-500 focus:border-blue-500 dark:focus:ring-blue-400 dark:focus:border-blue-400 dark:bg-gray-700 dark:text-white"
                placeholder="Enter your password"
              />
              {errors.encrypted_password && (
                <p className="text-red-500 text-sm">
                  {errors.encrypted_password.message}
                </p>
              )}
            </div>

            <div className="flex items-center justify-between">
              <div className="text-sm">
                <Link
                  href="/forgot-password"
                  className="font-medium text-blue-600 hover:text-blue-500 dark:text-blue-400 dark:hover:text-blue-300"
                >
                  Forgot your password?
                </Link>
              </div>
            </div>

            <div>
              <button
                type="submit"
                disabled={isSubmitting}
                className="group relative w-full flex justify-center py-2 px-4 border border-transparent text-sm font-medium rounded-md text-white bg-blue-600 hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-blue-500 disabled:opacity-50 disabled:cursor-not-allowed dark:bg-blue-500 dark:hover:bg-blue-600 dark:focus:ring-blue-400"
              >
                {isSubmitting ? (
                  <div className="animate-spin rounded-full h-5 w-5 border-b-2 border-white"></div>
                ) : (
                  'Sign in'
                )}
              </button>
            </div>
          </form>
        </div>
      </div>
    </div>
  );
}

```

<!-- path: app/(auth)/verify-email/page.tsx -->
```typescript
// app/(auth)/verify-email/page.tsx
import Link from 'next/link'

export default function VerifyEmailPage() {
  return (
    <div className="min-h-screen flex items-center justify-center bg-gray-50 dark:bg-gray-900 py-12 px-4 sm:px-6 lg:px-8">
      <div className="max-w-md w-full space-y-8 text-center">
        <div>
          <div className="mx-auto h-12 w-12 text-green-600 dark:text-green-500">
            <svg fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M3 8l7.89 7.89a2 2 0 002.82 0L21 8M5 19h14a2 2 0 002-2V7a2 2 0 00-2-2H5a2 2 0 00-2 2v10a2 2 0 002 2z" />
            </svg>
          </div>
          <h2 className="mt-6 text-3xl font-extrabold text-gray-900 dark:text-white">
            Check your email
          </h2>
          <p className="mt-2 text-sm text-gray-600 dark:text-gray-400">
            We&apos;ve sent a confirmation link to your email address. Please click the link to verify your account.
          </p>
        </div>

        <div className="mt-8 space-y-4">
          <p className="text-sm text-gray-500 dark:text-gray-400">
            Didn&apos;t receive the email? Check your spam folder or{' '}
            <Link href="/signup" className="font-medium text-indigo-600 hover:text-indigo-500 dark:text-indigo-400 dark:hover:text-indigo-300">
              try signing up again
            </Link>
          </p>

          <Link
            href="/login"
            className="inline-flex items-center px-4 py-2 border border-transparent text-sm font-medium rounded-md text-indigo-600 bg-indigo-100 hover:bg-indigo-200 dark:text-indigo-100 dark:bg-indigo-800 dark:hover:bg-indigo-700"
          >
            Back to Sign In
          </Link>
        </div>
      </div>
    </div>
  )
}
```

<!-- path: app/(auth)/reset-password/page.tsx -->
```typescript
// app/(auth)/reset-password/page.tsx
"use client";

import { useState } from "react";
import { useRouter } from "next/navigation";
import { motion } from "framer-motion";
import { toast } from "sonner";
import { LoadingSpinner } from "@/components/common/ui/LoadingSpinner";
import { useAuth } from "@/hooks/useAuth";

export default function ResetPasswordPage() {
  const [password, setPassword] = useState("");
  const [confirmPassword, setConfirmPassword] = useState("");
  const [isLoading, setIsLoading] = useState(false);
  const router = useRouter();
  // const searchParams = useSearchParams()
  const { resetPassword } = useAuth();

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();

    if (password !== confirmPassword) {
      toast.error("Passwords do not match");
      return;
    }

    if (password.length < 8) {
      toast.error("Password must be at least 8 characters long");
      return;
    }

    setIsLoading(true);
    try {
      const success = await resetPassword(password);

      if (success) {
        toast.success("Password updated successfully!");
        router.push("/login");
      } else {
        setIsLoading(false);
        toast.error("Something went wrong");
      }
    } catch (error) {
      toast.error("Something went wrong");
      setIsLoading(false);
    }
  };

  return (
    <div className='min-h-screen flex items-center justify-center bg-gray-50 dark:bg-gray-900 py-12 px-4 sm:px-6 lg:px-8'>
      <motion.div initial={{ opacity: 0, y: 20 }} animate={{ opacity: 1, y: 0 }} transition={{ duration: 0.5 }} className='max-w-md w-full space-y-8'>
        <div>
          <h2 className='mt-6 text-center text-3xl font-extrabold text-gray-900 dark:text-white'>Set new password</h2>
        </div>

        <form className='mt-8 space-y-6' onSubmit={handleSubmit}>
          <div>
            <label htmlFor='password' className='sr-only'>
              New Password
            </label>
            <input
              id='password'
              name='password'
              type='password'
              required
              value={password}
              onChange={(e) => setPassword(e.target.value)}
              className='appearance-none rounded-t-md relative block w-full px-3 py-2 border border-gray-300 dark:border-gray-600 placeholder-gray-500 dark:placeholder-gray-400 text-gray-900 dark:text-white bg-white dark:bg-gray-800 focus:outline-none focus:ring-blue-500 focus:border-blue-500 focus:z-10 sm:text-sm'
              placeholder='New password'
            />
          </div>
          <div>
            <label htmlFor='confirmPassword' className='sr-only'>
              Confirm Password
            </label>
            <input
              id='confirmPassword'
              name='confirmPassword'
              type='password'
              required
              value={confirmPassword}
              onChange={(e) => setConfirmPassword(e.target.value)}
              className='appearance-none rounded-b-md relative block w-full px-3 py-2 border border-gray-300 dark:border-gray-600 placeholder-gray-500 dark:placeholder-gray-400 text-gray-900 dark:text-white bg-white dark:bg-gray-800 focus:outline-none focus:ring-blue-500 focus:border-blue-500 focus:z-10 sm:text-sm'
              placeholder='Confirm new password'
            />
          </div>

          <div>
            <button
              type='submit'
              disabled={isLoading}
              className='group relative w-full flex justify-center py-2 px-4 border border-transparent text-sm font-medium rounded-md text-white bg-blue-600 hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-blue-500 disabled:opacity-50 disabled:cursor-not-allowed dark:bg-blue-700 dark:hover:bg-blue-800'>
              {isLoading ? <LoadingSpinner size='sm' /> : "Update Password"}
            </button>
          </div>
        </form>
      </motion.div>
    </div>
  );
}

```

<!-- path: app/(auth)/layout.tsx -->
```typescript
// app/(auth)/layout.tsx
"use client";

import { motion } from "framer-motion";
import { useAuth } from "@/hooks/useAuth";
import { redirect } from "next/navigation";

export default function AuthLayout({ children }: { children: React.ReactNode }) {
  const { authState } = useAuth();

  if (authState === "authenticated") {
    redirect("/dashboard");
  }

  return (
    <div className='min-h-screen bg-gradient-to-br from-blue-50 via-white to-purple-50 dark:from-gray-900 dark:via-gray-800 dark:to-gray-900'>
      <div className='flex min-h-screen'>
        {/* Left side - Branding */}
        <div className='relative hidden overflow-hidden lg:flex lg:flex-1'>
          <div className='absolute inset-0 bg-gradient-to-br from-blue-600 to-purple-700 opacity-90 dark:from-gray-800 dark:to-gray-900' />
          {/* <div className="absolute inset-0 bg-[url('/grid.svg')] opacity-5" /> */}
          <div className='relative z-10 flex flex-col justify-center px-12 text-white'>
            <motion.div initial={{ opacity: 0, y: 20 }} animate={{ opacity: 1, y: 0 }} transition={{ duration: 0.6 }}>
              <h1 className='mb-6 text-4xl font-bold'>Welcome to HARINAVI TRANSMISSION MAINTENANCE DATABASE</h1>
              <p className='mb-8 text-xl opacity-90 dark:opacity-80'>Secure authentication with role-based access control</p>
              <div className='space-y-4'>
                <div className='flex items-center space-x-3'>
                  <div className='h-2 w-2 rounded-full bg-white dark:bg-blue-400' />
                  <span>Multi-role user management</span>
                </div>
                <div className='flex items-center space-x-3'>
                  <div className='h-2 w-2 rounded-full bg-white dark:bg-blue-400' />
                  <span>Secure email verification</span>
                </div>
                <div className='flex items-center space-x-3'>
                  <div className='h-2 w-2 rounded-full bg-white dark:bg-blue-400' />
                  <span>Protected routes & permissions</span>
                </div>
                <div className='flex items-center space-x-3'>
                  <div className='h-2 w-2 rounded-full bg-white dark:bg-blue-400' />
                  <span>Dark mode support</span>
                </div>
              </div>
            </motion.div>
          </div>
        </div>

        {/* Right side - Auth forms */}
        <div className='flex flex-1 flex-col justify-center px-6 py-12 lg:px-8'>
          <motion.div initial={{ opacity: 0, x: 20 }} animate={{ opacity: 1, x: 0 }} transition={{ duration: 0.6, delay: 0.2 }} className='mx-auto w-full max-w-md'>
            {children}
          </motion.div>
        </div>
      </div>
    </div>
  );
}

```

<!-- path: app/(auth)/forgot-password/page.tsx -->
```typescript
// app/(auth)/forgot-password/page.tsx
'use client'

import { motion } from 'framer-motion'
import ForgotPasswordForm from '@/components/auth/ForgotPasswordForm'
import Link from 'next/link'

export default function ForgotPasswordPage() {
  return (
    <div className="min-h-screen flex items-center justify-center bg-gray-50 dark:bg-gray-900 py-12 px-4 sm:px-6 lg:px-8">
      <motion.div
        initial={{ opacity: 0, y: 20 }}
        animate={{ opacity: 1, y: 0 }}
        transition={{ duration: 0.5 }}
        className="max-w-md w-full space-y-8"
      >
        <div>
          <h2 className="mt-6 text-center text-3xl font-extrabold text-gray-900 dark:text-white">
            Reset your password
          </h2>
          <p className="mt-2 text-center text-sm text-gray-600 dark:text-gray-400">
            Remember your password?{' '}
            <Link
              href="/login"
              className="font-medium text-blue-600 hover:text-blue-500 dark:text-blue-400"
            >
              Sign in
            </Link>
          </p>
        </div>
        <ForgotPasswordForm />
      </motion.div>
    </div>
  )
}

```

<!-- path: app/(auth)/signup/page.tsx -->
```typescript
'use client';

import Link from 'next/link';
import { redirect, useRouter } from 'next/navigation';
import { useAuth } from '@/hooks/useAuth';
import { useEffect } from 'react';
import { toast } from 'sonner';
import { useForm } from 'react-hook-form';
import { zodResolver } from '@hookform/resolvers/zod';
import z from 'zod';
import { loginSchema } from '@/app/(auth)/login/page';

const signupSchema = loginSchema
  .extend({
    firstName: z
      .string()
      .min(1, 'First name is required')
      .max(50, 'First name must not exceed 50 characters'),
    lastName: z
      .string()
      .min(1, 'Last name is required')
      .max(50, 'Last name must not exceed 50 characters'),
    confirmPassword: z.string().min(6, 'Confirm password is required'),
  })
  .refine((data) => data.encrypted_password === data.confirmPassword, {
    message: 'Passwords must match',
    path: ['confirmPassword'],
  });

type SignupForm = z.infer<typeof signupSchema>;

export default function SignUpPage() {
  const { signUp, authState } = useAuth();
  const router = useRouter();

  // Redirect if already authenticated
  useEffect(() => {
    if (authState === 'authenticated') {
      redirect('/onboarding');
    }
  }, [authState]);

  // Setup React Hook Form
  const {
    register,
    handleSubmit,
    formState: { errors, isSubmitting },
  } = useForm<SignupForm>({
    resolver: zodResolver(signupSchema),
    defaultValues: {
      firstName: '',
      lastName: '',
      email: '',
      encrypted_password: '',
      confirmPassword: '',
    },
  });

  // Form submit handler
  const onSubmit = async (data: SignupForm) => {
    const success = await signUp({
      email: data.email || '',
      password: data.encrypted_password || '',
      firstName: data.firstName,
      lastName: data.lastName,
    });

    if (success) {
      router.push('/verify-email');
    } else {
      toast.error('Sign up failed. Please try again.');
    }
  };

  return (
    <div className="min-h-screen flex items-center justify-center bg-gray-50 dark:bg-gray-900 py-12 px-4 sm:px-6 lg:px-8">
      <div className="max-w-md w-full space-y-8">
        <div>
          <h2 className="mt-6 text-center text-3xl font-extrabold text-gray-900 dark:text-white">
            Create your account
          </h2>
          <p className="mt-2 text-center text-sm text-gray-600 dark:text-gray-400">
            Or{' '}
            <Link
              href="/login"
              className="font-medium text-blue-600 hover:text-blue-500 dark:text-blue-400 dark:hover:text-blue-300"
            >
              sign in to your existing account
            </Link>
          </p>
        </div>

        <div className="bg-white dark:bg-gray-800 py-8 px-6 shadow-lg rounded-lg">
          <form className="space-y-6" onSubmit={handleSubmit(onSubmit)}>
            <div className="grid grid-cols-2 gap-4">
              <div>
                <label
                  htmlFor="firstName"
                  className="block text-sm font-medium text-gray-700 dark:text-gray-300"
                >
                  First name *
                </label>
                <input
                  id="firstName"
                  type="text"
                  autoComplete="given-name"
                  {...register('firstName')}
                  className="mt-1 block w-full px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-md shadow-sm focus:outline-none focus:ring-blue-500 focus:border-blue-500 dark:bg-gray-700 dark:text-white"
                  placeholder="First name"
                />
                {errors.firstName && (
                  <p className="text-red-500 text-sm">
                    {errors.firstName.message}
                  </p>
                )}
              </div>

              <div>
                <label
                  htmlFor="lastName"
                  className="block text-sm font-medium text-gray-700 dark:text-gray-300"
                >
                  Last name *
                </label>
                <input
                  id="lastName"
                  type="text"
                  autoComplete="family-name"
                  {...register('lastName')}
                  className="mt-1 block w-full px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-md shadow-sm focus:outline-none focus:ring-blue-500 focus:border-blue-500 dark:bg-gray-700 dark:text-white"
                  placeholder="Last name"
                />
                {errors.lastName && (
                  <p className="text-red-500 text-sm">
                    {errors.lastName.message}
                  </p>
                )}
              </div>
            </div>

            <div>
              <label
                htmlFor="email"
                className="block text-sm font-medium text-gray-700 dark:text-gray-300"
              >
                Email address *
              </label>
              <input
                id="email"
                type="email"
                autoComplete="email"
                {...register('email')}
                className="mt-1 block w-full px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-md shadow-sm focus:outline-none focus:ring-blue-500 focus:border-blue-500 dark:bg-gray-700 dark:text-white"
                placeholder="Enter your email"
              />
              {errors.email && (
                <p className="text-red-500 text-sm">{errors.email.message}</p>
              )}
            </div>

            <div>
              <label
                htmlFor="password"
                className="block text-sm font-medium text-gray-700 dark:text-gray-300"
              >
                Password *
              </label>
              <input
                id="password"
                type="password"
                autoComplete="new-password"
                {...register('encrypted_password')}
                className="mt-1 block w-full px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-md shadow-sm focus:outline-none focus:ring-blue-500 focus:border-blue-500 dark:bg-gray-700 dark:text-white"
                placeholder="Create a password"
              />
              {errors.encrypted_password && (
                <p className="text-red-500 text-sm">
                  {errors.encrypted_password.message}
                </p>
              )}
            </div>

            <div>
              <label
                htmlFor="confirmPassword"
                className="block text-sm font-medium text-gray-700 dark:text-gray-300"
              >
                Confirm password *
              </label>
              <input
                id="confirmPassword"
                type="password"
                autoComplete="new-password"
                {...register('confirmPassword')}
                className="mt-1 block w-full px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-md shadow-sm focus:outline-none focus:ring-blue-500 focus:border-blue-500 dark:bg-gray-700 dark:text-white"
                placeholder="Confirm your password"
              />
              {errors.confirmPassword && (
                <p className="text-red-500 text-sm">
                  {errors.confirmPassword.message}
                </p>
              )}
            </div>

            <div>
              <button
                type="submit"
                disabled={isSubmitting || authState === 'loading'}
                className="group relative w-full flex justify-center py-2 px-4 border border-transparent text-sm font-medium rounded-md text-white bg-blue-600 hover:bg-blue-700 focus:outline-none disabled:opacity-50"
              >
                {isSubmitting || authState === 'loading' ? (
                  <div className="animate-spin rounded-full h-5 w-5 border-b-2 border-white"></div>
                ) : (
                  'Create account'
                )}
              </button>
            </div>

            <div className="text-center">
              <p className="text-xs text-gray-500 dark:text-gray-400">
                By creating an account, you agree to our{' '}
                <Link
                  href="/terms"
                  className="text-blue-600 hover:text-blue-500 dark:text-blue-400"
                >
                  Terms of Service
                </Link>{' '}
                and{' '}
                <Link
                  href="/privacy"
                  className="text-blue-600 hover:text-blue-500 dark:text-blue-400"
                >
                  Privacy Policy
                </Link>
              </p>
            </div>
          </form>
        </div>
      </div>
    </div>
  );
}

```

<!-- path: app/privacy/page.tsx -->
```typescript

// app/privacy/page.tsx
import Privacy from "@/components/auth/privacy";

const PrivacyPage = () => {
  return <Privacy />;
};

export default PrivacyPage;

```

<!-- path: app/api/admin/users/route.ts -->
```typescript
// app/api/admin/users/route.ts
import { NextResponse } from 'next/server';
import { Pool } from 'pg';
import bcrypt from 'bcrypt';

const pgHost = process.env.PGHOST;
const pgUser = process.env.PGUSER;
const pgPassword = process.env.PGPASSWORD;
const pgDatabase = process.env.PGDATABASE;
const pgPort = process.env.PGPORT;

const pool = new Pool({
  connectionString: `postgresql://${pgUser}:${pgPassword}@${pgHost}:${pgPort}/${pgDatabase}`,
});

export async function POST(req: Request) {
  try {
    const userData = await req.json();
    const hashed = await bcrypt.hash(userData.password, 10);

    const client = await pool.connect();
    try {
      await client.query('BEGIN');

      // 1 Insert into auth.users
      const { rows } = await client.query(
        `
        INSERT INTO auth.users (id, instance_id, email, encrypted_password, email_confirmed_at, raw_user_meta_data)
        VALUES ($1, '00000000-0000-0000-0000-000000000000', $2, $3, $4, $5)
        RETURNING id, email
        `,
        [
          userData.id,
          userData.email,
          hashed,
          userData.email_confirm ? new Date().toISOString() : null,
          JSON.stringify({
            first_name: userData.first_name,
            last_name: userData.last_name,
            role: userData.role,
            status: userData.status,
          }),
        ]
      );
      console.log('USER PAYLOAD:', {
        id: userData.id,
        email: userData.email,
        password: userData.password,
        email_confirm: userData.email_confirm,
        first_name: userData.first_name,
        last_name: userData.last_name,
        role: userData.role,
        status: userData.status,
      });

      await client.query('COMMIT');

      return NextResponse.json({ user: rows[0] });
    } catch (err) {
      await client.query('ROLLBACK');
      throw err;
    } finally {
      client.release();
    }
  } catch (err: unknown) {
    console.error('Error inserting user:', err);
    return NextResponse.json(
      { error: err instanceof Error ? err.message : 'Unknown error' },
      { status: 500 }
    );
  }
}

```

<!-- path: app/api/v1/routes/[id]/evolve/route.ts -->
```typescript
// app/api/v1/routes/[id]/evolve/route.ts
import { NextResponse } from 'next/server';
import { isEvolutionCommitPayload } from '@/components/route-manager/schemas';

export async function POST(
  request: Request,
  { params }: { params: { id: string } }
) {
  const routeId = params.id;
  const payload: unknown = await request.json();

  if (!isEvolutionCommitPayload(payload)) {
    return NextResponse.json(
      { message: 'Invalid payload for route evolution commit' },
      { status: 400 }
    );
  }

  console.log(`== API[v1] [POST]: Evolve route: ${routeId} ==`);
  console.log('Payload Received:', JSON.stringify(payload, null, 2));

  // Simulate success
  return NextResponse.json({
    message: `Successfully evolved route ${routeId} with ${payload.plannedEquipment.length} new closures.`,
  });
}

```

<!-- path: app/api/v1/routes/[id]/evolution/route.ts -->
```typescript
// app/api/v1/routes/[id]/evolution/route.ts
import { NextResponse } from 'next/server';
import { RouteDetailsPayload } from '@/components/route-manager/types';

export async function GET(
  request: Request,
  { params }: { params: { id: string } }
) {
  const routeId = params.id;
  console.log(`== API[v1] [GET]: Evolution details for route: ${routeId} ==`);

  // Reuse the same mock as the non-versioned endpoint
  const mockDetails: RouteDetailsPayload = {
    route: {
      id: routeId,
      name: `Route ${routeId.split('-')[1]}`,
      start_site: { id: 'site-a', name: 'NodeA' },
      end_site: { id: 'site-b', name: 'NodeB' },
      capacity: 48,
      distance_km: 25.5,
      evolution_status: routeId === 'route-1' ? 'simple' : 'with_jcs',
    },
    equipment: routeId === 'route-2' ? [
      {
        id: 'jc-existing-1',
        name: 'JC-Mid-01',
        equipment_type: 'junction_closure',
        latitude: 23.5254, longitude: 87.2926,
        status: 'existing',
        attributes: { jc_type: 'inline', capacity: 48, position_on_route: 40 }
      }
    ] : [],
  };

  return NextResponse.json(mockDetails);
}

```

<!-- path: app/api/route/[routeId]/route.ts -->
```typescript
// app/api/route/[routeId]/route.ts
import { NextResponse } from 'next/server';
import { RouteDetailsPayload, EvolutionCommitPayload } from '@/components/route-manager/types';
import { isEvolutionCommitPayload } from '@/components/route-manager/schemas';

// GET handler for fetching detailed data for a selected route
export async function GET(
  request: Request,
  { params }: { params: { routeId: string } }
) {
  const routeId = params.routeId;
  console.log(`== API [GET]: Fetching details for route: ${routeId} ==`);

  // Mocking a DB call to get full details
  const mockDetails: RouteDetailsPayload = {
    route: {
      id: routeId,
      name: `Route ${routeId.split('-')[1]}`,
      start_site: { id: 'site-a', name: 'NodeA' },
      end_site: { id: 'site-b', name: 'NodeB' },
      capacity: 48,
      distance_km: 25.5,
      evolution_status: routeId === 'route-1' ? 'simple' : 'with_jcs',
    },
    equipment: routeId === 'route-2' ? [
        {
            id: 'jc-existing-1',
            name: 'JC-Mid-01',
            equipment_type: 'junction_closure',
            latitude: 23.5254, longitude: 87.2926,
            status: 'existing',
            attributes: { jc_type: 'inline', capacity: 48, position_on_route: 40 }
        }
    ] : [],
  };

  return NextResponse.json(mockDetails);
}


// POST handler for committing the evolution
export async function POST(
  request: Request,
  { params }: { params: { routeId: string } }
) {
  const routeId = params.routeId;
  const payload: unknown = await request.json();

  if (!isEvolutionCommitPayload(payload)) {
    return NextResponse.json(
      { message: 'Invalid payload for route evolution commit' },
      { status: 400 }
    );
  }

  console.log(`== API [POST]: Committing evolution for route: ${routeId} ==`);
  console.log("Payload Received:", JSON.stringify(payload, null, 2));

  // --- In a real application, you would: ---
  // 1. Validate the incoming payload against a schema.
  // 2. Start a database transaction.
  // 3. await db.equipment.createMany({ data: payload.plannedEquipment });
  // 4. await db.cableSegments.createMany({ data: payload.plannedSegments });
  // 5. await db.fiberSplices.createMany({ data: payload.plannedSplices });
  // 6. await db.ofc_routes.update({ where: { id: routeId }, data: { evolution_status: 'fully_segmented' } });
  // 7. Log the event.
  // 8. If all successful, commit the transaction. If any step fails, rollback.

  // Simulating a successful commit
  return NextResponse.json({
    message: `Successfully evolved route ${routeId} with ${payload.plannedEquipment.length} new closures.`,
  });
}
```

<!-- path: app/customuppy.css -->
```css
/* Custom Uppy Styles - Add this to your globals.css or import as a separate file */

/* Dark theme customizations */
.uppy-dark .uppy-Dashboard {
  background-color: #1f2937;
  color: #f9fafb;
  border-color: #374151;
}

.uppy-dark .uppy-Dashboard-inner {
  background-color: #1f2937;
  border-color: #374151;
}

.uppy-dark .uppy-Dashboard-AddFiles {
  background-color: #374151;
  border-color: #4b5563;
}

.uppy-dark .uppy-Dashboard-AddFiles:hover {
  background-color: #4b5563;
}

.uppy-dark .uppy-DashboardTab-btn {
  color: #d1d5db;
  background-color: transparent;
}

.uppy-dark .uppy-DashboardTab-btn:hover {
  background-color: #374151;
  color: #f9fafb;
}

.uppy-dark .uppy-DashboardTab-btn:focus {
  background-color: #4b5563;
  color: #f9fafb;
}

.uppy-dark .uppy-DashboardTab-btn[aria-selected="true"] {
  background-color: #3b82f6;
  color: #ffffff;
}

.uppy-dark .uppy-Dashboard-dropFilesHereHint {
  color: #9ca3af;
}

.uppy-dark .uppy-Dashboard-browse {
  color: #60a5fa;
}

.uppy-dark .uppy-Dashboard-browse:hover {
  color: #93c5fd;
}

.uppy-dark .uppy-Dashboard-Item {
  background-color: #374151;
  border-color: #4b5563;
}

.uppy-dark .uppy-Dashboard-Item-preview {
  background-color: #4b5563;
}

.uppy-dark .uppy-Dashboard-Item-name {
  color: #f9fafb;
}

.uppy-dark .uppy-Dashboard-Item-status {
  color: #d1d5db;
}

.uppy-dark .uppy-Dashboard-ItemProgress {
  background-color: #4b5563;
}

.uppy-dark .uppy-Dashboard-ItemProgress-bar {
  background-color: #3b82f6;
}

/* Progress bar customization */
.uppy-ProgressBar {
  height: 8px;
  background-color: #e5e7eb;
  border-radius: 4px;
  overflow: hidden;
}

.uppy-dark .uppy-ProgressBar {
  background-color: #4b5563;
}

.uppy-ProgressBar-inner {
  background: linear-gradient(90deg, #3b82f6 0%, #1d4ed8 100%);
  transition: width 0.3s ease;
  height: 100%;
}

/* Custom drag-drop area */
.uppy-DragDrop-container {
  border: 2px dashed #d1d5db;
  border-radius: 8px;
  background-color: #f9fafb;
  transition: all 0.3s ease;
}

.uppy-dark .uppy-DragDrop-container {
  border-color: #4b5563;
  background-color: #374151;
  color: #f9fafb;
}

.uppy-DragDrop-container:hover,
.uppy-is-drag-over .uppy-DragDrop-container {
  border-color: #3b82f6;
  background-color: #eff6ff;
}

.uppy-dark .uppy-DragDrop-container:hover,
.uppy-dark.uppy-is-drag-over .uppy-DragDrop-container {
  border-color: #60a5fa;
  background-color: #1e3a8a;
}

/* Webcam styles */
.uppy-dark .uppy-Webcam-container {
  background-color: #1f2937;
}

.uppy-dark .uppy-Webcam-video {
  border-color: #374151;
}

.uppy-dark .uppy-Webcam-button {
  background-color: #3b82f6;
  color: #ffffff;
}

.uppy-dark .uppy-Webcam-button:hover {
  background-color: #2563eb;
}

/* Image editor styles */
.uppy-dark .uppy-ImageEditor-container {
  background-color: #1f2937;
}

.uppy-dark .uppy-ImageEditor-sidebar {
  background-color: #374151;
  border-color: #4b5563;
}

.uppy-dark .uppy-ImageEditor-button {
  background-color: #4b5563;
  color: #f9fafb;
  border-color: #6b7280;
}

.uppy-dark .uppy-ImageEditor-button:hover {
  background-color: #6b7280;
}

.uppy-dark .uppy-ImageEditor-button--active {
  background-color: #3b82f6;
  color: #ffffff;
}

/* Custom animations */
@keyframes uppy-fade-in {
  from {
    opacity: 0;
    transform: translateY(10px);
  }
  to {
    opacity: 1;
    transform: translateY(0);
  }
}

.uppy-Dashboard-Item {
  animation: uppy-fade-in 0.3s ease-out;
}

/* Responsive adjustments */
@media (max-width: 768px) {
  .uppy-Dashboard {
    border-radius: 0;
  }
  
  .uppy-Dashboard-inner {
    padding: 1rem;
  }
  
  .uppy-DragDrop-container {
    padding: 2rem 1rem;
  }
}

/* File type icons */
.uppy-Dashboard-Item-previewIcon {
  font-size: 2rem;
}

/* Success/Error states */
.uppy-Dashboard-Item--success .uppy-Dashboard-Item-progress {
  background-color: #10b981;
}

.uppy-Dashboard-Item--error .uppy-Dashboard-Item-progress {
  background-color: #ef4444;
}

.uppy-Dashboard-Item--error .uppy-Dashboard-Item-name {
  color: #ef4444;
}

/* Custom button styles */
.uppy-Dashboard-browse,
.uppy-Dashboard-AddFiles-title {
  font-weight: 600;
}

.uppy-Dashboard-AddFiles-info {
  font-size: 0.875rem;
  opacity: 0.8;
}

/* Hide powered by Uppy */
.uppy-Dashboard-poweredBy {
  display: none !important;
}

/* Add this to your customuppy.css file */
.uppy-dashboard-container {
  position: relative;
  width: 100%;
  overflow: hidden;
}

.uppy-dashboard-container .uppy-Dashboard {
  width: 100% !important;
  max-width: 100% !important;
}

.uppy-dashboard-container .uppy-Dashboard-inner {
  width: 100% !important;
  max-width: 100% !important;
  overflow-x: hidden;
}

/* For mobile devices */
@media (max-width: 768px) {
  .uppy-dashboard-container .uppy-Dashboard {
    height: 350px !important; /* Reduced height for mobile */
  }
  
  .uppy-dashboard-container .uppy-Dashboard-files {
    padding: 0 5px;
  }
  
  .uppy-dashboard-container .uppy-DashboardItem-name {
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
    max-width: 150px;
  }
}
```

<!-- path: app/page.tsx -->
```typescript
"use client";

import OfflineStatus from "@/components/pwa/offline-status";
import PWAInstallPrompt from "@/components/pwa/pwa-install-prompt";

import { useScroll, useTransform } from "framer-motion";
import { useEffect, useState } from "react";

import AnimatedBackground from "@/components/home/AnimatedBackground";
import HeroContent from "@/components/home/HeroContent";
import ParticlesOverlay from "@/components/home/ParticlesOverlay";
import ScrollIndicator from "@/components/home/ScrollIndicator";
import StatsHighlights from "@/components/home/StatsHighlights";
import { containerVariants, ctaVariants, floatingAnimation, highlightVariants, subtitleVariants, titleVariants } from "@/components/home/variants";
import OutdatedBrowserModal from "@/components/outdated/OutdatedBrowserModal";
import { useOutdatedBrowserCheck } from "@/hooks/useOutdatedBrowserCheck";

export default function Home() {
  const [showModal, setShowModal] = useState(false);
  const isOutdated = useOutdatedBrowserCheck();

  const { scrollY } = useScroll();
  const textY = useTransform(scrollY, [0, 500], [0, -50]);

  // Check if browser modal should be shown
  useEffect(() => {
    if (isOutdated && typeof window !== "undefined") {
      const dismissed = localStorage.getItem("legacyBrowserDismissed");
      if (!dismissed) {
        setShowModal(true);
      }
    }
  }, [isOutdated]);

  const handleCloseModal = () => {
    setShowModal(false);
    if (typeof window !== "undefined") {
      localStorage.setItem("legacyBrowserDismissed", "true");
    }
  };

  if (isOutdated === null) return null;

  return (
    <>
      <div className='relative min-h-screen w-full overflow-hidden'>
        <AnimatedBackground />
        <ParticlesOverlay />

        {showModal && <OutdatedBrowserModal handleCloseModal={handleCloseModal} />}

        <div className='overflow-hidden relative z-10 flex min-h-screen flex-col items-center justify-center bg-gradient-to-b from-black/60 via-black/40 to-black/60'>
          <HeroContent
            variants={{
              containerVariants,
              titleVariants,
              subtitleVariants,
              highlightVariants,
              ctaVariants,
            }}
            floatingAnimation={floatingAnimation}
            textY={textY}
          />
          <StatsHighlights />
        </div>

        <ScrollIndicator />
      </div>
      <PWAInstallPrompt />
      <OfflineStatus />
    </>
  );
}

```

<!-- path: app/auth/callback/route.ts -->
```typescript
// app/auth/callback/route.ts
import { createClient } from '@/utils/supabase/server'
import { NextResponse } from 'next/server'

export async function GET(request: Request) {
  const { searchParams, origin } = new URL(request.url)
  const code = searchParams.get('code')
  const next = searchParams.get('next') ?? '/dashboard'
  const error = searchParams.get('error')
  const errorDescription = searchParams.get('error_description')

  // console.log('Auth callback received:', { code: !!code, error, errorDescription })

  // Handle OAuth errors
  if (error) {
    console.error('OAuth error:', error, errorDescription)
    const errorParams = new URLSearchParams({
      error: error,
      message: errorDescription || 'Authentication failed'
    })
    return NextResponse.redirect(`${origin}/auth/error?${errorParams}`)
  }

  if (code) {
    const supabase = await createClient()
    
    try {
      // console.log('Exchanging code for session...')
      const { data, error: exchangeError } = await supabase.auth.exchangeCodeForSession(code)
      
      if (exchangeError) {
        console.error('Session exchange error:', exchangeError)
        const errorParams = new URLSearchParams({
          error: 'session_exchange_failed',
          message: exchangeError.message
        })
        return NextResponse.redirect(`${origin}/auth/error?${errorParams}`)
      }

      if (data.user) {
        // console.log('User authenticated:', data.user.id)
        
        // Check if user has a profile
        // console.log('Checking for existing profile...')
        const { data: profile, error: profileError } = await supabase
          .from('user_profiles')
          .select('id')
          .eq('id', data.user.id)
          .single()

        // console.log('Profile check result:', { profile: !!profile, error: profileError?.code })

        // If no profile exists, redirect to onboarding
        // check non blocking way after 2 seconds
        setTimeout(() => {
          if (profileError && profileError.code === 'PGRST116') {
            // console.log('No profile found, redirecting to onboarding')
            return NextResponse.redirect(`${origin}/onboarding`)
          }
        }, 2000)
        

        if (profileError && profileError.code !== 'PGRST116') {
          console.error('Profile check error:', profileError)
          // Continue anyway, let the client handle it
        }

        // If profile exists, redirect to intended destination
        if (profile) {
          // console.log('Profile exists, redirecting to:', next)
          return NextResponse.redirect(`${origin}${next}`)
        }

        // Fallback: redirect to dashboard if no profile check conclusive
        // console.log('Fallback redirect to dashboard')
        return NextResponse.redirect(`${origin}/dashboard`)
      }
      
    } catch (error) {
      console.error('Unexpected error in auth callback:', error)
      const errorParams = new URLSearchParams({
        error: 'unexpected_error',
        message: 'An unexpected error occurred during authentication'
      })
      return NextResponse.redirect(`${origin}/auth/error?${errorParams}`)
    }
  }

  // No code parameter - invalid callback
  console.error('No code parameter received')
  const errorParams = new URLSearchParams({
    error: 'invalid_callback',
    message: 'Invalid authentication callback'
  })
  return NextResponse.redirect(`${origin}/auth/error?${errorParams}`)
}
```

<!-- path: app/dashboard/lookup/page.tsx -->
```typescript
'use client';

import {
  PageHeader,
  useStandardHeaderActions,
} from '@/components/common/page-header';
import { ErrorDisplay } from '@/components/common/ui';
import { Card } from '@/components/common/ui/card';
import { useLookupTypes } from '@/components/lookup/lookup-hooks';
import { LookupModal } from '@/components/lookup/LookupModal';
import {
  ErrorState,
  LoadingState,
  NoCategoriesState,
  SelectCategoryPrompt,
} from '@/components/lookup/LookupTypesEmptyStates';
import { LookupTypesFilters } from '@/components/lookup/LookupTypesFilters';
import { LookupTypesTable } from '@/components/lookup/LookupTypesTable';
import { Filters } from '@/hooks/database';
import { useSorting } from '@/hooks/useSorting';
import { useMemo } from 'react';
import { FiList } from 'react-icons/fi';
import { toast } from 'sonner';

export default function LookupTypesPage() {
  const {
    state: {
      selectedCategory,
      isLookupModalOpen,
      searchTerm,
      editingLookup,
      categories,
      lookupTypes,
      isLoading,
      hasCategories,
      hasSelectedCategory,
      categoriesError,
      lookupError,
    },
    handlers: {
      setSearchTerm,
      handleCategoryChange,
      handleRefresh,
      handleAddNew,
      handleEdit,
      handleDelete,
      handleToggleStatus,
      handleModalClose,
      handleLookupCreated,
      handleLookupUpdated,
    },
  } = useLookupTypes();

  // Apply sorting to lookup types
  const {
    sortedData: sortedLookupTypes,
    handleSort,
    getSortDirection,
  } = useSorting({
    data: lookupTypes,
    defaultSortKey: 'name',
    defaultDirection: 'asc',
    options: {
      caseSensitive: false,
      numericSort: true,
    },
  });

  // Filter sorted data based on search term
  const filteredAndSortedLookupTypes = useMemo(() => {
    if (!searchTerm.trim()) return sortedLookupTypes;

    const lowerSearchTerm = searchTerm.toLowerCase();
    return sortedLookupTypes.filter(
      (lookup) =>
        lookup.name?.toLowerCase().includes(lowerSearchTerm) ||
        lookup.code?.toLowerCase().includes(lowerSearchTerm) ||
        lookup.description?.toLowerCase().includes(lowerSearchTerm)
    );
  }, [sortedLookupTypes, searchTerm]);

  // --- Define header content using the hook ---
  const serverFilters = useMemo(() => {
    const f: Filters = {
      // Filter to download only categories with name not equal to "DEFAULT"
      name: {
        operator: 'neq',
        value: 'DEFAULT',
      },
    };
    return f;
  }, []);
  const headerActions = useStandardHeaderActions({
    data: lookupTypes,
    onRefresh: async () => {
      await handleRefresh();
      toast.success('Refreshed successfully!');
    },
    onAddNew: handleAddNew,
    isLoading: isLoading,
    exportConfig: { tableName: 'lookup_types', filters: serverFilters },
  });

  // --- Define header stats ---
  const activeLookups = lookupTypes.filter((lookup) => lookup.status);
  const inactiveLookups = lookupTypes.filter((lookup) => !lookup.status);
  const headerStats = [
    { value: lookupTypes.length, label: 'Total Lookup Types' },
    { value: activeLookups.length, label: 'Active', color: 'success' as const },
    {
      value: inactiveLookups.length,
      label: 'Inactive',
      color: 'danger' as const,
    },
  ];

  // Error handling
  if (lookupError) {
    return (
      <ErrorDisplay
        error={lookupError.message}
        actions={[
          {
            label: 'Retry',
            onClick: handleRefresh,
            variant: 'primary',
          },
        ]}
      />
    );
  }

  return (
    <div className="space-y-6 p-6">
      <PageHeader
        title="Lookup Types"
        description="Manage lookup types"
        icon={<FiList />}
        stats={headerStats}
        actions={headerActions}
        isLoading={isLoading}
      />

      {!hasCategories && !isLoading && (
        <NoCategoriesState
          error={categoriesError as Error}
          isLoading={isLoading}
        />
      )}

      {hasCategories && (
        <LookupTypesFilters
          categories={categories}
          selectedCategory={selectedCategory}
          onCategoryChange={handleCategoryChange}
          searchTerm={searchTerm}
          onSearchTermChange={setSearchTerm}
          hasSelectedCategory={hasSelectedCategory}
        />
      )}

      {lookupError && hasSelectedCategory && (
        <ErrorState error={lookupError} onRetry={handleRefresh} />
      )}

      {isLoading && hasSelectedCategory && (
        <LoadingState selectedCategory={selectedCategory} />
      )}

      {hasSelectedCategory && !isLoading && !lookupError && (
        <Card className="overflow-hidden">
          <div className="border-b bg-gray-50 dark:bg-gray-800 dark:border-gray-700 p-4">
            <p className="text-sm text-gray-600 dark:text-gray-400">
              Showing {filteredAndSortedLookupTypes.length} of{' '}
              {lookupTypes.length} lookup types for category:{' '}
              <strong className="text-gray-900 dark:text-gray-100">{`"${selectedCategory}"`}</strong>
              {searchTerm && (
                <span className="ml-2">
                  (filtered by: <em>&quot;{searchTerm}&quot;</em>)
                </span>
              )}
            </p>
          </div>

          <LookupTypesTable
            lookups={filteredAndSortedLookupTypes.map((lookup) => ({
              ...lookup,
              sort_order: lookup.sort_order ?? 0,
              created_at: lookup.created_at
                ? new Date(lookup.created_at)
                : undefined,
              updated_at: lookup.updated_at
                ? new Date(lookup.updated_at)
                : undefined,
              is_system_default: lookup.is_system_default ?? false,
              status: lookup.status ?? true,
            }))}
            onEdit={handleEdit}
            onDelete={handleDelete}
            onToggleStatus={handleToggleStatus}
            selectedCategory={selectedCategory}
            searchTerm={searchTerm}
            onSort={handleSort}
            getSortDirection={getSortDirection}
          />
        </Card>
      )}

      {!hasSelectedCategory && !isLoading && hasCategories && (
        <SelectCategoryPrompt />
      )}

      <LookupModal
        isOpen={isLookupModalOpen}
        onClose={handleModalClose}
        onLookupCreated={handleLookupCreated}
        onLookupUpdated={handleLookupUpdated}
        editingLookup={editingLookup}
        category={selectedCategory}
        categories={categories}
      />
    </div>
  );
}

```

<!-- path: app/dashboard/route-manager/page.tsx -->
```typescript
// path: app/dashboard/route-manager/page.tsx
"use client";

import { useState } from "react";
import { PageHeader } from "@/components/common/page-header";
import { SearchableSelect } from "@/components/common/ui/select/SearchableSelect";
import { useDeleteJc, useOfcRoutesForSelection, useRouteDetails } from "@/hooks/database/route-manager-hooks";
import { PageSpinner } from "@/components/common/ui/LoadingSpinner";
import { FaRoute } from "react-icons/fa";
import { Equipment } from "@/components/route-manager/types";
// import { SpliceMatrixModal } from "@/components/route-manager/SpliceMatrixModal"; // <--- IMPORT THE NEW MODAL
import { FiPlus } from "react-icons/fi";
import { JcFormModal } from "@/components/route-manager/JcFormModal";
import { RouteVisualizer } from "@/components/route-manager/RouteVisualizer";
import { FiberSpliceManager } from "@/components/route-manager/FiberSpliceManager";
import { CableSegmentationManager } from "@/components/route-manager/CableSegmentationManager";
import { usePagedData } from "@/hooks/database";
import { createClient } from "@/utils/supabase/client";
import { Tabs, TabsContent, TabsList, TabsTrigger } from "@/components/common/ui/tabs";

// =================================================================
// Main Page Component
// =================================================================
export default function RouteManagerPage() {
  const [selectedRouteId, setSelectedRouteId] = useState<string | null>(null);
  const [selectedJc, setSelectedJc] = useState<Equipment | null>(null);
  const [editingJc, setEditingJc] = useState<Equipment | null>(null); // <--- For the JC form
  const [isSpliceModalOpen, setIsSpliceModalOpen] = useState(false);
  const [isJcFormModalOpen, setIsJcFormModalOpen] = useState(false); // <--- State for JC form modal
  const [activeTab, setActiveTab] = useState("visualizer");

  const supabase = createClient();

  // Data fetching and mutation hooks
  const { data: routesForSelection, isLoading: isLoadingRoutes } = useOfcRoutesForSelection();
  const { data: routeDetails, isLoading: isLoadingDetails, isError: isErrorRouteDetails, error: errorRouteDetails, refetch: refetchRouteDetails } = useRouteDetails(selectedRouteId);
  const deleteJcMutation = useDeleteJc();

  const handleJcClick = (jc: Equipment) => {
    setSelectedJc(jc);
    setIsSpliceModalOpen(true);
  };

  const handleOpenAddJcModal = () => {
    console.log("=== OPENING JC MODAL ===");
    console.log("selectedRouteId:", selectedRouteId);
    console.log("routeDetails:", routeDetails);
    setEditingJc(null); // Ensure we're in "create" mode
    setIsJcFormModalOpen(true);
  };

  const handleOpenEditJcModal = (jc: Equipment) => {
    setEditingJc(jc);
    setIsJcFormModalOpen(true);
  };

  const handleDeleteJc = (jc: Equipment) => {
    if (window.confirm(`Are you sure you want to delete the junction closure "${jc.name}"? This action cannot be undone.`)) {
      if (jc.id) {
        deleteJcMutation.mutate(jc.id);
      } else {
        console.error("Cannot delete junction closure: id is null");
      }
    }
  };

  const routeOptions = routesForSelection?.map((r) => ({ value: r.id, label: r.route_name })) || [];

  return (
    <div className='space-y-6'>
      <PageHeader
        title='Route Manager'
        description='Visualize and manage the fiber splices within your OFC routes.'
        icon={<FaRoute />}
        isLoading={isLoadingRoutes}
        actions={[
          {
            label: "Add Junction Closure",
            onClick: handleOpenAddJcModal,
            variant: "primary",
            leftIcon: <FiPlus />,
            disabled: !selectedRouteId || isLoadingDetails,
          },
        ]}
      />

      <div className='bg-white dark:bg-gray-800 p-4 rounded-lg shadow-md border dark:border-gray-700'>
        <label className='block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2'>Select an OFC Route to Manage</label>
        <SearchableSelect options={routeOptions} value={selectedRouteId || ""} onChange={(value) => setSelectedRouteId(value)} placeholder={isLoadingRoutes ? "Loading routes..." : "Search and select a route"} disabled={isLoadingRoutes} clearable />
      </div>

      {isLoadingDetails && <PageSpinner text='Loading route details...' />}

      {isErrorRouteDetails && (
        <div className="p-4 bg-red-50 text-red-700 border border-red-200 rounded-lg">
          Error loading route details: {errorRouteDetails.message}
        </div>
      )}

      {routeDetails && (
        <div className="space-y-6">
          {/* Tab Navigation */}
          <div className="flex space-x-1 bg-gray-100 dark:bg-gray-800 p-1 rounded-lg">
            <button
              onClick={() => setActiveTab("visualizer")}
              className={`px-4 py-2 rounded-md text-sm font-medium transition-colors ${
                activeTab === "visualizer"
                  ? 'bg-white dark:bg-gray-700 text-gray-900 dark:text-white shadow-sm'
                  : 'text-gray-600 dark:text-gray-400 hover:text-gray-900 dark:hover:text-white'
              }`}
            >
              Route Visualizer
            </button>
            <button
              onClick={() => setActiveTab("fiber-splice")}
              className={`px-4 py-2 rounded-md text-sm font-medium transition-colors ${
                activeTab === "fiber-splice"
                  ? 'bg-white dark:bg-gray-700 text-gray-900 dark:text-white shadow-sm'
                  : 'text-gray-600 dark:text-gray-400 hover:text-gray-900 dark:hover:text-white'
              }`}
            >
              Fiber Splice Manager
            </button>
            <button
              onClick={() => setActiveTab("segmentation")}
              className={`px-4 py-2 rounded-md text-sm font-medium transition-colors ${
                activeTab === "segmentation"
                  ? 'bg-white dark:bg-gray-700 text-gray-900 dark:text-white shadow-sm'
                  : 'text-gray-600 dark:text-gray-400 hover:text-gray-900 dark:hover:text-white'
              }`}
            >
              Cable Segmentation
            </button>
          </div>

          {/* Tab Content */}
          {activeTab === "visualizer" && (
            <RouteVisualizer routeDetails={routeDetails} onJcClick={handleJcClick} onEditJc={handleOpenEditJcModal} onDeleteJc={handleDeleteJc} />
          )}

          {activeTab === "fiber-splice" && (
            <FiberSpliceManager
              junctionClosureId={selectedJc?.id || ""}
              junctionClosureName={selectedJc?.name || ""}
              onSpliceComplete={() => refetchRouteDetails()}
              capacity={routeDetails.route.capacity ?? undefined}
            />
          )}

          {activeTab === "segmentation" && (
            <CableSegmentationManager
              cableId={selectedRouteId || ""}
              cableName={routeDetails.route.route_name || ""}
              onSegmentationComplete={() => refetchRouteDetails()}
            />
          )}
        </div>
      )}

      {/* Modals */}

      <JcFormModal
        isOpen={isJcFormModalOpen}
        onClose={() => setIsJcFormModalOpen(false)}
        onSave={() => refetchRouteDetails()} // Refetch details when a JC is created/updated
        routeId={selectedRouteId}
        editingJc={editingJc}
        rkm={routeDetails?.route.current_rkm ?? null}
      />
    </div>
  );
}

```

<!-- path: app/dashboard/rings/page.tsx -->
```typescript
// app/dashboard/rings/page.tsx
'use client';

import {
  PageHeader,
  useStandardHeaderActions,
} from '@/components/common/page-header';
import { ConfirmModal } from '@/components/common/ui';
import { RingModal } from '@/components/rings/RingModal';
import { RingsFilters } from '@/components/rings/RingsFilters';
import { createStandardActions } from '@/components/table/action-helpers';
import { DataTable } from '@/components/table/DataTable';
import { desiredRingColumnOrder } from '@/config/column-orders';
import { RingsColumns } from '@/config/table-columns/RingsTableColumns';
import { usePagedRingsWithCount } from '@/hooks/database';
import {
  DataQueryHookParams,
  DataQueryHookReturn,
  useCrudManager,
} from '@/hooks/useCrudManager';
import {
  RingsRowSchema,
  V_rings_with_countRowSchema,
} from '@/schemas/zod-schemas';
import { createClient } from '@/utils/supabase/client';
import { useMemo } from 'react';
import { GiLinkedRings } from 'react-icons/gi';
import { toast } from 'sonner';

export type RingRowsWithRelations = RingsRowSchema & {
  ring_type?: {
    id: string;
    code: string;
  } | null;
  maintenance_terminal?: {
    id: string;
    name: string;
  } | null;
};

// 1. ADAPTER HOOK: Makes `useRingsData` compatible with `useCrudManager`
const useRingsData = (
  params: DataQueryHookParams
): DataQueryHookReturn<V_rings_with_countRowSchema> => {
  const { currentPage, pageLimit, filters, searchQuery } = params;
  const supabase = createClient();

  const { data, isLoading, error, refetch } = usePagedRingsWithCount(supabase, {
    filters: {
      ...filters,
      ...(searchQuery ? { name: searchQuery } : {}),
    },
    limit: pageLimit,
    offset: (currentPage - 1) * pageLimit,
    // queryOptions: {
    //   enabled: true,
    //   refetchOnWindowFocus: false,
    //   refetchOnMount: true,
    //   refetchInterval: 0,
    //   refetchIntervalInBackground: false,
    //   staleTime: 3 * 60 * 1000,
    // }
  });

  // Calculate counts from the full dataset
  const totalCount = data?.[0]?.total_count || 0;
  const activeCount = data?.[0]?.active_count || 0;
  const inactiveCount = data?.[0]?.inactive_count || 0;

  return {
    data: data || [],
    totalCount,
    activeCount,
    inactiveCount,
    isLoading,
    error,
    refetch,
  };
};

const RingsPage = () => {
  // 2. USE THE CRUD MANAGER with the adapter hook and both generic types
  const {
    data: rings,
    totalCount,
    activeCount,
    inactiveCount,
    isLoading,
    // isMutating,
    // error,
    refetch,
    pagination,
    search,
    // filters,
    editModal,
    viewModal,
    // bulkActions,
    deleteModal,
    actions: crudActions,
  } = useCrudManager<'rings', V_rings_with_countRowSchema>({
    tableName: 'rings',
    dataQueryHook: useRingsData,
  });

  // 3. Extract ring types from the rings data
  const ringTypes = useMemo(() => {
    const uniqueRingTypes = new Map();
    // console.log("rings", rings);
    rings.forEach((ring) => {
      if (ring.ring_type_code) {
        uniqueRingTypes.set(ring.ring_type_id, {
          id: ring.ring_type_id,
          name: ring.ring_type_code,
        });
      }
    });
    return Array.from(uniqueRingTypes.values());
  }, [rings]);

  // 4. Extract maintenance areas from the rings data
  const maintenanceAreas = useMemo(() => {
    const uniqueMaintenanceAreas = new Map();
    rings.forEach((ring) => {
      if (ring.maintenance_area_area_type_id && ring.maintenance_terminal_id) {
        uniqueMaintenanceAreas.set(ring.maintenance_terminal_id, {
          id: ring.maintenance_terminal_id,
          name: ring.maintenance_area_name,
        });
      }
    });
    return Array.from(uniqueMaintenanceAreas.values());
  }, [rings]);

  const columns = RingsColumns(rings);
  // Type guard to remove undefined from the mapped array
  const notUndefined = <T,>(x: T | undefined): x is T => x !== undefined;
  const orderedColumns = [
    ...desiredRingColumnOrder
      .map((k) => columns.find((c) => c.key === k))
      .filter(notUndefined),
    ...columns.filter((c) => !desiredRingColumnOrder.includes(c.key)),
  ];

  // --- tableActions ---
  const tableActions = useMemo(
    () =>
      createStandardActions<V_rings_with_countRowSchema>({
        onEdit: editModal.openEdit,
        onView: viewModal.open,
        onDelete: crudActions.handleDelete,
        // You can also add custom logic, for example:
        // canDelete: (record) => record.name !== 'CRITICAL_RING',
      }),
    [editModal.openEdit, viewModal.open, crudActions.handleDelete]
  );

  // --- Define header content using the hook ---
  const headerActions = useStandardHeaderActions({
    data: rings as RingsRowSchema[],
    onRefresh: async () => {
      await refetch();
      toast.success('Refreshed successfully!');
    },
    onAddNew: editModal.openAdd,
    isLoading: isLoading,
    exportConfig: { tableName: 'rings' },
  });

  const headerStats = [
    { value: totalCount, label: 'Total Rings' },
    {
      value: activeCount,
      label: 'Active',
      color: 'success' as const,
    },
    {
      value: inactiveCount,
      label: 'Inactive',
      color: 'danger' as const,
    },
  ];

  return (
    <div className="mx-auto space-y-4">
      {/* Header */}
      <PageHeader
        title="Ring Management"
        description="Manage network rings and their related information."
        icon={<GiLinkedRings />}
        stats={headerStats}
        actions={headerActions} // <-- Pass the generated actions
        isLoading={isLoading}
      />

      {/* Table */}
      <DataTable
        tableName="v_rings_with_count"
        data={rings}
        columns={orderedColumns}
        loading={isLoading}
        actions={tableActions}
        pagination={{
          current: pagination.currentPage,
          pageSize: pagination.pageLimit,
          total: totalCount,
          showSizeChanger: true,
          onChange: (page, pageSize) => {
            pagination.setCurrentPage(page);
            pagination.setPageLimit(pageSize);
          },
        }}
        customToolbar={
          <RingsFilters
            searchQuery={search.searchQuery}
            onSearchChange={search.setSearchQuery}
          />
        }
      />

      <RingModal
        isOpen={editModal.isOpen}
        onClose={editModal.close}
        editingRing={editModal.record as RingRowsWithRelations | null}
        onCreated={crudActions.handleSave}
        onUpdated={crudActions.handleSave}
        ringTypes={ringTypes}
        maintenanceAreas={maintenanceAreas}
      />

      {/* Render the confirmation modal, driven by the hook's state */}
      <ConfirmModal
        isOpen={deleteModal.isOpen}
        onConfirm={deleteModal.onConfirm}
        onCancel={deleteModal.onCancel}
        title="Confirm Deletion"
        message={deleteModal.message}
        confirmText="Delete"
        cancelText="Cancel"
        type="danger"
        showIcon
        loading={deleteModal.loading}
      />
    </div>
  );
};

export default RingsPage;

```

<!-- path: app/dashboard/page.tsx -->
```typescript
"use client";

import { tableQueryUtils, useDashboardOverview, useQueryPerformance } from "@/hooks/database";
import { useQueryClient } from "@tanstack/react-query";
import { createClient } from "@/utils/supabase/client";
import { Button } from "@/components/common/ui";

export default function DashboardPage() {
  const { getQueryStats, clearStaleQueries, prefetchCriticalData } = useQueryPerformance();
  const queryClient = useQueryClient();
  const supabase = createClient();
  // const { data } = useDashboardOverview(supabase, {});

  const stats = getQueryStats();

  const handleOptimizeCache = async () => {
    // Clear stale queries
    clearStaleQueries();

    // Remove old queries
    tableQueryUtils.removeStaleQueries(queryClient, 5 * 60 * 1000); // 5 minutes

    // Prefetch critical data
    await prefetchCriticalData(supabase, ['lookup_types', 'employees', 'employee_designations']);

    // Get cache stats for specific table
    const lookupTypesCacheStats = tableQueryUtils.getTableCacheStats(queryClient, 'lookup_types');
    console.log('Lookup Types cache stats:', lookupTypesCacheStats);

    const employeesCacheStats = tableQueryUtils.getTableCacheStats(queryClient, 'employees');
    console.log('Employees cache stats:', employeesCacheStats);

    const employeeDesignationsCacheStats = tableQueryUtils.getTableCacheStats(queryClient, 'employee_designations');
    console.log('Employee Designations cache stats:', employeeDesignationsCacheStats);

    // console.log('Dashboard Overview:', data);
  };
  return (
    <div className="flex flex-col items-center justify-center py-16">
      <Button onClick={handleOptimizeCache}>Optimize Cache</Button>
      <h2 className="mb-4 text-2xl font-bold text-gray-600 dark:text-gray-300">Welcome to your dashboard</h2>
      <p className="text-gray-600 dark:text-gray-300">
        Select an item from the sidebar to get started.
      </p>
      <pre>{JSON.stringify(stats, null, 2)}</pre>
      <div>
      <h3>Query Performance</h3>
      <p>Total Queries: {stats.totalQueries}</p>
      <p>Stale Queries: {stats.staleQueries}</p>
      <p>Cache Size: {(stats.cacheSizeBytes / 1024 / 1024).toFixed(2)} MB</p>
      <button onClick={handleOptimizeCache}>Optimize Cache</button>
    </div>
    </div>
  );
}

```

<!-- path: app/dashboard/diagrams/page.tsx -->
```typescript
"use client";

// app/diagrams/page.tsx

import dynamic from "next/dynamic";

// Disable SSR for the StorageManager component
const FileUploader = dynamic(
  () => import("@/components/diagrams/FileUploader"),
  { ssr: false },
);

import { useEffect, useState } from "react";
import { createClient } from "@/utils/supabase/client";

export default function Home() {
  const [user, setUser] = useState<any>(null);
  const supabase = createClient();

  useEffect(() => {
    let listener: any;

    async function initSupabase() {
      const { data: { user } = {} } = await supabase.auth.getUser();
      setUser(user ?? null);

      const { data } = supabase.auth.onAuthStateChange(
        (_event: any, session: any) => {
          setUser(session?.user ?? null);
        },
      );
      listener = data;
    }

    initSupabase();

    return () => {
      if (listener?.unsubscribe) {
        listener.unsubscribe();
      }
    };
  }, []);

  return (
    <div className="p-4">
      <h1 className="mb-4 text-2xl font-bold">
        Upload OFC Diagrams
      </h1>
      {!user ? <p>Please log in to upload files.</p> : <FileUploader />}
    </div>
  );
}

```

<!-- path: app/dashboard/vmux/page.tsx -->
```typescript
import React from 'react'

const page = () => {
  return (
    <div>VMUX page</div>
  )
}

export default page
```

<!-- path: app/dashboard/categories/page.tsx -->
```typescript
'use client';

import { CategoriesTable } from '@/components/categories/CategoriesTable';
import { CategoryModal } from '@/components/categories/CategoryModal';
import { CategorySearch } from '@/components/categories/CategorySearch';
import { EmptyState } from '@/components/categories/EmptyState';
import { LoadingState } from '@/components/categories/LoadingState';
import { formatCategoryName } from '@/components/categories/utils';
import {
  PageHeader,
  useStandardHeaderActions,
} from '@/components/common/page-header';
import { ErrorDisplay } from '@/components/common/ui';
import { ConfirmModal } from '@/components/common/ui/Modal';
import { Filters, useDeduplicated, useTableQuery } from '@/hooks/database';
import { useDelete } from '@/hooks/useDelete';
import { useDeleteManager } from '@/hooks/useDeleteManager';
import { Lookup_typesRowSchema } from '@/schemas/zod-schemas';
import { createClient } from '@/utils/supabase/client';
import { useCallback, useEffect, useMemo, useState } from 'react';
import { FiLayers } from 'react-icons/fi';
import { toast } from 'sonner';

type GroupedLookupsByCategory = Record<string, Lookup_typesRowSchema[]>;
export interface CategoryInfo {
  name: string;
  lookupCount: number;
  hasSystemDefaults: boolean;
}

export default function CategoriesPage() {
  const [searchTerm, setSearchTerm] = useState('');
  const [isModalOpen, setIsModalOpen] = useState(false);
  const [editingCategory, setEditingCategory] = useState<string | null>(null);
  const [categoryLookupCounts, setCategoryLookupCounts] = useState<
    Record<string, CategoryInfo>
  >({});
  const [selectedCategoryId, setSelectedCategoryId] = useState<string | null>(
    null
  );

  const supabase = createClient();

  const {
    data: categoriesDeduplicated = [],
    isLoading: dedupLoading,
    error: dedupError,
    refetch: refetchCategories,
  } = useDeduplicated(supabase, 'lookup_types', {
    columns: ['category'],
    orderBy: [{ column: 'created_at', ascending: true }],
  });

  const {
    data: groupedLookupsByCategory,
    isLoading: groupedLookupsByCategoryLoading,
    error: groupedLookupsByCategoryError,
    refetch: refetchGroupedLookupsByCategory,
  } = useTableQuery(supabase, 'lookup_types', {
    select: (allLookups): GroupedLookupsByCategory => {
      if (!allLookups) return {};
      return allLookups.reduce((accumulator, currentLookup) => {
        const category = currentLookup.category;
        if (!accumulator[category]) {
          accumulator[category] = [];
        }
        accumulator[category].push(currentLookup);
        return accumulator;
      }, {} as GroupedLookupsByCategory);
    },
  });

  const deleteManager = useDelete({
    tableName: 'lookup_types',
    onSuccess: () => {
      if (selectedCategoryId === deleteManager.itemToDelete?.id) {
        setSelectedCategoryId(null);
      }
      refetchCategories();
    },
  });

  const isLoading =
    dedupLoading || groupedLookupsByCategoryLoading || deleteManager.isPending;

  const refreshCategoryInfo = useCallback(() => {
    const counts: Record<string, CategoryInfo> = {};
    for (const category of categoriesDeduplicated) {
      const categoryLookups =
        groupedLookupsByCategory?.[category.category] || [];
      counts[category.category] = {
        name: category.category,
        lookupCount: categoryLookups.length,
        hasSystemDefaults: categoryLookups.some(
          (lookup) => lookup.is_system_default
        ),
      };
    }
    setCategoryLookupCounts(counts);
  }, [categoriesDeduplicated, groupedLookupsByCategory]);

  useEffect(() => {
    if (!isLoading) {
      refreshCategoryInfo();
    }
  }, [isLoading]);

  async function handleRefresh() {
    try {
      await Promise.all([
        refetchCategories(),
        refetchGroupedLookupsByCategory(),
      ]);
      if (!isModalOpen) {
        toast.success('Data refreshed successfully');
      }
    } catch (error) {
      console.error('Error refreshing data:', error);
    }
  }

  const handleCategoryCreated = async () => {
    setIsModalOpen(false);
    setEditingCategory(null);
    handleRefresh();
  };

  const handleEdit = (categoryName: string) => {
    setEditingCategory(categoryName);
    setIsModalOpen(true);
    // handleRefresh();
  };

  const bulkDeleteManager = useDeleteManager({
    tableName: 'lookup_types',
    onSuccess: () => {
      if (selectedCategoryId === deleteManager.itemToDelete?.id) {
        setSelectedCategoryId(null);
      }
      refetchCategories();
    },
  });
  const handleDeleteCategory = (categoryToDelete: string) => {
    bulkDeleteManager.deleteBulk({
      column: 'category',
      value: categoryToDelete,
      displayName: categoryToDelete,
    });
  };

  const openCreateModal = () => {
    setEditingCategory(null);
    setIsModalOpen(true);
  };

  const handleModalClose = () => {
    setIsModalOpen(false);
    setEditingCategory(null);
  };

  const filteredCategories = (
    categoriesDeduplicated as Lookup_typesRowSchema[]
  )?.filter(
    (category) =>
      (category.category &&
        category.category.toLowerCase().includes(searchTerm.toLowerCase())) ||
      formatCategoryName(category as Lookup_typesRowSchema)
        .toLowerCase()
        .includes(searchTerm.toLowerCase())
  );

  // --- Define header content using the hook ---
  const serverFilters = useMemo(() => {
    const f: Filters = {
      // Filter to download only categories with name not equal to "DEFAULT"
      name: {
        operator: 'eq',
        value: 'DEFAULT',
      },
    };
    return f;
  }, []);
  const headerActions = useStandardHeaderActions({
    data: categoriesDeduplicated,
    onRefresh: async () => {
      await refetchCategories();
      toast.success('Refreshed successfully!');
    },
    onAddNew: openCreateModal,
    isLoading: isLoading,
    exportConfig: {
      tableName: 'lookup_types',
      fileName: 'Categories',
      filters: serverFilters,
    },
  });

  const activeCategories = categoriesDeduplicated.filter(
    (category) => category.status
  );
  const inactiveCategories = categoriesDeduplicated.filter(
    (category) => !category.status
  );

  const headerStats = [
    { value: categoriesDeduplicated.length, label: 'Total Categories' },
    {
      value: activeCategories.length,
      label: 'Active',
      color: 'success' as const,
    },
    {
      value: inactiveCategories.length,
      label: 'Inactive',
      color: 'danger' as const,
    },
  ];
  console.log(
    `Rendering ConfirmModal with isOpen: ${JSON.stringify(
      bulkDeleteManager.isConfirmModalOpen
    )}`
  );
  const error = dedupError || groupedLookupsByCategoryError;

  if (error) {
    return (
      <ErrorDisplay
        error={error.message}
        actions={[
          {
            label: 'Retry',
            onClick: refetchCategories,
            variant: 'primary',
          },
        ]}
      />
    );
  }

  return (
    <div className="space-y-6 p-6 dark:bg-gray-900 dark:text-gray-100">
      <PageHeader
        title="Categories"
        description="Manage categories and their related information."
        icon={<FiLayers />}
        stats={headerStats}
        actions={headerActions}
        isLoading={isLoading}
      />

      <CategorySearch searchTerm={searchTerm} onSearchChange={setSearchTerm} />

      {isLoading && <LoadingState />}

      {!isLoading && !dedupError && !groupedLookupsByCategoryError && (
        <CategoriesTable
          categories={filteredCategories}
          categoryLookupCounts={categoryLookupCounts}
          totalCategories={categoriesDeduplicated.length}
          onEdit={handleEdit}
          onDelete={handleDeleteCategory}
          isDeleting={deleteManager.isPending}
          searchTerm={searchTerm}
        />
      )}

      {categoriesDeduplicated.length === 0 && !isLoading && !dedupError && (
        <EmptyState onCreate={openCreateModal} />
      )}

      <ConfirmModal
        isOpen={bulkDeleteManager.isConfirmModalOpen}
        onConfirm={bulkDeleteManager.handleConfirm}
        onCancel={bulkDeleteManager.handleCancel}
        title="Confirm Deletion"
        message={bulkDeleteManager.confirmationMessage}
        confirmText="Delete"
        cancelText="Cancel"
        type="danger"
        showIcon
        closeOnBackdrop
        closeOnEscape
        loading={bulkDeleteManager.isPending}
        size="md"
      />

      <CategoryModal
        isOpen={isModalOpen}
        onClose={handleModalClose}
        onCategoryCreated={handleCategoryCreated}
        editingCategory={editingCategory || ''}
        categories={categoriesDeduplicated}
        lookupsByCategory={groupedLookupsByCategory}
      />
    </div>
  );
}

```

<!-- path: app/dashboard/maintenance-areas/page.tsx -->
```typescript
// components/maintenance-areas/MaintenanceAreasPage.tsx
'use client';

import { EntityManagementComponent } from '@/components/common/entity-management/EntityManagementComponent';
import {
  PageHeader,
  useStandardHeaderActions,
} from '@/components/common/page-header';
import { ErrorDisplay } from '@/components/common/ui';
import { ConfirmModal } from '@/components/common/ui/Modal';
import { AreaFormModal } from '@/components/maintenance-areas/AreaFormModal';
import { useMaintenanceAreasMutations } from '@/components/maintenance-areas/useMaintenanceAreasMutations';
import { areaConfig, MaintenanceAreaWithRelations } from '@/config/areas';
import {
  Filters,
  useTableQuery,
  useTableWithRelations,
} from '@/hooks/database';
import { useDelete } from '@/hooks/useDelete';
import { Maintenance_areasInsertSchema } from '@/schemas/zod-schemas';
import { createClient } from '@/utils/supabase/client';
import { useMemo, useState } from 'react';
import { FiMapPin } from 'react-icons/fi';
import { toast } from 'sonner';

export default function MaintenanceAreasPage() {
  const supabase = createClient();

  // State management
  const [filters, setFilters] = useState<{
    status?: string;
    areaType?: string;
  }>({});
  const [selectedAreaId, setSelectedAreaId] = useState<string | null>(null);
  const [isFormOpen, setFormOpen] = useState(false);
  const [editingArea, setEditingArea] =
    useState<MaintenanceAreaWithRelations | null>(null);

  // Data queries
  const serverFilters = useMemo(() => {
    const f: Filters = {};
    if (filters.status) f.status = filters.status === 'true';
    if (filters.areaType) f.area_type_id = filters.areaType;
    return f;
  }, [filters]);

  const areasQuery = useTableWithRelations(
    supabase,
    'maintenance_areas',
    [
      'area_type:area_type_id(id, name)',
      'parent_area:parent_id(id, name, code)',
    ],
    {
      filters: serverFilters,
      orderBy: [{ column: 'name', ascending: true }],
    }
  );

  const { isLoading, error, refetch } = areasQuery;

  const { data: areaTypes = [] } = useTableQuery(supabase, 'lookup_types', {
    filters: { category: { operator: 'eq', value: 'MAINTENANCE_AREA_TYPES' } },
    orderBy: [{ column: 'name', ascending: true }],
  });

  // Data mutations
  const {
    createAreaMutation,
    updateAreaMutation,
    toggleStatusMutation,
    handleFormSubmit,
  } = useMaintenanceAreasMutations(supabase, () => {
    areasQuery.refetch();
    setFormOpen(false);
    setEditingArea(null);
  });

  const deleteManager = useDelete({
    tableName: 'maintenance_areas',
    onSuccess: () => {
      if (selectedAreaId === deleteManager.itemToDelete?.id) {
        setSelectedAreaId(null);
      }
      areasQuery.refetch();
    },
  });

  // Derived state
  const allAreas = useMemo(
    () => (areasQuery.data as MaintenanceAreaWithRelations[]) || [],
    [areasQuery.data]
  );
  const selectedArea = useMemo(
    () => allAreas.find((area) => area.id === selectedAreaId) || null,
    [selectedAreaId, allAreas]
  );

  // Event handlers
  const handleOpenCreateForm = () => {
    setEditingArea(null);
    setFormOpen(true);
  };

  const handleOpenEditForm = (area: MaintenanceAreaWithRelations) => {
    setEditingArea(area);
    setFormOpen(true);
  };

  // --- Define header content using the hook ---
  const headerActions = useStandardHeaderActions({
    data: allAreas,
    onRefresh: async () => {
      await refetch();
      toast.success('Refreshed successfully!');
    },
    // onAddNew: handleOpenCreateForm,
    isLoading: areasQuery.isLoading,
    exportConfig: { tableName: 'maintenance_areas' },
  });

  const headerStats = [
    { value: allAreas.length, label: 'Total Areas' },
    {
      value: allAreas.filter((r) => r.status).length,
      label: 'Active',
      color: 'success' as const,
    },
    {
      value: allAreas.filter((r) => !r.status).length,
      label: 'Inactive',
      color: 'danger' as const,
    },
  ];

  if (error) {
    return (
      <ErrorDisplay
        error={error.message}
        actions={[
          {
            label: 'Retry',
            onClick: refetch,
            variant: 'primary',
          },
        ]}
      />
    );
  }

  return (
    <div className="p-4 md:p-6 dark:bg-gray-900 min-h-screen">
      <PageHeader
        title="Maintenance Areas"
        description="Manage maintenance areas, zones, and terminals."
        icon={<FiMapPin />}
        stats={headerStats}
        actions={headerActions}
        isLoading={isLoading}
        className="mb-4"
      />
      <EntityManagementComponent<MaintenanceAreaWithRelations>
        config={areaConfig}
        entitiesQuery={areasQuery}
        toggleStatusMutation={toggleStatusMutation}
        onEdit={handleOpenEditForm}
        onDelete={deleteManager.deleteSingle}
        onCreateNew={handleOpenCreateForm}
      />

      {/* Modals */}
      {isFormOpen && (
        <AreaFormModal
          isOpen={isFormOpen}
          onClose={() => setFormOpen(false)}
          onSubmit={(data: Maintenance_areasInsertSchema) =>
            handleFormSubmit(data, editingArea)
          }
          area={editingArea}
          allAreas={allAreas}
          areaTypes={areaTypes}
          isLoading={
            createAreaMutation.isPending || updateAreaMutation.isPending
          }
        />
      )}

      <ConfirmModal
        isOpen={deleteManager.isConfirmModalOpen}
        onConfirm={deleteManager.handleConfirm}
        onCancel={deleteManager.handleCancel}
        title="Confirm Deletion"
        message={deleteManager.confirmationMessage}
        confirmText="Delete"
        cancelText="Cancel"
        type="danger"
        showIcon
        closeOnBackdrop
        closeOnEscape
        loading={deleteManager.isPending}
        size="md"
      />
    </div>
  );
}

```

<!-- path: app/dashboard/employees/page.tsx -->
```typescript
'use client';

import React, { useMemo, useState } from 'react';
import { FiDownload, FiPlus } from 'react-icons/fi';
import { createClient } from '@/utils/supabase/client';
import {
  TableInsert,
  usePagedEmployeesWithCount,
  useTableQuery,
} from '@/hooks/database';
import { DataTable } from '@/components/table/DataTable';
import { Row } from '@/hooks/database';
import { Button, ConfirmModal, ErrorDisplay } from '@/components/common/ui';
import EmployeeForm from '@/components/employee/EmployeeForm';
import EmployeeFilters from '@/components/employee/EmployeeFilters';
import { getEmployeeTableColumns } from '@/components/employee/EmployeeTableColumns';
import { getEmployeeTableActions } from '@/components/employee/EmployeeTableActions';
import { EmployeeWithRelations } from '@/components/employee/employee-types';
import { BulkActions } from '@/components/common/BulkActions';
import { useTableExcelDownload } from '@/hooks/database/excel-queries';
import { toast } from 'sonner';
import { formatDate } from '@/utils/formatters';
import { useDynamicColumnConfig } from '@/hooks/useColumnConfig';
import { EmployeeDetailsModal } from '@/config/employee-details-config';
import {
  DataQueryHookParams,
  DataQueryHookReturn,
  useCrudManager,
} from '@/hooks/useCrudManager';
import { EmployeeRowsWithCount } from '@/types/view-row-types';
import { EmployeesRowSchema } from '@/schemas/zod-schemas';

// 1. ADAPTER HOOK
const useEmployeesData = (
  params: DataQueryHookParams
): DataQueryHookReturn<EmployeeRowsWithCount> => {
  const { currentPage, pageLimit, filters, searchQuery } = params;

  const supabase = createClient();

  const { data, isLoading, error, refetch } = usePagedEmployeesWithCount(
    supabase,
    {
      filters: {
        ...filters,
        ...(searchQuery ? { employee_name: searchQuery } : {}),
      },
      limit: pageLimit,
      offset: (currentPage - 1) * pageLimit,
    }
  );

  // Calculate counts from the full dataset
  const totalCount = data?.[0]?.total_count || 0;
  const activeCount = data?.[0]?.active_count || 0;
  const inactiveCount = data?.[0]?.inactive_count || 0;

  return {
    data: data || [],
    totalCount,
    activeCount,
    inactiveCount,
    isLoading,
    error,
    refetch,
  };
};

const EmployeesPage = () => {
  const [showFilters, setShowFilters] = useState(false);

  // 2. USE THE CRUD MANAGER with the adapter hook and both generic types
  const {
    data: employeesData,
    totalCount,
    activeCount,
    inactiveCount,
    isLoading,
    // isMutating,
    error,
    refetch,
    pagination,
    search,
    filters,
    editModal,
    viewModal,
    bulkActions,
    deleteModal,
    actions: crudActions,
  } = useCrudManager<'employees', EmployeeRowsWithCount>({
    tableName: 'employees',
    dataQueryHook: useEmployeesData,
    processDataForSave: (data) => {
      // Employee-specific date logic
      if (data.employee_dob) data.employee_dob = new Date(data.employee_dob);
      if (data.employee_doj) data.employee_doj = new Date(data.employee_doj);
      return data as TableInsert<'employees'>;
    },
  });

  const [viewingEmployeeId, setViewingEmployeeId] = useState<string | null>(
    null
  );

  const supabase = createClient();
  const { data: designations = [] } = useTableQuery(
    supabase,
    'employee_designations',
    { orderBy: [{ column: 'name' }] }
  );
  const { data: maintenanceAreas = [] } = useTableQuery(
    supabase,
    'maintenance_areas',
    { filters: { status: true }, orderBy: [{ column: 'name' }] }
  );

  const columns = useMemo(
    () =>
      getEmployeeTableColumns({
        designationMap: Object.fromEntries(
          designations.map((d) => [d.id, d.name])
        ),
        areaMap: Object.fromEntries(
          maintenanceAreas.map((a) => [a.id, a.name])
        ),
      }),
    [designations, maintenanceAreas]
  );

  const tableActions = useMemo(
    () =>
      getEmployeeTableActions({
        onView: (id) => setViewingEmployeeId(id),
        onEdit: (id) => {
          const emp = employeesData.find((e) => e.id === id);
          if (emp) editModal.openEdit(emp);
        },
        onToggleStatus: (record) => crudActions.handleToggleStatus(record),
        onDelete: (employeeId, displayName = 'this employee') =>
          crudActions.handleDelete({ id: employeeId, name: displayName }),
      }),
    [employeesData, editModal, crudActions]
  );

  // Download Configurations
  const exportColumns = useDynamicColumnConfig('employees', {
    data: employeesData as EmployeesRowSchema[],
  });
  const tableExcelDownload = useTableExcelDownload(supabase, 'employees', {
    onSuccess: () => {
      toast.success('Export successful');
    },
    onError: () => toast.error('Export failed'),
  });

  const handleExport = async () => {
    const tableName = 'employees';
    const tableOptions = {
      fileName: `${formatDate(new Date(), { format: 'dd-mm-yyyy' })}-${String(
        tableName
      )}-export.xlsx`,
      sheetName: String(tableName),
      columns: exportColumns,
      // filters: filters.filters,
      maxRows: 1000,
      customStyles: {},
    };
    tableExcelDownload.mutate(tableOptions);
  };

  if (error) {
    return (
      <ErrorDisplay
        error={error.message}
        actions={[
          {
            label: 'Retry',
            onClick: refetch,
            variant: 'primary',
          },
        ]}
      />
    );
  }

  return (
    <div className="mx-auto space-y-4">
      <div className="flex justify-between items-center">
        <h1 className="text-2xl font-bold">
          Employee Management ({totalCount})
        </h1>
        <div className="flex gap-2">
          <Button
            variant="outline"
            leftIcon={<FiDownload />}
            onClick={handleExport}
          >
            Export
          </Button>
          <Button onClick={editModal.openAdd} leftIcon={<FiPlus />}>
            Add Employee
          </Button>
        </div>
      </div>
      <BulkActions
        selectedCount={bulkActions.selectedCount}
        isOperationLoading={isLoading}
        onBulkDelete={bulkActions.handleBulkDelete}
        onBulkUpdateStatus={bulkActions.handleBulkUpdateStatus}
        onClearSelection={bulkActions.handleClearSelection}
        entityName="employee"
        showStatusUpdate={true}
      />

      <DataTable
        tableName="employees"
        data={employeesData as EmployeesRowSchema[]}
        columns={columns}
        loading={isLoading}
        actions={tableActions}
        selectable
        onRowSelect={(selectedRows) => {
          // Filter out any rows where id is null
          const validRows = selectedRows.filter(
            (
              row
            ): row is EmployeeRowsWithCount & {
              id: string;
              employee_name: string; // Ensure employee_name is not null
            } => row.id !== null && row.employee_name !== null
          );
          bulkActions.handleRowSelect(validRows);
        }}
        searchable={false} // Turn off internal search
        filterable={false} // Turn off internal filters
        showColumnsToggle={true}
        pagination={{
          current: pagination.currentPage,
          pageSize: pagination.pageLimit,
          total: totalCount,
          showSizeChanger: true,
          onChange: (page, pageSize) => {
            pagination.setCurrentPage(page);
            pagination.setPageLimit(pageSize);
          },
        }}
        customToolbar={
          <EmployeeFilters
            searchQuery={search.searchQuery} // <-- PASS THE SEARCH QUERY DOWN
            showFilters={showFilters}
            filters={filters.filters}
            onSearchChange={search.setSearchQuery}
            onFilterToggle={() => setShowFilters(!showFilters)}
            onDesignationChange={(value) =>
              filters.setFilters((prev) => ({
                ...prev,
                employee_designation_id: value,
              }))
            }
            onStatusChange={(value) =>
              filters.setFilters((prev) => ({ ...prev, status: value }))
            }
            onMaintenanceAreaChange={(value) =>
              filters.setFilters((prev) => ({
                ...prev,
                maintenance_terminal_id: value,
              }))
            }
            designations={designations}
            maintenanceAreas={maintenanceAreas}
          />
        }
      />

      <EmployeeForm
        isOpen={editModal.isOpen}
        onClose={editModal.close}
        employee={editModal.record as EmployeeWithRelations | null}
        onSubmit={crudActions.handleSave}
        onCancel={editModal.close}
        isLoading={isLoading}
        designations={designations}
        maintenanceAreas={maintenanceAreas}
      />
      <EmployeeDetailsModal
        employee={employeesData.find((e) => e.id === viewingEmployeeId)}
        onClose={() => setViewingEmployeeId(null)}
        isOpen={viewingEmployeeId !== null}
      />

      <ConfirmModal
        isOpen={deleteModal.isOpen}
        onConfirm={deleteModal.onConfirm}
        onCancel={deleteModal.onCancel}
        title="Confirm Deletion"
        message={deleteModal.message}
        loading={deleteModal.loading}
        type="danger"
      />
    </div>
  );
};

export default EmployeesPage;

```

<!-- path: app/dashboard/designations/page.tsx -->
```typescript
'use client';

import { EntityManagementComponent } from '@/components/common/entity-management/EntityManagementComponent';
import {
  PageHeader,
  useStandardHeaderActions,
} from '@/components/common/page-header';
import { ErrorDisplay } from '@/components/common/ui';
import { ConfirmModal } from '@/components/common/ui/Modal';
import { DesignationFormModal } from '@/components/designations/DesignationFormModal';
import { designationConfig } from '@/config/designations';
import {
  Filters,
  useTableInsert,
  useTableUpdate,
  useTableWithRelations,
  useToggleStatus,
} from '@/hooks/database';
import { useDelete } from '@/hooks/useDelete';
import {
  Employee_designationsInsertSchema,
  Employee_designationsUpdateSchema,
} from '@/schemas/zod-schemas';
import { createClient } from '@/utils/supabase/client';
import { useMemo, useState } from 'react';
import { ImUserTie } from 'react-icons/im';
import { toast } from 'sonner';

export interface DesignationWithRelations
  extends Omit<Employee_designationsInsertSchema, 'id'> {
  id: string;
  parent_designation: DesignationWithRelations | null;
  child_designations: DesignationWithRelations[];
  status: boolean | null;
}

export default function DesignationManagerPage() {
  const supabase = createClient();

  // State management
  const [filters, setFilters] = useState<{ status?: string }>({});
  const [selectedDesignationId, setSelectedDesignationId] = useState<
    string | null
  >(null);
  const [isFormOpen, setFormOpen] = useState(false);
  const [editingDesignation, setEditingDesignation] =
    useState<DesignationWithRelations | null>(null);
  // Data queries
  const serverFilters = useMemo(() => {
    const f: Filters = {};
    if (filters.status) f.status = filters.status === 'true';
    return f;
  }, [filters]);

  const designationsQuery = useTableWithRelations<
    'employee_designations',
    DesignationWithRelations[]
  >(
    supabase,
    'employee_designations',
    ['parent_designation:parent_id(id, name)'],
    {
      filters: serverFilters,
      orderBy: [{ column: 'name', ascending: true }],
    }
  );

  const { refetch, error, data } = designationsQuery;

  const totalCount = data?.length || 0;

  // Data mutations
  const onMutationSuccess = () => {
    designationsQuery.refetch();
    setFormOpen(false);
    setEditingDesignation(null);
  };

  const createDesignationMutation = useTableInsert(
    supabase,
    'employee_designations',
    { onSuccess: onMutationSuccess }
  );
  const updateDesignationMutation = useTableUpdate(
    supabase,
    'employee_designations',
    { onSuccess: onMutationSuccess }
  );
  const toggleStatusMutation = useToggleStatus(
    supabase,
    'employee_designations',
    { onSuccess: onMutationSuccess }
  );

  const deleteManager = useDelete({
    tableName: 'employee_designations',
    onSuccess: () => {
      if (selectedDesignationId === deleteManager.itemToDelete?.id) {
        setSelectedDesignationId(null);
      }
      designationsQuery.refetch();
    },
  });

  // Derived state
  const allDesignations = useMemo(
    () => (designationsQuery.data as DesignationWithRelations[]) || [],
    [designationsQuery.data]
  );

  // Event handlers
  const handleOpenCreateForm = () => {
    setEditingDesignation(null);
    setFormOpen(true);
  };

  const handleOpenEditForm = (designation: DesignationWithRelations) => {
    setEditingDesignation(designation);
    setFormOpen(true);
  };

  const handleFormSubmit = (data: Employee_designationsInsertSchema) => {
    if (editingDesignation) {
      updateDesignationMutation.mutate({
        id: editingDesignation.id || '',
        data: data as Employee_designationsUpdateSchema,
      });
    } else {
      createDesignationMutation.mutate(data);
    }
  };

  // --- Define header content using the hook ---
  const headerActions = useStandardHeaderActions({
    data: designationsQuery.data?.map((d) => ({
      id: d.id,
      name: d.name,
      created_at: d.created_at ?? null,
      updated_at: d.updated_at ?? null,
      parent_id: d.parent_id ?? null,
      status: d.status ?? null,
    })),
    onRefresh: async () => {
      await refetch();
      toast.success('Refreshed successfully!');
    },
    // onAddNew: placeholder ToDo,
    isLoading: designationsQuery.isLoading,
    exportConfig: { tableName: 'employee_designations' },
  });

  const headerStats = [
    { value: totalCount, label: 'Total Designations' },
    {
      value: allDesignations.filter((r) => r.status).length,
      label: 'Active',
      color: 'success' as const,
    },
    {
      value: allDesignations.filter((r) => !r.status).length,
      label: 'Inactive',
      color: 'danger' as const,
    },
  ];

  if (error) {
    return (
      <ErrorDisplay
        error={error.message}
        actions={[
          {
            label: 'Retry',
            onClick: refetch,
            variant: 'primary',
          },
        ]}
      />
    );
  }

  const isLoading =
    designationsQuery.isLoading ||
    createDesignationMutation.isPending ||
    updateDesignationMutation.isPending ||
    toggleStatusMutation.isPending;

  return (
    <div className="min-h-screen bg-gray-50 dark:bg-gray-900 overflow-x-hidden">
      <PageHeader
        title="Designation Management"
        description="Manage designations and their related information."
        icon={<ImUserTie />}
        stats={headerStats}
        actions={headerActions}
        isLoading={isLoading}
        className="mb-4"
      />
      <EntityManagementComponent<DesignationWithRelations>
        config={designationConfig}
        entitiesQuery={designationsQuery}
        toggleStatusMutation={toggleStatusMutation}
        onEdit={handleOpenEditForm}
        onDelete={deleteManager.deleteSingle}
        onCreateNew={handleOpenCreateForm}
      />

      {/* Modals */}
      {isFormOpen && (
        <DesignationFormModal
          isOpen={isFormOpen}
          onClose={() => setFormOpen(false)}
          onSubmit={handleFormSubmit}
          designation={editingDesignation}
          allDesignations={allDesignations.map((d) => ({
            id: d.id ?? '',
            name: d.name,
            created_at: d.created_at ?? null,
            updated_at: d.updated_at ?? null,
            parent_id: d.parent_id ?? null,
            status: d.status ?? null,
          }))}
          isLoading={
            createDesignationMutation.isPending ||
            updateDesignationMutation.isPending
          }
        />
      )}
      <ConfirmModal
        isOpen={deleteManager.isConfirmModalOpen}
        onConfirm={deleteManager.handleConfirm}
        onCancel={deleteManager.handleCancel}
        title="Confirm Deletion"
        message={deleteManager.confirmationMessage}
        confirmText="Delete"
        cancelText="Cancel"
        type="danger"
        showIcon
        closeOnBackdrop
        closeOnEscape
        loading={deleteManager.isPending}
        size="md"
      />
    </div>
  );
}

```

<!-- path: app/dashboard/layout.tsx -->
```typescript
"use client";

import useIsMobile from "@/hooks/useIsMobile";
import { UserRole } from "@/types/user-roles";
import { useState } from "react";
import { Protected } from "@/components/auth/Protected";
import DashboardContent from "@/components/dashboard/DashboardContent";
import { QueryProvider } from "@/providers/QueryProvider";
import { RouteBasedUploadConfigProvider } from "@/hooks/UseRouteBasedUploadConfigOptions";

interface DashboardLayoutProps {
  children: React.ReactNode;
  showFileUpload?: boolean;
  showColumnManagement?: boolean;
  allowedRoles?: UserRole[];
}

export default function DashboardLayout({
  children,
  showFileUpload = true,
  showColumnManagement = true,
  allowedRoles = [
    UserRole.VIEWER,
    UserRole.ADMIN,
    UserRole.CPANADMIN,
    UserRole.MAANADMIN,
    UserRole.SDHADMIN,
    UserRole.VMUXADMIN,
    UserRole.MNGADMIN,
  ],
}: DashboardLayoutProps) {
  const [isCollapsed, setIsCollapsed] = useState(true);
  const isMobile = useIsMobile();

  // Determine table name based on current route

  return (
    <QueryProvider>
      <Protected allowedRoles={allowedRoles}>
        <RouteBasedUploadConfigProvider
          options={{
            autoSetConfig: true,
            customConfig: {
              // Global defaults that apply to all pages
              isUploadEnabled: true,
            },
          }}
        >
          <div className="min-h-screen bg-gray-50 dark:bg-gray-900 overflow-x-hidden">
            {/* File Upload Provider - conditionally render */}
            {showFileUpload ? (
              <DashboardContent
                isCollapsed={isCollapsed}
                setIsCollapsed={setIsCollapsed}
                isMobile={isMobile}
                showColumnManagement={showColumnManagement}
              >
                {children}
              </DashboardContent>
            ) : (
              <DashboardContent
                isCollapsed={isCollapsed}
                setIsCollapsed={setIsCollapsed}
                isMobile={isMobile}
                showColumnManagement={showColumnManagement}
              >
                {children}
              </DashboardContent>
            )}
          </div>
        </RouteBasedUploadConfigProvider>
      </Protected>
    </QueryProvider>
  );
}

```

<!-- path: app/dashboard/ofc/[id]/page.tsx -->
```typescript
// path: app/dashboard/ofc/[id]/page.tsx
'use client';

import { useMemo, useState } from 'react';
import Link from 'next/link';
import { useParams, useRouter } from 'next/navigation';
import { createClient } from '@/utils/supabase/client';
import { PageSpinner } from '@/components/common/ui/LoadingSpinner';
import { DataTable } from '@/components/table';
import { Row, usePagedOfcConnectionsComplete } from '@/hooks/database';
import { Button, ConfirmModal } from '@/components/common/ui';
import { OfcDetailsTableColumns } from '@/config/table-columns/OfcDetailsTableColumns';
import useOrderedColumns from '@/hooks/useOrderedColumns';
import { TABLE_COLUMN_KEYS } from '@/config/table-column-keys';
import { DataQueryHookParams, DataQueryHookReturn, useCrudManager } from '@/hooks/useCrudManager';
import { OfcConnectionRowsWithCount } from '@/types/view-row-types';
import { createStandardActions } from '@/components/table/action-helpers';
import { useIsSuperAdmin } from '@/hooks/useAdminUsers';
import { OfcConnectionsFormModal, OfcConnectionsRow } from '@/components/ofc-details/OfcConnectionsFormModal';
import { FiberTraceModal } from '@/components/ofc-details/FiberTraceModal';
import { GitCommit } from 'lucide-react';
import { useOfcRoutesForSelection, useRouteDetails } from '@/hooks/database/route-manager-hooks';
import CableNotFound from '@/components/ofc-details/CableNotFound';
import OfcDetailsHeader from '@/components/ofc-details/OfcDetailsHeader';
import { useCreateOfcConnection } from '@/hooks/useCreateOfcConnection';
import { useEffect } from 'react';


export const dynamic = 'force-dynamic';

const useOfcConnectionsData = (params: DataQueryHookParams): DataQueryHookReturn<OfcConnectionRowsWithCount> => {
  const { currentPage, pageLimit, searchQuery } = params;
  const supabase = createClient();
  const { id } = useParams();
  const cableId = id as string;

  const { data, isLoading, error, refetch } = usePagedOfcConnectionsComplete(supabase, {
      filters: { ofc_id: cableId, ...(searchQuery ? { or: `system_name.ilike.%${searchQuery}%,connection_type.ilike.%${searchQuery}%` } : {}) },
      limit: pageLimit,
      offset: (currentPage - 1) * pageLimit,
    }
  );

  const totalCount = data?.[0]?.total_count || 0;
  const activeCount = data?.[0]?.active_count || 0;
  const inactiveCount = data?.[0]?.inactive_count || 0;

  return { data: data || [], totalCount, activeCount, inactiveCount, isLoading, error, refetch };
};

export default function OfcCableDetailsPage() {
  const {
    data: cableConnectionsData, totalCount, activeCount, inactiveCount,
    isLoading, refetch, pagination, editModal, deleteModal, actions: crudActions,
  } = useCrudManager<'ofc_connections', OfcConnectionRowsWithCount>({
    tableName: 'ofc_connections',
    dataQueryHook: useOfcConnectionsData,
  });

  const { id: cableId } = useParams();
  const router = useRouter();
  const supabase = createClient();

  const { data: routeDetails, isLoading: isLoadingRouteDetails } = useRouteDetails(cableId as string);
  const { data: allCablesData } = useOfcRoutesForSelection();
  const [tracingFiber, setTracingFiber] = useState<{ cableId: string; fiberNo: number } | null>(null);

  const { ensureConnectionsExist } = useCreateOfcConnection({
    supabase,
    cableId: cableId as string,
    rawConnections: cableConnectionsData,
    refetchOfcConnections: refetch,
    isLoadingOfcConnections: isLoading,
  });

  useEffect(() => {
    if (!isLoading && routeDetails?.route) {
        ensureConnectionsExist();
    }
  }, [isLoading, routeDetails, ensureConnectionsExist]);

  const columns = OfcDetailsTableColumns(cableConnectionsData);
  const orderedColumns = useOrderedColumns(columns, TABLE_COLUMN_KEYS.v_ofc_connections_complete);

  const { data: isSuperAdmin } = useIsSuperAdmin();

  const tableActions = useMemo(
    () => [
        {
            key: 'trace',
            label: 'Trace Fiber Path',
            icon: <GitCommit className="h-4 w-4" />,
            onClick: (record: OfcConnectionRowsWithCount) => {
                if (record.fiber_no_sn) {
                  setTracingFiber({ cableId: cableId as string, fiberNo: record.fiber_no_sn });
                }
            },
            variant: 'secondary' as const
        },
      ...createStandardActions({
        onEdit: editModal.openEdit,
        onDelete: crudActions.handleDelete,
        onToggleStatus: crudActions.handleToggleStatus,
        canDelete: () => isSuperAdmin === true,
      }),
    ],
    [editModal.openEdit, crudActions.handleDelete, crudActions.handleToggleStatus, isSuperAdmin, cableId]
  );

  if (isLoading || isLoadingRouteDetails) {
    return <PageSpinner />;
  }

  if (!routeDetails?.route) {
    return <CableNotFound id={cableId as string} handleBackToOfcList={() => router.push('/dashboard/ofc')} isBackClicked={false} />;
  }

  return (
    <div className="mx-auto space-y-6 p-4 md:p-6">
      <div className="flex items-center justify-between gap-4">
        <div>
          <h1 className="text-2xl md:text-3xl font-bold text-gray-800 dark:text-white">OFC Cable Details</h1>
          <p className="text-sm text-gray-500 dark:text-gray-400">{`Route: ${routeDetails.route.route_name}`}</p>
        </div>
        <div>
          <Link href="/dashboard/ofc" className="px-3 py-2 text-sm border rounded-lg hover:bg-gray-50 dark:border-gray-600 dark:hover:bg-gray-700">Back to List</Link>
        </div>
      </div>
      <OfcDetailsHeader cable={routeDetails.route as unknown as Row<'v_ofc_cables_complete'>} />

      <div className="rounded-lg border border-gray-200 dark:border-gray-700 p-4">
        <DataTable<'v_ofc_connections_complete'>
          tableName="v_ofc_connections_complete"
          data={cableConnectionsData as unknown as Row<'v_ofc_connections_complete'>[]}
          columns={orderedColumns}
          loading={isLoading}
          actions={tableActions}
          selectable={true}
          searchable={true}
          pagination={{
            current: pagination.currentPage, pageSize: pagination.pageLimit, total: totalCount,
            showSizeChanger: true, onChange: (page, limit) => { pagination.setCurrentPage(page); pagination.setPageLimit(limit); },
          }}
        />
      </div>
      <OfcConnectionsFormModal isOpen={editModal.isOpen} onClose={editModal.close} editingOfcConnections={editModal.record as OfcConnectionsRow | null} />
      <ConfirmModal
        isOpen={deleteModal.isOpen}
        onConfirm={deleteModal.onConfirm}
        onCancel={deleteModal.onCancel}
        title="Confirm Deletion"
        message={deleteModal.message}
        type="danger"
        loading={deleteModal.loading}
      />
       <FiberTraceModal
        isOpen={!!tracingFiber}
        onClose={() => setTracingFiber(null)}
        cableId={tracingFiber?.cableId || null}
        fiberNo={tracingFiber?.fiberNo || null}
        allCables={allCablesData}
      />
    </div>
  );
}
```

<!-- path: app/dashboard/ofc/page.tsx -->
```typescript
'use client';

import {
  Filters,
  convertRichFiltersToSimpleJson,
  usePagedOfcCablesComplete,
  useTableInsert,
  useTableUpdate,
} from '@/hooks/database';
import { useIsSuperAdmin } from '@/hooks/useAdminUsers';
import { createClient } from '@/utils/supabase/client';
import { useRouter } from 'next/navigation';
import { useCallback, useMemo, useState } from 'react';

import { BulkActions } from '@/components/common/BulkActions';
import { ConfirmModal, ErrorDisplay } from '@/components/common/ui';
import OfcForm from '@/components/ofc/OfcForm/OfcForm';
import { DataTable } from '@/components/table/DataTable';
import { Json, TablesInsert } from '@/types/supabase-types';
// import { OfcCablesWithRelations } from '@/components/ofc/ofc-types';
import { SelectFilter } from '@/components/common/filters/FilterInputs';
import { SearchAndFilters } from '@/components/common/filters/SearchAndFilters';
import {
  PageHeader,
  useStandardHeaderActions,
} from '@/components/common/page-header';
import { createStandardActions } from '@/components/table/action-helpers';
import { TABLE_COLUMN_KEYS } from '@/config/table-column-keys';
import { OfcTableColumns } from '@/config/table-columns/OfcTableColumns';
import {
  DataQueryHookParams,
  DataQueryHookReturn,
  useCrudManager,
} from '@/hooks/useCrudManager';
import useOrderedColumns from '@/hooks/useOrderedColumns';
import { V_ofc_cables_completeRowSchema } from '@/schemas/zod-schemas';
import { AiFillMerge } from 'react-icons/ai';
import { toast } from 'sonner';

export type OfcCablesWithRelations = V_ofc_cables_completeRowSchema & {
  ofc_type: {
    id: string;
    name: string;
  } | null;
  maintenance_area: {
    id: string;
    name: string;
  } | null;
};

// 1. ADAPTER HOOK: Makes `useOfcData` compatible with `useCrudManager`
const useOfcData = (
  params: DataQueryHookParams
): DataQueryHookReturn<V_ofc_cables_completeRowSchema> => {
  const { currentPage, pageLimit, filters, searchQuery } = params;
  const supabase = createClient();

  // Build the server filters object that the RPC function expects.
  const serverFilters = useMemo(() => {
    const richFilters: Filters = { ...filters };
    if (searchQuery) {
      richFilters.or = `(route_name ILIKE '%${searchQuery}%' OR asset_no ILIKE '%${searchQuery}%' OR transnet_id ILIKE '%${searchQuery}%')`;
    }
    return convertRichFiltersToSimpleJson(richFilters);
  }, [filters, searchQuery]);

  const { data, isLoading, error, refetch } = usePagedOfcCablesComplete(
    supabase,
    {
      filters: serverFilters as Json,
      limit: pageLimit,
      offset: (currentPage - 1) * pageLimit,
    }
  );

  // Calculate counts from the full dataset
  const totalCount = data?.[0]?.total_count || 0;
  const activeCount = data?.[0]?.active_count || 0;
  const inactiveCount = data?.[0]?.inactive_count || 0;

  return {
    data: data || [],
    totalCount,
    activeCount,
    inactiveCount,
    isLoading,
    error,
    refetch,
  };
};

const OfcPage = () => {
  // 2. USE THE CRUD MANAGER with the adapter hook and both generic types
  const {
    data: ofcData,
    totalCount,
    activeCount,
    inactiveCount,
    isLoading,
    isMutating,
    error,
    refetch,
    pagination,
    search,
    filters: crudFilters,
    editModal,
    // viewModal,
    bulkActions,
    deleteModal,
    actions: crudActions,
  } = useCrudManager<'ofc_cables', V_ofc_cables_completeRowSchema>({
    tableName: 'ofc_cables',
    dataQueryHook: useOfcData,
    searchColumn: 'route_name', // This can be considered the "primary" search field for display purposes
  });

  // 3. Extract ring types from the rings data
  const ofcTypes = useMemo(() => {
    const uniqueOfcTypes = new Map();
    ofcData.forEach((ofc) => {
      if (ofc.ofc_type_code) {
        uniqueOfcTypes.set(ofc.ofc_type_id, {
          id: ofc.ofc_type_id,
          name: ofc.ofc_type_code,
        });
      }
    });
    return Array.from(uniqueOfcTypes.values());
  }, [ofcData]);

  const maintenanceAreas = useMemo(() => {
    const uniqueMaintenanceAreas = new Map();
    ofcData.forEach((ofc) => {
      if (ofc.maintenance_area_code) {
        uniqueMaintenanceAreas.set(ofc.maintenance_terminal_id, {
          id: ofc.maintenance_terminal_id,
          name: ofc.maintenance_area_code,
        });
      }
    });
    return Array.from(uniqueMaintenanceAreas.values());
  }, [ofcData]);

  const ofcOwners = useMemo(() => {
    const uniqueOwners = new Map();
    ofcData.forEach((ofc) => {
      if (ofc.ofc_owner_code) {
        uniqueOwners.set(ofc.ofc_owner_id, {
          id: ofc.ofc_owner_id,
          ofc_owner_code: ofc.ofc_owner_code,
        });
      }
    });
    return Array.from(uniqueOwners.values());
  }, [ofcData]);

  const supabase = createClient();
  const router = useRouter();
  const [showFilters, setShowFilters] = useState(false);

  const activeFilterCount = Object.values(crudFilters.filters).filter(
    Boolean
  ).length;
  const hasActiveFilters = activeFilterCount > 0 || !!search.searchQuery;

  const handleClearFilters = () => {
    crudFilters.setFilters({});
    search.setSearchQuery('');
  };

  const { data: isSuperAdmin } = useIsSuperAdmin();

  // Memoize the record to prevent unnecessary re-renders
  const memoizedOfcCable = useMemo(
    () => editModal.record as OfcCablesWithRelations,
    [editModal.record]
  );

  // --- MUTATIONS ---
  const { mutate: insertOfcCable, isPending: isInserting } = useTableInsert(
    supabase,
    'ofc_cables',
    {
      onSuccess: () => {
        refetch();
        closeModal();
        toast.success('OFC Cable created.');
      },
    }
  );
  const { mutate: updateOfcCable, isPending: isUpdating } = useTableUpdate(
    supabase,
    'ofc_cables',
    {
      onSuccess: () => {
        refetch();
        closeModal();
        toast.success('OFC Cable updated.');
      },
    }
  );

  // --- HANDLERS ---
  const closeModal = useCallback(() => {
    editModal.close();
  }, [editModal]);
  const handleSave = (data: TablesInsert<'ofc_cables'>) => {
    if (editModal.record) {
      updateOfcCable({ id: editModal.record.id!, data });
    } else {
      insertOfcCable(data);
    }
  };

  // --- MEMOIZED VALUES ---
  const columns = OfcTableColumns(ofcData);

  const orderedColumns = useOrderedColumns(
    columns,
    TABLE_COLUMN_KEYS.ofc_cables
  );

  const tableActions = useMemo(
    () =>
      createStandardActions({
        onEdit: editModal.openEdit,
        onView: (record) => router.push(`/dashboard/ofc/${record.id}`),
        onDelete: crudActions.handleDelete,
        onToggleStatus: crudActions.handleToggleStatus,
        canDelete: () => isSuperAdmin === true,
      }),
    [crudActions, editModal.openEdit, router, isSuperAdmin]
  );

  const headerStats = [
    { value: totalCount, label: 'Total OFC Cables' },
    {
      value: activeCount,
      label: 'Active',
      color: 'success' as const,
    },
    {
      value: inactiveCount,
      label: 'Inactive',
      color: 'danger' as const,
    },
  ];

  const loading = isLoading || isInserting || isUpdating;

  const headerActions = useStandardHeaderActions({
    onRefresh: async () => {
      await refetch();
      toast.success('Refreshed successfully!');
    },
    onAddNew: editModal.openAdd,
    isLoading: loading,
    exportConfig: {
      tableName: 'ofc_cables',
      filterOptions: [
        {
          label: 'BSNL',
          filters: {
            ofc_owner_id: {
              operator: 'eq',
              value: 'ad3477d5-de78-4b9f-9302-a4b5db326e9f',
            },
          },
        },
        {
          label: 'BBNL',
          filters: {
            ofc_owner_id: {
              operator: 'eq',
              value: 'e40c2549-11ec-485d-a67a-8261fcaec68a',
            },
          },
        },
      ],
    },
  });

  if (error) {
    return (
      <ErrorDisplay
        error={error.message}
        actions={[
          {
            label: 'Retry',
            onClick: refetch,
            variant: 'primary',
          },
        ]}
      />
    );
  }

  return (
    <div className="mx-auto space-y-6 p-4 md:p-6">
      <PageHeader
        title="OFC Cable Management"
        description="Manage OFC cables and their related information."
        icon={<AiFillMerge />}
        stats={headerStats}
        actions={headerActions}
        isLoading={loading}
      />
      <BulkActions
        selectedCount={bulkActions.selectedCount}
        isOperationLoading={isMutating}
        onBulkDelete={() => bulkActions.handleBulkDelete()}
        onBulkUpdateStatus={bulkActions.handleBulkUpdateStatus}
        onClearSelection={bulkActions.handleClearSelection}
        entityName="ofc cable"
        showStatusUpdate={true}
        canDelete={() => isSuperAdmin === true && bulkActions.selectedCount > 0}
      />

      <DataTable
        tableName="v_ofc_cables_complete"
        data={ofcData}
        columns={orderedColumns}
        loading={loading}
        actions={tableActions}
        selectable
        onRowSelect={(selectedRows: V_ofc_cables_completeRowSchema[]): void => {
          // Update selection with new row IDs
          bulkActions.handleRowSelect(selectedRows as never);
        }}
        searchable={false}
        filterable={false}
        pagination={{
          current: pagination.currentPage,
          pageSize: pagination.pageLimit,
          total: totalCount,
          showSizeChanger: true,
          onChange: (page, limit) => {
            pagination.setCurrentPage(page);
            pagination.setPageLimit(limit);
          },
        }}
        customToolbar={
          <SearchAndFilters
            searchTerm={search.searchQuery}
            onSearchChange={search.setSearchQuery}
            showFilters={showFilters}
            onToggleFilters={() => setShowFilters((p) => !p)}
            onClearFilters={handleClearFilters}
            hasActiveFilters={hasActiveFilters}
            activeFilterCount={activeFilterCount}
            searchPlaceholder="Search by Asset No or Route Name or Transnet ID..."
          >
            {/* THIS IS THE CLEANER, TYPE-SAFE WAY */}
            <SelectFilter
              label="OFC Type"
              filterKey="ofc_type_id"
              filters={crudFilters.filters}
              setFilters={crudFilters.setFilters}
              options={ofcTypes.map((t) => ({ value: t.id, label: t.name }))}
            />
            <SelectFilter
              label="Status"
              filterKey="status"
              filters={crudFilters.filters}
              setFilters={crudFilters.setFilters}
              options={[
                { value: 'true', label: 'Active' },
                { value: 'false', label: 'Inactive' },
              ]}
            />
            <SelectFilter
              label="ofc_owner"
              filterKey="ofc_owner_id"
              filters={crudFilters.filters}
              setFilters={crudFilters.setFilters}
              options={ofcOwners.map((t) => ({
                value: t.id,
                label: t.ofc_owner_code,
              }))}
            />
            <SelectFilter
              label="Maintenance Terminal"
              filterKey="maintenance_terminal_id"
              filters={crudFilters.filters}
              setFilters={crudFilters.setFilters}
              options={maintenanceAreas.map((t) => ({
                value: t.id,
                label: t.name,
              }))}
            />
          </SearchAndFilters>
        }
      />

      <OfcForm
        isOpen={editModal.isOpen}
        onClose={editModal.close}
        ofcCable={memoizedOfcCable}
        onSubmit={handleSave}
        pageLoading={isMutating}
      />

      <ConfirmModal
        isOpen={deleteModal.isOpen}
        onConfirm={deleteModal.onConfirm}
        onCancel={deleteModal.onCancel}
        title="Confirm Deletion"
        message={deleteModal.message}
        type="danger"
        loading={deleteModal.loading}
        confirmText="Delete"
        cancelText="Cancel"
        showIcon={true}
      />
    </div>
  );
};

export default OfcPage;

```

<!-- path: app/dashboard/bsnl/page.tsx -->
```typescript
"use client"
"use client"

import React, { useState, useRef, useEffect, useMemo, useCallback } from 'react';
import { MapContainer, TileLayer, Marker, Popup, Polyline, useMap } from 'react-leaflet';
import { 
  Cable, 
  Network, 
  Settings, 
  MapPin, 
  Activity, 
  AlertTriangle, 
  CheckCircle, 
  Plus,
  Edit,
  Trash2,
  Search,
  Filter,
  Download,
  Upload,
  GitBranch,
  Layers,
  Route,
  Zap,
  ChevronDown,
  ChevronRight,
  Eye,
  EyeOff,
  MoreHorizontal,
  RefreshCw,
  X
} from 'lucide-react';
import 'leaflet/dist/leaflet.css';
import NewAllocationModal, { mockData } from '@/components/bsnl/NewAllocationModal';
import AdvancedAllocationModal from '@/components/bsnl/NewAllocationModal';

// Enhanced Types (keeping all existing types)
interface FiberNode {
  id: string;
  name: string;
  type: 'OFC' | 'JC' | 'END_POINT' | 'JOINT' | 'CPAN';
  position: [number, number];
  capacity: string;
  status: 'active' | 'inactive' | 'maintenance';
  connections: string[];
  fiberTerminations: FiberTermination[];
  region?: string;
  district?: string;
}

interface FiberTermination {
  fiberNumber: number;
  ofcId: string;
  systemId?: string;
  status: 'available' | 'occupied' | 'reserved' | 'faulty';
  connectedTo?: {
    nodeId: string;
    fiberNumber: number;
    ofcId: string;
  };
}

interface OFCCable {
  id: string;
  name: string;
  type: 'main' | 'branch' | 'cascade';
  startNode: string;
  endNode: string;
  fiberCount: number;
  length: number;
  status: 'operational' | 'damaged' | 'under_maintenance';
  path: [number, number][];
  fiberAllocations: FiberAllocation[];
  region?: string;
  district?: string;
  priority?: 'high' | 'medium' | 'low';
}

interface FiberAllocation {
  fiberNumber: number;
  systemId: string;
  allocatedAt: string;
  routePath: FiberRoutePath[];
  status: 'active' | 'standby' | 'faulty';
}

interface FiberRoutePath {
  nodeId: string;
  ofcId: string;
  fiberNumber: number;
  action: 'terminate' | 'pass_through' | 'tap' | 'cascade';
  tapTo?: {
    ofcId: string;
    fiberNumber: number;
  };
}

interface NetworkSystem {
  id: string;
  name: string;
  type: 'transmission' | 'access' | 'backbone';
  startNode: string;
  endNode: string;
  fiberRoute: FiberRoutePath[];
  bandwidth: string;
  redundancy: 'protected' | 'unprotected';
  status: 'operational' | 'degraded' | 'down';
  priority?: 'critical' | 'high' | 'medium' | 'low';
  region?: string;
  district?: string;
}

// Enhanced search and filter interfaces
interface SearchFilters {
  query: string;
  status: string[];
  type: string[];
  region: string[];
  district: string[];
  priority: string[];
}

interface PaginationState {
  page: number;
  pageSize: number;
  total: number;
}

// Virtual scrolling hook for large lists
function useVirtualScroll<T>(
  items: T[],
  containerHeight: number,
  itemHeight: number
) {
  const [scrollTop, setScrollTop] = useState(0);
  
  const visibleItems = useMemo(() => {
    const containerSize = Math.ceil(containerHeight / itemHeight);
    const startIndex = Math.floor(scrollTop / itemHeight);
    const endIndex = Math.min(startIndex + containerSize + 5, items.length);
    
    return {
      startIndex,
      endIndex,
      items: items.slice(startIndex, endIndex),
      totalHeight: items.length * itemHeight,
      offsetY: startIndex * itemHeight
    };
  }, [items, scrollTop, containerHeight, itemHeight]);
  
  return { visibleItems, setScrollTop };
}

// Search and filter utilities
function useSearchAndFilter<T>(
  items: T[],
  searchFn: (item: T, filters: SearchFilters) => boolean,
  filters: SearchFilters
) {
  return useMemo(() => {
    return items.filter(item => searchFn(item, filters));
  }, [items, searchFn, filters]);
}

// Sample data generator for testing scalability
function generateLargeDataset() {
  const regions = ['North', 'South', 'East', 'West', 'Central'];
  const districts = ['District-A', 'District-B', 'District-C', 'District-D', 'District-E'];
  
  // Generate nodes
  const nodes: FiberNode[] = [];
  for (let i = 0; i < 100; i++) {
    nodes.push({
      id: `node_${i}`,
      name: `NODE ${String.fromCharCode(65 + (i % 26))}${Math.floor(i / 26)}`,
      type: ['OFC', 'JC', 'END_POINT'][i % 3] as any,
      position: [22.5 + (Math.random() - 0.5) * 0.1, 88.35 + (Math.random() - 0.5) * 0.1],
      capacity: ['12F', '24F', '48F', '96F'][i % 4],
      status: ['active', 'inactive', 'maintenance'][i % 3] as any,
      connections: [],
      fiberTerminations: [],
      region: regions[i % regions.length],
      district: districts[i % districts.length]
    });
  }

  // Generate OFC cables
  const ofcCables: OFCCable[] = [];
  for (let i = 0; i < 500; i++) {
    const startNode = nodes[Math.floor(Math.random() * nodes.length)];
    const endNode = nodes[Math.floor(Math.random() * nodes.length)];
    
    ofcCables.push({
      id: `ofc_${i}`,
      name: `OFC ${String.fromCharCode(65 + (i % 26))}${Math.floor(i / 26)}`,
      type: ['main', 'branch', 'cascade'][i % 3] as any,
      startNode: startNode.id,
      endNode: endNode.id,
      fiberCount: [12, 24, 48, 96][i % 4],
      length: Math.random() * 10 + 0.5,
      status: ['operational', 'damaged', 'under_maintenance'][i % 3] as any,
      path: [startNode.position, endNode.position],
      fiberAllocations: [],
      region: regions[i % regions.length],
      district: districts[i % districts.length],
      priority: ['high', 'medium', 'low'][i % 3] as any
    });
  }

  // Generate systems
  const systems: NetworkSystem[] = [];
  for (let i = 0; i < 1000; i++) {
    const startNode = nodes[Math.floor(Math.random() * nodes.length)];
    const endNode = nodes[Math.floor(Math.random() * nodes.length)];
    
    systems.push({
      id: `system_${i}`,
      name: `CPAN ${String.fromCharCode(65 + (i % 26))}${Math.floor(i / 26)}`,
      type: ['transmission', 'access', 'backbone'][i % 3] as any,
      startNode: startNode.id,
      endNode: endNode.id,
      fiberRoute: [],
      bandwidth: ['1Gbps', '10Gbps', '100Gbps'][i % 3],
      redundancy: ['protected', 'unprotected'][i % 2] as any,
      status: ['operational', 'degraded', 'down'][i % 3] as any,
      priority: ['critical', 'high', 'medium', 'low'][i % 4] as any,
      region: regions[i % regions.length],
      district: districts[i % districts.length]
    });
  }

  return { nodes, ofcCables, systems };
}

// Enhanced search bar component
function AdvancedSearchBar({ 
  filters, 
  onFiltersChange, 
  onClear,
  suggestions = []
}: {
  filters: SearchFilters;
  onFiltersChange: (filters: SearchFilters) => void;
  onClear: () => void;
  suggestions?: string[];
}) {
  const [showFilters, setShowFilters] = useState(false);

  return (
    <div className="bg-white rounded-lg border p-4 mb-6">
      <div className="flex items-center space-x-4">
        <div className="flex-1 relative">
          <Search className="absolute left-3 top-1/2 transform -translate-y-1/2 text-gray-400 h-4 w-4" />
          <input
            type="text"
            placeholder="Search networks, cables, systems..."
            value={filters.query}
            onChange={(e) => onFiltersChange({ ...filters, query: e.target.value })}
            className="w-full pl-10 pr-4 py-2 border border-gray-300 rounded-md focus:ring-2 focus:ring-blue-500 focus:border-blue-500"
          />
        </div>
        
        <button
          onClick={() => setShowFilters(!showFilters)}
          className="flex items-center px-4 py-2 border border-gray-300 rounded-md hover:bg-gray-50"
        >
          <Filter className="h-4 w-4 mr-2" />
          Filters
          {showFilters ? <ChevronDown className="h-4 w-4 ml-1" /> : <ChevronRight className="h-4 w-4 ml-1" />}
        </button>
        
        <button
          onClick={onClear}
          className="px-4 py-2 text-gray-600 hover:text-gray-800"
        >
          Clear
        </button>
      </div>

      {showFilters && (
        <div className="mt-4 pt-4 border-t grid grid-cols-1 md:grid-cols-5 gap-4">
          {/* Status Filter */}
          <div>
            <label className="block text-sm font-medium text-gray-700 mb-1">Status</label>
            <select
              multiple
              value={filters.status}
              onChange={(e) => onFiltersChange({
                ...filters,
                status: Array.from(e.target.selectedOptions, option => option.value)
              })}
              className="w-full border border-gray-300 rounded-md p-2 text-sm"
            >
              <option value="operational">Operational</option>
              <option value="active">Active</option>
              <option value="degraded">Degraded</option>
              <option value="inactive">Inactive</option>
              <option value="maintenance">Maintenance</option>
            </select>
          </div>

          {/* Type Filter */}
          <div>
            <label className="block text-sm font-medium text-gray-700 mb-1">Type</label>
            <select
              multiple
              value={filters.type}
              onChange={(e) => onFiltersChange({
                ...filters,
                type: Array.from(e.target.selectedOptions, option => option.value)
              })}
              className="w-full border border-gray-300 rounded-md p-2 text-sm"
            >
              <option value="main">Main</option>
              <option value="branch">Branch</option>
              <option value="cascade">Cascade</option>
              <option value="transmission">Transmission</option>
              <option value="access">Access</option>
              <option value="backbone">Backbone</option>
            </select>
          </div>

          {/* Region Filter */}
          <div>
            <label className="block text-sm font-medium text-gray-700 mb-1">Region</label>
            <select
              multiple
              value={filters.region}
              onChange={(e) => onFiltersChange({
                ...filters,
                region: Array.from(e.target.selectedOptions, option => option.value)
              })}
              className="w-full border border-gray-300 rounded-md p-2 text-sm"
            >
              <option value="North">North</option>
              <option value="South">South</option>
              <option value="East">East</option>
              <option value="West">West</option>
              <option value="Central">Central</option>
            </select>
          </div>

          {/* District Filter */}
          <div>
            <label className="block text-sm font-medium text-gray-700 mb-1">District</label>
            <select
              multiple
              value={filters.district}
              onChange={(e) => onFiltersChange({
                ...filters,
                district: Array.from(e.target.selectedOptions, option => option.value)
              })}
              className="w-full border border-gray-300 rounded-md p-2 text-sm"
            >
              <option value="District-A">District A</option>
              <option value="District-B">District B</option>
              <option value="District-C">District C</option>
              <option value="District-D">District D</option>
              <option value="District-E">District E</option>
            </select>
          </div>

          {/* Priority Filter */}
          <div>
            <label className="block text-sm font-medium text-gray-700 mb-1">Priority</label>
            <select
              multiple
              value={filters.priority}
              onChange={(e) => onFiltersChange({
                ...filters,
                priority: Array.from(e.target.selectedOptions, option => option.value)
              })}
              className="w-full border border-gray-300 rounded-md p-2 text-sm"
            >
              <option value="critical">Critical</option>
              <option value="high">High</option>
              <option value="medium">Medium</option>
              <option value="low">Low</option>
            </select>
          </div>
        </div>
      )}
    </div>
  );
}

// Virtualized list component
function VirtualizedList<T>({ 
  items, 
  renderItem, 
  itemHeight = 80,
  containerHeight = 400,
  onItemClick
}: {
  items: T[];
  renderItem: (item: T, index: number) => React.ReactNode;
  itemHeight?: number;
  containerHeight?: number;
  onItemClick?: (item: T) => void;
}) {
  const { visibleItems, setScrollTop } = useVirtualScroll(items, containerHeight, itemHeight);
  
  return (
    <div 
      className="overflow-auto border rounded-lg"
      style={{ height: containerHeight }}
      onScroll={(e) => setScrollTop(e.currentTarget.scrollTop)}
    >
      <div style={{ height: visibleItems.totalHeight, position: 'relative' }}>
        <div style={{ transform: `translateY(${visibleItems.offsetY}px)` }}>
          {visibleItems.items.map((item, index) => (
            <div 
              key={visibleItems.startIndex + index}
              style={{ height: itemHeight }}
              className="flex items-center px-4 border-b hover:bg-gray-50 cursor-pointer"
              onClick={() => onItemClick?.(item)}
            >
              {renderItem(item, visibleItems.startIndex + index)}
            </div>
          ))}
        </div>
      </div>
    </div>
  );
}

// Paginated data table component
function PaginatedTable<T>({
  data,
  columns,
  pageSize = 50,
  onItemClick
}: {
  data: T[];
  columns: { key: string; label: string; render: (item: T) => React.ReactNode }[];
  pageSize?: number;
  onItemClick?: (item: T) => void;
}) {
  const [currentPage, setCurrentPage] = useState(1);
  
  const totalPages = Math.ceil(data.length / pageSize);
  const startIndex = (currentPage - 1) * pageSize;
  const paginatedData = data.slice(startIndex, startIndex + pageSize);
  
  return (
    <div>
      <div className="overflow-x-auto">
        <table className="min-w-full divide-y divide-gray-200">
          <thead className="bg-gray-50">
            <tr>
              {columns.map((column) => (
                <th
                  key={column.key}
                  className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider"
                >
                  {column.label}
                </th>
              ))}
            </tr>
          </thead>
          <tbody className="bg-white divide-y divide-gray-200">
            {paginatedData.map((item, index) => (
              <tr 
                key={index}
                className="hover:bg-gray-50 cursor-pointer"
                onClick={() => onItemClick?.(item)}
              >
                {columns.map((column) => (
                  <td key={column.key} className="px-6 py-4 whitespace-nowrap">
                    {column.render(item)}
                  </td>
                ))}
              </tr>
            ))}
          </tbody>
        </table>
      </div>
      
      {totalPages > 1 && (
        <div className="flex items-center justify-between mt-4">
          <div className="text-sm text-gray-700">
            Showing {startIndex + 1} to {Math.min(startIndex + pageSize, data.length)} of {data.length} results
          </div>
          <div className="flex space-x-2">
            <button
              onClick={() => setCurrentPage(Math.max(1, currentPage - 1))}
              disabled={currentPage === 1}
              className="px-3 py-1 border rounded disabled:opacity-50"
            >
              Previous
            </button>
            <span className="px-3 py-1">
              Page {currentPage} of {totalPages}
            </span>
            <button
              onClick={() => setCurrentPage(Math.min(totalPages, currentPage + 1))}
              disabled={currentPage === totalPages}
              className="px-3 py-1 border rounded disabled:opacity-50"
            >
              Next
            </button>
          </div>
        </div>
      )}
    </div>
  );
}

// Optimized map component with layer management
function OptimizedNetworkMap({ 
  nodes, 
  cables, 
  selectedSystem,
  visibleLayers = { nodes: true, cables: true, systems: true }
}: {
  nodes: FiberNode[];
  cables: OFCCable[];
  selectedSystem: NetworkSystem | null;
  visibleLayers?: { nodes: boolean; cables: boolean; systems: boolean };
}) {
  // Calculate map bounds
  const bounds = useMemo(() => {
    if (nodes.length === 0) return null;
    
    const lats = nodes.map(n => n.position[0]);
    const lngs = nodes.map(n => n.position[1]);
    
    return [
      [Math.min(...lats), Math.min(...lngs)],
      [Math.max(...lats), Math.max(...lngs)]
    ] as [[number, number], [number, number]];
  }, [nodes]);

  // Filter visible items based on zoom level and performance
  const [zoom, setZoom] = useState(13);
  const [bounds2, setBounds2] = useState<any>(null);
  
  const visibleNodes = useMemo(() => {
    if (!bounds2 || !visibleLayers.nodes) return [];
    
    // Show fewer items at lower zoom levels for performance
    const maxItems = zoom > 14 ? 1000 : zoom > 12 ? 500 : 100;
    
    return nodes.slice(0, maxItems).filter(node => {
      const [lat, lng] = node.position;
      return lat >= bounds2.getSouth() && lat <= bounds2.getNorth() &&
             lng >= bounds2.getWest() && lng <= bounds2.getEast();
    });
  }, [nodes, bounds2, zoom, visibleLayers.nodes]);

  const visibleCables = useMemo(() => {
    if (!bounds2 || !visibleLayers.cables) return [];
    
    const maxItems = zoom > 14 ? 1000 : zoom > 12 ? 200 : 50;
    
    return cables.slice(0, maxItems).filter(cable => {
      return cable.path.some(([lat, lng]) => {
        return lat >= bounds2.getSouth() && lat <= bounds2.getNorth() &&
               lng >= bounds2.getWest() && lng <= bounds2.getEast();
      });
    });
  }, [cables, bounds2, zoom, visibleLayers.cables]);

  if (!bounds) return null;

  return (
    <MapContainer
      bounds={bounds}
      className="h-full w-full rounded-lg"
      whenReady={(map) => {
        const mapInstance = map.target;
        setBounds2(mapInstance.getBounds());
        setZoom(mapInstance.getZoom());
        
        mapInstance.on('zoomend moveend', () => {
          setBounds2(mapInstance.getBounds());
          setZoom(mapInstance.getZoom());
        });
      }}
    >
      <TileLayer
        url="https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png"
        attribution='&copy; OpenStreetMap contributors'
      />
      
      {/* Render cables */}
      {visibleCables.map((cable) => (
        <Polyline
          key={cable.id}
          positions={cable.path}
          color={selectedSystem ? '#8b5cf6' : cable.status === 'operational' ? '#10b981' : '#ef4444'}
          weight={selectedSystem ? 6 : 3}
          opacity={0.7}
        >
          <Popup>
            <div className="w-48">
              <h3 className="font-semibold">{cable.name}</h3>
              <p className="text-sm">Type: {cable.type}</p>
              <p className="text-sm">Fibers: {cable.fiberCount}</p>
              <p className="text-sm">Status: {cable.status}</p>
              <p className="text-sm">Region: {cable.region}</p>
            </div>
          </Popup>
        </Polyline>
      ))}
      
      {/* Render nodes */}
      {visibleNodes.map((node) => (
        <Marker key={node.id} position={node.position}>
          <Popup>
            <div className="w-48">
              <h3 className="font-semibold">{node.name}</h3>
              <p className="text-sm">Type: {node.type}</p>
              <p className="text-sm">Status: {node.status}</p>
              <p className="text-sm">Region: {node.region}</p>
            </div>
          </Popup>
        </Marker>
      ))}
    </MapContainer>
  );
}

// Main dashboard component with scalability improvements
export default function ScalableFiberNetworkDashboard() {
  const [data] = useState(() => generateLargeDataset());
  const [selectedSystem, setSelectedSystem] = useState<NetworkSystem | null>(null);
  const [selectedCable, setSelectedCable] = useState<OFCCable | null>(null);
  const [activeTab, setActiveTab] = useState<'overview' | 'systems' | 'allocations'>('overview');
  const [loading, setLoading] = useState(false);
  // 2. Add state to control the modal
  const [isAllocationModalOpen, setIsAllocationModalOpen] = useState(false);
  // 3. Create a handler function for saving the new allocation
  const handleSaveAllocation = (allocationData: any) => {
    console.log("New Allocation to be saved:", allocationData);
    // In a real application, you would:
    // 1. Update your main data state
    //    const cableToUpdate = data.ofcCables.find(c => ...);
    //    cableToUpdate.fiberAllocations.push(...);
    // 2. Make an API call to save the data to the backend
    // 3. Re-fetch or re-validate data if necessary
    alert(`Allocation for ${allocationData.systemId} created successfully! Check the console.`);
  };
  // Search and filter states
  const [filters, setFilters] = useState<SearchFilters>({
    query: '',
    status: [],
    type: [],
    region: [],
    district: [],
    priority: []
  });

  const [visibleLayers, setVisibleLayers] = useState({
    nodes: true,
    cables: true,
    systems: true
  });

  // Search functions
  const searchSystems = useCallback((system: NetworkSystem, filters: SearchFilters) => {
    if (filters.query && !system.name.toLowerCase().includes(filters.query.toLowerCase())) {
      return false;
    }
    if (filters.status.length > 0 && !filters.status.includes(system.status)) {
      return false;
    }
    if (filters.type.length > 0 && !filters.type.includes(system.type)) {
      return false;
    }
    if (filters.region.length > 0 && system.region && !filters.region.includes(system.region)) {
      return false;
    }
    if (filters.district.length > 0 && system.district && !filters.district.includes(system.district)) {
      return false;
    }
    if (filters.priority.length > 0 && system.priority && !filters.priority.includes(system.priority)) {
      return false;
    }
    return true;
  }, []);

  const searchCables = useCallback((cable: OFCCable, filters: SearchFilters) => {
    if (filters.query && !cable.name.toLowerCase().includes(filters.query.toLowerCase())) {
      return false;
    }
    if (filters.status.length > 0 && !filters.status.includes(cable.status)) {
      return false;
    }
    if (filters.type.length > 0 && !filters.type.includes(cable.type)) {
      return false;
    }
    if (filters.region.length > 0 && cable.region && !filters.region.includes(cable.region)) {
      return false;
    }
    if (filters.district.length > 0 && cable.district && !filters.district.includes(cable.district)) {
      return false;
    }
    if (filters.priority.length > 0 && cable.priority && !filters.priority.includes(cable.priority)) {
      return false;
    }
    return true;
  }, []);

  // Filtered data
  const filteredSystems = useSearchAndFilter(data.systems, searchSystems, filters);
  const filteredCables = useSearchAndFilter(data.ofcCables, searchCables, filters);

  // Clear filters
  const clearFilters = useCallback(() => {
    setFilters({
      query: '',
      status: [],
      type: [],
      region: [],
      district: [],
      priority: []
    });
  }, []);

  const systemColumns = [
    {
      key: 'name',
      label: 'System Name',
      render: (system: NetworkSystem) => (
        <div>
          <div className="font-medium">{system.name}</div>
          <div className="text-sm text-gray-500">{system.type}</div>
        </div>
      )
    },
    {
      key: 'status',
      label: 'Status',
      render: (system: NetworkSystem) => (
        <span className={`px-2 py-1 text-xs rounded-full ${
          system.status === 'operational' ? 'bg-green-100 text-green-800' :
          system.status === 'degraded' ? 'bg-yellow-100 text-yellow-800' :
          'bg-red-100 text-red-800'
        }`}>
          {system.status}
        </span>
      )
    },
    {
      key: 'bandwidth',
      label: 'Bandwidth',
      render: (system: NetworkSystem) => system.bandwidth
    },
    {
      key: 'region',
      label: 'Region/District',
      render: (system: NetworkSystem) => (
        <div className="text-sm">
          <div>{system.region}</div>
          <div className="text-gray-500">{system.district}</div>
        </div>
      )
    },
    {
      key: 'priority',
      label: 'Priority',
      render: (system: NetworkSystem) => (
        <span className={`px-2 py-1 text-xs rounded ${
          system.priority === 'critical' ? 'bg-red-100 text-red-700' :
          system.priority === 'high' ? 'bg-orange-100 text-orange-700' :
          system.priority === 'medium' ? 'bg-yellow-100 text-yellow-700' :
          'bg-gray-100 text-gray-700'
        }`}>
          {system.priority}
        </span>
      )
    }
  ];

  const cableColumns = [
    {
      key: 'name',
      label: 'Cable Name',
      render: (cable: OFCCable) => (
        <div>
          <div className="font-medium">{cable.name}</div>
          <div className="text-sm text-gray-500">{cable.type}</div>
        </div>
      )
    },
    {
      key: 'status',
      label: 'Status',
      render: (cable: OFCCable) => (
        <span className={`px-2 py-1 text-xs rounded-full ${
          cable.status === 'operational' ? 'bg-green-100 text-green-800' :
          cable.status === 'damaged' ? 'bg-red-100 text-red-800' :
          'bg-yellow-100 text-yellow-800'
        }`}>
          {cable.status}
        </span>
      )
    },
    {
      key: 'capacity',
      label: 'Capacity',
      render: (cable: OFCCable) => `${cable.fiberCount}F / ${cable.length.toFixed(1)}km`
    },
    {
      key: 'utilization',
      label: 'Utilization',
      render: (cable: OFCCable) => {
        const used = cable.fiberAllocations.length;
        const total = cable.fiberCount;
        const percentage = (used / total * 100).toFixed(1);
        return (
          <div className="flex items-center space-x-2">
            <span className="text-sm">{used}/{total}</span>
            <div className="w-16 bg-gray-200 rounded-full h-2">
              <div 
                className={`h-2 rounded-full ${
                  parseFloat(percentage) > 80 ? 'bg-red-500' :
                  parseFloat(percentage) > 60 ? 'bg-yellow-500' :
                  'bg-green-500'
                }`}
                style={{ width: `${percentage}%` }}
              />
            </div>
            <span className="text-xs text-gray-500">{percentage}%</span>
          </div>
        );
      }
    },
    {
      key: 'region',
      label: 'Region/District',
      render: (cable: OFCCable) => (
        <div className="text-sm">
          <div>{cable.region}</div>
          <div className="text-gray-500">{cable.district}</div>
        </div>
      )
    }
  ];

  return (
    <div className="min-h-screen bg-gray-50">
      {/* Header */}
      <header className="bg-white shadow-sm border-b">
        <div className="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8">
          <div className="flex justify-between items-center h-16">
            <div className="flex items-center">
              <Network className="h-8 w-8 text-blue-600 mr-3" />
              <div>
                <h1 className="text-2xl font-bold text-gray-900">
                  BSNL Scalable Fiber Network
                </h1>
                <p className="text-sm text-gray-500">
                  {data.systems.length.toLocaleString()} Systems | {data.ofcCables.length.toLocaleString()} Cables | {data.nodes.length.toLocaleString()} Nodes
                </p>
              </div>
            </div>
            <div className="flex items-center space-x-4">
              <div className="flex items-center space-x-2">
                <button
                  onClick={() => setVisibleLayers({...visibleLayers, nodes: !visibleLayers.nodes})}
                  className={`p-2 rounded ${visibleLayers.nodes ? 'bg-blue-100 text-blue-600' : 'text-gray-400'}`}
                  title="Toggle Nodes"
                >
                  <MapPin className="h-4 w-4" />
                </button>
                <button
                  onClick={() => setVisibleLayers({...visibleLayers, cables: !visibleLayers.cables})}
                  className={`p-2 rounded ${visibleLayers.cables ? 'bg-green-100 text-green-600' : 'text-gray-400'}`}
                  title="Toggle Cables"
                >
                  <Cable className="h-4 w-4" />
                </button>
                <button
                  onClick={() => setVisibleLayers({...visibleLayers, systems: !visibleLayers.systems})}
                  className={`p-2 rounded ${visibleLayers.systems ? 'bg-purple-100 text-purple-600' : 'text-gray-400'}`}
                  title="Toggle Systems"
                >
                  <Route className="h-4 w-4" />
                </button>
              </div>
              <button 
                className="p-2 text-gray-400 hover:text-gray-600"
                onClick={() => {
                  setLoading(true);
                  setTimeout(() => setLoading(false), 1000);
                }}
              >
                <RefreshCw className={`h-5 w-5 ${loading ? 'animate-spin' : ''}`} />
              </button>
              <button className="p-2 text-gray-400 hover:text-gray-600">
                <Upload className="h-5 w-5" />
              </button>
              <button className="p-2 text-gray-400 hover:text-gray-600">
                <Download className="h-5 w-5" />
              </button>
              <button className="p-2 text-gray-400 hover:text-gray-600">
                <Settings className="h-5 w-5" />
              </button>
            </div>
          </div>
        </div>
      </header>

      <div className="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-6">
        {/* Search Bar */}
        <AdvancedSearchBar
          filters={filters}
          onFiltersChange={setFilters}
          onClear={clearFilters}
        />

        {/* Navigation Tabs */}
        <div className="mb-6">
          <nav className="flex space-x-8">
            {['overview', 'systems', 'allocations'].map((tab) => (
              <button
                key={tab}
                onClick={() => setActiveTab(tab as any)}
                className={`py-2 px-1 border-b-2 font-medium text-sm capitalize relative ${
                  activeTab === tab
                    ? 'border-blue-500 text-blue-600'
                    : 'border-transparent text-gray-500 hover:text-gray-700 hover:border-gray-300'
                }`}
              >
                {tab}
                {tab === 'systems' && (
                  <span className="ml-2 px-2 py-0.5 text-xs bg-blue-100 text-blue-600 rounded-full">
                    {filteredSystems.length}
                  </span>
                )}
                {tab === 'allocations' && (
                  <span className="ml-2 px-2 py-0.5 text-xs bg-green-100 text-green-600 rounded-full">
                    {filteredCables.length}
                  </span>
                )}
              </button>
            ))}
          </nav>
        </div>

        {/* Overview Tab */}
        {activeTab === 'overview' && (
          <div className="space-y-6">
            {/* Enhanced Stats Cards */}
            <div className="grid grid-cols-1 md:grid-cols-6 gap-4">
              <div className="bg-white rounded-lg shadow p-4">
                <div className="flex items-center">
                  <Network className="h-6 w-6 text-blue-600" />
                  <div className="ml-3">
                    <p className="text-xl font-semibold text-gray-900">
                      {data.systems.filter(s => s.status === 'operational').length.toLocaleString()}
                    </p>
                    <p className="text-xs text-gray-500">Active Systems</p>
                  </div>
                </div>
              </div>
              
              <div className="bg-white rounded-lg shadow p-4">
                <div className="flex items-center">
                  <Cable className="h-6 w-6 text-green-600" />
                  <div className="ml-3">
                    <p className="text-xl font-semibold text-gray-900">
                      {data.ofcCables.filter(c => c.status === 'operational').length.toLocaleString()}
                    </p>
                    <p className="text-xs text-gray-500">OFC Cables</p>
                  </div>
                </div>
              </div>
              
              <div className="bg-white rounded-lg shadow p-4">
                <div className="flex items-center">
                  <Activity className="h-6 w-6 text-purple-600" />
                  <div className="ml-3">
                    <p className="text-xl font-semibold text-gray-900">
                      {data.nodes.filter(n => n.status === 'active').length.toLocaleString()}
                    </p>
                    <p className="text-xs text-gray-500">Active Nodes</p>
                  </div>
                </div>
              </div>
              
              <div className="bg-white rounded-lg shadow p-4">
                <div className="flex items-center">
                  <GitBranch className="h-6 w-6 text-yellow-600" />
                  <div className="ml-3">
                    <p className="text-xl font-semibold text-gray-900">
                      {data.ofcCables.reduce((sum, cable) => sum + cable.fiberAllocations.length, 0).toLocaleString()}
                    </p>
                    <p className="text-xs text-gray-500">Fiber Allocations</p>
                  </div>
                </div>
              </div>
              
              <div className="bg-white rounded-lg shadow p-4">
                <div className="flex items-center">
                  <AlertTriangle className="h-6 w-6 text-red-600" />
                  <div className="ml-3">
                    <p className="text-xl font-semibold text-gray-900">
                      {data.systems.filter(s => s.status === 'down').length + 
                       data.ofcCables.filter(c => c.status === 'damaged').length}
                    </p>
                    <p className="text-xs text-gray-500">Issues</p>
                  </div>
                </div>
              </div>
              
              <div className="bg-white rounded-lg shadow p-4">
                <div className="flex items-center">
                  <CheckCircle className="h-6 w-6 text-green-600" />
                  <div className="ml-3">
                    <p className="text-xl font-semibold text-gray-900">
                      {(((data.systems.filter(s => s.status === 'operational').length / data.systems.length) * 100)).toFixed(1)}%
                    </p>
                    <p className="text-xs text-gray-500">Uptime</p>
                  </div>
                </div>
              </div>
            </div>

            {/* Network Map */}
            <div className="bg-white rounded-lg shadow">
              <div className="p-6 border-b flex justify-between items-center">
                <div>
                  <h2 className="text-lg font-semibold text-gray-900">Network Topology</h2>
                  <p className="text-sm text-gray-500 mt-1">
                    Showing {Math.min(1000, data.nodes.length)} nodes and {Math.min(1000, data.ofcCables.length)} cables (optimized for performance)
                  </p>
                </div>
                <div className="flex items-center space-x-2">
                  <span className="text-sm text-gray-500">Layers:</span>
                  <button
                    onClick={() => setVisibleLayers({...visibleLayers, nodes: !visibleLayers.nodes})}
                    className={`px-2 py-1 text-xs rounded ${
                      visibleLayers.nodes ? 'bg-blue-100 text-blue-700' : 'bg-gray-100 text-gray-500'
                    }`}
                  >
                    Nodes {visibleLayers.nodes ? <Eye className="inline h-3 w-3" /> : <EyeOff className="inline h-3 w-3" />}
                  </button>
                  <button
                    onClick={() => setVisibleLayers({...visibleLayers, cables: !visibleLayers.cables})}
                    className={`px-2 py-1 text-xs rounded ${
                      visibleLayers.cables ? 'bg-green-100 text-green-700' : 'bg-gray-100 text-gray-500'
                    }`}
                  >
                    Cables {visibleLayers.cables ? <Eye className="inline h-3 w-3" /> : <EyeOff className="inline h-3 w-3" />}
                  </button>
                </div>
              </div>
              <div className="h-96">
                <OptimizedNetworkMap 
                  nodes={data.nodes}
                  cables={data.ofcCables}
                  selectedSystem={selectedSystem}
                  visibleLayers={visibleLayers}
                />
              </div>
            </div>

            {/* Regional Distribution */}
            <div className="grid grid-cols-1 lg:grid-cols-2 gap-6">
              <div className="bg-white rounded-lg shadow p-6">
                <h3 className="text-lg font-semibold text-gray-900 mb-4">Regional Distribution</h3>
                <div className="space-y-3">
                  {['North', 'South', 'East', 'West', 'Central'].map(region => {
                    const regionSystems = data.systems.filter(s => s.region === region);
                    const regionCables = data.ofcCables.filter(c => c.region === region);
                    
                    return (
                      <div key={region} className="flex items-center justify-between">
                        <span className="font-medium">{region}</span>
                        <div className="text-sm text-gray-600">
                          <span className="mr-4">{regionSystems.length} systems</span>
                          <span>{regionCables.length} cables</span>
                        </div>
                      </div>
                    );
                  })}
                </div>
              </div>
              
              <div className="bg-white rounded-lg shadow p-6">
                <h3 className="text-lg font-semibold text-gray-900 mb-4">System Status Overview</h3>
                <div className="space-y-3">
                  {[
                    { status: 'operational', color: 'text-green-600', bgColor: 'bg-green-100' },
                    { status: 'degraded', color: 'text-yellow-600', bgColor: 'bg-yellow-100' },
                    { status: 'down', color: 'text-red-600', bgColor: 'bg-red-100' }
                  ].map(({ status, color, bgColor }) => {
                    const count = data.systems.filter(s => s.status === status).length;
                    const percentage = (count / data.systems.length * 100).toFixed(1);
                    
                    return (
                      <div key={status} className="flex items-center justify-between">
                        <div className="flex items-center">
                          <div className={`w-3 h-3 rounded-full ${bgColor} mr-3`}></div>
                          <span className="capitalize">{status}</span>
                        </div>
                        <div className={`text-sm font-medium ${color}`}>
                          {count.toLocaleString()} ({percentage}%)
                        </div>
                      </div>
                    );
                  })}
                </div>
              </div>
            </div>
          </div>
        )}

        {/* Systems Tab - Enhanced with scalability */}
        {activeTab === 'systems' && (
          <div className="space-y-6">
            <div className="flex justify-between items-center">
              <div>
                <h2 className="text-lg font-semibold text-gray-900">Network Systems</h2>
                <p className="text-sm text-gray-500">
                  Showing {filteredSystems.length.toLocaleString()} of {data.systems.length.toLocaleString()} systems
                </p>
              </div>
              <div className="flex space-x-2">
                <button className="px-4 py-2 bg-blue-600 text-white rounded-lg hover:bg-blue-700 flex items-center">
                  <Plus className="h-4 w-4 mr-2" />
                  Add System
                </button>
                <button className="px-4 py-2 border border-gray-300 rounded-lg hover:bg-gray-50 flex items-center">
                  <Download className="h-4 w-4 mr-2" />
                  Export
                </button>
              </div>
            </div>

            <div className="bg-white rounded-lg shadow">
              <PaginatedTable
                data={filteredSystems}
                columns={systemColumns}
                onItemClick={setSelectedSystem}
                pageSize={50}
              />
            </div>

            {/* Selected System Details */}
            {selectedSystem && (
              <div className="bg-white rounded-lg shadow p-6">
                <div className="flex justify-between items-start mb-4">
                  <div>
                    <h3 className="text-lg font-semibold text-gray-900">{selectedSystem.name}</h3>
                    <p className="text-sm text-gray-500">System Details</p>
                  </div>
                  <button 
                    onClick={() => setSelectedSystem(null)}
                    className="p-1 text-gray-400 hover:text-gray-600"
                  >
                    <X className="h-4 w-4" />
                  </button>
                </div>
                
                <div className="grid grid-cols-1 md:grid-cols-3 gap-6">
                  <div>
                    <h4 className="font-medium text-gray-900 mb-2">Basic Information</h4>
                    <div className="space-y-2 text-sm">
                      <div><span className="font-medium">Type:</span> {selectedSystem.type}</div>
                      <div><span className="font-medium">Bandwidth:</span> {selectedSystem.bandwidth}</div>
                      <div><span className="font-medium">Redundancy:</span> {selectedSystem.redundancy}</div>
                      <div><span className="font-medium">Region:</span> {selectedSystem.region}</div>
                      <div><span className="font-medium">District:</span> {selectedSystem.district}</div>
                      <div><span className="font-medium">Priority:</span> 
                        <span className={`ml-2 px-2 py-0.5 text-xs rounded ${
                          selectedSystem.priority === 'critical' ? 'bg-red-100 text-red-700' :
                          selectedSystem.priority === 'high' ? 'bg-orange-100 text-orange-700' :
                          'bg-yellow-100 text-yellow-700'
                        }`}>
                          {selectedSystem.priority}
                        </span>
                      </div>
                    </div>
                  </div>
                  
                  <div>
                    <h4 className="font-medium text-gray-900 mb-2">Status & Performance</h4>
                    <div className="space-y-2 text-sm">
                      <div><span className="font-medium">Status:</span> 
                        <span className={`ml-2 px-2 py-0.5 text-xs rounded-full ${
                          selectedSystem.status === 'operational' ? 'bg-green-100 text-green-700' :
                          selectedSystem.status === 'degraded' ? 'bg-yellow-100 text-yellow-700' :
                          'bg-red-100 text-red-700'
                        }`}>
                          {selectedSystem.status}
                        </span>
                      </div>
                      <div><span className="font-medium">Start Node:</span> {selectedSystem.startNode}</div>
                      <div><span className="font-medium">End Node:</span> {selectedSystem.endNode}</div>
                      <div><span className="font-medium">Route Hops:</span> {selectedSystem.fiberRoute.length}</div>
                    </div>
                  </div>
                  
                  <div>
                    <h4 className="font-medium text-gray-900 mb-2">Actions</h4>
                    <div className="space-y-2">
                      <button className="w-full px-3 py-2 text-left text-sm bg-blue-50 text-blue-700 rounded hover:bg-blue-100">
                        View Route Details
                      </button>
                      <button className="w-full px-3 py-2 text-left text-sm bg-green-50 text-green-700 rounded hover:bg-green-100">
                        Monitor Performance
                      </button>
                      <button className="w-full px-3 py-2 text-left text-sm bg-yellow-50 text-yellow-700 rounded hover:bg-yellow-100">
                        Schedule Maintenance
                      </button>
                    </div>
                  </div>
                </div>
              </div>
            )}
          </div>
        )}

        {/* Allocations Tab - Enhanced with scalability */}
        {activeTab === 'allocations' && (
          <div className="space-y-6">
            <div className="flex justify-between items-center">
              <div>
                <h2 className="text-lg font-semibold text-gray-900">Fiber Allocations</h2>
                <p className="text-sm text-gray-500">
                  Showing {filteredCables.length.toLocaleString()} of {data.ofcCables.length.toLocaleString()} cables
                </p>
              </div>
              <div className="flex space-x-2">
              <button 
              onClick={() => setIsAllocationModalOpen(true)}
              className="px-4 py-2 bg-green-600 text-white rounded-lg hover:bg-green-700 flex items-center"
            >
              <Plus className="h-4 w-4 mr-2" />
              New Allocation
            </button>
                <button className="px-4 py-2 border border-gray-300 rounded-lg hover:bg-gray-50 flex items-center">
                  <Download className="h-4 w-4 mr-2" />
                  Export Report
                </button>
              </div>
            </div>

            <div className="bg-white rounded-lg shadow">
              <PaginatedTable
                data={filteredCables}
                columns={cableColumns}
                onItemClick={setSelectedCable}
                pageSize={25}
              />
            </div>

            {/* Overall Utilization Summary */}
            <div className="grid grid-cols-1 md:grid-cols-3 gap-6">
              <div className="bg-white rounded-lg shadow p-6">
                <h3 className="text-lg font-semibold text-gray-900 mb-4">Utilization by Type</h3>
                <div className="space-y-3">
                  {['main', 'branch', 'cascade'].map(type => {
                    const cables = data.ofcCables.filter(c => c.type === type);
                    const totalFibers = cables.reduce((sum, c) => sum + c.fiberCount, 0);
                    const usedFibers = cables.reduce((sum, c) => sum + c.fiberAllocations.length, 0);
                    const percentage = totalFibers > 0 ? (usedFibers / totalFibers * 100).toFixed(1) : '0';
                    
                    return (
                      <div key={type} className="flex items-center justify-between">
                        <span className="capitalize font-medium">{type}</span>
                        <div className="flex items-center space-x-2">
                          <span className="text-sm text-gray-600">{usedFibers}/{totalFibers}</span>
                          <div className="w-20 bg-gray-200 rounded-full h-2">
                            <div 
                              className={`h-2 rounded-full ${
                                parseFloat(percentage) > 80 ? 'bg-red-500' :
                                parseFloat(percentage) > 60 ? 'bg-yellow-500' :
                                'bg-green-500'
                              }`}
                              style={{ width: `${percentage}%` }}
                            />
                          </div>
                          <span className="text-xs text-gray-500">{percentage}%</span>
                        </div>
                      </div>
                    );
                  })}
                </div>
              </div>
              
              <div className="bg-white rounded-lg shadow p-6">
                <h3 className="text-lg font-semibold text-gray-900 mb-4">Capacity Planning</h3>
                <div className="space-y-3">
                  {[
                    { threshold: 90, label: 'Critical (>90%)', color: 'text-red-600' },
                    { threshold: 80, label: 'Warning (>80%)', color: 'text-yellow-600' },
                    { threshold: 60, label: 'Good (>60%)', color: 'text-green-600' },
                    { threshold: 0, label: 'Low (<60%)', color: 'text-blue-600' }
                  ].map(({ threshold, label, color }) => {
                    let count = 0;
                    if (threshold === 90) {
                      count = data.ofcCables.filter(c => 
                        (c.fiberAllocations.length / c.fiberCount * 100) > 90
                      ).length;
                    } else if (threshold === 80) {
                      count = data.ofcCables.filter(c => {
                        const util = (c.fiberAllocations.length / c.fiberCount * 100);
                        return util > 80 && util <= 90;
                      }).length;
                    } else if (threshold === 60) {
                      count = data.ofcCables.filter(c => {
                        const util = (c.fiberAllocations.length / c.fiberCount * 100);
                        return util > 60 && util <= 80;
                      }).length;
                    } else {
                      count = data.ofcCables.filter(c => 
                        (c.fiberAllocations.length / c.fiberCount * 100) <= 60
                      ).length;
                    }
                    
                    return (
                      <div key={threshold} className="flex items-center justify-between">
                        <span className={`font-medium ${color}`}>{label}</span>
                        <span className={`text-sm ${color}`}>{count.toLocaleString()} cables</span>
                      </div>
                    );
                  })}
                </div>
              </div>
              
              <div className="bg-white rounded-lg shadow p-6">
                <h3 className="text-lg font-semibold text-gray-900 mb-4">Recent Activity</h3>
                <div className="space-y-3">
                  <div className="text-sm">
                    <div className="flex items-center">
                      <div className="w-2 h-2 bg-green-500 rounded-full mr-3"></div>
                      <span className="text-gray-900">New allocation created</span>
                    </div>
                    <p className="text-gray-500 ml-5 text-xs">2 minutes ago</p>
                  </div>
                  <div className="text-sm">
                    <div className="flex items-center">
                      <div className="w-2 h-2 bg-yellow-500 rounded-full mr-3"></div>
                      <span className="text-gray-900">Cable utilization warning</span>
                    </div>
                    <p className="text-gray-500 ml-5 text-xs">15 minutes ago</p>
                  </div>
                  <div className="text-sm">
                    <div className="flex items-center">
                      <div className="w-2 h-2 bg-blue-500 rounded-full mr-3"></div>
                      <span className="text-gray-900">System maintenance completed</span>
                    </div>
                    <p className="text-gray-500 ml-5 text-xs">1 hour ago</p>
                  </div>
                </div>
              </div>
            </div>
          </div>
        )}
      </div>
      <AdvancedAllocationModal
        isOpen={isAllocationModalOpen}
        onClose={() => setIsAllocationModalOpen(false)}
        onSave={handleSaveAllocation}
        systems={mockData.systems}
        nodes={mockData.nodes}
        cables={mockData.ofcCables}
      />
    </div>
  );
}
```

<!-- path: app/dashboard/systems/[id]/page.tsx -->
```typescript
"use client";

import { useParams } from "next/navigation";
import { createClient } from "@/utils/supabase/client";
import { useTableRecord } from "@/hooks/database";
import { PageSpinner } from "@/components/common/ui/LoadingSpinner";
import { ErrorDisplay } from "@/components/common/ui/error/ErrorDisplay";
import { SystemRingPath } from "@/components/systems/SystemRingPath";

import { Row } from "@/hooks/database";

type SystemWithNode = Row<'systems'> & {
  ring_no: string | null;
  node: {
    id: string;
    name: string;
  } | null;
};

export default function SystemDetailsPage() {
  const params = useParams();
  const id = params.id as string;
  const supabase = createClient();

  const { data: system, isLoading, isError, error, refetch } = useTableRecord<'systems', SystemWithNode>(
    supabase,
    "systems",
    id,
    { columns: "*, node:node_id(id, name)" }
  );

  if (isLoading) return <PageSpinner />;
  if (isError) return <ErrorDisplay error={error?.message} actions={[{ label: 'Retry', onClick: () => refetch(), variant: 'primary' }]} />;
  if (!system) return <div className="p-6">System not found.</div>;

  return (
    <div className="space-y-8 p-4 md:p-6">
      <header>
        <h1 className="text-3xl font-bold text-gray-900 dark:text-white">{system.system_name}</h1>
        <p className="text-gray-500 dark:text-gray-400">
          Ring: {system.ring_no || "Not Assigned"} | Home Node: {system.node?.name}
        </p>
      </header>

      <main>
        {/* You can add other system detail cards here in the future */}
        
        {/* The new Ring Path Management Component */}
        <SystemRingPath system={system as Row<'systems'> & { node: Row<'nodes'> | null }} />
      </main>
    </div>
  );
}
```

<!-- path: app/dashboard/systems/page.tsx -->
```typescript
'use client';

import { useRouter } from 'next/navigation';
import { useCallback, useMemo, useState } from 'react';
import { FiDatabase } from 'react-icons/fi';
import { toast } from 'sonner';

import { SelectFilter } from '@/components/common/filters/FilterInputs';
import { SearchAndFilters } from '@/components/common/filters/SearchAndFilters';
import {
  PageHeader,
  useStandardHeaderActions,
} from '@/components/common/page-header';
import { ErrorDisplay } from '@/components/common/ui';
import { ConfirmModal } from '@/components/common/ui/Modal/confirmModal';
import { PageSkeleton } from '@/components/common/ui/table/TableSkeleton';
import { SystemModal } from '@/components/systems/system-modal';
import { createStandardActions } from '@/components/table/action-helpers';
import { DataTable } from '@/components/table/DataTable';
import { SystemsTableColumns } from '@/config/table-columns/SystemsTableColumns';
import {
  convertRichFiltersToSimpleJson,
  Filters,
  Row,
  useGetLookupTypesByCategory,
  usePagedSystemsComplete,
} from '@/hooks/database';
import { useIsSuperAdmin } from '@/hooks/useAdminUsers';
import {
  DataQueryHookParams,
  DataQueryHookReturn,
  useCrudManager,
} from '@/hooks/useCrudManager';
import { Json } from '@/types/supabase-types';
import { SystemRowsWithCountWithRelations } from '@/types/view-row-types';
import { createClient } from '@/utils/supabase/client';

// 1. ADAPTER HOOK: Makes `useSystemsData` compatible with `useCrudManager`
const useSystemsData = (
  params: DataQueryHookParams
): DataQueryHookReturn<SystemRowsWithCountWithRelations> => {
  const { currentPage, pageLimit, filters, searchQuery } = params;
  const supabase = createClient();
  // Build the server filters object that the RPC function expects.
  const serverFilters = useMemo(() => {
    const richFilters: Filters = { ...filters };

    if (searchQuery) {
      richFilters.or = `system_name.ilike.%${searchQuery}%,system_type_name.ilike.%${searchQuery}%,status.ilike.%${searchQuery}%`;
    }
    return convertRichFiltersToSimpleJson(richFilters);
  }, [filters, searchQuery]);

  const { data, isLoading, error, refetch } = usePagedSystemsComplete(
    supabase,
    {
      filters: serverFilters as Json,
      limit: pageLimit,
      offset: (currentPage - 1) * pageLimit,
    }
  );

  // Calculate counts from the full dataset
  const totalCount = data?.[0]?.total_count || 0;
  const activeCount = data?.[0]?.active_count || 0;
  const inactiveCount = data?.[0]?.inactive_count || 0;

  return {
    data: (data || []).map((item) => ({
      ...item,
      maintenance_terminal_id: null, // Add missing field
      node_id: null, // Add missing field
      system_type_id: null, // Add missing field
    })),
    totalCount,
    activeCount,
    inactiveCount,
    isLoading,
    error,
    refetch,
  };
};

export default function SystemsPage() {
  const supabase = createClient();
  const router = useRouter();

  // 2. USE THE CRUD MANAGER with the adapter hook and both generic types
  const {
    data: paginatedSystems,
    totalCount,
    activeCount,
    inactiveCount,
    isLoading,
    isMutating,
    error: systemsError,
    refetch,
    pagination,
    search,
    filters: crudFilters,
    editModal,
    viewModal,
    bulkActions,
    deleteModal,
    actions: crudActions,
  } = useCrudManager<'systems', SystemRowsWithCountWithRelations>({
    tableName: 'systems',
    dataQueryHook: useSystemsData,
    searchColumn: 'system_name', // This can be considered the "primary" search field for display purposes
  });

  // --- State Management ---
  const { data: isSuperAdmin } = useIsSuperAdmin();
  const [showFilters, setShowFilters] = useState(false);
  const handleClearFilters = () => {
    crudFilters.setFilters({});
    search.setSearchQuery('');
  };
  const activeFilterCount = Object.values(crudFilters.filters).filter(
    Boolean
  ).length;
  const hasActiveFilters = activeFilterCount > 0 || !!search.searchQuery;

  const { data: systemTypes = [], isLoading: isLoadingSystemTypes } =
    useGetLookupTypesByCategory(supabase, 'SYSTEM_TYPES');

  // --- Action Handlers ---
  const handleView = useCallback(
    (system: Row<'v_systems_complete'>) => {
      router.push(`/dashboard/systems/${system.id}`);
    },
    [router]
  );

  const handleEdit = useCallback(
    (system: Row<'v_systems_complete'>) => {
      router.push(`/systems/${system.id}/edit`);
    },
    [router]
  );

  const handleRefresh = useCallback(() => {
    refetch();
    toast.success('Systems data refreshed');
  }, [refetch]);

  // --- Table Column Configuration ---
  const columns = SystemsTableColumns(paginatedSystems);

  // --- tableActions ---
  const tableActions = useMemo(
    () =>
      createStandardActions<SystemRowsWithCountWithRelations>({
        onEdit: editModal.openEdit,
        onView: handleView,
        onDelete: crudActions.handleDelete,
        onToggleStatus: crudActions.handleToggleStatus,
        canDelete: () => isSuperAdmin === true,
      }),
    [
      editModal.openEdit,
      handleView,
      crudActions.handleDelete,
      crudActions.handleToggleStatus,
      isSuperAdmin,
    ]
  );

  // --- Define header content using the hook ---
  const headerActions = useStandardHeaderActions({
    data: paginatedSystems as Row<'systems'>[],
    onRefresh: async () => {
      await refetch();
      toast.success('Refreshed successfully!');
    },
    onAddNew: editModal.openAdd,
    isLoading: isLoading,
    exportConfig: { tableName: 'systems' },
  });

  const headerStats = [
    { value: totalCount, label: 'Total Systems', color: 'primary' as const },
    {
      value: activeCount,
      label: 'Active',
      color: 'success' as const,
    },
    {
      value: inactiveCount,
      label: 'Inactive',
      color: 'danger' as const,
    },
    {
      value: systemTypes.length,
      label: 'System Types',
      color: 'default' as const,
    },
  ];

  // --- Loading State ---
  if (isLoading && !paginatedSystems.length) {
    return <PageSkeleton />;
  }

  if (systemsError) {
    return (
      <ErrorDisplay
        error={systemsError.message}
        actions={[
          {
            label: 'Retry',
            onClick: refetch,
            variant: 'primary',
          },
        ]}
      />
    );
  }

  return (
    <>
      <div className="min-h-screen bg-gray-50 p-6 dark:bg-gray-900">
        <div className="mx-auto">
          {/* Header */}
          <PageHeader
            title="System Management"
            description="Manage network systems and their related information."
            icon={<FiDatabase />}
            stats={headerStats}
            actions={headerActions}
            isLoading={isLoading}
          />

          <DataTable
            title="Systems"
            data={paginatedSystems}
            columns={columns}
            pagination={{
              current: pagination.currentPage,
              pageSize: pagination.pageLimit,
              total: totalCount,
              onChange: (page, limit) => {
                pagination.setCurrentPage(page);
                pagination.setPageLimit(limit);
              },
            }}
            actions={tableActions}
            searchable={true}
            filterable={true}
            sortable={true}
            selectable={true}
            exportable={true}
            refreshable={true}
            density="default"
            bordered={true}
            striped={true}
            hoverable={true}
            className="mt-6"
            emptyText="No systems found matching your criteria"
            tableName="v_systems_complete"
            loading={isLoading}
            customToolbar={
              <SearchAndFilters
                searchTerm={search.searchQuery}
                onSearchChange={search.setSearchQuery}
                showFilters={showFilters}
                onToggleFilters={() => setShowFilters((p) => !p)}
                onClearFilters={handleClearFilters}
                hasActiveFilters={hasActiveFilters}
                activeFilterCount={activeFilterCount}
                searchPlaceholder="Search by Asset No or Route Name or Transnet ID..."
              >
                {/* THIS IS THE CLEANER, TYPE-SAFE WAY */}
                <SelectFilter
                  label="System Type"
                  filterKey="system_type_id"
                  filters={crudFilters.filters}
                  setFilters={crudFilters.setFilters}
                  options={systemTypes.map((t) => ({
                    value: t.id,
                    label: t.code,
                  }))}
                />
              </SearchAndFilters>
            }
          />
        </div>
      </div>

      {/* Modals */}
      <SystemModal
        isOpen={editModal.isOpen}
        onClose={editModal.close}
        rowData={editModal.record as SystemRowsWithCountWithRelations | null}
        refetch={refetch}
      />

      <ConfirmModal
        isOpen={deleteModal.isOpen}
        onConfirm={deleteModal.onConfirm}
        onCancel={deleteModal.onCancel}
        title="Confirm Deletion"
        message={deleteModal.message}
        confirmText="Delete"
        cancelText="Cancel"
        type="danger"
        showIcon
        closeOnBackdrop
        closeOnEscape
        loading={deleteModal.loading}
        size="md"
      />
    </>
  );
}

```

<!-- path: app/dashboard/nodes/page.tsx -->
```typescript
'use client';

import {
  PageHeader,
  useStandardHeaderActions,
} from '@/components/common/page-header';
import { ConfirmModal, ErrorDisplay } from '@/components/common/ui';
import { NodeFormModal } from '@/components/nodes/NodeFormModal';
import { NodesFilters } from '@/components/nodes/NodesFilters';
import { createStandardActions } from '@/components/table/action-helpers';
import { DataTable } from '@/components/table/DataTable';
import { NodeDetailsModal } from '@/config/node-details-config';
import { NodesTableColumns } from '@/config/table-columns/NodesTableColumns';
import { usePagedNodesComplete } from '@/hooks/database';
import {
  DataQueryHookParams,
  DataQueryHookReturn,
  useCrudManager,
} from '@/hooks/useCrudManager';
import useOrderedColumns from '@/hooks/useOrderedColumns';
import { NodesRowSchema } from '@/schemas/zod-schemas';
import { NodeRowsWithCount } from '@/types/view-row-types';
import { createClient } from '@/utils/supabase/client';
import { useMemo } from 'react';
import { FiCpu } from 'react-icons/fi';
import { toast } from 'sonner';

export type NodeRowsWithRelations = NodesRowSchema & {
  maintenance_terminal?: {
    id: string;
    name: string;
  } | null;
  node_type?: {
    id: string;
    name: string;
  } | null;
};

// 1. ADAPTER HOOK: Makes `useNodesData` compatible with `useCrudManager`
const useNodesData = (
  params: DataQueryHookParams
): DataQueryHookReturn<NodeRowsWithCount> => {
  const { currentPage, pageLimit, filters, searchQuery } = params;

  const supabase = createClient();

  const { data, isLoading, error, refetch } = usePagedNodesComplete(supabase, {
    filters: {
      ...filters,
      ...(searchQuery ? { name: searchQuery } : {}),
    },
    limit: pageLimit,
    offset: (currentPage - 1) * pageLimit,
  });

  // Calculate counts from the full dataset
  const totalCount = data?.[0]?.total_count || 0;
  const activeCount = data?.[0]?.active_count || 0;
  const inactiveCount = data?.[0]?.inactive_count || 0;

  return {
    data: data || [],
    totalCount,
    activeCount,
    inactiveCount,
    isLoading,
    error,
    refetch,
  };
};

const NodesPage = () => {
  // 2. USE THE CRUD MANAGER with the adapter hook and both generic types
  const {
    data: nodes,
    totalCount,
    activeCount,
    inactiveCount,
    isLoading,
    // isMutating,
    error,
    refetch,
    pagination,
    search,
    filters,
    editModal,
    viewModal,
    // bulkActions,
    deleteModal,
    actions: crudActions,
  } = useCrudManager<'nodes', NodeRowsWithCount>({
    tableName: 'nodes',
    dataQueryHook: useNodesData,
  });

  // 3. Extract node types from the nodes data
  const nodeTypes = useMemo(() => {
    const uniqueNodeTypes = new Map();
    nodes.forEach((node) => {
      if (node.node_type_id) {
        uniqueNodeTypes.set(node.node_type_id, {
          id: node.node_type_id,
          name: node.node_type_name,
        });
      }
    });

    return Array.from(uniqueNodeTypes.values());
  }, [nodes]);

  const columns = NodesTableColumns(nodes);

  const desiredColumns = [
    'name',
    'latitude',
    'longitude',
    'node_type_name',
    'node_type_code',
    'maintenance_area_name',
    'maintenance_area_code',
    'maintenance_area_type_name',
    'status',
    'remark',
    'id',
    'node_type_id',
    'maintenance_terminal_id',
    'created_at',
    'updated_at',
    'total_count',
    'active_count',
    'inactive_count',
  ];

  const orderedColumns = useOrderedColumns(columns, desiredColumns);

  const tableActions = useMemo(
    () =>
      createStandardActions<NodeRowsWithCount>({
        onEdit: editModal.openEdit,
        onView: viewModal.open,
        onDelete: crudActions.handleDelete,
      }),
    [editModal.openEdit, viewModal.open, crudActions.handleDelete]
  );

  // --- Define header content using the hook ---
  const headerActions = useStandardHeaderActions({
    data: nodes as NodesRowSchema[],
    onAddNew: () => {
      editModal.openAdd();
    },
    onRefresh: () => {
      refetch();
      toast.success('Refreshed successfully!');
    },
    isLoading: isLoading,
    exportConfig: { tableName: 'nodes' },
  });

  const headerStats = [
    { value: totalCount, label: 'Total Nodes' },
    {
      value: activeCount,
      label: 'Active',
      color: 'success' as const,
    },
    {
      value: inactiveCount,
      label: 'Inactive',
      color: 'danger' as const,
    },
  ];

  if (error) {
    return (
      <ErrorDisplay
        error={error.message}
        actions={[
          {
            label: 'Retry',
            onClick: refetch,
            variant: 'primary',
          },
        ]}
      />
    );
  }

  return (
    <div className="mx-auto space-y-4">
      <PageHeader
        title="Node Management"
        description="Manage network nodes and their related information."
        icon={<FiCpu />}
        stats={headerStats}
        actions={headerActions} // <-- Pass the generated actions
        isLoading={isLoading}
      />

      <NodeDetailsModal
        isOpen={viewModal.isOpen}
        node={viewModal.record as NodeRowsWithCount}
        onClose={viewModal.close}
      />

      <DataTable
        tableName="v_nodes_complete"
        data={nodes}
        columns={orderedColumns}
        loading={isLoading}
        actions={tableActions}
        selectable={true} // Assuming you might want bulk actions later
        showColumnsToggle={true}
        pagination={{
          current: pagination.currentPage,
          pageSize: pagination.pageLimit,
          total: totalCount,
          showSizeChanger: true,
          onChange: (page, pageSize) => {
            pagination.setCurrentPage(page);
            pagination.setPageLimit(pageSize);
          },
        }}
        customToolbar={
          <NodesFilters
            searchQuery={search.searchQuery}
            onSearchChange={search.setSearchQuery}
            nodeTypes={nodeTypes}
            selectedNodeType={
              filters.filters.node_type_id as string | undefined
            }
            onNodeTypeChange={(value) =>
              filters.setFilters((prev) => ({ ...prev, node_type_id: value }))
            }
          />
        }
      />

      {editModal.isOpen && (
        <NodeFormModal
          isOpen={editModal.isOpen}
          onClose={editModal.close}
          editingNode={editModal.record as NodeRowsWithRelations | null}
          onCreated={crudActions.handleSave}
          onUpdated={crudActions.handleSave}
        />
      )}

      <ConfirmModal
        isOpen={deleteModal.isOpen}
        onConfirm={deleteModal.onConfirm}
        onCancel={deleteModal.onCancel}
        title="Confirm Deletion"
        message={deleteModal.message}
        loading={deleteModal.loading}
        type="danger"
      />
    </div>
  );
};

export default NodesPage;

```

<!-- path: app/dashboard/users/page.tsx -->
```typescript
'use client';

import {
  PageHeader,
  useStandardHeaderActions,
} from '@/components/common/page-header';
import { ConfirmModal, ErrorDisplay } from '@/components/common/ui';
import { createStandardActions } from '@/components/table/action-helpers';
import { DataTable } from '@/components/table/DataTable';
import { BulkActions } from '@/components/users/BulkActions';
import { UserProfileData } from '@/components/users/user-types';
import { UserCreateModal } from '@/components/users/UserCreateModal';
import { UserFilters } from '@/components/users/UserFilters';
import UserProfileEditModal from '@/components/users/UserProfileEditModal';
import { UserProfileColumns } from '@/config/table-columns/UsersTableColumns';
import { UserDetailsModal } from '@/config/user-details-config';
import { Row } from '@/hooks/database';
import {
  useAdminGetAllUsersExtended,
  useAdminUserOperations,
  useIsSuperAdmin,
} from '@/hooks/useAdminUsers';
import {
  DataQueryHookParams,
  DataQueryHookReturn,
  useCrudManager,
} from '@/hooks/useCrudManager';
import { UserProfileFormData } from '@/schemas';
import { useCallback, useMemo, useState } from 'react';
import { FiUsers } from 'react-icons/fi';
import { toast } from 'sonner';

// This hook adapts the specific RPC hook to the generic interface required by useCrudManager.
// 1. ADAPTER HOOK: Makes `useAdminGetAllUsersExtended` compatible with `useCrudManager`
const useUsersData = (
  params: DataQueryHookParams
): DataQueryHookReturn<UserProfileData> => {
  const { currentPage, pageLimit, searchQuery, filters } = params;

  const { data, isLoading, error, refetch } = useAdminGetAllUsersExtended({
    search_query: searchQuery || undefined,
    filter_role: (filters.role as string) || undefined,
    filter_status: (filters.status as string) || undefined,
    page_offset: (currentPage - 1) * pageLimit,
    page_limit: pageLimit,
  });

  return {
    data: data || [], // `data` is now correctly typed as UserProfileData[]
    totalCount: data?.length || 0,
    activeCount: (data || []).filter((u) => !!u.status).length,
    inactiveCount: (data || []).filter((u) => !u.status).length,
    isLoading,
    error: (error as Error) || null,
    refetch: () => {
      void refetch();
    },
  };
};
const AdminUsersPage = () => {
  // --- STATE MANAGEMENT (Mimicking useCrudManager) ---
  const [showFilters, setShowFilters] = useState(false);
  const { data: isSuperAdmin } = useIsSuperAdmin();
  const {
    createUser,
    deleteUsers: bulkDelete,
    updateUserRoles: bulkUpdateRole,
    updateUserStatus: bulkUpdateStatus,
    isLoading: isOperationLoading,
  } = useAdminUserOperations();

  // 2. USE THE CRUD MANAGER with the adapter hook and both generic types
  const {
    data: users,
    totalCount,
    isLoading,
    isMutating,
    error,
    refetch,
    pagination,
    search,
    filters,
    editModal,
    viewModal,
    bulkActions,
    deleteModal,
    actions: crudActions,
  } = useCrudManager<'user_profiles', UserProfileData>({
    tableName: 'user_profiles',
    dataQueryHook: useUsersData,
  });

  const columns = UserProfileColumns(users);
  const { selectedRowIds, handleClearSelection } = bulkActions;

  const tableActions = useMemo(
    () =>
      createStandardActions<UserProfileData>({
        onEdit: editModal.openEdit,
        onView: viewModal.open,
        onDelete: crudActions.handleDelete,
        canDelete: (record) => !record.is_super_admin,
      }),
    [editModal.openEdit, viewModal.open, crudActions.handleDelete]
  );

  const [isCreateModalOpen, setIsCreateModalOpen] = useState(false);

  const handleCreateUser = async (userData: any) => {
    await createUser.mutateAsync({
      ...userData,
      status: 'active', // Default status for new users
    });
  };

  const handleBulkDelete = useCallback(async () => {
    if (selectedRowIds.length === 0) return;
    if (
      !window.confirm(
        `Are you sure you want to delete ${selectedRowIds.length} selected user(s)?`
      )
    )
      return;

    await bulkDelete.mutateAsync({ user_ids: selectedRowIds });
    handleClearSelection();
  }, [selectedRowIds, bulkDelete, handleClearSelection]);

  const handleBulkUpdateRole = useCallback(
    async (newRole: string) => {
      if (selectedRowIds.length === 0) return;
      await bulkUpdateRole.mutateAsync({
        user_ids: selectedRowIds,
        new_role: newRole,
      });
      handleClearSelection();
    },
    [selectedRowIds, bulkUpdateRole, handleClearSelection]
  );

  const handleBulkUpdateStatus = useCallback(
    async (newStatus: string) => {
      if (selectedRowIds.length === 0) return;
      await bulkUpdateStatus.mutateAsync({
        user_ids: selectedRowIds,
        new_status: newStatus,
      });
      handleClearSelection();
    },
    [selectedRowIds, bulkUpdateStatus, handleClearSelection]
  );

  // --- Define header content using the hook ---
  const headerActions = useStandardHeaderActions<'user_profiles'>({
    data: users as Row<'user_profiles'>[],
    onRefresh: async () => {
      await refetch();
      toast.success('Refreshed successfully!');
    },
    onAddNew: () => setIsCreateModalOpen(true),
    isLoading: isLoading,
    exportConfig: { tableName: 'user_profiles' },
  });

  const headerStats = [
    { value: totalCount, label: 'Total Users' },
    {
      value: users.filter((r) => r.status).length,
      label: 'Active',
      color: 'success' as const,
    },
    {
      value: users.filter((r) => !r.status).length,
      label: 'Inactive',
      color: 'danger' as const,
    },
  ];

  if (error) {
    return (
      <ErrorDisplay
        error={error.message}
        actions={[
          {
            label: 'Retry',
            onClick: refetch,
            variant: 'primary',
          },
        ]}
      />
    );
  }

  return (
    <div className="p-3 sm:p-4 md:p-6 lg:p-8 space-y-4 sm:space-y-6">
      <PageHeader
        title="User Management"
        description="Manage network users and their related information."
        icon={<FiUsers />}
        stats={headerStats}
        actions={headerActions} // <-- Pass the generated actions
        isLoading={isLoading}
      />
      <BulkActions
        selectedCount={bulkActions.selectedCount}
        isSuperAdmin={!!isSuperAdmin}
        isOperationLoading={isMutating}
        onBulkDelete={handleBulkDelete}
        onBulkUpdateRole={handleBulkUpdateRole}
        onBulkUpdateStatus={handleBulkUpdateStatus}
        onClearSelection={bulkActions.handleClearSelection}
      />
      <DataTable
        tableName="v_user_profiles_extended"
        data={users as unknown as Row<'v_user_profiles_extended'>[]}
        columns={columns}
        loading={isLoading || isOperationLoading}
        actions={tableActions}
        selectable
        onRowSelect={(rows) => {
          // Filter out any rows where id is null
          const validRows = rows.filter(
            (row): row is UserProfileData & { id: string } => row.id !== null
          );
          bulkActions.handleRowSelect(validRows);
        }}
        searchable={false}
        filterable={false}
        pagination={{
          current: pagination.currentPage,
          pageSize: pagination.pageLimit,
          total: totalCount,
          showSizeChanger: true,
          onChange: (page, pageSize) => {
            pagination.setCurrentPage(page);
            pagination.setPageLimit(pageSize);
          },
        }}
        customToolbar={
          <UserFilters
            searchQuery={search.searchQuery}
            onSearchChange={search.setSearchQuery}
            roleFilter={(filters.filters.role as string) || ''}
            onRoleFilterChange={(value) =>
              filters.setFilters((prev) => ({ ...prev, role: value }))
            }
            statusFilter={(filters.filters.status as string) || ''}
            onStatusFilterChange={(value) =>
              filters.setFilters((prev) => ({ ...prev, status: value }))
            }
            emailVerificationFilter={''} // This filter is not implemented in the hook yet
            onEmailVerificationFilterChange={() => {}}
            showFilters={showFilters}
            onToggleFilters={() => setShowFilters(!showFilters)}
            onClearFilters={() => {
              search.setSearchQuery('');
              filters.setFilters((prev) => ({ ...prev, role: '', status: '' }));
            }}
          />
        }
      />
      <UserProfileEditModal
        isOpen={editModal.isOpen}
        user={editModal.record as UserProfileFormData}
        onClose={editModal.close}
        onSave={() => {
          refetch();
        }}
      />

      <UserDetailsModal
        isOpen={viewModal.isOpen}
        user={viewModal.record}
        onClose={viewModal.close}
      />
      <ConfirmModal
        isOpen={deleteModal.isOpen}
        onConfirm={deleteModal.onConfirm}
        onCancel={deleteModal.onCancel}
        title="Confirm Deletion"
        message={deleteModal.message}
        loading={deleteModal.loading}
        type="danger"
      />

      <UserCreateModal
        isOpen={isCreateModalOpen}
        onClose={() => setIsCreateModalOpen(false)}
        onCreate={handleCreateUser}
        isLoading={createUser.isPending}
      />
    </div>
  );
};

export default AdminUsersPage;

```

<!-- path: app/layout.tsx -->
```typescript
import type { Metadata, Viewport } from "next";
import localFont from "next/font/local";
import "./globals.css";
import "react-datepicker/dist/react-datepicker.css";
import PolyfillLoader from "@/components/polyfills/PolyfillLoader";
import { ToastProvider } from "@/providers/ToastProvider";
import ThemeProvider from "@/providers/ThemeProvider";

const defaultUrl = process.env.VERCEL_URL
  ? `https://${process.env.VERCEL_URL}`
  : "http://localhost:3000";

// Load the main body font (Inter)
const fontSans = localFont({
  src: "../public/fonts/Inter.woff2",
  display: "swap",
  variable: "--font-sans", // We'll use this for Tailwind's 'sans' class
  preload: true,
  fallback: ["system-ui", "arial"],
});

// Load the secondary heading font (Montserrat)
const fontHeading = localFont({
  src: "../public/fonts/Montserrat.woff2",
  display: "swap",
  variable: "--font-heading", // We'll use this for a custom 'heading' class
  preload: true,
  fallback: ["system-ui", "times new roman"],
});

export const viewport: Viewport = {
  width: "device-width",
  initialScale: 1,
  maximumScale: 1,
  userScalable: false,
  themeColor: [
    { media: "(prefers-color-scheme: light)", color: "cyan" },
    { media: "(prefers-color-scheme: dark)", color: "black" },
  ],
};

export const metadata: Metadata = {
  metadataBase: new URL(defaultUrl),
  applicationName: "Harinavi Transmission Maintenance",
  title: {
    default: "Harinavi Transmission Maintenance",
    template: "%s - PWA App",
  },
  description: "We provide reliable telecom transmission maintenance services.",
  manifest: "/manifest.json",
  appleWebApp: {
    capable: true,
    statusBarStyle: "default",
    title: "Harinavi Transmission Maintenance",
  },
  formatDetection: {
    telephone: false,
  },
  icons: {
    shortcut: "/favicon.ico",
    apple: [{ url: "/icon-192x192.png", sizes: "192x192" }],
    icon: "/favicon.ico",
  },
};

export default function RootLayout({
  children,
}: Readonly<{
  children: React.ReactNode;
}>) {
  return (
    <html lang="en" suppressHydrationWarning>
      <body
        className={`${fontSans.variable} ${fontHeading.variable} antialiased`}
      >
        <ThemeProvider>
          <ToastProvider>{children}</ToastProvider>
        </ThemeProvider>
        <PolyfillLoader />
      </body>
    </html>
  );
}

```

<!-- path: app/onboarding/page.tsx -->
```typescript
"use client";
import Link from "next/link";
import OnboardingFormEnhanced from "./onboarding-form-enhanced";
import { useAuth } from "@/hooks/useAuth";
import { useState } from "react";

export default function OnboardingPage() {
  const { logout } = useAuth();
  const [initialLoading, setInitialLoading] = useState(true);
  

  return (
    <div className="min-h-screen bg-gray-50 dark:bg-gray-900 flex flex-col">
      {/* Header */}
      <div className="px-6 py-4 border-b border-gray-200 dark:border-gray-700 flex justify-between items-center bg-white dark:bg-gray-800">
        <h1 className="text-2xl font-bold text-gray-900 dark:text-white">Update Your Profile</h1>
        <div className="flex items-center gap-4">
          <Link
            href="/dashboard"
            className="text-blue-600 dark:text-blue-400 hover:underline text-sm font-medium"
          >
            Go to Dashboard
          </Link>
          <form onSubmit={logout}>
            <button
              type="submit"
              className="bg-red-600 hover:bg-red-700 dark:hover:bg-red-800 text-white px-4 py-2 rounded-md text-sm font-medium"
            >
              Sign Out
            </button>
          </form>
        </div>
      </div>

      {/* Centered Form */}
      <div className="flex flex-1 items-center justify-center p-4">
        <div className="w-full bg-white dark:bg-gray-800 shadow-lg rounded-lg p-6 border border-gray-200 dark:border-gray-700">
          <OnboardingFormEnhanced />
        </div>
      </div>
    </div>
  );
}
```

<!-- path: app/onboarding/layout.tsx -->
```typescript
// app/onboarding/layout.tsx
"use client"

import { Protected } from "@/components/auth/Protected";
import { QueryProvider } from "@/providers/QueryProvider";


export default function AccountLayout({ children }: { children: React.ReactNode }) {
    
  return (
    <QueryProvider><Protected>{children}</Protected></QueryProvider>
  );
}

```

<!-- path: app/onboarding/onboarding-form-enhanced.tsx -->
```typescript
"use client";

import { useState, useEffect, useCallback } from "react";
import { useAuthStore } from "@/stores/authStore";
import { Database, Json } from "@/types/supabase-types";
import Image from "next/image";
import { createClient } from "@/utils/supabase/client";
import { useGetMyUserDetails, useTableUpdate } from "@/hooks/database";
import { useRouter } from "next/navigation";


type ProfileUpdate = Database["public"]["Tables"]["user_profiles"]["Update"];

// Define Address as a type that can be serialized to JSON
type Address = {
  street?: string | null;
  city?: string | null;
  state?: string | null;
  zip_code?: string | null;
  country?: string | null;
};

interface ProfileFormData {
  first_name: string;
  last_name: string;
  avatar_url: string;
  date_of_birth: string;
  designation: string;
  phone_number: string;
  address: Address | null;
  preferences: Json | null;
}

// Helper function to safely get first profile
const getFirstProfile = (profiles: any[] | undefined) => {
  return profiles && profiles.length > 0 ? profiles[0] : null;
};

// Helper function to safely cast to Address
const toAddress = (data: unknown): Address | null => {
  if (!data || typeof data !== "object") return null;
  return data as Address;
};

// Helper function to create initial form data
const createInitialFormData = (): ProfileFormData => ({
  first_name: "",
  last_name: "",
  avatar_url: "",
  date_of_birth: "",
  designation: "",
  phone_number: "",
  address: null,
  preferences: null,
});

export default function OnboardingFormEnhanced() {
  const user = useAuthStore((state) => state.user);
  const supabase = createClient();
  // const updateProfile = useUpdateProfile();
  const [isDirty, setIsDirty] = useState(false);
  const [formData, setFormData] = useState<ProfileFormData>(createInitialFormData);
  const [localError, setLocalError] = useState<Error | null>(null);
  const [isUpdateSuccess, setIsUpdateSuccess] = useState(false);

  const router = useRouter();
  
  
  const { data: profiles, isLoading: profileLoading, error: profileError } = useGetMyUserDetails(supabase);

  const { mutate, isPending: updatePending } = useTableUpdate(supabase, "user_profiles", {
    onSuccess: () => {
      setIsDirty(false);
      setIsUpdateSuccess(true);
      setLocalError(null); // Clear any previous errors on success
    },
    onError: (error) => {
      console.log(error);
      setLocalError(error); // Store the error in local state
      setIsUpdateSuccess(false);
    },
  });

  const isLoading = profileLoading || updatePending;

  // Get the first profile safely
  const profile = getFirstProfile(profiles);

  // Initialize form data when profile loads
  useEffect(() => {
    if (profile) {
      // console.log("profile", profile);
      const newFormData: ProfileFormData = {
        first_name: profile.first_name || "",
        last_name: profile.last_name || "",
        avatar_url: profile.avatar_url || "",
        date_of_birth: profile.date_of_birth || "",
        designation: profile.designation || "",
        phone_number: profile.phone_number || "",
        address: toAddress(profile.address),
        preferences: (profile.preferences as Json) || null,
      };
      setFormData(newFormData);
      setIsDirty(false);
    }
  }, [profile]);

  // Memoized reset function
  const resetForm = useCallback(() => {
    if (profile) {
      setFormData({
        first_name: profile.first_name || "",
        last_name: profile.last_name || "",
        avatar_url: profile.avatar_url || "",
        date_of_birth: profile.date_of_birth || "",
        designation: profile.designation || "",
        phone_number: profile.phone_number || "",
        address: toAddress(profile.address),
        preferences: (profile.preferences as Json) || null,
      });
      setIsDirty(false);
    }
  }, [profile]);

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();

    if (!isDirty) return;

    try {
      const updates: Partial<ProfileUpdate> = {};

      if (profile) {
        // Compare each field and only update if changed
        if (formData.first_name !== (profile.first_name || "")) {
          updates.first_name = formData.first_name;
        }
        if (formData.last_name !== (profile.last_name || "")) {
          updates.last_name = formData.last_name;
        }
        if (formData.avatar_url !== (profile.avatar_url || "")) {
          updates.avatar_url = formData.avatar_url;
        }
        if (formData.date_of_birth !== (profile.date_of_birth || "")) {
          updates.date_of_birth = formData.date_of_birth;
        }
        if (formData.designation !== (profile.designation || "")) {
          updates.designation = formData.designation;
        }
        if (formData.phone_number !== (profile.phone_number || "")) {
          updates.phone_number = formData.phone_number;
        }

        // Compare address objects
        const currentAddress = toAddress(profile.address) || {};
        const newAddress = formData.address || {};
        if (JSON.stringify(currentAddress) !== JSON.stringify(newAddress)) {
          updates.address = newAddress;
        }

        // Compare preferences objects
        const currentPreferences = (profile.preferences as Json) || {};
        const newPreferences = formData.preferences || {};
        if (JSON.stringify(currentPreferences) !== JSON.stringify(newPreferences)) {
          updates.preferences = newPreferences;
        }
      } else {
        // If no profile exists, create a new one with all form data
        Object.assign(updates, {
          first_name: formData.first_name,
          last_name: formData.last_name,
          avatar_url: formData.avatar_url,
          date_of_birth: formData.date_of_birth,
          designation: formData.designation,
          phone_number: formData.phone_number,
          address: formData.address,
          preferences: formData.preferences,
        });
      }

      if (Object.keys(updates).length > 0) {
        await mutate({
          id: profile.id,
          data: updates,
        });
      }
    } catch (error) {
      console.error("Update failed:", error);
    }
  };

  const handleChange = (e: React.ChangeEvent<HTMLInputElement | HTMLTextAreaElement>) => {
    const { name, value } = e.target;
    setFormData((prev) => ({
      ...prev,
      [name]: value,
    }));
    setIsDirty(true);
  };

  const handleAddressChange = (field: keyof Address, value: string) => {
    setFormData((prev) => ({
      ...prev,
      address: {
        ...(prev.address || {}),
        [field]: value,
      },
    }));
    setIsDirty(true);
  };

  // Show loading state
  if (profileLoading) {
    return (
      <div className='animate-pulse space-y-4'>
        <div className='h-4 bg-gray-200 dark:bg-gray-700 rounded w-1/4'></div>
        <div className='space-y-3'>
          <div className='h-10 bg-gray-200 dark:bg-gray-700 rounded'></div>
          <div className='h-10 bg-gray-200 dark:bg-gray-700 rounded'></div>
          <div className='h-10 bg-gray-200 dark:bg-gray-700 rounded'></div>
        </div>
      </div>
    );
  }

  // Show error state
  if (profileError) {
    return (
      <div className='p-4 rounded-md bg-red-100 dark:bg-red-900/30 text-red-700 dark:text-red-300'>
        <h3 className='font-medium'>Error loading profile</h3>
        <p className='text-sm mt-1'>{profileError.message}</p>
        <button onClick={() => window.location.reload()} className='mt-3 text-sm underline hover:no-underline text-red-600 dark:text-red-400'>
          Try again
        </button>
      </div>
    );
  }

  return (
    <form onSubmit={handleSubmit} className='space-y-6 w-full max-w-3xl mx-auto p-6 bg-white dark:bg-gray-900 border border-gray-200 dark:border-gray-700 rounded-md shadow-sm'>
      {/* Status Messages */}
      {localError && (
        <div className='p-4 rounded-md bg-red-100 dark:bg-red-900/30 text-red-700 dark:text-red-300 flex justify-between items-start'>
          <div>
            <h3 className='font-medium'>Update Failed</h3>
            <p className='text-sm mt-1'>{localError.message}</p>
          </div>
          <button type='button' onClick={() => setLocalError(null)} className='text-red-400 hover:text-red-600 dark:hover:text-red-200' aria-label='Dismiss error'>
            
          </button>
        </div>
      )}
      {isUpdateSuccess && (
        <div className='p-4 rounded-md bg-green-100 dark:bg-green-900/30 text-green-700 dark:text-green-300 flex justify-between items-center'>
          <span className='font-medium'>Profile updated successfully!</span>
          <button type='button' onClick={() => setIsUpdateSuccess(false)} className='text-green-400 hover:text-green-600 dark:hover:text-green-200' aria-label='Dismiss success message'>
            
          </button>
        </div>
      )}

      <div className='grid grid-cols-1 gap-6 sm:grid-cols-2'>
        {/* Email - Read Only */}
        <div>
          <label htmlFor='email' className='block text-sm font-medium text-gray-700 dark:text-gray-300'>
            Email
          </label>
          <input
            id='email'
            type='email'
            value={user?.email || ""}
            disabled
            className='mt-1 block w-full px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-md shadow-sm bg-gray-50 dark:bg-gray-700 text-gray-500 dark:text-gray-400 sm:text-sm'
          />
        </div>

        {/* Phone Number */}
        <div>
          <label htmlFor='phone_number' className='block text-sm font-medium text-gray-700 dark:text-gray-300'>
            Phone Number
          </label>
          <input
            id='phone_number'
            name='phone_number'
            type='tel'
            value={formData.phone_number}
            onChange={handleChange}
            placeholder='+1 (555) 123-4567'
            className='mt-1 block w-full px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-md shadow-sm focus:outline-none focus:ring-indigo-500 focus:border-indigo-500 sm:text-sm bg-white dark:bg-gray-800 text-gray-900 dark:text-gray-100'
          />
        </div>

        {/* First Name */}
        <div>
          <label htmlFor='first_name' className='block text-sm font-medium text-gray-700 dark:text-gray-300'>
            First Name <span className='text-red-500'>*</span>
          </label>
          <input
            id='first_name'
            name='first_name'
            type='text'
            required
            value={formData.first_name}
            onChange={handleChange}
            className='mt-1 block w-full px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-md shadow-sm focus:outline-none focus:ring-indigo-500 focus:border-indigo-500 sm:text-sm bg-white dark:bg-gray-800 text-gray-900 dark:text-gray-100'
          />
        </div>

        {/* Last Name */}
        <div>
          <label htmlFor='last_name' className='block text-sm font-medium text-gray-700 dark:text-gray-300'>
            Last Name <span className='text-red-500'>*</span>
          </label>
          <input
            id='last_name'
            name='last_name'
            type='text'
            required
            value={formData.last_name}
            onChange={handleChange}
            className='mt-1 block w-full px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-md shadow-sm focus:outline-none focus:ring-indigo-500 focus:border-indigo-500 sm:text-sm bg-white dark:bg-gray-800 text-gray-900 dark:text-gray-100'
          />
        </div>

        {/* Designation */}
        <div>
          <label htmlFor='designation' className='block text-sm font-medium text-gray-700 dark:text-gray-300'>
            Job Title / Designation
          </label>
          <input
            id='designation'
            name='designation'
            type='text'
            value={formData.designation}
            onChange={handleChange}
            placeholder='e.g. Software Engineer'
            className='mt-1 block w-full px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-md shadow-sm focus:outline-none focus:ring-indigo-500 focus:border-indigo-500 sm:text-sm bg-white dark:bg-gray-800 text-gray-900 dark:text-gray-100'
          />
        </div>

        {/* Date of Birth */}
        <div>
          <label htmlFor='date_of_birth' className='block text-sm font-medium text-gray-700 dark:text-gray-300'>
            Date of Birth
          </label>
          <input
            id='date_of_birth'
            name='date_of_birth'
            type='date'
            value={formData.date_of_birth}
            onChange={handleChange}
            max={new Date().toISOString().split("T")[0]} // Prevent future dates
            className='mt-1 block w-full px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-md shadow-sm focus:outline-none focus:ring-indigo-500 focus:border-indigo-500 sm:text-sm bg-white dark:bg-gray-800 text-gray-900 dark:text-gray-100'
          />
        </div>

        {/* Avatar URL */}
        <div className='sm:col-span-2'>
          <label htmlFor='avatar_url' className='block text-sm font-medium text-gray-700 dark:text-gray-300'>
            Avatar URL
          </label>
          <div className='mt-1 flex rounded-md shadow-sm'>
            <input
              id='avatar_url'
              name='avatar_url'
              type='url'
              value={formData.avatar_url}
              onChange={handleChange}
              placeholder='https://example.com/avatar.jpg'
              className='flex-1 block w-full px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-l-md shadow-sm focus:outline-none focus:ring-indigo-500 focus:border-indigo-500 sm:text-sm bg-white dark:bg-gray-800 text-gray-900 dark:text-gray-100'
            />
            {formData.avatar_url && (
              <div className='inline-flex items-center px-3 border border-l-0 border-gray-300 dark:border-gray-600 bg-gray-50 dark:bg-gray-700 rounded-r-md'>
                <Image
                  src={formData.avatar_url}
                  alt='Avatar preview'
                  className='h-8 w-8 rounded-full object-cover'
                  width={32}
                  height={32}
                  onError={(e) => {
                    e.currentTarget.style.display = "none";
                  }}
                />
              </div>
            )}
          </div>
        </div>

        {/* Address Section */}
        <div className='sm:col-span-2 space-y-4 border border-gray-200 dark:border-gray-700 p-4 rounded-md bg-gray-50 dark:bg-gray-800'>
          <h3 className='text-sm font-medium text-gray-700 dark:text-gray-300 flex items-center'>
            <svg className='w-4 h-4 mr-2' fill='none' stroke='currentColor' viewBox='0 0 24 24'>
              <path strokeLinecap='round' strokeLinejoin='round' strokeWidth={2} d='M17.657 16.657L13.414 20.9a1.998 1.998 0 01-2.827 0l-4.244-4.243a8 8 0 1111.314 0z' />
              <path strokeLinecap='round' strokeLinejoin='round' strokeWidth={2} d='M15 11a3 3 0 11-6 0 3 3 0 016 0z' />
            </svg>
            Address Information
          </h3>

          <div className='grid grid-cols-1 gap-4 sm:grid-cols-2'>
            <div className='sm:col-span-2'>
              <label htmlFor='address_street' className='block text-sm font-medium text-gray-700 dark:text-gray-300'>
                Street Address
              </label>
              <input
                id='address_street'
                type='text'
                value={formData.address?.street || ""}
                onChange={(e) => handleAddressChange("street", e.target.value)}
                placeholder='123 Main Street'
                className='mt-1 block w-full px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-md shadow-sm focus:outline-none focus:ring-indigo-500 focus:border-indigo-500 sm:text-sm bg-white dark:bg-gray-800 text-gray-900 dark:text-gray-100'
              />
            </div>

            <div>
              <label htmlFor='address_city' className='block text-sm font-medium text-gray-700 dark:text-gray-300'>
                City
              </label>
              <input
                id='address_city'
                type='text'
                value={formData.address?.city || ""}
                onChange={(e) => handleAddressChange("city", e.target.value)}
                placeholder='New York'
                className='mt-1 block w-full px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-md shadow-sm focus:outline-none focus:ring-indigo-500 focus:border-indigo-500 sm:text-sm bg-white dark:bg-gray-800 text-gray-900 dark:text-gray-100'
              />
            </div>

            <div>
              <label htmlFor='address_state' className='block text-sm font-medium text-gray-700 dark:text-gray-300'>
                State/Province
              </label>
              <input
                id='address_state'
                type='text'
                value={formData.address?.state || ""}
                onChange={(e) => handleAddressChange("state", e.target.value)}
                placeholder='NY'
                className='mt-1 block w-full px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-md shadow-sm focus:outline-none focus:ring-indigo-500 focus:border-indigo-500 sm:text-sm bg-white dark:bg-gray-800 text-gray-900 dark:text-gray-100'
              />
            </div>

            <div>
              <label htmlFor='address_postal_code' className='block text-sm font-medium text-gray-700 dark:text-gray-300'>
                Postal Code
              </label>
              <input
                id='address_postal_code'
                type='text'
                value={formData.address?.zip_code || ""}
                onChange={(e) => handleAddressChange("zip_code", e.target.value)}
                placeholder='10001'
                className='mt-1 block w-full px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-md shadow-sm focus:outline-none focus:ring-indigo-500 focus:border-indigo-500 sm:text-sm bg-white dark:bg-gray-800 text-gray-900 dark:text-gray-100'
              />
            </div>

            <div>
              <label htmlFor='address_country' className='block text-sm font-medium text-gray-700 dark:text-gray-300'>
                Country
              </label>
              <input
                id='address_country'
                type='text'
                value={formData.address?.country || ""}
                onChange={(e) => handleAddressChange("country", e.target.value)}
                placeholder='United States'
                className='mt-1 block w-full px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-md shadow-sm focus:outline-none focus:ring-indigo-500 focus:border-indigo-500 sm:text-sm bg-white dark:bg-gray-800 text-gray-900 dark:text-gray-100'
              />
            </div>
          </div>
        </div>
      </div>

      {/* Form Actions */}
      <div className='flex justify-between items-center pt-4 border-t border-gray-200 dark:border-gray-700'>
        <div className='text-sm text-gray-500 dark:text-gray-400'>{isDirty && <span className='text-orange-600 dark:text-orange-400'> Unsaved changes</span>}</div>
        <div className='flex space-x-3'>
          <button onClick={() => router.back()} className='px-4 py-2 text-sm font-medium text-gray-700 dark:text-gray-300 bg-white dark:bg-gray-700 border border-gray-300 dark:border-gray-600 rounded-md hover:bg-gray-50 dark:hover:bg-gray-600 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-indigo-500'>
            Close
          </button>
          <button
            type='button'
            onClick={resetForm}
            disabled={!isDirty || updatePending}
            className='px-4 py-2 text-sm font-medium text-gray-700 dark:text-gray-300 bg-white dark:bg-gray-700 border border-gray-300 dark:border-gray-600 rounded-md hover:bg-gray-50 dark:hover:bg-gray-600 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-indigo-500 disabled:opacity-50 disabled:cursor-not-allowed'>
            Reset
          </button>
          <button
            type='submit'
            disabled={!isDirty || updatePending}
            className='px-4 py-2 text-sm font-medium text-white bg-indigo-600 border border-transparent rounded-md hover:bg-indigo-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-indigo-500 disabled:opacity-50 disabled:cursor-not-allowed flex items-center'>
            {updatePending && (
              <svg className='animate-spin -ml-1 mr-2 h-4 w-4 text-white' fill='none' viewBox='0 0 24 24'>
                <circle className='opacity-25' cx='12' cy='12' r='10' stroke='currentColor' strokeWidth='4' />
                <path className='opacity-75' fill='currentColor' d='M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z' />
              </svg>
            )}
            {updatePending ? "Updating..." : "Update Profile"}
          </button>
        </div>
      </div>
    </form>
  );
}

```

<!-- path: app/manifest.ts -->
```typescript
import type { MetadataRoute } from "next";
 
export default function manifest(): MetadataRoute.Manifest {
  return {
    name: "Harinavi Transmission Maintenance",
    short_name: "Harinavi Database App",
    description:
      "Complete records management system for Harinavi Transmission maintenance",
    start_url: "/",
    display: "standalone",
    background_color: "#ffffff",
    theme_color: "#000000",
    orientation: "portrait-primary",
    icons: [
      {
        src: "/icon-192x192.png",
        sizes: "192x192",
        type: "image/png",
        purpose: "maskable",
      },
      {
        src: "/icon-256x256.png",
        sizes: "256x256",
        type: "image/png",
      },
      {
        src: "/icon-384x384.png",
        sizes: "384x384",
        type: "image/png",
      },
      {
        src: "/icon-512x512.png",
        sizes: "512x512",
        type: "image/png",
        purpose: "maskable",
      },
    ],
    categories: ["productivity", "business"],
    screenshots: [
      {
        src: "/screenshot-wide.png",
        sizes: "1280x720",
        type: "image/png",
        form_factor: "wide",
      },
      {
        src: "/screenshot-narrow.png",
        sizes: "750x1334",
        type: "image/png",
        form_factor: "narrow",
      },
    ],
  };
}
```

<!-- path: app/globals.css -->
```css
@import "tailwindcss";

@custom-variant dark (&:where([class=dark], [class=dark] *));

:root {
  --background: #ffffff;
  --foreground: #171717;
}

@theme inline {
  --color-background: var(--background);
  --color-foreground: var(--foreground);
  --font-sans: var(--font-geist-sans);
  --font-mono: var(--font-geist-mono);
}


/* Smooth transitions for interactive elements */
button,
a {
  transition: opacity 0.15s ease-in-out, transform 0.15s ease-in-out;
}

/* Loading state transitions */
[data-loading='true'] {
  opacity: 0.8;
  transform: translateY(1px);
}

.dark {
  --background: #0a0a0a;
  --foreground: #ededed;
  input[type="date"]::-webkit-calendar-picker-indicator {
    filter: invert(1);
  }
}

body {
  background: var(--background);
  color: var(--foreground);
  font-family: var(--font-sans);
  overflow-x: hidden;
}

/* Ensure react-datepicker popper appears above modals/overlays */
.react-datepicker-popper {
  z-index: 9999 !important;
}
```

<!-- path: middleware.ts -->
```typescript
import { type NextRequest } from "next/server";
import { updateSession } from "@/utils/supabase/middleware";

export async function middleware(request: NextRequest) {
  // update user's auth session
  return await updateSession(request);
}

export const config = {
  matcher: [
    /*
     * Match all request paths except the landing page `/`, `/login`, `/signup` and for the ones starting with:
     * - _next/static (static files)
     * - _next/image (image optimization files)
     * - favicon.ico (favicon file)
     * Feel free to modify this pattern to include more paths.
     */
    "/((?!_next/static|_next/image|favicon\\.ico|.*\\.(?:svg|png|jpg|jpeg|gif|webp)$|^$|^login$|^signup$).*)",
  ],
};

```

<!-- path: package.json -->
```json
{
  "name": "hnvtx",
  "version": "0.1.0",
  "private": true,
  "scripts": {
    "dev": "next dev --turbopack",
    "cleandev": "rm -rf .next node_modules && npm install && next dev --turbopack",
    "build": "next build",
    "start": "next start",
    "lint": "next lint",
    "gitpush": "git add . && git commit -m \"$(date +'%Y-%m-%d %H:%M:%S')\" && git push",
    "find-unused": "node scripts/find-unused-files.js",
    "supabase": "supabase",
    "gen:types": "supabase gen types typescript --project-id mnnttnrgafkymejqpjhw --schema public,auth > types/supabase-types.ts",
    "gen:flattened": "tsx scripts/generate-flattened-types.ts",
    "gen:zod": "tsx scripts/generate-zod-schemas.ts",
    "gen:all": "npm run gen:types && npm run gen:flattened && npm run gen:zod",
    "debug:script": "dotenv -e .env node scripts/debug-connection.js",
    "push:migrations": "dotenv -e .env node scripts/push-sql.js data/migrations/",
    "push:seeds": "dotenv -e .env node scripts/push-sql.js data/seeds/",
    "push:setup": "dotenv -e .env node scripts/push-sql.js data/migrations/00_setup/",
    "push:users": "dotenv -e .env node scripts/push-sql.js data/migrations/01_user_management/",
    "push:core": "dotenv -e .env node scripts/push-sql.js data/migrations/02_core_infrastructure/",
    "push:systems": "dotenv -e .env node scripts/push-sql.js data/migrations/03_network_systems/",
    "push:ofc": "dotenv -e .env node scripts/push-sql.js data/migrations/04_advanced_ofc/",
    "push:audit": "dotenv -e .env node scripts/push-sql.js data/migrations/05_auditing/",
    "push:util": "dotenv -e .env node scripts/push-sql.js data/migrations/06_utilities/",
    "push:final": "dotenv -e .env node scripts/push-sql.js data/migrations/99_finalization/",
    "push:sql": "dotenv -e .env node scripts/push-sql.js"
  },
  "dependencies": {
    "@dnd-kit/core": "^6.3.1",
    "@dnd-kit/sortable": "^10.0.0",
    "@dnd-kit/utilities": "^3.2.2",
    "@hookform/resolvers": "^5.2.1",
    "@radix-ui/react-select": "^2.2.6",
    "@radix-ui/react-tabs": "^1.1.13",
    "@supabase/ssr": "^0.6.1",
    "@supabase/supabase-js": "^2.56.0",
    "@tanstack/react-query": "^5.85.5",
    "@tanstack/react-query-devtools": "^5.85.1",
    "@types/bcrypt": "^6.0.0",
    "@types/pg": "^8.15.5",
    "@uppy/core": "^5.0.1",
    "@uppy/dashboard": "^5.0.1",
    "@uppy/drag-drop": "^5.0.1",
    "@uppy/react": "^5.0.2",
    "@uppy/webcam": "^5.0.0",
    "@uppy/xhr-upload": "^5.0.0",
    "bcrypt": "^6.0.0",
    "class-variance-authority": "^0.7.1",
    "clsx": "^2.1.1",
    "core-js": "^3.45.0",
    "exceljs": "^4.4.0",
    "framer-motion": "^12.23.12",
    "intersection-observer": "^0.12.2",
    "lodash.isequal": "^4.5.0",
    "lucide-react": "^0.541.0",
    "next": "^15.4.4",
    "papaparse": "^5.5.3",
    "pg": "^8.16.3",
    "react": "^19.1.0",
    "react-datepicker": "^8.7.0",
    "react-dom": "^19.1.0",
    "react-hook-form": "^7.62.0",
    "react-icons": "^5.5.0",
    "react-leaflet": "^5.0.0",
    "react-select": "^5.10.2",
    "regenerator-runtime": "^0.14.1",
    "sonner": "^2.0.7",
    "tailwind-merge": "^3.3.1",
    "url-polyfill": "^1.1.13",
    "use-debounce": "^10.0.5",
    "web-push": "^3.6.7",
    "whatwg-fetch": "^3.6.20",
    "xlsx": "^0.18.5",
    "zod": "^4.1.5",
    "zustand": "^5.0.7"
  },
  "devDependencies": {
    "@eslint/eslintrc": "^3.3.1",
    "@tailwindcss/postcss": "^4.1.11",
    "@tanstack/eslint-plugin-query": "^5.83.1",
    "@types/estree": "^1.0.8",
    "@types/json-schema": "^7.0.15",
    "@types/lodash": "^4.17.20",
    "@types/lodash.isequal": "^4.5.8",
    "@types/node": "^20.19.17",
    "@types/papaparse": "^5.3.16",
    "@types/prismjs": "^1.26.5",
    "@types/react": "^19.1.10",
    "@types/react-dom": "^19.1.7",
    "@types/uuid": "^10.0.0",
    "@types/web-push": "^3.6.4",
    "dotenv-cli": "^10.0.0",
    "eslint": "^9.33.0",
    "eslint-config-next": "^15.4.4",
    "eslint-formatter-compact": "^8.40.0",
    "prism-react-renderer": "^2.4.1",
    "supabase": "^2.45.5",
    "tailwindcss": "^4.1.11",
    "tsx": "^4.20.5",
    "tw-animate-css": "^1.3.7",
    "typescript": "^5.9.2"
  }
}

```

<!-- path: config/employee-details-config.tsx -->
```typescript
// ==== EMPLOYEE DETAILS MODAL CONFIGURATION ====
import { 
    DetailsModal, 
    defaultFormatters, 
    type HeaderConfig, 
    type SectionConfig 
  } from '@/components/common/ui/Modal/DetailsModal';
  import { 
    FiUser, 
    FiPhone, 
    FiMail, 
    FiBriefcase, 
    FiCalendar, 
    FiClock, 
    FiMapPin, 
    FiInfo 
  } from "react-icons/fi";
  import { StatusBadge } from "@/components/common/ui/badges/StatusBadge";
  
  // Employee details modal configuration
  export const employeeDetailsConfig = {
    header: {
      title: (emp: any) => emp.employee_name || "Unnamed Employee",
      subtitle: (emp: any) => emp.employee_pers_no || "No Personnel No.",
      avatar: {
        urlKey: '', // employees dont have avatars
        fallbackText: (emp: any) => (emp.employee_name?.charAt(0)?.toUpperCase() || "?")
      },
      badges: [
        {
          key: 'employee_designations.name',
          component: (designation: string) => designation ? (
            <span className="px-3 py-1 text-xs font-semibold bg-blue-100 text-blue-800 rounded-full dark:bg-blue-900 dark:text-blue-200">
              {designation}
            </span>
          ) : null
        },
        {
          key: 'status',
          component: (status: boolean) => (
            <StatusBadge status={status ? "ACTIVE" : "INACTIVE"} />
          )
        }
      ]
    } as HeaderConfig,
  
    sections: [
      {
        title: "Personal Information",
        icon: <FiUser size={20} />,
        fields: [
          { key: 'employee_name', label: 'Full Name', icon: <FiUser size={18} /> },
          { key: 'employee_pers_no', label: 'Personnel No.', icon: <FiInfo size={18} /> },
          { key: 'employee_contact', label: 'Contact No.', icon: <FiPhone size={18} /> },
          { 
            key: 'employee_email', 
            label: 'Email Address', 
            icon: <FiMail size={18} />, 
            formatter: (email: string, data: any) => email || "Not Provided" 
          },
          { 
            key: 'employee_dob', 
            label: 'Date of Birth', 
            icon: <FiCalendar size={18} />, 
            formatter: defaultFormatters.date 
          },
          { 
            key: 'employee_doj', 
            label: 'Date of Joining', 
            icon: <FiCalendar size={18} />, 
            formatter: defaultFormatters.date 
          }
        ]
      },
      {
        title: "Employment Details",
        icon: <FiBriefcase size={20} />,
        fields: [
          { 
            key: 'employee_designations.name', 
            label: 'Designation', 
            icon: <FiBriefcase size={18} /> 
          },
          { 
            key: 'maintenance_terminal_id', 
            label: 'Maintenance Terminal ID', 
            icon: <FiInfo size={18} /> 
          },
          { 
            key: 'remark', 
            label: 'Remark', 
            icon: <FiInfo size={18} /> 
          }
        ]
      },
      {
        title: "Address",
        icon: <FiMapPin size={20} />,
        condition: (emp: any) => !!emp.employee_addr,
        renderCustom: (emp: any) => (
          <div className=" bg-gray-50 dark:bg-gray-800 p-6 rounded-2xl border border-gray-200 dark:border-gray-700">
            <p className="text-gray-900 dark:text-white font-medium text-lg leading-relaxed">
              {emp.employee_addr}
            </p>
          </div>
        )
      },
      {
        title: "Timestamps",
        icon: <FiCalendar size={20} />,
        fields: [
          { key: 'created_at', label: 'Created At', icon: <FiCalendar size={18} />, formatter: defaultFormatters.dateTime },
          { key: 'updated_at', label: 'Updated At', icon: <FiClock size={18} />, formatter: defaultFormatters.dateTime }
        ]
      }
    ] as SectionConfig[]
  };
  
  export const EmployeeDetailsModal = ({ employee, onClose, isOpen }: { employee: any, onClose: () => void, isOpen: boolean }) => {
    return (
      <DetailsModal
        data={employee}
        onClose={onClose}
        isOpen={isOpen}
        config={employeeDetailsConfig}
      />
    );
  };
  
```

<!-- path: config/areas.ts -->
```typescript
// config/designations.ts

import { EntityConfig } from "@/components/common/entity-management/types";
import { FiBriefcase } from "react-icons/fi";
import { Tables, TablesInsert } from "@/types/supabase-types";

// --- TYPE DEFINITIONS ---
export type MaintenanceArea = Tables<"maintenance_areas">;

export type AreaType = Tables<"lookup_types">;

export interface MaintenanceAreaWithRelations extends MaintenanceArea {
  area_type: AreaType | null;
  parent_area: MaintenanceAreaWithRelations | null;
  child_areas: MaintenanceAreaWithRelations[];
}

export interface DeleteProps {
  tableName: string;
  onSuccess?: () => void;
}

export interface AreaFormModalProps {
  isOpen: boolean;
  onClose: () => void;
  onSubmit: (data: TablesInsert<"maintenance_areas">) => void;
  area: MaintenanceAreaWithRelations | null;
  allAreas: MaintenanceArea[];
  areaTypes: AreaType[];
  isLoading: boolean;
}

export interface DetailItemProps {
  label: string;
  value: string | null | undefined;
  icon?: React.ReactNode;
}

export const areaConfig: EntityConfig<MaintenanceAreaWithRelations> = {
  entityName: 'area',
  entityDisplayName: 'Area',
  entityPluralName: 'Areas',
  parentField: 'parent_area',
  icon: FiBriefcase,
  isHierarchical: true,
  searchFields: ['name'],
  detailFields: [
    { key: 'name', label: 'Name', type: 'text' },
    { key: 'status', label: 'Status', type: 'status' },
    { 
      key: 'parent_area', 
      label: 'Parent Area', 
      type: 'parent' 
    },
    { key: 'created_at', label: 'Created At', type: 'date' },
  ],
  filterOptions: [
    {
      key: 'status',
      label: 'Status',
      type: 'select',
      options: [
        { value: '', label: 'All Status' },
        { value: 'true', label: 'Active' },
        { value: 'false', label: 'Inactive' },
      ],
    },
  ],
};
```

<!-- path: config/column-orders.ts -->
```typescript
export const desiredCpanConnectionColumnOrder = [
    "customer_name",
    "bandwidth_allocated_mbps",
    "sfp_type_id",
    "sfp_capacity",
    "sfp_port",
    "sfp_serial_no",
    "fiber_in",
    "fiber_out",
    "system_connection_id",
  ];
  
  export const desiredCpanSystemColumnOrder = [
    "area",
    "ring_no",
    "system_id",
  ];
  
  export const desiredEmployeeDesignationColumnOrder = [
    "name",
    "parent_id",
    "status",
    "created_at",
    "updated_at",
    "id",
  ];
  
  export const desiredEmployeeColumnOrder = [
    "employee_name",
    "employee_pers_no",
    "employee_designation_id",
    "employee_contact",
    "employee_email",
    "employee_addr",
    "employee_dob",
    "employee_doj",
    "maintenance_terminal_id",
    "remark",
    "status",
    "created_at",
    "updated_at",
    "id",
  ];
  
  export const desiredFiberJointConnectionColumnOrder = [
    "joint_id",
    "input_ofc_id",
    "input_fiber_no",
    "output_ofc_id",
    "output_fiber_no",
    "splice_loss_db",
    "logical_path_id",
    "created_at",
    "updated_at",
    "id",
  ];
  
  export const desiredFiberJointColumnOrder = [
    "joint_name",
    "joint_category",
    "joint_type",
    "installed_date",
    "node_id",
    "maintenance_area_id",
    "location_description",
    "latitude",
    "longitude",
    "remark",
    "status",
    "created_at",
    "updated_at",
    "id",
  ];
  
  export const desiredLogicalFiberPathColumnOrder = [
    "path_name",
    "path_category",
    "path_type",
    "source_system_id",
    "destination_system_id",
    "source_port",
    "destination_port",
    "operational_status_category",
    "operational_status",
    "service_type",
    "bandwidth_gbps",
    "wavelength_nm",
    "total_distance_km",
    "total_loss_db",
    "commissioned_date",
    "remark",
    "created_at",
    "updated_at",
    "id",
  ];
  
  export const desiredLookupTypeColumnOrder = [
    "category",
    "name",
    "code",
    "description",
    "sort_order",
    "is_system_default",
    "status",
    "created_at",
    "updated_at",
    "id",
  ];
  
  export const desiredMaanConnectionColumnOrder = [
    "customer_name",
    "bandwidth_allocated_mbps",
    "sfp_type_id",
    "sfp_capacity",
    "sfp_port",
    "sfp_serial_no",
    "fiber_in",
    "fiber_out",
    "system_connection_id",
  ];
  
  export const desiredMaanSystemColumnOrder = [
    "area",
    "ring_no",
    "system_id",
  ];
  
  export const desiredMaintenanceAreaColumnOrder = [
    "name",
    "area_type_id",
    "code",
    "parent_id",
    "address",
    "contact_person",
    "contact_number",
    "email",
    "latitude",
    "longitude",
    "status",
    "created_at",
    "updated_at",
    "id",
  ];
  
  export const desiredManagementPortColumnOrder = [
    "port_no",
    "name",
    "system_id",
    "node_id",
    "commissioned_on",
    "remark",
    "status",
    "created_at",
    "updated_at",
    "id",
  ];
  
  export const desiredNodeColumnOrder = [
    "name",
    "node_type_id",
    "maintenance_terminal_id",
    "latitude",
    "longitude",
    "remark",
    "status",
    "created_at",
    "updated_at",
    "id",
  ];
  
  export const desiredOfcCableColumnOrder = [
    "route_name",
    "ofc_type_id",
    "capacity",
    "ofc_owner_id",
    "sn_id",
    "en_id",
    "transnet_id",
    "transnet_rkm",
    "current_rkm",
    "maintenance_terminal_id",
    "asset_no",
    "commissioned_on",
    "remark",
    "status",
    "created_at",
    "updated_at",
    "id",
  ];
  
  export const desiredOfcConnectionColumnOrder = [
    "ofc_id",
    "connection_category",
    "connection_type",
    "system_id",
    "fiber_no_sn",
    "fiber_no_en",
    "source_port",
    "destination_port",
    "sn_power_dbm",
    "en_power_dbm",
    "route_loss_db",
    "sn_dom",
    "en_dom",
    "otdr_distance_sn_km",
    "otdr_distance_en_km",
    "logical_path_id",
    "path_segment_order",
    "remark",
    "status",
    "created_at",
    "updated_at",
    "id",
  ];
  
  // "id", "created_at", "updated_at","active_count","inactive_count","maintenance_area_area_type_id","maintenance_area_code","maintenance_area_contact_number","maintenance_area_contact_person","maintenance_area_created_at","maintenance_area_email","maintenance_area_latitude","maintenance_area_longitude","maintenance_area_parent_id","maintenance_area_status","maintenance_area_updated_at","ring_type_category","ring_type_created_at","ring_type_id","ring_type_is_system_default","ring_type_name","ring_type_sort_order","ring_type_status","ring_type_updated_at","total_count","maintenance_terminal_id"
  export const desiredRingColumnOrder = [
    "name",
    "total_nodes",
    "maintenance_area_name",
    "ring_type_code",
    "description",
    "status",
    "created_at",
    "updated_at",
    "id",
  ];
  
  export const desiredSdhConnectionColumnOrder = [
    "stm_no",
    "carrier",
    "a_customer",
    "b_customer",
    "a_slot",
    "b_slot",
    "system_connection_id",
  ];
  
  export const desiredSdhNodeAssociationColumnOrder = [
    "sdh_system_id",
    "node_id",
    "node_position",
    "node_ip",
    "id",
  ];
  
  export const desiredSdhSystemColumnOrder = [
    "gne",
    "make",
    "system_id",
  ];
  
  export const desiredSystemConnectionColumnOrder = [
    "system_id",
    "connected_system_id",
    "media_type_id",
    "bandwidth_mbps",
    "sn_id",
    "sn_interface",
    "sn_ip",
    "en_id",
    "en_interface",
    "en_ip",
    "vlan",
    "commissioned_on",
    "remark",
    "status",
    "created_at",
    "updated_at",
    "id",
  ];
  
  export const desiredSystemColumnOrder = [
    "system_name",
    "system_type_id",
    "node_id",
    "s_no",
    "ip_address",
    "maintenance_terminal_id",
    "commissioned_on",
    "remark",
    "status",
    "created_at",
    "updated_at",
    "id",
  ];
  
  export const desiredUserActivityLogColumnOrder = [
    "user_id",
    "user_role",
    "action_type",
    "table_name",
    "record_id",
    "details",
    "old_data",
    "new_data",
    "created_at",
    "id",
  ];
  
  export const desiredUserProfileColumnOrder = [
    "first_name",
    "last_name",
    "designation",
    "phone_number",
    "email", // Assuming email will be derived from user_profiles_extended or similar
    "role",
    "status",
    "date_of_birth",
    "address",
    "avatar_url",
    "preferences",
    "created_at",
    "updated_at",
    "id",
  ];
  
  export const desiredVmuxConnectionColumnOrder = [
    "c_code",
    "subscriber",
    "channel",
    "tk",
    "system_connection_id",
  ];
  
  export const desiredVmuxSystemColumnOrder = [
    "vm_id",
    "system_id",
  ];
```

<!-- path: config/designations.ts -->
```typescript
// config/designations.ts

import { DesignationWithRelations } from "@/app/dashboard/designations/page";
import { EntityConfig } from "@/components/common/entity-management/types";
import { FiBriefcase } from "react-icons/fi";


export const designationConfig: EntityConfig<DesignationWithRelations> = {
  entityName: 'designation',
  entityDisplayName: 'Designation',
  entityPluralName: 'Designations',
  parentField: 'parent_designation',
  icon: FiBriefcase,
  isHierarchical: true,
  searchFields: ['name'],
  detailFields: [
    { key: 'name', label: 'Name', type: 'text' },
    { key: 'status', label: 'Status', type: 'status' },
    { 
      key: 'parent_designation', 
      label: 'Parent Designation', 
      type: 'parent' 
    },
    { key: 'created_at', label: 'Created At', type: 'date' },
  ],
  filterOptions: [
    {
      key: 'status',
      label: 'Status',
      type: 'select',
      options: [
        { value: '', label: 'All Status' },
        { value: 'true', label: 'Active' },
        { value: 'false', label: 'Inactive' },
      ],
    },
  ],
};
```

<!-- path: config/ofc-details-config.tsx -->
```typescript
// ==== OFC DETAILS MODAL CONFIGURATION ====
import { 
    DetailsModal, 
    defaultFormatters, 
    type HeaderConfig, 
    type SectionConfig 
  } from '@/components/common/ui/Modal/DetailsModal';
  import { 
    FiActivity,
    FiCalendar, 
    FiClock, 
    FiDatabase, 
    FiMapPin, 
    FiInfo,
    FiGitBranch,
    FiTool
  } from "react-icons/fi";
  import { StatusBadge } from "@/components/common/ui/badges/StatusBadge";
import { Row } from '@/hooks/database';
  
  // OFC details modal configuration
  export const ofcDetailsConfig = {
    header: {
      title: (ofc: Row<"v_ofc_cables_complete">) => ofc.route_name || "Unnamed OFC Route",
      subtitle: (ofc: Row<"v_ofc_cables_complete">) => ofc.ofc_owner_name || "Unknown Owner",
      avatar: {
        urlKey: '', // OFC doesnt have avatars
        fallbackText: (ofc: Row<"v_ofc_cables_complete">) => (ofc.ofc_owner_name?.charAt(0)?.toUpperCase() || "O")
      },
      badges: [
        {
          key: 'ofc_type_name',
          component: (type: string) => type ? (
            <span className="px-3 py-1 text-xs font-semibold bg-purple-100 text-purple-800 rounded-full dark:bg-purple-900 dark:text-purple-200">
              {type}
            </span>
          ) : null
        },
        {
          key: 'status',
          component: (status: boolean) => (
            <StatusBadge status={status ? "ACTIVE" : "INACTIVE"} />
          )
        }
      ]
    } as HeaderConfig,
  
    sections: [
      {
        title: "Route Information",
        icon: <FiGitBranch size={20} />,
        fields: [
          { key: 'route_name', label: 'Route Name', icon: <FiInfo size={18} /> },
          { key: 'asset_no', label: 'Asset No.', icon: <FiDatabase size={18} /> },
          { key: 'sn_id', label: 'SN ID', icon: <FiDatabase size={18} /> },
          { key: 'en_id', label: 'EN ID', icon: <FiDatabase size={18} /> },
          { key: 'transnet_id', label: 'Transnet ID', icon: <FiDatabase size={18} /> }
        ]
      },
      {
        title: "Capacity & Type",
        icon: <FiTool size={20} />,
        fields: [
          { key: 'capacity', label: 'Capacity (Fibers)', icon: <FiActivity size={18} /> },
          { key: 'ofc_type_name', label: 'OFC Type', icon: <FiTool size={18} /> },
          { key: 'ofc_type_code', label: 'OFC Type Code', icon: <FiTool size={18} /> }
        ]
      },
      {
        title: "Ownership & Maintenance",
        icon: <FiMapPin size={20} />,
        fields: [
          { key: 'ofc_owner_name', label: 'Owner', icon: <FiInfo size={18} /> },
          { key: 'ofc_owner_code', label: 'Owner Code', icon: <FiDatabase size={18} /> },
          { key: 'maintenance_area_name', label: 'Maintenance Area', icon: <FiMapPin size={18} /> },
          { key: 'maintenance_area_code', label: 'Area Code', icon: <FiDatabase size={18} /> },
          { key: 'maintenance_terminal_id', label: 'Maintenance Terminal ID', icon: <FiDatabase size={18} /> }
        ]
      },
      {
        title: "Length Information",
        icon: <FiActivity size={20} />,
        fields: [
          { key: 'current_rkm', label: 'Current RKM', icon: <FiActivity size={18} /> },
          { key: 'transnet_rkm', label: 'Transnet RKM', icon: <FiActivity size={18} /> }
        ]
      },
      {
        title: "Commissioning & Timestamps",
        icon: <FiCalendar size={20} />,
        fields: [
          { key: 'commissioned_on', label: 'Commissioned On', icon: <FiCalendar size={18} />, formatter: defaultFormatters.date },
          { key: 'created_at', label: 'Created At', icon: <FiCalendar size={18} />, formatter: defaultFormatters.dateTime },
          { key: 'updated_at', label: 'Updated At', icon: <FiClock size={18} />, formatter: defaultFormatters.dateTime }
        ]
      },
      {
        title: "Counts",
        icon: <FiDatabase size={20} />,
        fields: [
          { key: 'total_count', label: 'Total', icon: <FiDatabase size={18} /> },
          { key: 'active_count', label: 'Active', icon: <FiDatabase size={18} /> },
          { key: 'inactive_count', label: 'Inactive', icon: <FiDatabase size={18} /> }
        ]
      }
    ] as SectionConfig[]
  };
  
  export const OfcDetailsModal = ({ ofc, onClose, isOpen }: { ofc: Row<"v_ofc_connections_complete">[], onClose: () => void, isOpen: boolean }) => {
    return (
      <DetailsModal
        data={ofc}
        onClose={onClose}
        isOpen={isOpen}
        config={ofcDetailsConfig}
      />
    );
  };
  
```

<!-- path: config/helper-types.ts -->
```typescript
// config/helpers.ts

import { Database, Tables } from "@/types/supabase-types";
import { TABLES, VIEWS } from "@/config/table-column-keys";

// Database schema types
export type ViewName = keyof Database["public"]["Views"];
export type TableName = keyof Database["public"]["Tables"];

export type TableNames = keyof typeof TABLES;
export type ViewNames = keyof typeof VIEWS;

export type TableOrViewName = TableName | ViewName;

export type CurrentTableName = keyof typeof TABLES;

// A generic Row type helper that works for both tables and views
export type GenericRow<T extends TableOrViewName> = T extends TableName
  ? Tables<T>
  : T extends ViewName
  ? Database["public"]["Views"][T]["Row"]
  : never;

// This Mapped Type now correctly includes both Tables and Views.
export type AllColumnKeys = {
  [K in TableName]: (keyof Tables<K> & string)[];
} & {
  // Add a mapped type for Views. This merges the view keys into the type.
  [K in ViewName]: (keyof Database["public"]["Views"][K]["Row"] & string)[];
};



export type ExcelFormat =
  | "text"
  | "number"
  | "date"
  | "currency"
  | "percentage";
export type ColumnTransform = (value: unknown) => unknown;

export type ColumnMeta = {
  title?: string;
  excelHeader?: string;
  excelFormat?: ExcelFormat;
  transform?: ColumnTransform;
};

export type TableMetaMap = {
  [K in TableName]?: Partial<Record<keyof Tables<K> & string, ColumnMeta>>;
};

export type UploadTableMeta<T extends TableName> = {
  uploadType: "insert" | "upsert";
  conflictColumn?: keyof Tables<T> & string;
  isUploadEnabled?: boolean;
};

export type UploadMetaMap = {
  [K in TableName]?: UploadTableMeta<K>;
};

// export function toTitleCase(str: string): string {
//   return str
//     .replace(/_/g, " ")
//     .replace(/\w\S*/g, (w) => w.charAt(0).toUpperCase() + w.slice(1));
// }





```

<!-- path: config/node-details-config.tsx -->
```typescript
// ==== NODE DETAILS MODAL CONFIGURATION ====
import { 
  DetailsModal, 
  defaultFormatters, 
  type HeaderConfig, 
  type SectionConfig 
} from '@/components/common/ui/Modal/DetailsModal';
import { 
  FiCpu,
  FiCalendar, 
  FiClock, 
  FiMapPin, 
  FiDatabase, 
  FiServer,
  FiCode,
  FiInfo
} from "react-icons/fi";
import { StatusBadge } from "@/components/common/ui/badges/StatusBadge";
import { V_nodes_completeRowSchema } from '@/schemas/zod-schemas';

// Node details modal configuration
export const nodeDetailsConfig = {
  header: {
    title: (node: V_nodes_completeRowSchema) => node.name || "Unnamed Node",
    avatar: {
      urlKey: '', // nodes probably dont have avatars
      fallbackText: (node: V_nodes_completeRowSchema) => (node.name?.charAt(0)?.toUpperCase() || "?")
    },
    badges: [
      {
        key: 'node_type_name',
        component: (type: string) => type ? (
          <span className="px-3 py-1 text-xs font-semibold bg-green-100 text-green-800 rounded-full dark:bg-green-900 dark:text-green-200">
            {type}
          </span>
        ) : null
      },
      {
        key: 'ring_status',
        component: (status: string) => status ? (
          <StatusBadge status={status} />
        ) : null
      }
    ]
  } as HeaderConfig,

  sections: [
    {
      title: "Basic Information",
      icon: <FiCpu size={20} />,
      fields: [
        { key: 'name', label: 'Node Name', icon: <FiServer size={18} /> },
        { key: 'node_type_name', label: 'Node Type', icon: <FiCode size={18} /> },
        { key: 'remark', label: 'Remark', icon: <FiInfo size={18} /> },
      ]
    },
    {
      title: "Maintenance Area",
      icon: <FiMapPin size={20} />,
      fields: [
        { key: 'maintenance_area_code', label: 'Area Code', icon: <FiDatabase size={18} /> },
        { key: 'maintenance_area_name', label: 'Area Name', icon: <FiMapPin size={18} /> },
        { key: 'maintenance_area_type_name', label: 'Area Type', icon: <FiMapPin size={18} /> },
      ]
    },
    {
      title: "Geolocation",
      icon: <FiMapPin size={20} />,
      fields: [
        { key: 'latitude', label: 'Latitude', icon: <FiMapPin size={18} /> },
        { key: 'longitude', label: 'Longitude', icon: <FiMapPin size={18} /> },
      ]
    },
    {
      title: "Timestamps",
      icon: <FiCalendar size={20} />,
      fields: [
        { key: 'created_at', label: 'Created At', icon: <FiCalendar size={18} />, formatter: defaultFormatters.dateTime },
        { key: 'updated_at', label: 'Updated At', icon: <FiClock size={18} />, formatter: defaultFormatters.dateTime }
      ]
    }
  ] as SectionConfig[]
};

export const NodeDetailsModal = ({ node, onClose, isOpen }: { node: V_nodes_completeRowSchema, onClose: () => void, isOpen: boolean }) => {
  return (
    <DetailsModal
      data={node}
      onClose={onClose}
      isOpen={isOpen}
      config={nodeDetailsConfig}
    />
  );
};

```

<!-- path: config/table-columns/NodesTableColumns.tsx -->
```typescript
import { useDynamicColumnConfig } from '@/hooks/useColumnConfig';
import TruncateTooltip from '@/components/common/TruncateTooltip';
import { StatusBadge } from '@/components/common/ui';
import { V_nodes_completeRowSchema } from '@/schemas/zod-schemas';

export const NodesTableColumns = (data: V_nodes_completeRowSchema[]) => {
  return useDynamicColumnConfig('v_nodes_complete', {
    data: data,
    omit: [
      'node_type_id',
      'node_type_code',
      'maintenance_area_code',
      'id',
      'maintenance_terminal_id',
      'created_at',
      'updated_at',
      'total_count',
      'active_count',
      'inactive_count',
    ],
    overrides: {
      name: {
        render: (value: unknown) => {
          return (
            <TruncateTooltip
              text={(value as string) ?? ''}
              className="font-semibold"
            />
          );
        },
      },
      maintenance_area_name: {
        title: 'Maintenance Area',
        render: (_value: unknown, record: V_nodes_completeRowSchema) => {
          const rel = record.maintenance_area_name;
          return (
            <TruncateTooltip text={rel ?? 'N/A'} className="font-semibold" />
          );
        },
      },
      status: {
        render: (value: unknown) => {
          return <StatusBadge status={value as string} />;
        },
      },
    },
  });
};

```

<!-- path: config/table-columns/OfcDetailsTableColumns.tsx -->
```typescript
import { Row } from '@/hooks/database';
import { useDynamicColumnConfig } from '@/hooks/useColumnConfig';
import { formatDate } from '@/utils/formatters';

export const OfcDetailsTableColumns = (
  data: Row<'v_ofc_connections_complete'>[]
) => {
  return useDynamicColumnConfig('v_ofc_connections_complete', {
    data: data,

    omit: [
      'id',
      'ofc_id',
      'created_at',
      'updated_at',
      'sn_id',
      'en_id',
      'connection_category',
      // 'connection_type',
      'destination_port',
      'en_name',
      'logical_path_id',
      'path_segment_order',
      'sn_name',
      'source_port',
      'system_id',
      'system_name',
      'ofc_type_name',
      'ofc_route_name',
    ],
    overrides: {
      fiber_no_sn: { 
        title: 'End A Fiber', 
        sortable: true, 
        searchable: true,
        excelFormat: 'number',
        // render: (value) => {
        //   if (value === null || value === undefined) return '';
        //   return String(value);
        // }
      },
      fiber_no_en: { 
        title: 'End B Fiber', 
        sortable: true, 
        searchable: true,
        excelFormat: 'number',
        // render: (value) => {
        //   if (value === null || value === undefined) return '';
        //   return String(value);
        // }
      },
      otdr_distance_sn_km: {
        title: 'End A OTDR Distance (km)',
        sortable: true,
        searchable: true,
      },
      otdr_distance_en_km: {
        title: 'End B OTDR Distance (km)',
        sortable: true,
        searchable: true,
      },
      en_dom: { title: 'End B D.O.M.', sortable: true, width: '150px', searchable: true, render: (value) => formatDate(value as string, { format: 'dd-mm-yyyy' }) },
      en_power_dbm: {
        title: 'End B Power (dBm)',
        sortable: true,
        searchable: true,
      },
      sn_dom: { title: 'End A D.O.M.', sortable: true, width: '150px', searchable: true, render: (value) => formatDate(value as string, { format: 'dd-mm-yyyy' }) },
      sn_power_dbm: {
        title: 'End A Power (dBm)',
        sortable: true,
        searchable: true,
      },
      route_loss_db: {
        title: 'Route Loss (dB)',
        sortable: true,
        searchable: true,
      },
      connection_type: {
        title: 'Connection Type',
        sortable: true,
        searchable: true,
      },
      ofc_type_name: { title: 'Ofc Type', sortable: true, searchable: true },
      destination_port: {
        title: 'Destination Port',
        sortable: true,
        searchable: true,
      },
      logical_path_id: {
        title: 'Logical Path ID',
        sortable: true,
        searchable: true,
      },
      ofc_id: { title: 'OFC ID', sortable: true, searchable: true },
      path_segment_order: {
        title: 'Path Segment Order',
        sortable: true,
        searchable: true,
      },
      remark: { title: 'Remark', sortable: true, searchable: true },
      source_port: { title: 'Source Port', sortable: true, searchable: true },
      system_id: { title: 'System ID', sortable: true, searchable: true },
      updated_at: { title: 'Updated At', sortable: true, searchable: true },
      status: {
        title: 'Status',
        sortable: true,
        searchable: true,
        render: (value) => (
          <span
            className={`inline-flex items-center px-2.5 py-0.5 rounded-full text-xs font-medium ${
              value ? 'bg-green-100 text-green-800' : 'bg-red-100 text-red-800'
            }`}
          >
            {value ? 'Active' : 'Inactive'}
          </span>
        ),
      },
    },
  });
};

```

<!-- path: config/table-columns/UsersTableColumns.tsx -->
```typescript
import Image from 'next/image';
import {StatusBadge} from '@/components/common/ui/badges/StatusBadge';
import { useDynamicColumnConfig } from "@/hooks/useColumnConfig";
import { formatDate } from "@/utils/formatters";
import { RoleBadge } from '@/components/common/ui';
import { UserRole } from '@/types/user-roles';
import { renderKeyValueCell } from '@/utils/renderKeyValueCell';
import { UserProfileData } from '@/components/users/user-types';
import TruncateTooltip from '@/components/common/TruncateTooltip';

export const UserProfileColumns = (data:UserProfileData[]) => {
  return useDynamicColumnConfig("v_user_profiles_extended", {
    data:data,
    omit: ["id", "created_at", "updated_at", "auth_updated_at", "email_confirmed_at", "raw_user_meta_data", "raw_app_meta_data", "phone_confirmed_at", "first_name", "last_name", "is_phone_verified", "computed_status"],
    overrides: {
      last_sign_in_at: {
        render: (value) => {
          return formatDate(value as string, { format: "dd-mm-yyyy" });
        },
      },
      status: {
        render: (value) => {
          return <StatusBadge status={value as string} />;
        },
      },
      date_of_birth: {
        render: (value) => {
          return formatDate(value as string, { format: "dd-mm-yyyy" });
        },
      },
      avatar_url: {
        render: (value) => {
          return value ? (
            <><Image src={value as string} alt='Avatar' className='w-10 h-10 rounded-full' width={40} height={40} /> <TruncateTooltip text={value as string} className="font-semibold" /></>
          ) : (
            <><Image src='/default-avatar.png' alt='Avatar' className='w-10 h-10 rounded-full bg-gray-200 dark:bg-gray-700' width={40} height={40} /> <TruncateTooltip text={value as string} className="font-semibold" /></>
          );
        },
      },
      role: {
        render: (value) => {
          return <RoleBadge role={value as UserRole} />;
        },
      },
      address: {
        render: (value) => renderKeyValueCell(value),
      },
      preferences: {
        render: (value) => renderKeyValueCell(value),
      },
    },
  });
};
```

<!-- path: config/table-columns/RingsTableColumns.tsx -->
```typescript
import { StatusBadge } from "@/components/common/ui/badges/StatusBadge";
import { useDynamicColumnConfig } from "@/hooks/useColumnConfig";
import { TruncateTooltip } from "@/components/common/TruncateTooltip";
import { V_rings_with_countRowSchema } from "@/schemas/zod-schemas";

export const RingsColumns = (data: V_rings_with_countRowSchema[]) => {
  return useDynamicColumnConfig("v_rings_with_count", {
    data: data,
    omit: [
      "id",
      "created_at",
      "updated_at",
      "active_count",
      "inactive_count",
      "maintenance_area_area_type_id",
      "maintenance_area_code",
      "maintenance_area_contact_number",
      "maintenance_area_contact_person",
      "maintenance_area_created_at",
      "maintenance_area_email",
      "maintenance_area_latitude",
      "maintenance_area_longitude",
      "maintenance_area_parent_id",
      "maintenance_area_status",
      "maintenance_area_updated_at",
      "ring_type_category",
      "ring_type_created_at",
      "ring_type_id",
      "ring_type_is_system_default",
      "ring_type_name",
      "ring_type_sort_order",
      "ring_type_status",
      "ring_type_updated_at",
      "total_count",
      "maintenance_terminal_id",
    ],
    overrides: {
      name: {
        render: (value: unknown) => {
          return <TruncateTooltip text={(value as string) ?? ""} className='font-semibold' />;
        },
      },
      description: {
        title: "Description",
        render: (value: unknown) => {
          return <TruncateTooltip text={(value as string) ?? ""} className='font-semibold' />;
        },
      },
      total_nodes: {
        title: "Total Nodes",
        render: (value: unknown) => {
          return <span className='font-semibold'>{value as string}</span>;
        },
      },
      ring_type_code: {
        title: "Ring Type",
        render: (_value: unknown, record: V_rings_with_countRowSchema) => {
          const rel = record.ring_type_code;
          return <TruncateTooltip text={rel ?? "N/A"} className='font-semibold' />;
        },
      },
      maintenance_area_name: {
        title: "Maintenance Area",
        render: (_value: unknown, record: V_rings_with_countRowSchema) => {
          const rel = record.maintenance_area_name;
          return <TruncateTooltip text={rel ?? "N/A"} className='font-semibold' />;
        },
      },
      status: {
        render: (value: unknown) => {
          return <StatusBadge status={value as string} />;
        },
      },
    },
  });
};

```

<!-- path: config/table-columns/SystemsTableColumns.tsx -->
```typescript
import { Row } from '@/hooks/database';
import { useDynamicColumnConfig } from '@/hooks/useColumnConfig';
import TruncateTooltip from '@/components/common/TruncateTooltip';
import { StatusBadge } from '@/components/common/ui';
import { FiMapPin } from 'react-icons/fi';
import { formatDate } from '@/utils/formatters';

export const SystemsTableColumns = (data: Row<'v_systems_complete'>[]) => {
  return useDynamicColumnConfig('v_systems_complete', {
    data: data,
    omit: [
 
    ],
    overrides: {
      system_name:{
            key: "system_name",
            title: "Name",
            dataIndex: "system_name",
            sortable: true,
            searchable: true,
            filterable: true,
            width: 200,
            render: (value: unknown, record: Row<'v_systems_complete'>) => {
              const stringValue = value as string; // Type assertion since we know it will be a string
              return (
                <div className='flex flex-col'>
                  <span className='font-medium text-gray-900 dark:text-white'>{stringValue}</span>
                  <span className='text-xs text-gray-500 dark:text-gray-400'>S/N: {record.s_no}</span>
                </div>
              );
            },
          },
          system_type_name:{
            key: "system_type_name",
            title: "Type",
            dataIndex: "system_type_name",
            sortable: true,
            searchable: true,
            filterable: true,
            width: 150,
          },
          node_name:{
            key: "node_name",
            title: "Node / Location",
            dataIndex: "node_name",
            sortable: true,
            searchable: true,
            filterable: true,
            width: 150,
            render: (value) => (
              <div className="flex items-center gap-1">
                <FiMapPin className="h-3 w-3 text-gray-400" />
                <span>{value as string || "N/A"}</span>
              </div>
            ),
          },
          ip_address:{
            key: "ip_address",
            title: "IP Address",
            dataIndex: "ip_address",
            sortable: true,
            searchable: true,
            filterable: true,
            width: 150,
            render: (value: unknown) => (
              <code className="rounded bg-gray-100 px-2 py-1 text-sm dark:bg-gray-700">
                {value as string || "N/A"}
              </code>
            ),
          },
          status:{
            key: "status",
            title: "Status",
            dataIndex: "status",
            sortable: true,
            searchable: true,
            filterable: true,
            width: 150,
            render: (value) => <StatusBadge status={value as boolean} />
          },
          commissioned_on:{
            key: "commissioned_on",
            title: "Commissioned On",
            dataIndex: "commissioned_on",
            sortable: true,
            searchable: true,
            filterable: true,
            width: 150,
            render: (value) => formatDate(value as string, { format: 'dd-mm-yyyy' }),
          }
    },
  });
};

```

<!-- path: config/table-columns/OfcTableColumns.tsx -->
```typescript
import { Row } from '@/hooks/database';
import { useDynamicColumnConfig } from '@/hooks/useColumnConfig';
import TruncateTooltip from '@/components/common/TruncateTooltip';
import { StatusBadge } from '@/components/common/ui';
import { formatDate } from '@/utils/formatters';

export const OfcTableColumns = (data: Row<'v_ofc_cables_complete'>[]) => {
  return useDynamicColumnConfig('v_ofc_cables_complete', {
    data: data,

    omit: [
      'active_count',
      'created_at',
      'en_id',
      'id',
      'inactive_count',
      'maintenance_area_name',
      'maintenance_terminal_id',
      'ofc_owner_id',
      'ofc_owner_name',
      'ofc_type_id',
      'ofc_type_name',
      'sn_id',
      'total_count',
      'updated_at',
      'status'
    ],
    overrides: {
      asset_no: {
        render: (value: unknown) => {
          return (
            <TruncateTooltip
              text={(value as string) ?? ''}
              className="font-semibold"
            />
          );
        },
      },
      route_name: {
        title: 'Route',
        render: (_value: unknown, record: Row<'v_ofc_cables_complete'>) => {
          const rel = record.route_name;
          return (
            <TruncateTooltip text={rel ?? 'N/A'} className="font-semibold" />
          );
        },
      },
      maintenance_area_name: {
        title: 'Maintenance Area',
        render: (_value: unknown, record: Row<'v_ofc_cables_complete'>) => {
          const rel = record.maintenance_area_name;
          return (
            <TruncateTooltip text={rel ?? 'N/A'} className="font-semibold" />
          );
        },
      },
      commissioned_on: {
        render: (value: unknown) => {
          return formatDate(value as string, { format: 'dd-mm-yyyy' });
        },
      },
      status: {
        render: (value: unknown) => {
          return <StatusBadge status={value as string} />;
        },
      },
    },
  });
};

```

<!-- path: config/helper-functions.ts -->
```typescript
// Helper: normalize various Excel/CSV date representations to 'YYYY-MM-DD' or null
export const toPgDate = (value: unknown): string | null => {
  if (value === null || value === undefined) return null;
  // Treat empty string as null to avoid Postgres date parse errors
  if (typeof value === "string") {
    const v = value.trim();
    if (v === "") return null;
    // If already in YYYY-MM-DD, return as-is
    if (/^\d{4}-\d{2}-\d{2}$/.test(v)) return v;

    // If the string is a numeric-like Excel serial, treat it as such
    if (/^\d+(?:\.\d+)?$/.test(v)) {
      const num = parseFloat(v);
      if (!isNaN(num)) {
        const ms = Math.round((num - 25569) * 86400 * 1000);
        const d = new Date(ms);
        if (!isNaN(d.getTime())) {
          const yyyy = d.getFullYear();
          const mm = String(d.getMonth() + 1).padStart(2, "0");
          const dd = String(d.getDate()).padStart(2, "0");
          return `${yyyy}-${mm}-${dd}`;
        }
      }
    }

    // Handle common D/M/Y or M/D/Y with optional time "DD/MM/YYYY HH:MM:SS" or "MM/DD/YYYY HH:MM:SS"
    const dmYTime =
      /^(\d{1,2})\/(\d{1,2})\/(\d{4})(?:[ T](\d{1,2}):(\d{2})(?::(\d{2}))?)?$/;
    const match = v.match(dmYTime);
    if (match) {
      const d1 = parseInt(match[1], 10);
      const d2 = parseInt(match[2], 10);
      const yyyy = parseInt(match[3], 10);
      // Disambiguate: if first part > 12 -> DD/MM/YYYY; if second part > 12 -> MM/DD/YYYY; otherwise assume DD/MM/YYYY (common in India)
      const isDMY = d1 > 12 || (d2 <= 12 && d1 <= 12);
      const dd = String(isDMY ? d1 : d2).padStart(2, "0");
      const mm = String(isDMY ? d2 : d1).padStart(2, "0");
      return `${yyyy}-${mm}-${dd}`;
    }

    // Fallback to Date parsing for other formats
    const d = new Date(v);
    if (!isNaN(d.getTime())) {
      const yyyy = d.getFullYear();
      const mm = String(d.getMonth() + 1).padStart(2, "0");
      const dd = String(d.getDate()).padStart(2, "0");
      return `${yyyy}-${mm}-${dd}`;
    }
    return null;
  }
  // Excel serial number dates
  if (typeof value === "number") {
    // Excel epoch (days since 1899-12-30). Multiply by ms per day.
    const ms = Math.round((value - 25569) * 86400 * 1000);
    const d = new Date(ms);
    if (!isNaN(d.getTime())) {
      const yyyy = d.getFullYear();
      const mm = String(d.getMonth() + 1).padStart(2, "0");
      const dd = String(d.getDate()).padStart(2, "0");
      return `${yyyy}-${mm}-${dd}`;
    }
    return null;
  }
  // Date object
  if (value instanceof Date && !isNaN(value.getTime())) {
    const yyyy = value.getFullYear();
    const mm = String(value.getMonth() + 1).padStart(2, "0");
    const dd = String(value.getDate()).padStart(2, "0");
    return `${yyyy}-${mm}-${dd}`;
  }
  return null;
};

export function toTitleCase(str: string): string {
  if (!str) return "";
  return str
    .replace(/_/g, " ")
    .replace(/([A-Z])/g, " $1")
    .replace(/\b\w/g, (char) => char.toUpperCase())
    .trim();
}

export function inferExcelFormat(
  columnName: string
): "text" | "number" | "date" | "currency" | "percentage" | "json" {
  const name = columnName.toLowerCase();
  if (
    name.endsWith("_at") ||
    name.endsWith("_on") ||
    name.endsWith("dob") ||
    name.endsWith("doj") ||
    name.includes("date")
  )
    return "date";
  if (
    name.includes("amount") ||
    name.includes("price") ||
    name.includes("total") ||
    name.includes("rkm") ||
    name.includes("mbps")
  )
    return "number";
  if (name.includes("percent")) return "percentage";
  // common JSON-like columns
  if (
    name.includes("address") ||
    name.includes("preference") ||
    name.includes("metadata") ||
    name.includes("meta_data") ||
    name.includes("raw_user_meta_data") ||
    name.includes("raw_app_meta_data") ||
    name.endsWith("_json") ||
    name.includes("json")
  )
    return "json";
  return "text";
}

// Helper: normalize boolean-like values to true/false or null
export const toPgBoolean = (value: unknown): boolean | null => {
  if (value === null || value === undefined) return null;
  if (typeof value === "boolean") return value;
  if (typeof value === "number") {
    if (value === 1) return true;
    if (value === 0) return false;
  }
  if (typeof value === "string") {
    const v = value.trim().toLowerCase();
    if (v === "") return null;
    if (["true", "t", "1", "yes", "y"].includes(v)) return true;
    if (["false", "f", "0", "no", "n"].includes(v)) return false;
  }
  return null;
};

/**
 * Dynamically calculates the width of a column based on its content.
 * 
 * @param columnName - The name of the column
 * @param rows - The table data (array of objects from Supabase)
 * @param ctx - Optional CanvasRenderingContext2D for measuring text width
 * @returns A number representing the width in pixels (capped at 300px)
 */
export function inferDynamicColumnWidth(
  columnName: string,
  rows: Record<string, any>[],
  ctx?: CanvasRenderingContext2D
): number {
  const MIN_WIDTH = 120;
  const MAX_WIDTH = 400;
  const PADDING = 32; // left + right cell padding
  
  // fallback font if no canvas context provided
  if (!ctx) {
    const canvas = document.createElement("canvas");
    ctx = canvas.getContext("2d")!;
    ctx.font = "14px Inter, sans-serif"; // match your table CSS font
  }

  // measure header
  let maxWidth = ctx.measureText(columnName).width;

  // measure each row cell
  for (const row of rows) {
    const value = row[columnName];
    if (value == null) continue;
    const text = String(value);
    const width = ctx.measureText(text).width;
    if (width > maxWidth) {
      maxWidth = width;
    }
  }

  // add padding and clamp
  return Math.min(Math.max(Math.ceil(maxWidth) + PADDING, MIN_WIDTH), MAX_WIDTH);
}


```

<!-- path: config/user-details-config.tsx -->
```typescript
// ==== USER DETAILS MODAL CONFIGURATION ====
import { 
    DetailsModal, 
    defaultFormatters, 
    type HeaderConfig, 
    type SectionConfig 
  } from '@/components/common/ui/Modal/DetailsModal';
  import { 
    FiUser, 
    FiPhone, 
    FiCalendar, 
    FiUserCheck, 
    FiBriefcase, 
    FiMail, 
    FiShield, 
    FiClock, 
    FiSettings, 
    FiMapPin 
  } from "react-icons/fi";
  import { RoleBadge } from "@/components/common/ui/badges/RoleBadge";
  import { StatusBadge } from "@/components/common/ui/badges/StatusBadge";
  
  // User details modal configuration
  export const userDetailsConfig = {
    header: {
      title: (user: any) => {
        const firstName = user.first_name?.trim() || "";
        const lastName = user.last_name?.trim() || "";
        const fullName = `${firstName} ${lastName}`.trim();
        return fullName || "No name provided";
      },
      subtitle: (user: any) => user.email,
      avatar: {
        urlKey: 'avatar_url',
        fallbackText: (user: any) => {
          const firstInitial = user.first_name?.charAt(0)?.toUpperCase() || "";
          const lastInitial = user.last_name?.charAt(0)?.toUpperCase() || "";
          return firstInitial + lastInitial || "?";
        }
      },
      badges: [
        {
          key: 'designation',
          component: (designation: string) => designation ? (
            <span className="px-3 py-1 text-xs font-semibold bg-blue-100 text-blue-800 rounded-full dark:bg-blue-900 dark:text-blue-200">
              {designation}
            </span>
          ) : null
        }
      ]
    } as HeaderConfig,
    sections: [
      {
        title: "Personal Information",
        icon: <FiUser size={20} />,
        fields: [
          {
            key: 'first_name',
            label: 'First Name',
            icon: <FiUser size={18} />
          },
          {
            key: 'last_name',
            label: 'Last Name',
            icon: <FiUser size={18} />
          },
          {
            key: 'email',
            label: 'Email Address',
            icon: <FiMail size={18} />,
            formatter: (email: string, data: any) => defaultFormatters.email(email, data?.is_email_verified)
          },
          {
            key: 'phone_number',
            label: 'Phone Number',
            icon: <FiPhone size={18} />
          },
          {
            key: 'date_of_birth',
            label: 'Date of Birth',
            icon: <FiCalendar size={18} />,
            formatter: defaultFormatters.date
          },
          {
            key: 'designation',
            label: 'Designation',
            icon: <FiBriefcase size={18} />
          }
        ]
      },
      {
        title: "Account Information",
        icon: <FiUserCheck size={20} />,
        fields: [
          {
            key: 'role',
            label: 'Role',
            icon: <FiShield size={18} />,
            formatter: (role: any) => <RoleBadge role={role} />
          },
          {
            key: 'status',
            label: 'Status',
            formatter: (status: string) => <StatusBadge status={status || ""} />
          },
          {
            key: 'created_at',
            label: 'Account Created',
            icon: <FiCalendar size={18} />,
            formatter: defaultFormatters.date
          },
          {
            key: 'last_sign_in_at',
            label: 'Last Sign In',
            icon: <FiClock size={18} />,
            formatter: defaultFormatters.dateTime
          },
          {
            key: 'updated_at',
            label: 'Last Updated',
            icon: <FiClock size={18} />,
            formatter: defaultFormatters.dateTime
          }
        ]
      },
      {
        title: "Address Information",
        icon: <FiMapPin size={20} />,
        condition: (user: any) => user.address && defaultFormatters.address(user.address),
        renderCustom: (user: any) => (
          <div className="p-6 bg-gradient-to-br from-gray-50 to-gray-100 dark:from-gray-800 dark:to-gray-850 rounded-2xl border border-gray-200 dark:border-gray-700">
            <p className="text-gray-900 dark:text-white font-medium text-lg leading-relaxed">
              {defaultFormatters.address(user.address)}
            </p>
          </div>
        )
      },
      {
        title: "User Preferences",
        icon: <FiSettings size={20} />,
        condition: (user: any) => user.preferences && Object.keys(user.preferences).length > 0,
        renderCustom: (user: any) => (
          <div className="p-6 bg-gradient-to-br from-gray-50 to-gray-100 dark:from-gray-800 dark:to-gray-850 rounded-2xl border border-gray-200 dark:border-gray-700 overflow-hidden">
            {defaultFormatters.json(user.preferences)}
          </div>
        )
      }
    ] as SectionConfig[]
  };

  export const UserDetailsModal = ({ user, onClose, isOpen }: { user: any, onClose: () => void, isOpen: boolean }) => {
    return (
      <DetailsModal
        data={user}
        onClose={onClose}
        isOpen={isOpen}
        config={userDetailsConfig}
      />
    );
  };
```

<!-- path: config/constants.ts -->
```typescript
export const DEFAULTS = {
  DEBOUNCE_DELAY: 400,
  PAGE_SIZE: 10,
  PAGE_SIZE_OPTIONS: [10, 20, 50, 100, 500],
};

```

<!-- path: config/table-column-keys.ts -->
```typescript
import { toPgBoolean, toPgDate, toTitleCase } from '@/config/helper-functions';
import {
  ColumnMeta,
  ColumnTransform,
  GenericRow,
  TableMetaMap,
  TableName,
  TableOrViewName,
  UploadMetaMap,
  UploadTableMeta,
} from '@/config/helper-types';
import { Tables } from '@/types/supabase-types';

export const UPLOAD_TABLE_META: UploadMetaMap = {
  employees: {
    uploadType: 'upsert',
    conflictColumn: 'employee_pers_no',
    isUploadEnabled: true,
  },
  user_profiles: {
    uploadType: 'upsert',
    conflictColumn: 'id',
    isUploadEnabled: true,
  },
  lookup_types: {
    uploadType: 'upsert',
    conflictColumn: 'id',
    isUploadEnabled: true,
  },
  rings: { uploadType: 'upsert', conflictColumn: 'id', isUploadEnabled: true },
  employee_designations: {
    uploadType: 'upsert',
    conflictColumn: 'id',
    isUploadEnabled: true,
  },
  maintenance_areas: {
    uploadType: 'upsert',
    conflictColumn: 'id',
    isUploadEnabled: true,
  },
  ofc_cables: {
    uploadType: 'upsert',
    conflictColumn: 'id',
    isUploadEnabled: true,
  },
  ofc_connections: {
    uploadType: 'upsert',
    conflictColumn: 'id',
    isUploadEnabled: true,
  },
  nodes: { uploadType: 'upsert', conflictColumn: 'id', isUploadEnabled: true },
  systems: {
    uploadType: 'upsert',
    conflictColumn: 'id',
    isUploadEnabled: true,
  },
};

// Per-table column metadata for UI/export and upload (only override where needed)
export const TABLE_COLUMN_META: TableMetaMap = {
  employees: {
    employee_dob: {
      title: 'Employee DOB',
      excelHeader: 'Employee DOB',
      transform: toPgDate,
      excelFormat: 'date',
    },
    employee_doj: {
      title: 'Employee DOJ',
      excelHeader: 'Employee DOJ',
      transform: toPgDate,
      excelFormat: 'date',
    },
    status: { title: 'Status', excelHeader: 'Status', transform: toPgBoolean },
  },
  lookup_types: {
    status: { transform: toPgBoolean },
    is_system_default: { transform: toPgBoolean },
  },
  rings: {
    status: { transform: toPgBoolean },
  },
  user_profiles: {
    date_of_birth: { transform: toPgDate, excelFormat: 'date' },
  },
  ofc_cables: {
    commissioned_on: { transform: toPgDate, excelFormat: 'date' },
    status: { transform: toPgBoolean },
  },
  ofc_connections: {
    en_dom: { transform: toPgDate, excelFormat: 'date' },
    sn_dom: { transform: toPgDate, excelFormat: 'date' },
    status: { transform: toPgBoolean },
  },
  nodes: {
    status: { transform: toPgBoolean },
  },
  systems: {
    commissioned_on: { transform: toPgDate, excelFormat: 'date' },
    status: { transform: toPgBoolean },
  },
};

// Build UI column configs (lightweight structure; consumer can enrich widths/formats)
export function buildColumnConfig<T extends TableOrViewName>(tableName: T) {
  const keys = TABLE_COLUMN_KEYS[tableName] as (keyof GenericRow<T> & string)[];
  const meta = (TABLE_COLUMN_META[tableName as TableName] || {}) as Record<
    string,
    ColumnMeta
  >;
  return keys.map((key) => {
    const m = meta[key] || {};
    const title = m.title ?? toTitleCase(key);
    return {
      key,
      dataIndex: key,
      title,
      excelFormat: m.excelFormat,
    };
  });
}
// Build upload config from SSOT
export function buildUploadConfig<T extends TableName>(tableName: T) {
  const keys = TABLE_COLUMN_KEYS[tableName] as (keyof Tables<T> & string)[];
  const meta = (TABLE_COLUMN_META[tableName] || {}) as Record<
    string,
    ColumnMeta
  >;
  const tableMeta = (UPLOAD_TABLE_META[tableName] || {
    uploadType: 'upsert',
  }) as UploadTableMeta<T>;

  const columnMapping = keys.map((key) => {
    const m = meta[key] || {};
    const excelHeader = m.excelHeader ?? toTitleCase(key);
    // Auto-infer transforms if not explicitly provided
    let transform = m.transform as ColumnTransform | undefined;
    if (!transform) {
      const k = String(key).toLowerCase();
      if (k.endsWith('_at') || k.endsWith('_on') || k.includes('date')) {
        transform = toPgDate;
      } else if (
        k.startsWith('is_') ||
        k.startsWith('has_') ||
        k.startsWith('can_') ||
        k.includes('enabled') ||
        k.includes('active') ||
        k === 'status'
      ) {
        transform = toPgBoolean;
      }
    }
    return {
      excelHeader,
      dbKey: key,
      transform,
    };
  });

  return {
    tableName,
    columnMapping,
    uploadType: tableMeta.uploadType,
    conflictColumn: tableMeta.conflictColumn,
    isUploadEnabled: tableMeta.isUploadEnabled ?? true,
  };
}

/**
 * The single source of truth for the default columns to be displayed for each table.
 * This is the ONLY place you need to manually list column names.
 * TypeScript validates this entire object.
 */
export const TABLE_COLUMN_KEYS = {
  // We list all keys for each table here.
  user_profiles: [
    'id',
    'first_name',
    'last_name',
    'phone_number',
    'role',
    'designation',
    'status',
    'avatar_url',
    'date_of_birth',
    'address',
    'preferences',
    'created_at',
    'updated_at',
  ],
  lookup_types: [
    'id',
    'category',
    'name',
    'code',
    'description',
    'sort_order',
    'status',
    'is_system_default',
    'created_at',
    'updated_at',
  ],
  maintenance_areas: [
    'id',
    'code',
    'name',
    'address',
    'email',
    'contact_person',
    'contact_number',
    'latitude',
    'longitude',
    'area_type_id',
    'parent_id',
    'status',
    'created_at',
    'updated_at',
  ],
  employee_designations: [
    'id',
    'name',
    'parent_id',
    'status',
    'created_at',
    'updated_at',
  ],
  employees: [
    'id',
    'employee_pers_no',
    'employee_name',
    'employee_email',
    'employee_dob',
    'employee_doj',
    'employee_contact',
    'employee_addr',
    'employee_designation_id',
    'maintenance_terminal_id',
    'status',
    'remark',
    'created_at',
    'updated_at',
  ],
  rings: [
    'id',
    'name',
    'description',
    'ring_type_id',
    'maintenance_terminal_id',
    'total_nodes',
    'status',
    'created_at',
    'updated_at',
  ],
  nodes: [
    'id',
    'name',
    'node_type_id',
    'maintenance_terminal_id',
    'latitude',
    'longitude',
    'status',
    'remark',
    'created_at',
    'updated_at',
  ],
  ofc_cables: [
    'id',
    'route_name',
    'capacity',
    'ofc_type_id', // Correct: references lookup_types table
    'transnet_id',
    'transnet_rkm',
    'current_rkm',
    'ofc_owner_id', // Correct: references lookup_types table
    'asset_no',
    'maintenance_terminal_id', // Correct: references maintenance_areas table
    'commissioned_on',
    'remark',
    'sn_id', // Correct: references nodes table
    'en_id', // Correct: references nodes table
    'status',
    'created_at',
    'updated_at',
  ],
  systems: [
    'id',
    'system_name',
    's_no',
    'node_id',
    'system_type_id',
    'ip_address',
    'maintenance_terminal_id',
    'commissioned_on',
    'status',
    'remark',
    'created_at',
    'updated_at',
  ],
  ofc_connections: [
    'id',
    'ofc_id',
    'logical_path_id',
    'system_id',
    'fiber_no_sn',
    'fiber_no_en',
    'path_segment_order',
    'connection_type',
    'connection_category',
    'source_port',
    'destination_port',
    'en_dom',
    'sn_dom',
    'otdr_distance_en_km',
    'otdr_distance_sn_km',
    'sn_power_dbm',
    'en_power_dbm',
    'route_loss_db',
    'status',
    'remark',
    'created_at',
    'updated_at',
  ],
  // 'maan_connections' and 'cpan_connections' refer to 'sfp_based_connections'
  sfp_based_connections: [
    'system_connection_id',
    'bandwidth_allocated_mbps',
    'customer_name',
    'fiber_in',
    'fiber_out',
    'sfp_capacity',
    'sfp_port',
    'sfp_serial_no',
    'sfp_type_id',
  ],
  // 'maan_systems' and 'cpan_systems' are not directly present as tables in your types.
  // Assuming they might be specialized systems or a view not provided.
  // For now, I'll remove them or if they refer to `systems` with specific types, you need to clarify.
  // I will skip them for now.
  management_ports: [
    'id',
    'name',
    'port_no',
    'commissioned_on',
    'node_id',
    'system_id',
    'status',
    'remark',
    'created_at',
    'updated_at',
  ],
  sdh_connections: [
    'system_connection_id',
    'stm_no',
    'carrier',
    'a_customer',
    'a_slot',
    'b_customer',
    'b_slot',
  ],
  sdh_node_associations: [
    'id',
    'sdh_system_id',
    'node_id',
    'node_position',
    'node_ip',
  ],
  sdh_systems: ['system_id', 'make', 'gne'],
  system_connections: [
    'id',
    'system_id',
    'sn_id',
    'en_id',
    'connected_system_id',
    'media_type_id',
    'sn_interface',
    'en_interface',
    'sn_ip',
    'en_ip',
    'vlan',
    'bandwidth_mbps',
    'commissioned_on',
    'status',
    'remark',
    'created_at',
    'updated_at',
  ],
  vmux_connections: [
    'system_connection_id',
    'subscriber',
    'channel',
    'c_code',
    'tk',
  ],
  vmux_systems: ['system_id', 'vm_id'],
  fiber_joints: [
    'id',
    'joint_name',
    'joint_category',
    'joint_type',
    'node_id',
    'maintenance_area_id',
    'latitude',
    'longitude',
    'location_description',
    'installed_date',
    'status',
    'remark',
    'created_at',
    'updated_at',
  ],
  logical_fiber_paths: [
    'bandwidth_gbps',
    'commissioned_date',
    'created_at',
    'destination_port',
    'destination_system_id',
    'id',
    'operational_status_id',
    'path_name',
    'path_type_id',
    'remark',
    'service_type',
    'source_port',
    'source_system_id',
    'total_distance_km',
    'total_loss_db',
    'updated_at',
    'wavelength_nm',
  ],
  // 'fiber_joint_connections' is not directly present as a table in your types.
  // Assuming it might be a junction table or a view not provided.
  // I will skip it for now.
  user_activity_logs: [
    'id',
    'created_at',
    'user_id',
    'user_role',
    'action_type',
    'table_name',
    'record_id',
    'old_data',
    'new_data',
    'details',
  ],
  files: [
    'id',
    'file_name',
    'file_route',
    'file_size',
    'file_type',
    'file_url',
    'folder_id',
    'uploaded_at',
    'user_id',
  ],
  folders: ['id', 'name', 'user_id', 'created_at'],
  ring_based_systems: ['maintenance_area_id', 'ring_id', 'system_id'],
  logical_path_segments: [
    'created_at',
    'fiber_joint_id',
    'id',
    'logical_path_id',
    'ofc_cable_id',
    'path_order',
  ],

  // ===== Views =====
  v_cable_utilization: [
    'cable_id',
    'route_name',
    'capacity',
    'used_fibers',
    'available_fibers',
    'utilization_percent',
  ],
  v_end_to_end_paths: [
    'path_id',
    'path_name',
    'source_system_id',
    'destination_system_id',
    'operational_status',
    'segment_count',
    'route_names',
    'total_distance_km',
    'total_loss_db',
  ],
  v_ofc_cables_complete: [
    'id',
    'route_name',
    'sn_id',
    'en_id',
    'capacity',
    'ofc_type_id',
    'ofc_type_name',
    'ofc_type_code',
    'ofc_owner_id',
    'ofc_owner_name',
    'ofc_owner_code',
    'asset_no',
    'transnet_id',
    'transnet_rkm',
    'current_rkm',
    'maintenance_terminal_id',
    'maintenance_area_name',
    'maintenance_area_code',
    'commissioned_on',
    'status',
    'remark',
    'created_at',
    'updated_at',
    'total_count',
    'active_count',
    'inactive_count',
  ],
  v_nodes_complete: [
    'id',
    'name',
    'node_type_id',
    'node_type_name',
    'node_type_code',
    'maintenance_terminal_id',
    'maintenance_area_name',
    'maintenance_area_code',
    'maintenance_area_type_name',
    'latitude',
    'longitude',
    'status',
    'remark',
    'created_at',
    'updated_at',
    'total_count',
    'active_count',
    'inactive_count',
  ],
  v_ofc_connections_complete: [
    'fiber_no_sn',
    'otdr_distance_sn_km',
    'sn_power_dbm',
    'sn_dom',
    'fiber_no_en',
    'otdr_distance_en_km',
    'en_power_dbm',
    'en_dom',
    'route_loss_db',
    'connection_type',
    'maintenance_area_name',
    'remark',
    'status',
    'active_count',
    'inactive_count',
    'ofc_route_name',
    'ofc_type_name',
    'connection_category',
    'system_name',
    'system_id',
    'source_port',
    'destination_port',
    'path_segment_order',
    'logical_path_id',
    'sn_name',
    'en_name',
    'sn_id',
    'en_id',
    'total_count',
    'created_at',
    'updated_at',
    'ofc_id',
    'id',
  ],
  v_system_connections_complete: [
    'active_count',
    'bandwidth_allocated_mbps',
    'bandwidth_mbps',
    'commissioned_on',
    'connected_system_name',
    'connected_system_type_name',
    'created_at',
    'customer_name',
    'en_interface',
    'en_ip',
    'en_name',
    'en_node_name',
    'fiber_in',
    'fiber_out',
    'id',
    'inactive_count',
    'media_type_name',
    'remark',
    'sdh_a_customer',
    'sdh_a_slot',
    'sdh_b_customer',
    'sdh_b_slot',
    'sdh_carrier',
    'sdh_stm_no',
    'sfp_capacity',
    'sfp_port',
    'sfp_serial_no',
    'sfp_type_name',
    'sn_interface',
    'sn_ip',
    'sn_name',
    'sn_node_name',
    'status',
    'system_id',
    'system_name',
    'system_type_name',
    'total_count',
    'updated_at',
    'vlan',
    'vmux_c_code',
    'vmux_channel',
    'vmux_subscriber',
    'vmux_tk',
  ],
  v_systems_complete: [
    'active_count',
    'commissioned_on',
    'created_at',
    'id',
    'inactive_count',
    'ip_address',
    'latitude',
    'longitude',
    'maintenance_terminal_id',
    'node_id',
    'node_name',
    'remark',
    'ring_id',
    'ring_logical_area_name',
    's_no',
    'sdh_gne',
    'sdh_make',
    'status',
    'system_category',
    'system_maintenance_terminal_name',
    'system_name',
    'system_type_code',
    'system_type_id',
    'system_type_name',
    'total_count',
    'updated_at',
    'vmux_vm_id',
  ],
  v_user_profiles_extended: [
    'id',
    'email',
    'last_sign_in_at',
    'created_at',
    'updated_at',
    'auth_updated_at',
    'is_super_admin',
    'is_email_verified',
    'email_confirmed_at',
    'is_phone_verified',
    'phone_confirmed_at',
    'first_name',
    'last_name',
    'full_name',
    'avatar_url',
    'phone_number',
    'date_of_birth',
    'address',
    'preferences',
    'role',
    'designation',
    'status',
    'raw_user_meta_data',
    'raw_app_meta_data',
    'computed_status',
    'account_age_days',
    'last_activity_period',
  ],
  v_lookup_types_with_count: [
    'id',
    'category',
    'name',
    'code',
    'description',
    'sort_order',
    'status',
    'is_system_default',
    'created_at',
    'updated_at',
    'total_count',
    'active_count',
    'inactive_count',
  ],
  v_employee_designations_with_count: [
    'id',
    'name',
    'parent_id',
    'status',
    'created_at',
    'updated_at',
    'total_count',
    'active_count',
    'inactive_count',
  ],
  v_maintenance_areas_with_count: [
    'id',
    'code',
    'name',
    'address',
    'email',
    'contact_person',
    'contact_number',
    'latitude',
    'longitude',
    'area_type_id',
    'parent_id',
    'status',
    'created_at',
    'updated_at',
    'total_count',
    'active_count',
    'inactive_count',
    'maintenance_area_type_category',
    'maintenance_area_type_code',
    'maintenance_area_type_created_at',
    'maintenance_area_type_is_system_default',
    'maintenance_area_type_name',
    'maintenance_area_type_sort_order',
    'maintenance_area_type_status',
    'maintenance_area_type_updated_at',
  ],
  v_employees_with_count: [
    'id',
    'employee_pers_no',
    'employee_name',
    'employee_email',
    'employee_dob',
    'employee_doj',
    'employee_contact',
    'employee_addr',
    'employee_designation_id',
    'employee_designation_name',
    'maintenance_terminal_id',
    'remark',
    'status',
    'created_at',
    'updated_at',
    'total_count',
    'active_count',
    'inactive_count',
  ],
  v_rings_with_count: [
    // from rings r.*
    'id',
    'name',
    'description',
    'ring_type_id',
    'maintenance_terminal_id',
    'total_nodes',
    'status',
    'created_at',
    'updated_at',

    // from lookup_types lt_ring
    'ring_type_name',
    'ring_type_code',
    'ring_type_category',
    'ring_type_sort_order',
    'ring_type_is_system_default',
    'ring_type_status',
    'ring_type_created_at',
    'ring_type_updated_at',

    // from maintenance_areas ma
    'maintenance_area_name',
    'maintenance_area_code',
    'maintenance_area_email',
    'maintenance_area_contact_person',
    'maintenance_area_contact_number',
    'maintenance_area_latitude',
    'maintenance_area_longitude',
    'maintenance_area_area_type_id',
    'maintenance_area_parent_id',
    'maintenance_area_status',
    'maintenance_area_created_at',
    'maintenance_area_updated_at',

    // counts
    'total_count',
    'active_count',
    'inactive_count',
  ],
  v_system_ring_paths_detailed: [
    'created_at',
    'end_node_id',
    'end_node_name',
    'id',
    'logical_path_id',
    'ofc_cable_id',
    'path_name',
    'path_order',
    'route_name',
    'source_system_id',
    'start_node_id',
    'start_node_name',
  ],
};

// Separate tables and views for better type safety
export const TABLES = {
  user_profiles: 'user_profiles',
  employees: 'employees',
  lookup_types: 'lookup_types',
  rings: 'rings',
  employee_designations: 'employee_designations',
  maintenance_areas: 'maintenance_areas',
  ofc_cables: 'ofc_cables',
  ofc_connections: 'ofc_connections',
  nodes: 'nodes',
  systems: 'systems',
  // 'cpan_connections' is SFP based connections
  sfp_based_connections: 'sfp_based_connections',
  // 'cpan_systems' is not in types, removed
  // 'fiber_joint_connections' is not in types, removed
  fiber_joints: 'fiber_joints',
  logical_fiber_paths: 'logical_fiber_paths',
  logical_path_segments: 'logical_path_segments',
  // 'maan_connections' is SFP based connections
  management_ports: 'management_ports',
  sdh_connections: 'sdh_connections',
  sdh_node_associations: 'sdh_node_associations',
  sdh_systems: 'sdh_systems',
  system_connections: 'system_connections',
  user_activity_logs: 'user_activity_logs',
  vmux_connections: 'vmux_connections',
  vmux_systems: 'vmux_systems',
  files: 'files',
  folders: 'folders',
  ring_based_systems: 'ring_based_systems',
} as const;

// Define views separately
export const VIEWS = {
  v_cable_utilization: 'v_cable_utilization',
  v_end_to_end_paths: 'v_end_to_end_paths',
  v_nodes_complete: 'v_nodes_complete',
  v_ofc_cables_complete: 'v_ofc_cables_complete',
  v_ofc_connections_complete: 'v_ofc_connections_complete',
  v_system_connections_complete: 'v_system_connections_complete',
  v_systems_complete: 'v_systems_complete',
  v_user_profiles_extended: 'v_user_profiles_extended',
  v_lookup_types_with_count: 'v_lookup_types_with_count',
  v_employee_designations_with_count: 'v_employee_designations_with_count',
  v_maintenance_areas_with_count: 'v_maintenance_areas_with_count',
  v_employees_with_count: 'v_employees_with_count',
  v_rings_with_count: 'v_rings_with_count',
  v_system_ring_paths_detailed: 'v_system_ring_paths_detailed',
} as const;

// For backward compatibility, export TABLE_NAMES as a union of tables and views
export const TABLE_NAMES = {
  ...TABLES,
  ...VIEWS,
} as const;

```

