<!-- path: postcss.config.mjs -->
```mjs
const config = {
  plugins: ["@tailwindcss/postcss"],
};

export default config;

```

<!-- path: stores/authStore.ts -->
```typescript
// stores/authStore.ts
import { create } from 'zustand';
import { devtools, persist } from 'zustand/middleware';
import { AuthError, User } from '@supabase/supabase-js';

export type AuthState = 'loading' | 'authenticated' | 'unauthenticated';

interface AuthStore {
  // Auth State
  user: User | null;
  authState: AuthState;

  // Actions
  setUser: (user: User | null) => void;
  setAuthState: (state: AuthState) => void;
  logout: () => void;

  // Async action wrapper to handle loading states
  executeWithLoading: <T>(action: () => Promise<T>) => Promise<T>;

  // Getters
  isLoading: () => boolean;
  isAuthenticated: () => boolean;
  getUserId: () => string | null;
}

export const useAuthStore = create<AuthStore>()(
  persist(
    devtools(
      (set, get) => ({
        // Initial State
        user: null,
        authState: 'loading',

        // Actions
        setUser: (user) => {
          // Only update if the user has actually changed
          const currentUser = get().user;
          if (user?.id !== currentUser?.id) {
            set({
              user,
              authState: user ? 'authenticated' : 'unauthenticated',
            });
          }
        },

        setAuthState: (newAuthState) => {
          // Only update if the state has actually changed
          if (get().authState !== newAuthState) {
            set({ authState: newAuthState });
          }
        },

        logout: () => {
          set({
            user: null,
            authState: 'unauthenticated',
          });
        },

        executeWithLoading: async <T>(action: () => Promise<T>): Promise<T> => {
          const previousAuthState = get().authState;
          if (previousAuthState !== 'loading') {
            set({ authState: 'loading' });
          }

          try {
            const result = await action();
            // Only revert state if it's still loading, to avoid race conditions
            // with onAuthStateChange listener.
            if (get().authState === 'loading') {
              const finalUser = get().user;
              set({ authState: finalUser ? 'authenticated' : 'unauthenticated' });
            }
            return result;
          } catch (error) {
            // **REFINED ERROR HANDLING**
            const isAuthError = error instanceof AuthError && error.status === 401;

            if (isAuthError) {
              // It's a real authentication error, so log the user out.
              set({ authState: 'unauthenticated', user: null });
            } else {
              // It's a network or other error, revert to the previous state.
              set({ authState: previousAuthState });
            }
            // Re-throw the error to be handled by the caller.
            throw error;
          }
        },

        // Getters
        isLoading: () => {
          return get().authState === 'loading';
        },

        isAuthenticated: () => {
          const { user, authState } = get();
          return user !== null && authState === 'authenticated';
        },

        getUserId: () => {
          const { user } = get();
          return user?.id || null;
        },
      }),
      {
        name: 'AuthenticationStore',
      }
    ),
    {
      name: 'auth-store',
      partialize: (state) => ({
        user: state.user,
        authState: state.authState,
      }),
    }
  )
);

```

<!-- path: stores/useUploadConfigStore.ts -->
```typescript
// src/stores/useUploadConfigStore.ts

import { create } from "zustand";
import { devtools, persist } from "zustand/middleware";
import { PublicTableName} from "@/hooks/database/queries-type-helpers";
import { Tables } from "@/types/supabase-types";

type UploadableTableRow<T extends PublicTableName> = Tables<T>;

export interface UploadColumnMapping<T extends PublicTableName> {
  excelHeader: string;
  dbKey: keyof UploadableTableRow<T> & string;
  transform?: (value: unknown) => unknown;
}

export interface UploadConfig<T extends PublicTableName> {
  tableName: T;
  columnMapping: UploadColumnMapping<T>[];
  uploadType: "insert" | "upsert";
  conflictColumn?: keyof UploadableTableRow<T> & string;
  isUploadEnabled: boolean;
}

interface UploadConfigState {
  configs: Record<string, UploadConfig<PublicTableName>>;
  setUploadConfig: <T extends PublicTableName>(pageKey: string, config: UploadConfig<T>) => void;
  getUploadConfig: (pageKey: string) => UploadConfig<PublicTableName> | undefined;
  clearUploadConfig: (pageKey: string) => void;
}

export const useUploadConfigStore = create<UploadConfigState>()(
  persist(
    devtools(
      (set, get) => ({
        configs: {},
        setUploadConfig: (pageKey, config) => {
          if (config?.uploadType === "upsert" && !config.conflictColumn) {
            console.error(`UploadConfig Error...`);
          }
          set((state) => ({
            configs: { ...state.configs, [pageKey]: config },
          }));
        },
        getUploadConfig: (pageKey) => get().configs[pageKey],
        clearUploadConfig: (pageKey) => {
          set((state) => {
            const newConfigs = { ...state.configs };
            delete newConfigs[pageKey];
            return { configs: newConfigs };
          });
        },
      }),
      { name: "UploadConfigStore" }
    ),
    { name: "upload-config-storage" }
  )
);
```

<!-- path: stores/themeStore.ts -->
```typescript
import { create } from "zustand";
import { persist } from "zustand/middleware";

export type Theme = "light" | "dark" | "system";

interface ThemeState {
  theme: Theme;
  setTheme: (theme: Theme) => void;
}

export const useThemeStore = create<ThemeState>()(
  persist(
    (set) => ({
      theme: "system", // Default value
      setTheme: (newTheme: Theme) => {
        set({ theme: newTheme });
      },
    }),
    {
      name: "theme-storage", // localStorage key
      // **RECOMMENDATION: Add partialize to ensure consistent storage format**
      partialize: (state) => ({ theme: state.theme }),
    }
  )
);
```

<!-- path: providers/QueryProvider.tsx -->
```typescript
// providers/QueryProvider.tsx
'use client'

import { QueryClient, QueryClientProvider } from '@tanstack/react-query'
import { ReactQueryDevtools } from '@tanstack/react-query-devtools'
import { useState } from 'react'

export function QueryProvider({ children }: { children: React.ReactNode }) {
  const [queryClient] = useState(() => new QueryClient({
    defaultOptions: {
      queries: {
        staleTime: 5 * 60 * 1000, // 5 minutes
        gcTime: 10 * 60 * 1000, // 10 minutes
        retry: (failureCount, error: Error) => {
          if ('status' in error && typeof error.status === 'number' && error.status >= 400 && error.status < 500) {
            return false
          }
          return failureCount < 3
        },
        refetchOnWindowFocus: false,
      },
      mutations: {
        retry: 1,
      },
    },
  }))

  return (
    <QueryClientProvider client={queryClient}>
      {children}
      <ReactQueryDevtools initialIsOpen={false} />
    </QueryClientProvider>
  )
}


```

<!-- path: providers/ToastProvider.tsx -->
```typescript
// components/providers/ToastProvider.tsx
'use client';

import { Toaster } from 'sonner';
import { useThemeStore } from '@/stores/themeStore';

export function ToastProvider({ children }: { children: React.ReactNode }) {
  const { theme } = useThemeStore();

  return (
    <>
      {children}
      <Toaster
        theme={theme === 'system' ? 'system' : theme}
        className="toaster group"
        toastOptions={{
          classNames: {
            toast:
              'group toast group-[.toaster]:bg-white group-[.toaster]:text-gray-950 group-[.toaster]:border-gray-200 group-[.toaster]:shadow-lg dark:group-[.toaster]:bg-gray-950 dark:group-[.toaster]:text-gray-50 dark:group-[.toaster]:border-gray-800',
            description: 'group-[.toast]:text-gray-500 dark:group-[.toast]:text-gray-400',
            actionButton:
              'group-[.toast]:bg-gray-900 group-[.toast]:text-gray-50 dark:group-[.toast]:bg-gray-50 dark:group-[.toast]:text-gray-900',
            cancelButton:
              'group-[.toast]:bg-gray-100 group-[.toast]:text-gray-500 dark:group-[.toast]:bg-gray-800 dark:group-[.toast]:text-gray-400',
          },
        }}
        richColors
        closeButton
        position="top-right"
      />
    </>
  );
}
```

<!-- path: providers/ThemeProvider.tsx -->
```typescript
"use client";

import { useEffect } from "react";
import { useThemeStore, Theme } from "@/stores/themeStore";

export default function ThemeProvider({
  children,
}: {
  children: React.ReactNode;
}) {
  const theme = useThemeStore((state) => state.theme);

  // This useEffect now only needs to react to subsequent theme changes.
  useEffect(() => {
    const applyTheme = (themeToApply: Theme) => {
      const root = document.documentElement;
      
      const isDark =
        themeToApply === "dark" ||
        (themeToApply === "system" &&
          window.matchMedia("(prefers-color-scheme: dark)").matches);

      // Simply toggle the class. No need for transition management.
      root.classList.toggle("dark", isDark);
    };

    applyTheme(theme);

    // If the theme is 'system', we still need to listen for OS-level changes.
    if (theme === "system") {
      const mediaQuery = window.matchMedia("(prefers-color-scheme: dark)");
      const handleChange = () => applyTheme("system");

      mediaQuery.addEventListener("change", handleChange);
      return () => mediaQuery.removeEventListener("change", handleChange);
    }
  }, [theme]);

  return <>{children}</>;
}
```

<!-- path: scripts/generate-flattened-types.ts -->
```typescript
import * as ts from 'typescript';
import * as fs from 'fs';
import * as path from 'path';

interface TableInfo {
  name: string;
  schema: string;
  row?: string;
  insert?: string;
  update?: string;
}

interface ViewInfo {
  name: string;
  schema: string;
  row?: string;
}

interface EnumInfo {
  name: string;
  schema: string;
  values: string[];
}

class SupabaseTypeExtractor {
  private sourceFile: ts.SourceFile;
  private checker: ts.TypeChecker;

  constructor(filePath: string) {
    const program = ts.createProgram([filePath], {});
    this.sourceFile = program.getSourceFile(filePath)!;
    this.checker = program.getTypeChecker();
  }

  extract() {
    const tables: TableInfo[] = [];
    const views: ViewInfo[] = [];
    const enums: EnumInfo[] = [];

    const visit = (node: ts.Node) => {
      if (ts.isTypeAliasDeclaration(node) && node.name.text === 'Database') {
        this.extractFromDatabaseType(node, tables, views, enums);
      }
      ts.forEachChild(node, visit);
    };

    visit(this.sourceFile);
    return { tables, views, enums };
  }

  private extractFromDatabaseType(
    node: ts.TypeAliasDeclaration,
    tables: TableInfo[],
    views: ViewInfo[],
    enums: EnumInfo[]
  ) {
    if (!ts.isTypeLiteralNode(node.type)) return;

    for (const member of node.type.members) {
      if (ts.isPropertySignature(member) && ts.isIdentifier(member.name)) {
        const schemaName = member.name.text;
        if (member.type && ts.isTypeLiteralNode(member.type)) {
          this.extractFromSchema(member.type, schemaName, tables, views, enums);
        }
      }
    }
  }

  private extractFromSchema(
    schemaNode: ts.TypeLiteralNode,
    schemaName: string,
    tables: TableInfo[],
    views: ViewInfo[],
    enums: EnumInfo[]
  ) {
    for (const member of schemaNode.members) {
      if (ts.isPropertySignature(member) && ts.isIdentifier(member.name)) {
        const sectionName = member.name.text;

        if (
          sectionName === 'Tables' &&
          member.type &&
          ts.isTypeLiteralNode(member.type)
        ) {
          this.extractTables(member.type, schemaName, tables);
        } else if (
          sectionName === 'Views' &&
          member.type &&
          ts.isTypeLiteralNode(member.type)
        ) {
          this.extractViews(member.type, schemaName, views);
        } else if (
          sectionName === 'Enums' &&
          member.type &&
          ts.isTypeLiteralNode(member.type)
        ) {
          this.extractEnums(member.type, schemaName, enums);
        }
      }
    }
  }

  private extractTables(
    tablesNode: ts.TypeLiteralNode,
    schemaName: string,
    tables: TableInfo[]
  ) {
    for (const member of tablesNode.members) {
      if (ts.isPropertySignature(member) && ts.isIdentifier(member.name)) {
        const tableName = member.name.text;
        const tableInfo: TableInfo = { name: tableName, schema: schemaName };

        if (member.type && ts.isTypeLiteralNode(member.type)) {
          this.extractTableStructure(member.type, tableInfo);
        }

        tables.push(tableInfo);
      }
    }
  }

  private extractTableStructure(
    tableNode: ts.TypeLiteralNode,
    tableInfo: TableInfo
  ) {
    for (const member of tableNode.members) {
      if (ts.isPropertySignature(member) && ts.isIdentifier(member.name)) {
        const propertyName = member.name.text;

        if (propertyName === 'Row' && member.type) {
          tableInfo.row = this.typeToString(member.type);
        } else if (propertyName === 'Insert' && member.type) {
          tableInfo.insert = this.typeToString(member.type);
        } else if (propertyName === 'Update' && member.type) {
          tableInfo.update = this.typeToString(member.type);
        }
      }
    }
  }

  private extractViews(
    viewsNode: ts.TypeLiteralNode,
    schemaName: string,
    views: ViewInfo[]
  ) {
    for (const member of viewsNode.members) {
      if (ts.isPropertySignature(member) && ts.isIdentifier(member.name)) {
        const viewName = member.name.text;
        const viewInfo: ViewInfo = { name: viewName, schema: schemaName };

        if (member.type && ts.isTypeLiteralNode(member.type)) {
          this.extractViewStructure(member.type, viewInfo);
        }

        views.push(viewInfo);
      }
    }
  }

  private extractViewStructure(
    viewNode: ts.TypeLiteralNode,
    viewInfo: ViewInfo
  ) {
    for (const member of viewNode.members) {
      if (ts.isPropertySignature(member) && ts.isIdentifier(member.name)) {
        const propertyName = member.name.text;

        if (propertyName === 'Row' && member.type) {
          viewInfo.row = this.typeToString(member.type);
        }
      }
    }
  }

  private extractEnums(
    enumsNode: ts.TypeLiteralNode,
    schemaName: string,
    enums: EnumInfo[]
  ) {
    for (const member of enumsNode.members) {
      if (ts.isPropertySignature(member) && ts.isIdentifier(member.name)) {
        const enumName = member.name.text;
        const enumInfo: EnumInfo = {
          name: enumName,
          schema: schemaName,
          values: [],
        };

        if (member.type && ts.isUnionTypeNode(member.type)) {
          enumInfo.values = this.extractUnionValues(member.type);
        }

        enums.push(enumInfo);
      }
    }
  }

  private extractUnionValues(unionNode: ts.UnionTypeNode): string[] {
    const values: string[] = [];

    for (const type of unionNode.types) {
      if (ts.isLiteralTypeNode(type) && ts.isStringLiteral(type.literal)) {
        values.push(type.literal.text);
      }
    }

    return values;
  }

  private typeToString(node: ts.TypeNode): string {
    const printer = ts.createPrinter();
    return printer.printNode(ts.EmitHint.Unspecified, node, this.sourceFile);
  }
}

function generateFlattenedTypes(
  tables: TableInfo[],
  views: ViewInfo[],
  enums: EnumInfo[]
): string {
  let output = '// Auto-generated from types/supabase-types.ts\n\n';

  // Import the Json type
  output += 'import type { Json, Database } from "@/types/supabase-types";\n\n';

  // Generate table types
  output += '// ============= TABLES =============\n\n';

  for (const table of tables) {
    const capitalizedName =
      table.name.charAt(0).toUpperCase() + table.name.slice(1);
    const schemaPrefix =
      table.schema === 'public' ? '' : `${capitalizeFirst(table.schema)}`;

    if (table.row) {
      output += `export type ${schemaPrefix}${capitalizedName}Row = ${table.row};\n\n`;
    }

    if (table.insert) {
      output += `export type ${schemaPrefix}${capitalizedName}Insert = ${table.insert};\n\n`;
    }

    if (table.update) {
      output += `export type ${schemaPrefix}${capitalizedName}Update = ${table.update};\n\n`;
    }
  }

  // Generate view types
  if (views.length > 0) {
    output += '// ============= VIEWS =============\n\n';

    for (const view of views) {
      const capitalizedName =
        view.name.charAt(0).toUpperCase() + view.name.slice(1);
      const schemaPrefix =
        view.schema === 'public' ? '' : `${capitalizeFirst(view.schema)}`;

      if (view.row) {
        output += `export type ${schemaPrefix}${capitalizedName}Row = ${view.row};\n\n`;
      }
    }
  }

  // Generate enum types
  if (enums.length > 0) {
    output += '// ============= ENUMS =============\n\n';

    for (const enumInfo of enums) {
      const capitalizedName =
        enumInfo.name.charAt(0).toUpperCase() + enumInfo.name.slice(1);
      const schemaPrefix =
        enumInfo.schema === 'public'
          ? ''
          : `${capitalizeFirst(enumInfo.schema)}`;
      const unionType = enumInfo.values.map((v) => `"${v}"`).join(' | ');

      output += `export type ${schemaPrefix}${capitalizedName} = ${unionType};\n\n`;
    }
  }

  // Generate lists of table and view names for runtime checks
  output += '// ============= HELPERS =============\n\n';

  const tableNamesArray = tables.map(t => `"${t.name}"`).join(',\n  ');
  output += `export const tableNames = [\n  ${tableNamesArray}\n] as const;\n\n`;

  const viewNamesArray = views.map(v => `"${v.name}"`).join(',\n  ');
  output += `export const viewNames = [\n  ${viewNamesArray}\n] as const;\n\n`;

  return output;
}

function capitalizeFirst(str: string): string {
  return str.charAt(0).toUpperCase() + str.slice(1);
}

// Main execution
async function main() {
  try {
    const supabaseTypesPath = path.join(
      process.cwd(),
      'types/supabase-types.ts'
    );

    if (!fs.existsSync(supabaseTypesPath)) {
      console.error(
        '❌ types/supabase-types.ts not found in current directory'
      );
      process.exit(1);
    }

    console.log('🔍 Extracting types from types/supabase-types.ts...');

    const extractor = new SupabaseTypeExtractor(supabaseTypesPath);
    const { tables, views, enums } = extractor.extract();

    console.log(
      `✅ Found ${tables.length} tables, ${views.length} views, ${enums.length} enums`
    );

    const flattenedTypes = generateFlattenedTypes(tables, views, enums);
    const outputPath = path.join(process.cwd(), 'types/flattened-types.ts');

    fs.writeFileSync(outputPath, flattenedTypes, 'utf-8');

    console.log(`🎉 Generated flattened types: ${outputPath}`);

    // Log summary
    console.log('\n📊 Summary:');
    tables.forEach((table) => {
      const types = [
        table.row && 'Row',
        table.insert && 'Insert',
        table.update && 'Update',
      ]
        .filter(Boolean)
        .join(', ');
      console.log(`  📋 ${table.schema}.${table.name}: ${types}`);
    });

    if (views.length > 0) {
      views.forEach((view) => {
        console.log(`  👁️  ${view.schema}.${view.name}: Row`);
      });
    }

    if (enums.length > 0) {
      enums.forEach((enumInfo) => {
        console.log(
          `  🔤 ${enumInfo.schema}.${enumInfo.name}: ${enumInfo.values.length} values`
        );
      });
    }
  } catch (error) {
    console.error('❌ Error generating flattened types:', error);
    process.exit(1);
  }
}

main();

```

<!-- path: scripts/generate-zod-schemas.ts -->
```typescript
import * as ts from 'typescript';
import * as fs from 'fs';
import * as path from 'path';
import {
  ValidationConfig,
  loadValidationConfig,
} from '@/utils/zod-validation.config';

interface PropertyInfo {
  name: string;
  type: string;
  isOptional: boolean;
  isNullable: boolean;
}

interface TypeInfo {
  name: string;
  properties: PropertyInfo[];
}

class TypeScriptToZodConverter {
  private sourceFile: ts.SourceFile;
  private checker: ts.TypeChecker;
  private config: ValidationConfig;

  constructor(filePath: string) {
    const program = ts.createProgram([filePath], {
      target: ts.ScriptTarget.ES2020,
      module: ts.ModuleKind.CommonJS,
    });
    this.sourceFile = program.getSourceFile(filePath)!;
    this.checker = program.getTypeChecker();
    this.config = loadValidationConfig();
  }

  extractTypes(): TypeInfo[] {
    const types: TypeInfo[] = [];

    const visit = (node: ts.Node) => {
      if (ts.isTypeAliasDeclaration(node) && ts.isIdentifier(node.name)) {
        const typeName = node.name.text;

        // Skip the Json type import
        if (typeName === 'Json') {
          ts.forEachChild(node, visit);
          return;
        }

        if (ts.isTypeLiteralNode(node.type)) {
          const properties = this.extractProperties(node.type);
          types.push({ name: typeName, properties });
        }
      }
      ts.forEachChild(node, visit);
    };

    visit(this.sourceFile);
    return types;
  }

  private extractProperties(typeNode: ts.TypeLiteralNode): PropertyInfo[] {
    const properties: PropertyInfo[] = [];

    for (const member of typeNode.members) {
      if (ts.isPropertySignature(member) && ts.isIdentifier(member.name)) {
        const name = member.name.text;
        const isOptional = !!member.questionToken;

        if (member.type) {
          const typeInfo = this.analyzeType(member.type);
          properties.push({
            name,
            type: typeInfo.type,
            isOptional,
            isNullable: typeInfo.isNullable,
          });
        }
      }
    }

    return properties;
  }

  private analyzeType(typeNode: ts.TypeNode): {
    type: string;
    isNullable: boolean;
  } {
    if (ts.isUnionTypeNode(typeNode)) {
      const types = typeNode.types.map((t) => this.analyzeType(t));
      const hasNull = types.some((t) => t.type === 'null');
      const nonNullTypes = types.filter((t) => t.type !== 'null');

      if (nonNullTypes.length === 1) {
        return {
          type: nonNullTypes[0].type,
          isNullable: hasNull || nonNullTypes[0].isNullable,
        };
      } else {
        // Multiple non-null types - create union
        const unionTypes = nonNullTypes.map((t) => t.type).join(' | ');
        return {
          type: unionTypes,
          isNullable: hasNull,
        };
      }
    }

    if (
      ts.isToken(typeNode) &&
      typeNode.kind >= ts.SyntaxKind.FirstKeyword &&
      typeNode.kind <= ts.SyntaxKind.LastKeyword
    ) {
      switch (typeNode.kind) {
        case ts.SyntaxKind.StringKeyword:
          return { type: 'string', isNullable: false };
        case ts.SyntaxKind.NumberKeyword:
          return { type: 'number', isNullable: false };
        case ts.SyntaxKind.BooleanKeyword:
          return { type: 'boolean', isNullable: false };
        case ts.SyntaxKind.NullKeyword:
          return { type: 'null', isNullable: false };
        case ts.SyntaxKind.UndefinedKeyword:
          return { type: 'undefined', isNullable: false };
      }
    }

    if (
      ts.isTypeReferenceNode(typeNode) &&
      ts.isIdentifier(typeNode.typeName)
    ) {
      const typeName = typeNode.typeName.text;
      if (typeName === 'Json') {
        return { type: 'Json', isNullable: false };
      }
      return { type: typeName, isNullable: false };
    }

    if (ts.isLiteralTypeNode(typeNode)) {
      if (ts.isStringLiteral(typeNode.literal)) {
        return { type: `"${typeNode.literal.text}"`, isNullable: false };
      }
      if (ts.isNumericLiteral(typeNode.literal)) {
        return { type: typeNode.literal.text, isNullable: false };
      }
    }

    // Fallback - get the text representation
    const printer = ts.createPrinter();
    const typeText = printer.printNode(
      ts.EmitHint.Unspecified,
      typeNode,
      this.sourceFile
    );
    return { type: typeText, isNullable: false };
  }

  private typeToZodSchema(
    type: string,
    isNullable: boolean,
    fieldName?: string,
    tableName?: string
  ): string {
    // Handle literal types (enums)
    if (type.includes('"') && type.includes('|')) {
      const literalValues = type.split(' | ').map((v) => v.trim());
      const zodEnum = `z.enum([${literalValues.join(', ')}])`;
      return isNullable ? `${zodEnum}.nullable()` : zodEnum;
    }

    // Handle single literal types
    if (type.startsWith('"') && type.endsWith('"')) {
      const literal = `z.literal(${type})`;
      return isNullable ? `${literal}.nullable()` : literal;
    }

    // Handle basic types with smart validation based on field names
    let zodType: string;
    switch (type) {
      case 'string':
        zodType = this.getSmartStringValidation(fieldName || '', tableName);
        break;
      case 'number':
        zodType = this.getSmartNumberValidation(fieldName || '', tableName);
        break;
      case 'boolean':
        zodType = 'z.boolean()';
        break;
      case 'Json':
        zodType = 'z.any()'; // Json type is flexible
        break;
      case 'null':
        zodType = 'z.null()';
        break;
      case 'undefined':
        zodType = 'z.undefined()';
        break;
      default:
        // Handle custom types or unions
        if (type.includes(' | ')) {
          const unionTypes = type.split(' | ').map((t) => t.trim());
          const zodUnionTypes = unionTypes
            .map((t) => this.typeToZodSchema(t, false, fieldName))
            .join(', ');
          zodType = `z.union([${zodUnionTypes}])`;
        } else {
          // Assume it's a string for unknown types
          zodType = 'z.string()';
        }
    }

    return isNullable ? `${zodType}.nullable()` : zodType;
  }

  private getSmartStringValidation(
    fieldName: string,
    tableName?: string
  ): string {
    // Check custom rules first
    const customRule = this.config.customRules.find(
      (rule) =>
        rule.fieldName === fieldName &&
        this.matchesTableName(rule.tableName, tableName)
    );
    if (customRule) {
      return customRule.validation;
    }

    // Check string rules
    const lowerName = fieldName.toLowerCase();
    for (const rule of this.config.stringRules) {
      for (const pattern of rule.fieldPatterns) {
        if (this.matchesPattern(lowerName, pattern)) {
          return rule.validation;
        }
      }
    }

    // Default string validation
    return 'z.string()';
  }

  private getSmartNumberValidation(
    fieldName: string,
    tableName?: string
  ): string {
    // Check custom rules first
    const customRule = this.config.customRules.find(
      (rule) =>
        rule.fieldName === fieldName &&
        this.matchesTableName(rule.tableName, tableName)
    );
    if (customRule) {
      return customRule.validation;
    }

    // Check number rules
    const lowerName = fieldName.toLowerCase();
    for (const rule of this.config.numberRules) {
      for (const pattern of rule.fieldPatterns) {
        if (this.matchesPattern(lowerName, pattern)) {
          return rule.validation;
        }
      }
    }

    // Default number validation
    return 'z.number()';
  }

  private matchesTableName(
    ruleTableName?: string,
    actualTableName?: string
  ): boolean {
    if (!ruleTableName) {
      return true; // Global rule
    }
    if (!actualTableName) {
      return false; // Cannot match a specific rule if table name is unknown
    }
  
    // ** Use includes() for partial matching**
    return actualTableName.toLowerCase().includes(ruleTableName.toLowerCase());
  }

  private matchesPattern(fieldName: string, pattern: string): boolean {
    // If pattern starts and ends with ^$, treat as regex
    if (pattern.startsWith('^') && pattern.endsWith('$')) {
      return new RegExp(pattern).test(fieldName);
    }

    // If pattern contains regex chars, treat as regex
    if (
      pattern.includes('*') ||
      pattern.includes('.') ||
      pattern.includes('^') ||
      pattern.includes('$') ||
      pattern.includes('[') ||
      pattern.includes(']')
    ) {
      return new RegExp(pattern).test(fieldName);
    }

    // Otherwise, simple includes check
    return fieldName.includes(pattern);
  }

  generateZodSchemas(types: TypeInfo[]): string {
    let output = '// Auto-generated Zod schemas from flattened-types.ts\n\n';
    output += 'import { z } from "zod";\n\n';
    output += 'import { UserRole } from "@/types/user-roles";\n\n';

    // Group types by category
    const tableTypes = types.filter(
      (t) =>
        t.name.endsWith('Row') ||
        t.name.endsWith('Insert') ||
        t.name.endsWith('Update')
    );
    const viewTypes = types.filter(
      (t) => t.name.includes('v_') // or whatever your view naming convention is
    );
    const enumTypes = types.filter(
      (t) =>
        !t.name.endsWith('Row') &&
        !t.name.endsWith('Insert') &&
        !t.name.endsWith('Update')
    );

    // Generate table schemas
    if (tableTypes.length > 0) {
      output += '// ============= TABLE SCHEMAS =============\n\n';

      for (const type of tableTypes) {
        output += this.generateTypeSchema(type);
      }
    }

    // Generate view schemas
    if (viewTypes.length > 0) {
      output += '// ============= VIEW SCHEMAS =============\n\n';

      for (const type of viewTypes) {
        output += this.generateTypeSchema(type);
      }
    }

    // Generate enum schemas
    if (enumTypes.length > 0) {
      output += '// ============= ENUM SCHEMAS =============\n\n';

      for (const type of enumTypes) {
        // For enums, we need to handle them differently since they're usually union types
        if (type.properties.length === 0) {
          // This is likely a direct enum type, skip for now
          continue;
        }
        output += this.generateTypeSchema(type);
      }
    }

    // Generate a convenience export object
    output += '// ============= CONVENIENCE EXPORTS =============\n\n';
    output += 'export const schemas = {\n';

    for (const type of types) {
      if (type.properties.length > 0) {
        const schemaName = `${type.name
          .charAt(0)
          .toLowerCase()}${type.name.slice(1)}Schema`;
        output += `  ${schemaName},\n`;
      }
    }

    output += '} as const;\n\n';

    // Generate type exports
    output += '// ============= TYPE EXPORTS =============\n\n';
    for (const type of types) {
      if (type.properties.length > 0) {
        const schemaName = `${type.name
          .charAt(0)
          .toLowerCase()}${type.name.slice(1)}Schema`;
        output += `export type ${type.name}Schema = z.infer<typeof ${schemaName}>;\n`;
      }
    }

    return output;
  }

  private generateTypeSchema(type: TypeInfo): string {
    if (type.properties.length === 0) {
      return '';
    }

    // ✅ derive real table name from the type alias
    const baseTableName = type.name.replace(/(Row|Insert|Update)$/, ''); // strip suffixes like "Row"

    const schemaName = `${type.name.charAt(0).toLowerCase()}${type.name.slice(
      1
    )}Schema`;
    let output = `export const ${schemaName} = z.object({\n`;

    for (const prop of type.properties) {
      const zodType = this.typeToZodSchema(
        prop.type,
        prop.isNullable,
        prop.name,
        baseTableName // pass table name
      );
      const finalType = prop.isOptional ? `${zodType}.optional()` : zodType;
      output += `  ${prop.name}: ${finalType},\n`;
    }

    output += '});\n\n';
    return output;
  }
}

async function main() {
  try {
    const flattenedTypesPath = path.join(
      process.cwd(),
      'types/flattened-types.ts'
    );

    if (!fs.existsSync(flattenedTypesPath)) {
      console.error(
        '❌ flattened-types.ts not found. Run gen:flattened first.'
      );
      process.exit(1);
    }

    console.log('🔍 Converting TypeScript types to Zod schemas...');

    const converter = new TypeScriptToZodConverter(flattenedTypesPath);
    const types = converter.extractTypes();

    console.log(`✅ Found ${types.length} types to convert`);

    const zodSchemas = converter.generateZodSchemas(types);
    const outputPath = path.join(process.cwd(), 'schemas/zod-schemas.ts');
    const outputDir = path.dirname(outputPath);
    if (!fs.existsSync(outputDir)) {
      fs.mkdirSync(outputDir, { recursive: true });
    }

    fs.writeFileSync(outputPath, zodSchemas, 'utf-8');

    console.log(`🎉 Generated Zod schemas: ${outputPath}`);

    // Log summary
    console.log('\n📊 Summary:');
    for (const type of types) {
      if (type.properties.length > 0) {
        console.log(`  🔧 ${type.name}: ${type.properties.length} properties`);
      }
    }
  } catch (error) {
    console.error('❌ Error generating Zod schemas:', error);
    process.exit(1);
  }
}

main();
```

<!-- path: data/migrations/05_auditing/03_triggers_attach_all.sql -->
```sql
-- Path: migrations/05_auditing/03_triggers_attach_all.sql
-- Description: Dynamically attaches the log_data_changes trigger to all relevant tables.
-- This script is idempotent and can be re-run safely.

DO $$
DECLARE
    table_rec RECORD;
    trigger_name TEXT;
BEGIN
    -- Loop through all user tables in the 'public' schema
    FOR table_rec IN
        SELECT t.table_name
        FROM information_schema.tables t
        WHERE t.table_schema = 'public'
          AND t.table_type = 'BASE TABLE'
          -- Exclude the log table itself to prevent infinite loops
          AND t.table_name <> 'user_activity_logs'
          -- Only attach to tables that have an 'id' column, which is our standard for auditable records
          AND EXISTS (
              SELECT 1
              FROM information_schema.columns c
              WHERE c.table_schema = t.table_schema
                AND c.table_name = t.table_name
                AND c.column_name = 'id'
          )
    LOOP
        trigger_name := table_rec.table_name || '_log_trigger';

        -- Drop the trigger if it already exists to ensure it's up-to-date
        EXECUTE format('DROP TRIGGER IF EXISTS %I ON public.%I;', trigger_name, table_rec.table_name);

        -- Create the new trigger
        EXECUTE format('CREATE TRIGGER %I ' ||
                       'AFTER INSERT OR UPDATE OR DELETE ON public.%I ' ||
                       'FOR EACH ROW EXECUTE FUNCTION public.log_data_changes();',
                       trigger_name,
                       table_rec.table_name);

        RAISE NOTICE 'Created/Refreshed audit trigger on table: public.%', table_rec.table_name;
    END LOOP;
END;
$$;
```

<!-- path: data/migrations/05_auditing/01_table_user_activity_logs.sql -->
```sql
-- Path: migrations/05_auditing/01_table_user_activity_logs.sql
-- Description: Defines the table for storing all user activity and data change logs.

CREATE TABLE IF NOT EXISTS public.user_activity_logs (
    id BIGSERIAL PRIMARY KEY,
    user_id UUID REFERENCES auth.users(id) ON DELETE SET NULL,
    user_role TEXT,
    action_type TEXT NOT NULL,
    table_name TEXT,
    record_id TEXT,
    old_data JSONB,
    new_data JSONB,
    details TEXT,
    created_at TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP
);

-- Add indexes for better query performance on the logs table
CREATE INDEX IF NOT EXISTS idx_user_activity_logs_user_id ON public.user_activity_logs(user_id);
CREATE INDEX IF NOT EXISTS idx_user_activity_logs_action_type ON public.user_activity_logs(action_type);
CREATE INDEX IF NOT EXISTS idx_user_activity_logs_table_name ON public.user_activity_logs(table_name);
```

<!-- path: data/migrations/05_auditing/02_functions.sql -->
```sql
-- Path: migrations/05_auditing/02_functions.sql
-- Description: Core functions for the auditing system.

-- Function 1: log_user_activity()
-- This is the generic logging function that inserts a record into the audit table.
-- It can be called directly for custom actions or by the trigger function for data changes.
CREATE OR REPLACE FUNCTION public.log_user_activity(
    p_action_type TEXT,
    p_table_name TEXT DEFAULT NULL,
    p_record_id TEXT DEFAULT NULL,
    p_old_data JSONB DEFAULT NULL,
    p_new_data JSONB DEFAULT NULL,
    p_details TEXT DEFAULT NULL
)
RETURNS VOID
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = ''
AS $$
BEGIN
    INSERT INTO public.user_activity_logs (
        user_id,
        user_role,
        action_type,
        table_name,
        record_id,
        old_data,
        new_data,
        details
    )
    VALUES (
        auth.uid(),
        public.get_my_role(),
        p_action_type,
        p_table_name,
        p_record_id,
        p_old_data,
        p_new_data,
        p_details
    );
END;
$$;


-- Function 2: log_data_changes()
-- This is the TRIGGER function that will be attached to tables.
-- It captures INSERT, UPDATE, DELETE events and calls log_user_activity() with the correct data.
CREATE OR REPLACE FUNCTION public.log_data_changes()
RETURNS TRIGGER
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = ''
AS $$
DECLARE
    v_record_id TEXT;
BEGIN
    IF (TG_OP = 'INSERT') THEN
        v_record_id := NEW.id::TEXT;
        PERFORM public.log_user_activity(
            'INSERT',
            TG_TABLE_NAME,
            v_record_id,
            NULL,
            row_to_json(NEW)::jsonb
        );
        RETURN NEW;
    ELSIF (TG_OP = 'UPDATE') THEN
        v_record_id := NEW.id::TEXT;
        PERFORM public.log_user_activity(
            'UPDATE',
            TG_TABLE_NAME,
            v_record_id,
            row_to_json(OLD)::jsonb,
            row_to_json(NEW)::jsonb
        );
        RETURN NEW;
    ELSIF (TG_OP = 'DELETE') THEN
        v_record_id := OLD.id::TEXT;
        PERFORM public.log_user_activity(
            'DELETE',
            TG_TABLE_NAME,
            v_record_id,
            row_to_json(OLD)::jsonb,
            NULL
        );
        RETURN OLD;
    END IF;
    -- This line is unreachable in an AFTER trigger but is good practice.
    RETURN NULL;
END;
$$;
```

<!-- path: data/migrations/05_auditing/04_rls_and_grants.sql -->
```sql
-- Path: migrations/05_auditing/04_rls_and_grants.sql
-- Description: Secures the user_activity_logs table, allowing access only to admins.

-- Enable Row Level Security on the log table
ALTER TABLE public.user_activity_logs ENABLE ROW LEVEL SECURITY;

-- Grant table-level permissions to the 'admin' role
GRANT ALL ON public.user_activity_logs TO admin;

-- Drop existing policies for idempotency
DROP POLICY IF EXISTS "Allow full access to admins" ON public.user_activity_logs;

-- Create a single policy granting full access (SELECT, INSERT, UPDATE, DELETE)
-- only to users who are super_admins or have the 'admin' role.
CREATE POLICY "Allow full access to admins"
ON public.user_activity_logs
FOR ALL
TO admin
USING (is_super_admin() OR get_my_role() = 'admin')
WITH CHECK (is_super_admin() OR get_my_role() = 'admin');
```

<!-- path: data/migrations/03_network_systems/02_views.sql -->
```sql
-- path: data/migrations/03_network_systems/02_views.sql
-- Description: Defines denormalized views for the Network Systems module. [PERFORMANCE OPTIMIZED]

-- View for a complete picture of a system and its specific details.
CREATE OR REPLACE VIEW public.v_systems_complete WITH (security_invoker = true) AS
SELECT
  s.*,
  n.name AS node_name,
  lt_node_type.name AS node_type_name,
  n.latitude,
  n.longitude,
  lt_system.name AS system_type_name,
  lt_system.code AS system_type_code,
  lt_system.category AS system_category,
  ma.name AS system_maintenance_terminal_name,
  rbs.ring_id,
  ring_area.name AS ring_logical_area_name,
  ss.gne AS sdh_gne,
  vs.vm_id AS vmux_vm_id
FROM public.systems s
  JOIN public.nodes n ON s.node_id = n.id
  JOIN public.lookup_types lt_system ON s.system_type_id = lt_system.id
  LEFT JOIN public.lookup_types lt_node_type ON n.node_type_id = lt_node_type.id
  LEFT JOIN public.maintenance_areas ma ON s.maintenance_terminal_id = ma.id
  LEFT JOIN public.ring_based_systems rbs ON s.id = rbs.system_id
  LEFT JOIN public.maintenance_areas ring_area ON rbs.maintenance_area_id = ring_area.id
  LEFT JOIN public.sdh_systems ss ON s.id = ss.system_id
  LEFT JOIN public.vmux_systems vs ON s.id = vs.system_id;


-- View for a complete picture of a system connection and its specific details.
CREATE OR REPLACE VIEW public.v_system_connections_complete WITH (security_invoker = true) AS
SELECT
  sc.id, sc.system_id, s.system_name, lt_system.name AS system_type_name,
  s_sn.system_name AS sn_name, na.name AS sn_node_name, sc.sn_ip, sc.sn_interface,
  s_en.system_name AS en_name, nb.name AS en_node_name, sc.en_ip, sc.en_interface,
  lt_media.name AS media_type_name, sc.bandwidth_mbps, cs.system_name AS connected_system_name,
  lt_cs_type.name AS connected_system_type_name, sc.vlan, sc.commissioned_on,
  sc.remark, sc.status, sc.created_at, sc.updated_at,
  -- SFP-based details
  sfpc.sfp_port, lt_sfp.name as sfp_type_name, sfpc.sfp_capacity,
  sfpc.sfp_serial_no, sfpc.fiber_in, sfpc.fiber_out, sfpc.customer_name, sfpc.bandwidth_allocated_mbps,
  -- SDH details
  scs.stm_no AS sdh_stm_no, scs.carrier AS sdh_carrier, scs.a_slot AS sdh_a_slot,
  scs.a_customer AS sdh_a_customer, scs.b_slot AS sdh_b_slot, scs.b_customer AS sdh_b_customer,
  -- VMUX details
  vcs.subscriber AS vmux_subscriber, vcs.c_code AS vmux_c_code, vcs.channel AS vmux_channel, vcs.tk AS vmux_tk
FROM public.system_connections sc
  JOIN public.systems s ON sc.system_id = s.id
  JOIN public.lookup_types lt_system ON s.system_type_id = lt_system.id
  LEFT JOIN public.systems s_sn ON sc.sn_id = s_sn.id
  LEFT JOIN public.nodes na ON s_sn.node_id = na.id
  LEFT JOIN public.systems s_en ON sc.en_id = s_en.id
  LEFT JOIN public.nodes nb ON s_en.node_id = nb.id
  LEFT JOIN public.systems cs ON sc.connected_system_id = cs.id
  LEFT JOIN public.lookup_types lt_cs_type ON cs.system_type_id = lt_cs_type.id
  LEFT JOIN public.lookup_types lt_media ON sc.media_type_id = lt_media.id
  LEFT JOIN public.sfp_based_connections sfpc ON sc.id = sfpc.system_connection_id
  LEFT JOIN public.lookup_types lt_sfp ON sfpc.sfp_type_id = lt_sfp.id
  LEFT JOIN public.sdh_connections scs ON sc.id = scs.system_connection_id
  LEFT JOIN public.vmux_connections vcs ON sc.id = vcs.system_connection_id;


-- View for OFC Connections, now including system details from this module.
CREATE OR REPLACE VIEW public.v_ofc_connections_complete WITH (security_invoker = true) AS
SELECT
  oc.id::uuid,
  oc.ofc_id::uuid,
  oc.fiber_no_sn::integer,
  oc.fiber_no_en::integer,
  oc.updated_fiber_no_sn::integer,
  oc.updated_fiber_no_en::integer,
  oc.updated_sn_id::uuid,
  oc.updated_en_id::uuid,
  oc.otdr_distance_sn_km::numeric(10,3),
  oc.sn_dom::date,
  oc.sn_power_dbm::numeric(10,3),
  oc.system_id::uuid,
  oc.otdr_distance_en_km::numeric(10,3),
  oc.en_dom::date,
  oc.en_power_dbm::numeric(10,3),
  oc.route_loss_db::numeric(10,3),
  oc.logical_path_id::uuid,
  oc.fiber_role::text,
  oc.path_segment_order::integer,
  oc.source_port::text,
  oc.destination_port::text,
  oc.connection_category::text,
  oc.connection_type::text,
  oc.remark::text,
  oc.status::boolean,
  oc.created_at::timestamptz,
  oc.updated_at::timestamptz,
  ofc.route_name AS ofc_route_name,
  ma.name AS maintenance_area_name,
  ofc.sn_id::uuid,
  ofc.en_id::uuid,
  ofc_type.name AS ofc_type_name,
  na.name AS sn_name,
  s.system_name AS system_name,
  nb.name AS en_name,
  updated_na.name AS updated_sn_name, -- NEW: The name of the logical start node
  updated_nb.name AS updated_en_name  -- NEW: The name of the logical end node
FROM public.ofc_connections oc
  JOIN public.ofc_cables ofc ON oc.ofc_id = ofc.id
  JOIN public.lookup_types ofc_type ON ofc.ofc_type_id = ofc_type.id
  LEFT JOIN public.nodes na ON ofc.sn_id = na.id
  LEFT JOIN public.nodes nb ON ofc.en_id = nb.id
  LEFT JOIN public.systems s ON oc.system_id = s.id
  LEFT JOIN public.maintenance_areas ma ON ofc.maintenance_terminal_id = ma.id
  LEFT JOIN public.nodes updated_na ON oc.updated_sn_id = updated_na.id
  LEFT JOIN public.nodes updated_nb ON oc.updated_en_id = updated_nb.id;


-- View for Ring Map Node Data
CREATE OR REPLACE VIEW public.v_ring_nodes WITH (security_invoker = true) AS
SELECT
    n.id,
    r.id as ring_id,
    r.name as ring_name,
    n.name,
    n.latitude as lat,
    n.longitude as long,
    ROW_NUMBER() OVER(PARTITION BY r.id ORDER BY n.name) as order_in_ring,
    lt.name as type,
    -- [THE FIX] Expose both the ring's status and the system's status for accurate representation.
    r.status AS ring_status,
    s.status AS system_status,
    s.ip_address::text as ip,
    n.remark
FROM
    public.rings r
JOIN
    public.ring_based_systems rbs ON r.id = rbs.ring_id
JOIN
    public.systems s ON rbs.system_id = s.id
JOIN
    public.nodes n ON s.node_id = n.id
LEFT JOIN
    public.lookup_types lt ON n.node_type_id = lt.id;

-- View for rings with joined data
CREATE OR REPLACE VIEW public.v_rings WITH (security_invoker = true) AS
SELECT
  r.id,
  r.name,
  r.description,
  r.ring_type_id,
  r.maintenance_terminal_id,
  r.status,
  r.created_at,
  r.updated_at,
  (SELECT COUNT(s.node_id) FROM public.ring_based_systems rbs JOIN public.systems s ON rbs.system_id = s.id WHERE rbs.ring_id = r.id) as total_nodes,
  lt_ring.name AS ring_type_name,
  lt_ring.code AS ring_type_code,
  ma.name AS maintenance_area_name
FROM public.rings r
LEFT JOIN public.lookup_types lt_ring ON r.ring_type_id = lt_ring.id
LEFT JOIN public.maintenance_areas ma ON r.maintenance_terminal_id = ma.id;
```

<!-- path: data/migrations/03_network_systems/03_indexes.sql -->
```sql
-- Path: migrations/03_network_systems/03_indexes.sql
-- Description: Creates B-tree and GIN (FTS) indexes for the Network Systems module.

-- =================================================================
-- Section 1: Standard B-Tree Indexes
-- =================================================================

-- Indexes for the generic systems table
CREATE INDEX IF NOT EXISTS idx_systems_node_id ON public.systems (node_id);

-- Indexes for the new consolidated tables
CREATE INDEX IF NOT EXISTS idx_ring_based_systems_ring_area ON public.ring_based_systems (ring_id, maintenance_area_id);
CREATE INDEX IF NOT EXISTS idx_sfp_based_connections_customer ON public.sfp_based_connections (customer_name);

-- Indexes for other system-specific tables
CREATE INDEX IF NOT EXISTS idx_systems_make ON public.systems (make);

-- =================================================================
-- Section 2: Full-Text Search (FTS) GIN Indexes
-- =================================================================

CREATE INDEX IF NOT EXISTS idx_systems_remark_fts ON public.systems USING gin(to_tsvector('english', remark));
CREATE INDEX IF NOT EXISTS idx_system_connections_remark_fts ON public.system_connections USING gin(to_tsvector('english', remark));
CREATE INDEX IF NOT EXISTS idx_management_ports_remark_fts ON public.management_ports USING gin(to_tsvector('english', remark));
```

<!-- path: data/migrations/03_network_systems/01_tables_systems.sql -->
```sql
-- Path: migrations/03_network_systems/01_tables_systems.sql
-- Description: Defines tables for generic and specific network systems.

-- 1. Generic Systems Table (e.g., CPAN, MAAN, SDH, VMUX)
CREATE TABLE IF NOT EXISTS public.systems (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  system_type_id UUID REFERENCES public.lookup_types (id) NOT NULL,
  node_id UUID REFERENCES public.nodes (id) NOT NULL,
  system_name TEXT,
  ip_address INET,
  maintenance_terminal_id UUID REFERENCES public.maintenance_areas (id),
  commissioned_on DATE,
  s_no TEXT,
  make TEXT, -- ADDED: 'make' is a common property, moved to the main table.
  remark TEXT,
  status BOOLEAN DEFAULT true,
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);


-- 2. Generic System Connections Table
CREATE TABLE IF NOT EXISTS public.system_connections (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  system_id UUID REFERENCES public.systems (id) NOT NULL,
  sn_id UUID REFERENCES public.systems (id),
  en_id UUID REFERENCES public.systems (id),
  connected_system_id UUID REFERENCES public.systems (id),
  sn_ip INET,
  sn_interface TEXT,
  en_ip INET,
  en_interface TEXT,
  media_type_id UUID REFERENCES public.lookup_types (id),
  bandwidth_mbps INTEGER,
  vlan TEXT,
  commissioned_on DATE,
  remark TEXT,
  status BOOLEAN DEFAULT true,
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- 3. Management Network Ports Table
CREATE TABLE IF NOT EXISTS public.management_ports (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  port_no TEXT NOT NULL,
  name TEXT,
  node_id UUID REFERENCES public.nodes (id),
  system_id UUID REFERENCES public.systems (id),
  commissioned_on DATE,
  remark TEXT,
  status BOOLEAN DEFAULT true,
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- 4. Consolidated Table for Ring-Based System Details (replaces cpan_systems, maan_systems)
CREATE TABLE IF NOT EXISTS public.ring_based_systems (
  system_id UUID PRIMARY KEY REFERENCES public.systems (id) ON DELETE CASCADE,
  ring_id UUID REFERENCES public.rings (id),
  maintenance_area_id UUID REFERENCES public.maintenance_areas (id)
);

-- 5. Consolidated Table for SFP-Based Connection Details (replaces cpan_connections, maan_connections)
CREATE TABLE IF NOT EXISTS public.sfp_based_connections (
  system_connection_id UUID PRIMARY KEY REFERENCES public.system_connections (id) ON DELETE CASCADE,
  sfp_port TEXT,
  sfp_type_id UUID REFERENCES public.lookup_types (id),
  sfp_capacity TEXT,
  sfp_serial_no TEXT,
  fiber_in INTEGER,
  fiber_out INTEGER,
  customer_name TEXT,
  bandwidth_allocated_mbps INTEGER
);

-- 6. Dedicated Table for SDH System Specific Details
CREATE TABLE IF NOT EXISTS public.sdh_systems (
  system_id UUID PRIMARY KEY REFERENCES public.systems (id) ON DELETE CASCADE,
  gne TEXT
);

-- 7. Dedicated Table for SDH Connection Specific Details
CREATE TABLE IF NOT EXISTS public.sdh_connections (
  system_connection_id UUID PRIMARY KEY REFERENCES public.system_connections (id) ON DELETE CASCADE,
  stm_no TEXT,
  carrier TEXT,
  a_slot TEXT,
  a_customer TEXT,
  b_slot TEXT,
  b_customer TEXT
);

-- 8. SDH Node Associations Table
CREATE TABLE IF NOT EXISTS public.sdh_node_associations (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  sdh_system_id UUID REFERENCES public.sdh_systems (system_id) NOT NULL,
  node_id UUID REFERENCES public.nodes (id) NOT NULL,
  node_position CHAR(1) CHECK (node_position IN ('A', 'B', 'C', 'D', 'E', 'F', 'G', 'H')),
  node_ip INET,
  CONSTRAINT uq_sdh_system_position UNIQUE (sdh_system_id, node_position)
);

-- 9. Dedicated Table for VMUX System Specific Details
CREATE TABLE IF NOT EXISTS public.vmux_systems (
  system_id UUID PRIMARY KEY REFERENCES public.systems (id) ON DELETE CASCADE,
 vm_id TEXT
);

-- 10. Dedicated Table for VMUX Connection Specific Details
CREATE TABLE IF NOT EXISTS public.vmux_connections (
  system_connection_id UUID PRIMARY KEY REFERENCES public.system_connections (id) ON DELETE CASCADE,
  subscriber TEXT,
  c_code TEXT,
  channel TEXT,
  tk TEXT
);
```

<!-- path: data/migrations/03_network_systems/04_rls_and_grants.sql -->
```sql
-- path: data/migrations/03_network_systems/05_rls_and_grants.sql
-- Description: Defines all RLS policies and Grants for the Network Systems module. [UPDATED VIEW NAMES]

-- =================================================================
-- PART 1: GENERIC GRANTS AND RLS SETUP FOR ALL SYSTEM TABLES
-- =================================================================
DO $$
DECLARE
  tbl TEXT;
BEGIN
  -- List all tables related to network systems
  FOREACH tbl IN ARRAY ARRAY[
    'systems', 'system_connections', 'management_ports',
    'ring_based_systems', 'sfp_based_connections',
    'sdh_systems', 'sdh_connections', 'sdh_node_associations',
    'vmux_systems', 'vmux_connections'
  ]
  LOOP
    EXECUTE format('ALTER TABLE public.%I ENABLE ROW LEVEL SECURITY;', tbl);
    EXECUTE format('GRANT SELECT, INSERT, UPDATE, DELETE ON public.%I TO admin;', tbl);
    EXECUTE format('GRANT SELECT ON public.%I TO viewer;', tbl);
    EXECUTE format('GRANT SELECT, INSERT, UPDATE, DELETE ON public.%I TO cpan_admin;', tbl);
    EXECUTE format('GRANT SELECT, INSERT, UPDATE, DELETE ON public.%I TO maan_admin;', tbl);
    EXECUTE format('GRANT SELECT, INSERT, UPDATE, DELETE ON public.%I TO sdh_admin;', tbl);
    EXECUTE format('GRANT SELECT, INSERT, UPDATE, DELETE ON public.%I TO vmux_admin;', tbl);
    EXECUTE format('GRANT SELECT, INSERT, UPDATE, DELETE ON public.%I TO mng_admin;', tbl);
  END LOOP;
END;
$$;


-- =================================================================
-- PART 2: COMPLEX POLICIES FOR GENERIC TABLES (systems, system_connections)
-- =================================================================

-- Policies for the 'systems' table
DO $$
BEGIN
  -- Clean up old policies for idempotency
  DROP POLICY IF EXISTS "Allow full access based on system type" ON public.systems;
  DROP POLICY IF EXISTS "Allow viewer read-access" ON public.systems;
  DROP POLICY IF EXISTS "Allow admin full access" ON public.systems;

  -- Viewer can see all systems
  CREATE POLICY "Allow viewer read-access" ON public.systems FOR SELECT TO viewer USING (true);
  -- Admin/Super-Admin can do anything
  CREATE POLICY "Allow admin full access" ON public.systems FOR ALL TO admin USING (is_super_admin() OR get_my_role() = 'admin') WITH CHECK (is_super_admin() OR get_my_role() = 'admin');

  -- ** Decouple RLS from hardcoded names.**
  -- This policy now maps the user's role (e.g., 'cpan_admin') to the system type name ('CPAN')
  -- and then joins on the ID, making it resilient to name changes.
  CREATE POLICY "Allow full access based on system type" ON public.systems
  FOR ALL TO cpan_admin, maan_admin, sdh_admin, vmux_admin, mng_admin
  USING (
    systems.system_type_id IN (
      SELECT lt.id
      FROM public.lookup_types lt
      WHERE lt.category = 'SYSTEM' AND (
        (public.get_my_role() = 'cpan_admin' AND lt.name = 'CPAN') OR
        (public.get_my_role() = 'maan_admin' AND lt.name = 'MAAN') OR
        (public.get_my_role() = 'sdh_admin' AND lt.name = 'SDH') OR
        (public.get_my_role() = 'vmux_admin' AND lt.name = 'VMUX') OR
        (public.get_my_role() = 'mng_admin' AND lt.name = 'MNGPAN')
      )
    )
  )
  WITH CHECK (
    systems.system_type_id IN (
      SELECT lt.id
      FROM public.lookup_types lt
      WHERE lt.category = 'SYSTEM' AND (
        (public.get_my_role() = 'cpan_admin' AND lt.name = 'CPAN') OR
        (public.get_my_role() = 'maan_admin' AND lt.name = 'MAAN') OR
        (public.get_my_role() = 'sdh_admin' AND lt.name = 'SDH') OR
        (public.get_my_role() = 'vmux_admin' AND lt.name = 'VMUX') OR
        (public.get_my_role() = 'mng_admin' AND lt.name = 'MNGPAN')
      )
    )
  );
END;
$$;


-- Policies for the 'system_connections' table
DO $$
BEGIN
  DROP POLICY IF EXISTS "Allow full access based on parent system type" ON public.system_connections;
  DROP POLICY IF EXISTS "Allow viewer read-access" ON public.system_connections;
  DROP POLICY IF EXISTS "Allow admin full access" ON public.system_connections;

  CREATE POLICY "Allow viewer read-access" ON public.system_connections FOR SELECT TO viewer USING (true);
  CREATE POLICY "Allow admin full access" ON public.system_connections FOR ALL TO admin USING (is_super_admin() OR get_my_role() = 'admin') WITH CHECK (is_super_admin() OR get_my_role() = 'admin');

  -- ** Apply the same robust pattern here.**
  CREATE POLICY "Allow full access based on parent system type" ON public.system_connections
  FOR ALL TO cpan_admin, maan_admin, sdh_admin, vmux_admin, mng_admin
  USING (
    EXISTS (
      SELECT 1 FROM public.systems s
      WHERE s.id = system_connections.system_id
      AND s.system_type_id IN (
        SELECT lt.id
        FROM public.lookup_types lt
        WHERE lt.category = 'SYSTEM' AND (
          (public.get_my_role() = 'cpan_admin' AND lt.name = 'CPAN') OR
          (public.get_my_role() = 'maan_admin' AND lt.name = 'MAAN') OR
          (public.get_my_role() = 'sdh_admin' AND lt.name = 'SDH') OR
          (public.get_my_role() = 'vmux_admin' AND lt.name = 'VMUX') OR
          (public.get_my_role() = 'mng_admin' AND lt.name = 'MNGPAN')
        )
      )
    )
  )
  WITH CHECK (
    EXISTS (
      SELECT 1 FROM public.systems s
      WHERE s.id = system_connections.system_id
      AND s.system_type_id IN (
        SELECT lt.id
        FROM public.lookup_types lt
        WHERE lt.category = 'SYSTEM' AND (
          (public.get_my_role() = 'cpan_admin' AND lt.name = 'CPAN') OR
          (public.get_my_role() = 'maan_admin' AND lt.name = 'MAAN') OR
          (public.get_my_role() = 'sdh_admin' AND lt.name = 'SDH') OR
          (public.get_my_role() = 'vmux_admin' AND lt.name = 'VMUX') OR
          (public.get_my_role() = 'mng_admin' AND lt.name = 'MNGPAN')
        )
      )
    )
  );
END;
$$;


-- =================================================================
-- PART 3: AUTOMATED POLICIES FOR SYSTEM-SPECIFIC SUB-TABLES
-- =================================================================
DO $$
DECLARE
    -- Maps tables to their specific admin roles
    mappings TEXT[][] := ARRAY[
        ['ring_based_systems', 'cpan_admin'], ['ring_based_systems', 'maan_admin'],
        ['sfp_based_connections', 'cpan_admin'], ['sfp_based_connections', 'maan_admin'],
        ['sdh_systems', 'sdh_admin'], ['sdh_connections', 'sdh_admin'],
        ['sdh_node_associations', 'sdh_admin'], ['vmux_systems', 'vmux_admin'],
        ['vmux_connections', 'vmux_admin']
    ];
    tbl TEXT;
    specific_role TEXT;
    i INT;
BEGIN
    FOR i IN 1..array_length(mappings, 1) LOOP
        tbl := mappings[i][1];
        specific_role := mappings[i][2];

        -- Clean up old policies for idempotency
        EXECUTE format('DROP POLICY IF EXISTS "Allow viewer read-access" ON public.%I;', tbl);
        EXECUTE format('DROP POLICY IF EXISTS "Allow admin full access" ON public.%I;', tbl);
        EXECUTE format('DROP POLICY IF EXISTS "Allow %s full access" ON public.%I;', specific_role, tbl);

        -- Viewer can read
        EXECUTE format('CREATE POLICY "Allow viewer read-access" ON public.%I FOR SELECT TO viewer USING (true);', tbl);
        -- Admin/Super-Admin can do everything
        EXECUTE format('CREATE POLICY "Allow admin full access" ON public.%I FOR ALL TO admin USING (is_super_admin() OR get_my_role() = ''admin'') WITH CHECK (is_super_admin() OR get_my_role() = ''admin'');', tbl);
        -- The specific system admin can do everything
        EXECUTE format($p$
            CREATE POLICY "Allow %s full access" ON public.%I
            FOR ALL TO %I
            USING (public.get_my_role() = %L)
            WITH CHECK (public.get_my_role() = %L);
        $p$, specific_role, tbl, specific_role, specific_role, specific_role);

        RAISE NOTICE 'Applied specific policies for role % on table %', specific_role, tbl;
    END LOOP;
END;
$$;

-- =================================================================
-- Section 4: View-Level Grants [UPDATED VIEW NAMES]
-- =================================================================
DO $$
BEGIN
  GRANT SELECT ON public.v_systems_complete TO admin, viewer, cpan_admin, maan_admin, sdh_admin, vmux_admin, mng_admin;
  GRANT SELECT ON public.v_system_connections_complete TO admin, viewer, cpan_admin, maan_admin, sdh_admin, vmux_admin, mng_admin;
  GRANT SELECT ON public.v_ring_nodes TO admin, viewer, cpan_admin, maan_admin, sdh_admin, vmux_admin, mng_admin;
  GRANT SELECT ON public.v_rings TO admin, viewer, cpan_admin, maan_admin, sdh_admin, vmux_admin, mng_admin;
  GRANT SELECT ON public.v_ofc_connections_complete TO admin, viewer, cpan_admin, maan_admin, sdh_admin, vmux_admin, mng_admin;

  RAISE NOTICE 'Applied SELECT grants on network system views.';
END;
$$;
```

<!-- path: data/migrations/03_network_systems/05_functions.sql -->
```sql
-- Path: data/migrations/03_network_systems/06_functions.sql
-- Description: Contains functions for the Network Systems module.

-- The function logic is now restructured to handle all system subtypes correctly.
CREATE OR REPLACE FUNCTION public.upsert_system_with_details(
    p_system_name TEXT,
    p_system_type_id UUID,
    p_node_id UUID,
    p_status BOOLEAN,
    p_ip_address INET DEFAULT NULL,
    p_maintenance_terminal_id UUID DEFAULT NULL,
    p_commissioned_on DATE DEFAULT NULL,
    p_s_no TEXT DEFAULT NULL,
    p_remark TEXT DEFAULT NULL,
    p_id UUID DEFAULT NULL,
    p_ring_id UUID DEFAULT NULL,
    p_gne TEXT DEFAULT NULL,
    p_make TEXT DEFAULT NULL,
    p_vm_id TEXT DEFAULT NULL
)
RETURNS SETOF public.systems
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
DECLARE
    v_system_id UUID;
    v_system_type_name TEXT;
BEGIN
    -- Get the name of the system type to determine which subtype table to use
    SELECT name INTO v_system_type_name FROM public.lookup_types WHERE id = p_system_type_id;

    -- Step 1: Upsert the main system record (CORRECTED: Added 'make' column)
    INSERT INTO public.systems (
        id, system_name, system_type_id, node_id, ip_address,
        maintenance_terminal_id, commissioned_on, s_no, remark, status, make
    ) VALUES (
        COALESCE(p_id, gen_random_uuid()), p_system_name, p_system_type_id, p_node_id, p_ip_address,
        p_maintenance_terminal_id, p_commissioned_on, p_s_no, p_remark, p_status, p_make
    )
    ON CONFLICT (id) DO UPDATE SET
        system_name = EXCLUDED.system_name,
        system_type_id = EXCLUDED.system_type_id,
        node_id = EXCLUDED.node_id,
        ip_address = EXCLUDED.ip_address,
        maintenance_terminal_id = EXCLUDED.maintenance_terminal_id,
        commissioned_on = EXCLUDED.commissioned_on,
        s_no = EXCLUDED.s_no,
        remark = EXCLUDED.remark,
        status = EXCLUDED.status,
        make = EXCLUDED.make, -- CORRECTED: Added 'make' to the update set
        updated_at = NOW()
    RETURNING id INTO v_system_id;

    -- Step 2: Handle subtype tables based on the system type name.
    -- This logic is now separate and allows for multiple conditions to be met.

    -- Handle Ring-Based Systems (CPAN, MAAN, and SDH variants)
    IF v_system_type_name IN (
      'Next Gen Optical Transport Network', 'Converged Packet Aggregation Node', 'Multi-Access Aggregation Node', 
      'Multiprotocol Label Switching', 'Next Generation SDH', 'Optical Transport Network', 
      'Packet Transport Network', 'Plesiochronous Digital Hierarchy', 'Synchronous Digital Hierarchy'
    ) THEN
        INSERT INTO public.ring_based_systems (system_id, ring_id)
        VALUES (v_system_id, p_ring_id)
        ON CONFLICT (system_id) DO UPDATE SET ring_id = EXCLUDED.ring_id;
    END IF;

    -- Handle SDH-Specific Systems (CORRECTED: Removed 'make' from this part)
    IF v_system_type_name IN ('Synchronous Digital Hierarchy', 'Next Generation SDH') THEN
        INSERT INTO public.sdh_systems (system_id, gne)
        VALUES (v_system_id, p_gne)
        ON CONFLICT (system_id) DO UPDATE SET gne = EXCLUDED.gne;
    END IF;
    
    -- Handle VMUX-Specific Systems
    IF v_system_type_name = 'VMUX' THEN
        INSERT INTO public.vmux_systems (system_id, vm_id)
        VALUES (v_system_id, p_vm_id)
        ON CONFLICT (system_id) DO UPDATE SET vm_id = EXCLUDED.vm_id;
    END IF;

    -- Return the main system record
    RETURN QUERY SELECT * FROM public.systems WHERE id = v_system_id;
END;
$$;

GRANT EXECUTE ON FUNCTION public.upsert_system_with_details(TEXT, UUID, UUID, BOOLEAN, INET, UUID, DATE, TEXT, TEXT, UUID, UUID, TEXT, TEXT, TEXT) TO authenticated;

-- NEW FUNCTION: To manage system associations for a ring
CREATE OR REPLACE FUNCTION public.update_ring_system_associations(
    p_ring_id UUID,
    p_system_ids UUID[]
)
RETURNS VOID
LANGUAGE plpgsql
SECURITY DEFINER -- Use definer to ensure permissions are handled correctly within the function
AS $$
BEGIN
    -- First, delete all existing associations for this ring that are NOT in the provided list.
    DELETE FROM public.ring_based_systems rbs
    WHERE rbs.ring_id = p_ring_id
      AND NOT (rbs.system_id = ANY(p_system_ids));

    -- Second, insert all the new associations.
    -- The ON CONFLICT clause gracefully handles any systems that are already associated,
    -- preventing errors and ensuring the state is consistent.
    INSERT INTO public.ring_based_systems (ring_id, system_id)
    SELECT p_ring_id, unnest(p_system_ids)
    ON CONFLICT (system_id) DO UPDATE
    SET ring_id = EXCLUDED.ring_id;
END;
$$;

GRANT EXECUTE ON FUNCTION public.update_ring_system_associations(UUID, UUID[]) TO authenticated;
```

<!-- path: data/migrations/06_utilities/01_generic_functions.sql -->
```sql
-- path: data/migrations/06_utilities/01_generic_functions.sql
-- Description: A collection of generic, reusable utility functions. [CORRECTED DEPENDENCIES]

-- =================================================================
-- Section 1: Helper Functions (Dependencies)
-- =================================================================

-- Helper function to check if a column exists in a given table/view
CREATE OR REPLACE FUNCTION public.column_exists(p_schema_name TEXT, p_table_name TEXT, p_column_name TEXT)
RETURNS BOOLEAN LANGUAGE plpgsql STABLE AS $$
BEGIN
    RETURN EXISTS (
        SELECT 1
        FROM information_schema.columns
        WHERE table_schema = p_schema_name
          AND table_name = p_table_name
          AND column_name = p_column_name
    );
END;
$$;

-- ** Moved build_where_clause here from 02_paged_functions.sql to resolve dependency issue.**
-- Helper function to build the WHERE clause dynamically
CREATE OR REPLACE FUNCTION public.build_where_clause(p_filters JSONB, p_view_name TEXT, p_alias TEXT DEFAULT 'v')
RETURNS TEXT LANGUAGE plpgsql STABLE AS $$
DECLARE
  where_clause TEXT := '';
  filter_key TEXT;
  filter_value JSONB;
  or_conditions TEXT[];
  or_key TEXT;
  or_value TEXT;
  alias_prefix TEXT;
BEGIN
    alias_prefix := CASE WHEN p_alias IS NOT NULL AND p_alias != '' THEN format('%I.', p_alias) ELSE '' END;

    IF p_filters IS NULL OR jsonb_typeof(p_filters) != 'object' THEN
        RETURN '';
    END IF;

    FOR filter_key, filter_value IN SELECT key, value FROM jsonb_each(p_filters) LOOP
        IF filter_value IS NULL OR filter_value = '""'::jsonb THEN CONTINUE; END IF;

        IF filter_key = 'or' AND jsonb_typeof(filter_value) = 'object' THEN
            or_conditions := ARRAY[]::TEXT[];
            FOR or_key, or_value IN SELECT key, value FROM jsonb_each_text(filter_value) LOOP
                IF public.column_exists('public', p_view_name, or_key) THEN
                    or_conditions := array_append(or_conditions, format('%s%I::text ILIKE %L', alias_prefix, or_key, '%' || or_value || '%'));
                END IF;
            END LOOP;

            IF array_length(or_conditions, 1) > 0 THEN
                where_clause := where_clause || ' AND (' || array_to_string(or_conditions, ' OR ') || ')';
            END IF;
        ELSE
            IF public.column_exists('public', p_view_name, filter_key) THEN
                IF jsonb_typeof(filter_value) = 'object' AND filter_value ? 'operator' THEN
                    -- Handle complex filters like { "operator": "in", "value": [...] }
                ELSIF jsonb_typeof(filter_value) = 'array' THEN
                    where_clause := where_clause || format(' AND %s%I IN (SELECT value::text FROM jsonb_array_elements_text(%L))', alias_prefix, filter_key, filter_value);
                ELSE
                    where_clause := where_clause || format(' AND %s%I::text = %L', alias_prefix, filter_key, filter_value->>0);
                END IF;
            END IF;
        END IF;
    END LOOP;

    RETURN where_clause;
END;
$$;

-- =================================================================
-- Section 2: Generic Query & Data Operation Functions
-- =================================================================

-- Function: execute_sql
-- Executes a read-only SQL query and returns the result as JSON.
DROP FUNCTION IF EXISTS public.execute_sql(TEXT);
CREATE OR REPLACE FUNCTION public.execute_sql(sql_query TEXT)
RETURNS JSON
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public, pg_temp
AS $$
DECLARE
  cleaned_query TEXT;
  result_json JSON;
BEGIN
  cleaned_query := lower(regexp_replace(sql_query, '^\s+', ''));
  
  IF cleaned_query !~ '^(select|with|call)\s' THEN
    RAISE EXCEPTION 'Only read-only statements (SELECT, WITH, CALL) are allowed.';
  END IF;

  EXECUTE 'SELECT json_agg(t) FROM (' || sql_query || ') t' INTO result_json;
  RETURN json_build_object('result', COALESCE(result_json, '[]'::json));
EXCEPTION WHEN OTHERS THEN
  RETURN json_build_object('error', SQLERRM);
END;
$$;
GRANT EXECUTE ON FUNCTION public.execute_sql(TEXT) TO authenticated;


-- Function: aggregate_query
-- Performs dynamic aggregations (COUNT, SUM, AVG, etc.) on a table.
CREATE OR REPLACE FUNCTION public.aggregate_query(
    table_name TEXT,
    aggregation_options JSONB,
    filters JSONB DEFAULT '{}'::jsonb,
    order_by JSONB DEFAULT '[]'::jsonb
)
RETURNS TABLE(result JSONB)
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public, pg_temp
AS $$
DECLARE
  query_text TEXT;
  select_clause TEXT := '';
  where_clause TEXT := '';
  group_clause TEXT := '';
  order_clause TEXT := '';
  agg_parts TEXT[] := ARRAY[]::TEXT[];
BEGIN
  IF (aggregation_options->>'count')::boolean THEN agg_parts := array_append(agg_parts, 'COUNT(*) as count');
  ELSIF aggregation_options->'count' IS NOT NULL THEN agg_parts := array_append(agg_parts, format('COUNT(%I) as count', aggregation_options->>'count')); END IF;
  IF aggregation_options->'sum' IS NOT NULL THEN SELECT array_cat(agg_parts, array_agg(format('SUM(%I) as sum_%s', value, value))) INTO agg_parts FROM jsonb_array_elements_text(aggregation_options->'sum') AS value; END IF;
  IF aggregation_options->'avg' IS NOT NULL THEN SELECT array_cat(agg_parts, array_agg(format('AVG(%I) as avg_%s', value, value))) INTO agg_parts FROM jsonb_array_elements_text(aggregation_options->'avg') AS value; END IF;
  IF aggregation_options->'min' IS NOT NULL THEN SELECT array_cat(agg_parts, array_agg(format('MIN(%I) as min_%s', value, value))) INTO agg_parts FROM jsonb_array_elements_text(aggregation_options->'min') AS value; END IF;
  IF aggregation_options->'max' IS NOT NULL THEN SELECT array_cat(agg_parts, array_agg(format('MAX(%I) as max_%s', value, value))) INTO agg_parts FROM jsonb_array_elements_text(aggregation_options->'max') AS value; END IF;

  IF aggregation_options->'groupBy' IS NOT NULL THEN
    SELECT string_agg(format('%I', value), ', ') INTO group_clause FROM jsonb_array_elements_text(aggregation_options->'groupBy') AS value;
    SELECT string_agg(format('%I', value), ', ') INTO select_clause FROM jsonb_array_elements_text(aggregation_options->'groupBy') AS value;
    group_clause := 'GROUP BY ' || group_clause;
  END IF;

  IF select_clause != '' AND array_length(agg_parts, 1) > 0 THEN select_clause := select_clause || ', ' || array_to_string(agg_parts, ', ');
  ELSIF array_length(agg_parts, 1) > 0 THEN select_clause := array_to_string(agg_parts, ', ');
  ELSE select_clause := '*'; END IF;

  where_clause := public.build_where_clause(filters, '');
  
  IF where_clause != '' THEN
    where_clause := 'WHERE ' || substr(where_clause, 6);
  END IF;

  IF jsonb_typeof(order_by) = 'array' AND jsonb_array_length(order_by) > 0 THEN
    SELECT string_agg(format('%I %s', item->>'column', CASE WHEN (item->>'ascending')::boolean THEN 'ASC' ELSE 'DESC' END), ', ') INTO order_clause FROM jsonb_array_elements(order_by) AS item;
    IF order_clause IS NOT NULL THEN order_clause := 'ORDER BY ' || order_clause; END IF;
  END IF;

  query_text := format('SELECT %s FROM %I %s %s %s', select_clause, table_name, where_clause, group_clause, order_clause);
  RETURN QUERY EXECUTE format('SELECT row_to_json(t)::jsonb FROM (%s) t', query_text);
END;
$$;
GRANT EXECUTE ON FUNCTION public.aggregate_query(TEXT, JSONB, JSONB, JSONB) TO authenticated;

-- ... (rest of the functions from the original file) ...

-- Function: get_unique_values
CREATE OR REPLACE FUNCTION public.get_unique_values(p_table_name TEXT, p_column_name TEXT, p_filters JSONB DEFAULT '{}'::jsonb, p_order_by JSONB DEFAULT '[]'::jsonb, p_limit_count INTEGER DEFAULT NULL)
RETURNS TABLE(value JSONB) LANGUAGE plpgsql SECURITY DEFINER SET search_path = public, pg_temp AS $$
DECLARE
  query_text TEXT; where_clause TEXT := ''; order_clause TEXT := ''; limit_clause TEXT := '';
BEGIN
    IF jsonb_typeof(p_filters) = 'object' AND p_filters != '{}'::jsonb THEN
        SELECT string_agg(format('%I = %L', key, p_filters->>key), ' AND ') INTO where_clause FROM jsonb_object_keys(p_filters) key;
        IF where_clause IS NOT NULL THEN where_clause := 'WHERE ' || where_clause; END IF;
    END IF;
    IF jsonb_typeof(p_order_by) = 'array' AND jsonb_array_length(p_order_by) > 0 THEN
        SELECT string_agg(format('%I %s', item->>'column', CASE WHEN (item->>'ascending')::boolean THEN 'ASC' ELSE 'DESC' END), ', ') INTO order_clause FROM jsonb_array_elements(p_order_by) AS item;
        IF order_clause IS NOT NULL THEN order_clause := 'ORDER BY ' || order_clause; END IF;
    END IF;
    IF p_limit_count IS NOT NULL THEN limit_clause := format('LIMIT %s', p_limit_count); END IF;
    query_text := format('SELECT DISTINCT %I as value FROM %I %s %s %s', p_column_name, p_table_name, where_clause, order_clause, limit_clause);
    RETURN QUERY EXECUTE format('SELECT to_jsonb(t.value) FROM (%s) t', query_text);
END;
$$;
GRANT EXECUTE ON FUNCTION public.get_unique_values(TEXT, TEXT, JSONB, JSONB, INTEGER) TO authenticated;

-- Function: bulk_update
CREATE OR REPLACE FUNCTION public.bulk_update(p_table_name TEXT, p_updates JSONB)
RETURNS JSONB LANGUAGE plpgsql SECURITY DEFINER SET search_path = public AS $$
DECLARE
  update_item JSONB; set_clause TEXT; query_text TEXT; updated_count INTEGER := 0; current_updated_count INTEGER;
BEGIN
  FOR update_item IN SELECT * FROM jsonb_array_elements(p_updates) LOOP
    SELECT string_agg(format('%I = %L', key, value), ', ') INTO set_clause FROM jsonb_each_text(update_item->'data');
    IF set_clause IS NOT NULL THEN
      query_text := format('UPDATE public.%I SET %s, updated_at = NOW() WHERE id = %L', p_table_name, set_clause, update_item->>'id');
      EXECUTE query_text;
      GET DIAGNOSTICS current_updated_count = ROW_COUNT;
      updated_count := updated_count + current_updated_count;
    END IF;
  END LOOP;
  RETURN jsonb_build_object('updated_count', updated_count);
END;
$$;
GRANT EXECUTE ON FUNCTION public.bulk_update(TEXT, JSONB) TO authenticated;

-- Lookup and Enumeration Functions
CREATE OR REPLACE FUNCTION public.get_lookup_type_id(p_category TEXT, p_name TEXT)
RETURNS UUID LANGUAGE plpgsql SECURITY DEFINER SET search_path = public AS $$
DECLARE v_type_id UUID;
BEGIN
  SELECT id INTO v_type_id FROM public.lookup_types WHERE category = p_category AND name = p_name AND status = true;
  IF v_type_id IS NULL THEN RAISE EXCEPTION 'Lookup type not found for category=% and name=%', p_category, p_name; END IF;
  RETURN v_type_id;
END;
$$;
GRANT EXECUTE ON FUNCTION public.get_lookup_type_id(TEXT, TEXT) TO authenticated;

CREATE OR REPLACE FUNCTION public.add_lookup_type(p_category TEXT, p_name TEXT, p_code TEXT DEFAULT NULL, p_description TEXT DEFAULT NULL, p_sort_order INTEGER DEFAULT 0)
RETURNS UUID LANGUAGE plpgsql SECURITY DEFINER SET search_path = public AS $$
DECLARE v_type_id UUID;
BEGIN
  INSERT INTO public.lookup_types (category, name, code, description, sort_order) VALUES (p_category, p_name, p_code, p_description, p_sort_order) RETURNING id INTO v_type_id;
  RETURN v_type_id;
END;
$$;
GRANT EXECUTE ON FUNCTION public.add_lookup_type(TEXT, TEXT, TEXT, TEXT, INTEGER) TO authenticated;

CREATE OR REPLACE FUNCTION public.get_lookup_types_by_category(p_category TEXT)
RETURNS TABLE (id UUID, name TEXT, code TEXT, description TEXT, sort_order INTEGER) LANGUAGE sql STABLE SECURITY INVOKER AS $$
  SELECT lt.id, lt.name, lt.code, lt.description, lt.sort_order FROM public.lookup_types lt WHERE lt.category = p_category AND lt.status = true ORDER BY lt.sort_order, lt.name;
$$;
GRANT EXECUTE ON FUNCTION public.get_lookup_types_by_category(TEXT) TO authenticated;

CREATE OR REPLACE FUNCTION public.get_entity_counts(p_entity_name TEXT, p_filters JSONB DEFAULT '{}')
RETURNS TABLE (total_count BIGINT, active_count BIGINT, inactive_count BIGINT) LANGUAGE plpgsql SECURITY DEFINER SET search_path = public AS $$
DECLARE
    sql_query TEXT; sql_where TEXT := 'WHERE 1=1'; filter_key TEXT; filter_value JSONB;
BEGIN
    IF p_filters IS NOT NULL AND jsonb_typeof(p_filters) = 'object' AND p_filters != '{}'::jsonb THEN
        FOR filter_key, filter_value IN SELECT * FROM jsonb_each(p_filters) LOOP
            sql_where := sql_where || format(' AND %I = %L', filter_key, trim(both '"' from filter_value::text));
        END LOOP;
    END IF;
    sql_query := format('SELECT count(*), count(*) FILTER (WHERE status = true), count(*) FILTER (WHERE status = false) FROM %I %s', p_entity_name, sql_where);
    RETURN QUERY EXECUTE sql_query;
END;
$$;
GRANT EXECUTE ON FUNCTION public.get_entity_counts(TEXT, JSONB) TO authenticated;
```

<!-- path: data/migrations/06_utilities/06_bsnl_dashboard_data.sql -->
```sql
-- path: data/migrations/06_utilities/08_bsnl_dashboard_data.sql
-- Description: Creates a centralized RPC function to fetch filtered data for the BSNL dashboard.

CREATE OR REPLACE FUNCTION public.get_bsnl_dashboard_data(
    p_query TEXT DEFAULT NULL,
    p_status BOOLEAN DEFAULT NULL,
    p_system_types TEXT[] DEFAULT NULL,
    p_cable_types TEXT[] DEFAULT NULL,
    p_regions TEXT[] DEFAULT NULL,
    p_node_types TEXT[] DEFAULT NULL
)
RETURNS JSONB
LANGUAGE plpgsql
SECURITY INVOKER
STABLE
AS $$
DECLARE
    v_nodes JSONB;
    v_ofc_cables JSONB;
    v_systems JSONB;
    search_query TEXT := '%' || p_query || '%';
BEGIN
    -- 1. Fetch Nodes
    SELECT COALESCE(jsonb_agg(n), '[]'::jsonb)
    INTO v_nodes
    FROM public.v_nodes_complete n
    WHERE
        (p_query IS NULL OR (
            n.name ILIKE search_query OR
            n.remark ILIKE search_query OR
            n.maintenance_area_name ILIKE search_query
        )) AND
        (p_status IS NULL OR n.status = p_status) AND
        (p_regions IS NULL OR n.maintenance_area_name = ANY(p_regions)) AND
        (p_node_types IS NULL OR n.node_type_name = ANY(p_node_types));

    -- 2. Fetch OFC Cables
    SELECT COALESCE(jsonb_agg(c), '[]'::jsonb)
    INTO v_ofc_cables
    FROM public.v_ofc_cables_complete c
    WHERE
        (p_query IS NULL OR (
            c.route_name ILIKE search_query OR
            c.asset_no ILIKE search_query OR
            c.sn_name ILIKE search_query OR
            c.en_name ILIKE search_query
        )) AND
        (p_status IS NULL OR c.status = p_status) AND
        (p_regions IS NULL OR c.maintenance_area_name = ANY(p_regions)) AND
        (p_cable_types IS NULL OR c.ofc_type_name = ANY(p_cable_types));

    -- 3. Fetch Systems
    SELECT COALESCE(jsonb_agg(s), '[]'::jsonb)
    INTO v_systems
    FROM public.v_systems_complete s
    WHERE
        (p_query IS NULL OR (
            s.system_name ILIKE search_query OR
            s.node_name ILIKE search_query OR
            s.ip_address::TEXT ILIKE search_query
        )) AND
        (p_status IS NULL OR s.status = p_status) AND
        (p_regions IS NULL OR s.system_maintenance_terminal_name = ANY(p_regions)) AND
        (p_system_types IS NULL OR s.system_type_name = ANY(p_system_types));

    -- 4. Construct and return the final JSON object
    RETURN jsonb_build_object(
        'nodes', v_nodes,
        'ofcCables', v_ofc_cables,
        'systems', v_systems
    );
END;
$$;

-- Grant execute permission to the authenticated role
GRANT EXECUTE ON FUNCTION public.get_bsnl_dashboard_data(TEXT, BOOLEAN, TEXT[], TEXT[], TEXT[], TEXT[]) TO authenticated;
```

<!-- path: data/migrations/06_utilities/07_attach_updated_at_triggers.sql -->
```sql
-- path: data/migrations/06_utilities/07_attach_updated_at_triggers.sql
-- Description: Dynamically attaches the 'update_updated_at_column' trigger to all tables that have an 'updated_at' column.

DO $$
DECLARE
    table_rec RECORD;
    trigger_name TEXT;
BEGIN
    -- Loop through all tables in the 'public' schema
    FOR table_rec IN
        SELECT t.table_name
        FROM information_schema.tables t
        WHERE t.table_schema = 'public'
          AND t.table_type = 'BASE TABLE'
          -- **Key Condition: Only act on tables that actually have an 'updated_at' column.**
          AND EXISTS (
              SELECT 1
              FROM information_schema.columns c
              WHERE c.table_schema = t.table_schema
                AND c.table_name = t.table_name
                AND c.column_name = 'updated_at'
          )
    LOOP
        -- Create a standardized trigger name
        trigger_name := 'trigger_' || table_rec.table_name || '_updated_at';

        -- Drop the trigger if it already exists to ensure it's up-to-date
        EXECUTE format('DROP TRIGGER IF EXISTS %I ON public.%I;', trigger_name, table_rec.table_name);

        -- Create the new trigger
        EXECUTE format('CREATE TRIGGER %I ' ||
                       'BEFORE UPDATE ON public.%I ' ||
                       'FOR EACH ROW EXECUTE FUNCTION public.update_updated_at_column();',
                       trigger_name,
                       table_rec.table_name);

        RAISE NOTICE 'Attached/Refreshed updated_at trigger on table: public.%', table_rec.table_name;
    END LOOP;
END;
$$;
```

<!-- path: data/migrations/06_utilities/03_no_pagination_specialized_function.sql -->
```sql
-- =================================================================
-- Section 3: Specialized Utility Functions (No Pagination)
-- =================================================================

CREATE OR REPLACE FUNCTION public.get_system_path_details(p_path_id UUID)
RETURNS SETOF public.v_system_ring_paths_detailed LANGUAGE plpgsql SECURITY DEFINER SET search_path = public AS $$
BEGIN
    IF NOT EXISTS (SELECT 1 FROM public.logical_fiber_paths lfp WHERE lfp.id = p_path_id AND EXISTS (SELECT 1 FROM public.systems s WHERE s.id = lfp.source_system_id)) THEN
        RETURN;
    END IF;
    RETURN QUERY SELECT * FROM public.v_system_ring_paths_detailed WHERE logical_path_id = p_path_id ORDER BY path_order ASC;
END; $$;
GRANT EXECUTE ON FUNCTION public.get_system_path_details(UUID) TO authenticated;

CREATE OR REPLACE FUNCTION public.get_continuous_available_fibers(p_path_id UUID)
RETURNS TABLE(fiber_no INT) LANGUAGE plpgsql SECURITY DEFINER SET search_path = public AS $$
DECLARE path_cable_count INT;
BEGIN
    SELECT COUNT(DISTINCT seg.ofc_cable_id) INTO path_cable_count FROM public.logical_path_segments seg WHERE seg.logical_path_id = p_path_id AND seg.ofc_cable_id IS NOT NULL;
    IF COALESCE(path_cable_count, 0) = 0 THEN RETURN; END IF;
    RETURN QUERY SELECT conn.fiber_no_sn::INT FROM public.ofc_connections conn JOIN public.logical_path_segments seg ON conn.ofc_id = seg.ofc_cable_id
    WHERE seg.logical_path_id = p_path_id AND conn.logical_path_id IS NULL AND conn.status = TRUE
    GROUP BY conn.fiber_no_sn HAVING COUNT(conn.ofc_id) = path_cable_count;
END; $$;
GRANT EXECUTE ON FUNCTION public.get_continuous_available_fibers(UUID) TO authenticated;

CREATE OR REPLACE FUNCTION public.find_cable_between_nodes(
    p_node1_id UUID,
    p_node2_id UUID
)
RETURNS TABLE (id UUID, route_name TEXT)
LANGUAGE sql
STABLE
SECURITY DEFINER
SET search_path = public
AS $$
  SELECT oc.id, oc.route_name
  FROM public.ofc_cables oc
  WHERE
    (oc.sn_id = p_node1_id AND oc.en_id = p_node2_id) OR
    (oc.sn_id = p_node2_id AND oc.en_id = p_node1_id)
  LIMIT 1;
$$;

GRANT EXECUTE ON FUNCTION public.find_cable_between_nodes(UUID, UUID) TO authenticated;

CREATE OR REPLACE FUNCTION public.validate_ring_path(p_path_id UUID)
RETURNS JSONB
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
DECLARE
    v_segment_count INT;
    v_first_segment RECORD;
    v_last_segment RECORD;
    v_is_continuous BOOLEAN;
    v_is_closed_loop BOOLEAN;
BEGIN
    -- Count segments in the path
    SELECT COUNT(*) INTO v_segment_count FROM logical_path_segments WHERE logical_path_id = p_path_id;

    IF v_segment_count = 0 THEN
        RETURN jsonb_build_object('status', 'empty', 'message', 'Path has no segments.');
    END IF;

    -- Get first and last segments using the detailed view
    SELECT * INTO v_first_segment FROM v_system_ring_paths_detailed WHERE logical_path_id = p_path_id ORDER BY path_order ASC LIMIT 1;
    SELECT * INTO v_last_segment FROM v_system_ring_paths_detailed WHERE logical_path_id = p_path_id ORDER BY path_order DESC LIMIT 1;

    -- Check for continuity (every segment's start node matches the previous segment's end node)
    SELECT NOT EXISTS (
        SELECT 1
        FROM v_system_ring_paths_detailed s1
        LEFT JOIN v_system_ring_paths_detailed s2 ON s1.logical_path_id = s2.logical_path_id AND s2.path_order = s1.path_order + 1
        WHERE s1.logical_path_id = p_path_id AND s2.id IS NOT NULL AND s1.end_node_id <> s2.start_node_id
    ) INTO v_is_continuous;

    IF NOT v_is_continuous THEN
        RETURN jsonb_build_object('status', 'broken', 'message', 'Path is not continuous. A segment connection is mismatched.');
    END IF;

    -- Check if the path forms a closed loop
    v_is_closed_loop := v_first_segment.start_node_id = v_last_segment.end_node_id;

    IF v_is_closed_loop THEN
        RETURN jsonb_build_object('status', 'valid_ring', 'message', 'Path forms a valid closed-loop ring.');
    ELSE
        RETURN jsonb_build_object('status', 'open_path', 'message', 'Path is a valid point-to-point route but not a closed ring.');
    END IF;
END;
$$;

GRANT EXECUTE ON FUNCTION public.validate_ring_path(UUID) TO authenticated;


CREATE OR REPLACE FUNCTION public.deprovision_logical_path(p_path_id UUID)
RETURNS VOID
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
DECLARE
    v_working_path_id UUID;
    v_protection_path_id UUID;
BEGIN
    -- Find the working path ID, regardless if the input is a working or protection path ID
    SELECT
        CASE
            WHEN path_role = 'working' THEN id
            ELSE working_path_id
        END
    INTO v_working_path_id
    FROM public.logical_fiber_paths
    WHERE id = p_path_id OR working_path_id = p_path_id
    LIMIT 1;

    -- If a valid working path was found, find its associated protection path
    IF v_working_path_id IS NOT NULL THEN
        SELECT id INTO v_protection_path_id
        FROM public.logical_fiber_paths
        WHERE working_path_id = v_working_path_id;
    END IF;

    -- Clear the logical_path_id and fiber_role from all associated connections
    UPDATE public.ofc_connections
    SET
        logical_path_id = NULL,
        fiber_role = NULL
    WHERE logical_path_id = v_working_path_id OR logical_path_id = v_protection_path_id;

    -- Delete the logical_fiber_paths records themselves (cascading delete will handle protection path)
    DELETE FROM public.logical_fiber_paths WHERE id = v_working_path_id;
    
END;
$$;

GRANT EXECUTE ON FUNCTION public.deprovision_logical_path(UUID) TO authenticated;
```

<!-- path: data/migrations/06_utilities/04_dashboard_functions.sql -->
```sql
-- path: migrations/06_utilities/05_dashboard_functions.sql
-- Description: Contains functions for dashboard aggregations.

CREATE OR REPLACE FUNCTION public.get_dashboard_overview()
RETURNS JSONB LANGUAGE plpgsql SECURITY INVOKER SET search_path = public AS $$
DECLARE
    result jsonb;
    v_user_activity jsonb;
BEGIN
    -- CORRECTED: Check if the user_activity_logs table exists before querying it.
    IF EXISTS (
        SELECT FROM information_schema.tables 
        WHERE table_schema = 'public' AND table_name = 'user_activity_logs'
    ) THEN
        SELECT jsonb_agg(jsonb_build_object('date', day::date, 'count', COALESCE(activity_count, 0)) ORDER BY day)
        INTO v_user_activity
        FROM generate_series(CURRENT_DATE - interval '29 days', CURRENT_DATE, '1 day') as s(day) 
        LEFT JOIN (
            SELECT created_at::date as activity_date, COUNT(*) as activity_count 
            FROM public.user_activity_logs 
            WHERE created_at >= CURRENT_DATE - interval '29 days' 
            GROUP BY activity_date
        ) as activity ON s.day = activity.activity_date;
    ELSE
        -- If the table doesn't exist, return an empty array.
        v_user_activity := '[]'::jsonb;
    END IF;

    SELECT jsonb_build_object(
        'system_status_counts', (SELECT jsonb_object_agg(CASE WHEN status THEN 'Active' ELSE 'Inactive' END, count) FROM (SELECT status, COUNT(*) as count FROM public.systems GROUP BY status) as s),
        'node_status_counts', (SELECT jsonb_object_agg(CASE WHEN status THEN 'Active' ELSE 'Inactive' END, count) FROM (SELECT status, COUNT(*) as count FROM public.nodes GROUP BY status) as n),
        'path_operational_status', (SELECT jsonb_object_agg(lt.name, p.count) FROM (SELECT operational_status_id, COUNT(*) as count FROM public.logical_fiber_paths WHERE operational_status_id IS NOT NULL GROUP BY operational_status_id) as p JOIN lookup_types lt ON p.operational_status_id = lt.id),
        'cable_utilization_summary', (SELECT jsonb_build_object('average_utilization_percent', ROUND(AVG(utilization_percent)::numeric, 2), 'high_utilization_count', COUNT(*) FILTER (WHERE utilization_percent > 80), 'total_cables', COUNT(*)) FROM public.v_cable_utilization),
        'user_activity_last_30_days', v_user_activity, -- Use the safely-fetched activity data
        'systems_per_maintenance_area', (SELECT jsonb_object_agg(ma.name, s.system_count) FROM (SELECT maintenance_terminal_id, COUNT(id) as system_count FROM public.systems WHERE maintenance_terminal_id IS NOT NULL GROUP BY maintenance_terminal_id) as s JOIN public.maintenance_areas ma ON s.maintenance_terminal_id = ma.id)
    ) INTO result;

    RETURN result;
END; 
$$;
GRANT EXECUTE ON FUNCTION public.get_dashboard_overview() TO authenticated;
```

<!-- path: data/migrations/06_utilities/05_search_nodes.sql -->
```sql
-- path: migrations/06_utilities/07_search_nodes.sql
-- Description: Creates a function to search nodes for dropdowns with pagination and filtering.

CREATE OR REPLACE FUNCTION public.search_nodes_for_select(
    p_search_term TEXT DEFAULT '',
    p_limit INT DEFAULT 20
)
RETURNS TABLE (id UUID, name TEXT)
LANGUAGE plpgsql
SECURITY INVOKER
STABLE
AS $$
BEGIN
    RETURN QUERY
    SELECT n.id, n.name
    FROM public.v_nodes_complete n
    WHERE n.status = true
      AND (
        p_search_term = '' OR
        n.name ILIKE ('%' || p_search_term || '%')
      )
    ORDER BY n.name
    LIMIT p_limit;
END;
$$;

GRANT EXECUTE ON FUNCTION public.search_nodes_for_select(TEXT, INT) TO authenticated;
```

<!-- path: data/migrations/06_utilities/02_paged_functions.sql -->
```sql
-- path: data/migrations/06_utilities/02_paged_functions.sql
-- =================================================================
-- Generic Pagination Functions
-- =================================================================
-- These functions build dynamic SQL. They are constructed to be secure
-- using format() with %I for identifiers and %L for literals.

-- ** The helper functions (column_exists, build_where_clause) have been moved to 01_generic_functions.sql to resolve dependency errors.**
-- This file now only contains the get_paged_data function which depends on them.

CREATE OR REPLACE FUNCTION public.get_paged_data(
    p_view_name TEXT, p_limit INT, p_offset INT, p_order_by TEXT DEFAULT 'id',
    p_order_dir TEXT DEFAULT 'asc', p_filters JSONB DEFAULT '{}'
)
RETURNS JSONB LANGUAGE plpgsql SECURITY DEFINER SET search_path = public AS $$
DECLARE
    data_query TEXT; count_query TEXT; where_clause TEXT; order_by_column TEXT;
    result_data JSONB; total_records BIGINT; active_records BIGINT := 0; inactive_records BIGINT := 0;
    status_column_exists BOOLEAN;
BEGIN
    status_column_exists := public.column_exists('public', p_view_name, 'status');
    where_clause := public.build_where_clause(p_filters, p_view_name);
    
    IF public.column_exists('public', p_view_name, p_order_by) THEN
        order_by_column := p_order_by;
    ELSE
        IF public.column_exists('public', p_view_name, 'id') THEN
            order_by_column := 'id';
        ELSE
            SELECT column_name INTO order_by_column FROM information_schema.columns
            WHERE table_schema = 'public' AND table_name = p_view_name
            ORDER BY ordinal_position LIMIT 1;
        END IF;
    END IF;
    
    data_query := format(
        'SELECT jsonb_agg(v) FROM (SELECT * FROM public.%I v WHERE 1=1 %s ORDER BY v.%I %s LIMIT %L OFFSET %L) v',
        p_view_name, where_clause, order_by_column, p_order_dir, p_limit, p_offset
    );
    
    IF status_column_exists THEN
        count_query := format(
            'SELECT count(*), count(*) FILTER (WHERE v.status = true), count(*) FILTER (WHERE v.status = false)
             FROM public.%I v WHERE 1=1 %s', p_view_name, where_clause
        );
        EXECUTE count_query INTO total_records, active_records, inactive_records;
    ELSE
        count_query := format('SELECT count(*) FROM public.%I v WHERE 1=1 %s', p_view_name, where_clause);
        EXECUTE count_query INTO total_records;
    END IF;
    
    EXECUTE data_query INTO result_data;
    
    RETURN jsonb_build_object(
        'data', COALESCE(result_data, '[]'::jsonb), 'total_count', COALESCE(total_records, 0),
        'active_count', COALESCE(active_records, 0), 'inactive_count', COALESCE(inactive_records, 0)
    );
END;
$$;
GRANT EXECUTE ON FUNCTION public.get_paged_data(TEXT, INT, INT, TEXT, TEXT, JSONB) TO authenticated;
```

<!-- path: data/migrations/99_finalization/01_cross_module_constraints.sql -->
```sql
-- Path: migrations/99_finalization/01_cross_module_constraints.sql
-- Description: Adds all cross-module foreign key constraints after all tables have been created.
-- This script is essential for maintaining referential integrity between different domains.

-- =================================================================
-- Constraint Set 1: Linking Core Infrastructure to Network Systems
-- =================================================================

-- Add the foreign key from ofc_connections (Module 02) to systems (Module 03).
-- This links a physical fiber connection to the network equipment it terminates on.
ALTER TABLE public.ofc_connections
ADD CONSTRAINT fk_ofc_connections_system
FOREIGN KEY (system_id)
REFERENCES public.systems(id)
ON DELETE SET NULL;


-- =================================================================
-- Constraint Set 2: Linking Core Infrastructure to Advanced OFC
-- =================================================================

-- Add the foreign key from ofc_connections (Module 02) to logical_fiber_paths (Module 04).
-- This assigns a physical fiber to a logical end-to-end path.
ALTER TABLE public.ofc_connections
ADD CONSTRAINT fk_ofc_connections_logical_path
FOREIGN KEY (logical_path_id)
REFERENCES public.logical_fiber_paths(id)
ON DELETE SET NULL;


-- =================================================================
-- Constraint Set 3: Linking Network Systems to Advanced OFC
-- =================================================================

-- Add foreign keys from logical_fiber_paths (Module 04) to systems (Module 03).
-- This defines the start and end systems for a logical path.
ALTER TABLE public.logical_fiber_paths
ADD CONSTRAINT fk_lfp_source_system
FOREIGN KEY (source_system_id)
REFERENCES public.systems(id)
ON DELETE SET NULL;

ALTER TABLE public.logical_fiber_paths
ADD CONSTRAINT fk_lfp_destination_system
FOREIGN KEY (destination_system_id)
REFERENCES public.systems(id)
ON DELETE SET NULL;
```

<!-- path: data/migrations/00_setup/01_roles.sql -->
```sql
-- Path: migrations/00_setup/01_roles.sql
-- Description: Creates all custom database roles. Must be run first.

-- Create roles only if they don't exist
DO $$
BEGIN
    IF NOT EXISTS (SELECT FROM pg_roles WHERE rolname = 'admin') THEN
        CREATE ROLE admin NOINHERIT;
    END IF;

    IF NOT EXISTS (SELECT FROM pg_roles WHERE rolname = 'cpan_admin') THEN
        CREATE ROLE cpan_admin NOINHERIT;
    END IF;

    IF NOT EXISTS (SELECT FROM pg_roles WHERE rolname = 'maan_admin') THEN
        CREATE ROLE maan_admin NOINHERIT;
    END IF;

    IF NOT EXISTS (SELECT FROM pg_roles WHERE rolname = 'sdh_admin') THEN
        CREATE ROLE sdh_admin NOINHERIT;
    END IF;

    IF NOT EXISTS (SELECT FROM pg_roles WHERE rolname = 'vmux_admin') THEN
        CREATE ROLE vmux_admin NOINHERIT;
    END IF;

    IF NOT EXISTS (SELECT FROM pg_roles WHERE rolname = 'mng_admin') THEN
        CREATE ROLE mng_admin NOINHERIT;
    END IF;

    IF NOT EXISTS (SELECT FROM pg_roles WHERE rolname = 'viewer') THEN
        CREATE ROLE viewer NOINHERIT;
    END IF;
END
$$;

-- Safely grant membership to the 'authenticated' role for all custom roles.
-- This allows any logged-in user to assume one of these roles via JWT claims.
DO $$
DECLARE
    r TEXT;
BEGIN
    FOR r IN
        SELECT unnest(ARRAY['admin','cpan_admin','maan_admin','sdh_admin','vmux_admin','mng_admin','viewer'])
    LOOP
        IF NOT EXISTS (
            SELECT 1
            FROM pg_auth_members m
            JOIN pg_roles r1 ON r1.oid = m.roleid
            JOIN pg_roles r2 ON r2.oid = m.member
            WHERE r1.rolname = r
              AND r2.rolname = 'authenticated'
        ) THEN
            EXECUTE format('GRANT %I TO authenticated', r);
        END IF;
    END LOOP;
END
$$;
```

<!-- path: data/migrations/00_setup/02_function_stubs.sql -->
```sql
-- Path: migrations/00_setup/02_function_stubs.sql
-- Description: Creates dummy "stub" versions of functions that may be optionally defined later.
-- This prevents dependency errors if certain modules (like Auditing) are not deployed.

-- Stub for the user activity logging function.
-- The real version is in the 05_auditing module.
CREATE OR REPLACE FUNCTION public.log_user_activity(
    p_action_type TEXT,
    p_table_name TEXT DEFAULT NULL,
    p_record_id TEXT DEFAULT NULL,
    p_old_data JSONB DEFAULT NULL,
    p_new_data JSONB DEFAULT NULL,
    p_details TEXT DEFAULT NULL
)
RETURNS VOID
LANGUAGE plpgsql
AS $$
BEGIN
    -- This is a stub function. It does nothing.
    -- If the 05_auditing module is deployed, it will replace this function
    -- with the real implementation.
    RETURN;
END;
$$;
```

<!-- path: data/migrations/01_user_management/02_views.sql -->
```sql
-- Path: migrations/01_user_management/02_views.sql
-- Description: Defines views for the User Management module.

-- Extended view combining auth.users and public.user_profiles
CREATE OR REPLACE VIEW v_user_profiles_extended WITH (security_invoker = true) AS
SELECT
    u.id,
    u.email::text AS email,
    u.last_sign_in_at,
    u.created_at,
    u.is_super_admin,
    (u.email_confirmed_at IS NOT NULL) AS is_email_verified,
    p.first_name::text AS first_name,
    p.last_name::text AS last_name,
    p.avatar_url::text AS avatar_url,
    p.phone_number::text AS phone_number,
    p.date_of_birth,
    p.address,
    p.preferences,
    p.role::text AS role,
    p.designation::text AS designation,
    p.updated_at,
    p.status::text AS status,
    u.email_confirmed_at,
    u.phone_confirmed_at,
    (u.phone_confirmed_at IS NOT NULL) AS is_phone_verified,
    u.updated_at AS auth_updated_at,
    u.raw_user_meta_data,
    u.raw_app_meta_data,
    CONCAT(p.first_name::text, ' ', p.last_name::text) AS full_name,
    CASE
        WHEN p.status::text = 'active' AND u.email_confirmed_at IS NOT NULL THEN 'active_verified'
        WHEN p.status::text = 'active' AND u.email_confirmed_at IS NULL THEN 'active_unverified'
        WHEN p.status::text = 'inactive' THEN 'inactive'
        WHEN p.status::text = 'suspended' THEN 'suspended'
        ELSE 'unknown'
    END::text AS computed_status,
    EXTRACT(DAYS FROM (NOW() - u.created_at))::INTEGER AS account_age_days,
    CASE
        WHEN u.last_sign_in_at > NOW() - INTERVAL '1 day' THEN 'today'
        WHEN u.last_sign_in_at > NOW() - INTERVAL '7 days' THEN 'this_week'
        WHEN u.last_sign_in_at > NOW() - INTERVAL '30 days' THEN 'this_month'
        WHEN u.last_sign_in_at > NOW() - INTERVAL '90 days' THEN 'last_3_months'
        ELSE 'older'
    END::text AS last_activity_period
FROM auth.users u
JOIN public.user_profiles p ON u.id = p.id;
```

<!-- path: data/migrations/01_user_management/06_rls_and_grants.sql -->
```sql
-- Path: migrations/01_user_management/06_rls_and_grants.sql
-- Description: All RLS policies and Grants for the User Management module.

-- =================================================================
-- Section 1: Grants
-- =================================================================

-- Grants for utility functions
GRANT EXECUTE ON FUNCTION public.is_super_admin() TO authenticated;
GRANT EXECUTE ON FUNCTION public.get_my_role() TO authenticated;
GRANT EXECUTE ON FUNCTION public.get_my_user_details() TO authenticated;

-- Grants for admin functions
GRANT EXECUTE ON FUNCTION public.admin_get_all_users_extended(text, text, text, text, timestamptz, timestamptz, integer, integer) TO authenticated;
GRANT EXECUTE ON FUNCTION public.admin_get_user_by_id(uuid) TO authenticated;
GRANT EXECUTE ON FUNCTION public.admin_update_user_profile(uuid, text, text, text, text, date, jsonb, jsonb, text, text, text) TO authenticated;
GRANT EXECUTE ON FUNCTION public.admin_bulk_update_status(uuid[], text) TO authenticated;
GRANT EXECUTE ON FUNCTION public.admin_bulk_update_role(uuid[], text) TO authenticated;
GRANT EXECUTE ON FUNCTION public.admin_bulk_delete_users(uuid[]) TO authenticated;

-- Grant Table Permissions
GRANT SELECT, INSERT, UPDATE, DELETE ON public.user_profiles TO admin;
GRANT SELECT ON public.user_profiles TO viewer;


-- =================================================================
-- Section 2: RLS Policies for user_profiles
-- =================================================================

-- Enable RLS on the table
ALTER TABLE public.user_profiles ENABLE ROW LEVEL SECURITY;

-- Drop existing policies for idempotency
DROP POLICY IF EXISTS "Super admins have full access to user_profiles" ON public.user_profiles;
DROP POLICY IF EXISTS "Users can view their own profile" ON public.user_profiles;
DROP POLICY IF EXISTS "Users can update their own profile" ON public.user_profiles;
DROP POLICY IF EXISTS "Users can insert their own profile" ON public.user_profiles;
DROP POLICY IF EXISTS "Users can delete their own profile" ON public.user_profiles;

-- Allow super admins full access to all rows
CREATE POLICY "Super admins have full access to user_profiles"
ON public.user_profiles
FOR ALL
USING (public.is_super_admin())
WITH CHECK (public.is_super_admin());

-- Allow users to read their own profile
CREATE POLICY "Users can view their own profile"
ON public.user_profiles
FOR SELECT
USING ((select auth.uid()) = id);

-- Allow users to update their own profile
CREATE POLICY "Users can update their own profile"
ON public.user_profiles
FOR UPDATE
USING ((select auth.uid()) = id)
WITH CHECK ((select auth.uid()) = id);

-- Allow users to insert their own profile
CREATE POLICY "Users can insert their own profile"
ON public.user_profiles
FOR INSERT
WITH CHECK ((select auth.uid()) = id);

-- Allow users to delete their own profile
CREATE POLICY "Users can delete their own profile"
ON public.user_profiles
FOR DELETE
USING ((select auth.uid()) = id);
```

<!-- path: data/migrations/01_user_management/05_triggers.sql -->
```sql
-- Path: migrations/01_user_management/05_triggers.sql
-- Description: Attaches triggers for the User Management module.

-- CREATE TRIGGER for new auth users to create a public profile
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_trigger WHERE tgname = 'on_auth_user_created') THEN
        CREATE TRIGGER on_auth_user_created
        AFTER INSERT ON auth.users
        FOR EACH ROW EXECUTE FUNCTION public.create_public_profile_for_new_user();
    END IF;
END $$;

-- CREATE TRIGGER for role sync to auth.users on profile UPDATE
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_trigger WHERE tgname = 'sync_user_role_trigger') THEN
        CREATE TRIGGER sync_user_role_trigger
        AFTER UPDATE ON public.user_profiles
        FOR EACH ROW
        WHEN (NEW.role IS DISTINCT FROM OLD.role)
        EXECUTE FUNCTION sync_user_role_to_auth();
    END IF;
END $$;

-- CREATE TRIGGER for role sync to auth.users on profile INSERT
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_trigger WHERE tgname = 'sync_user_role_insert_trigger') THEN
        CREATE TRIGGER sync_user_role_insert_trigger
        AFTER INSERT ON public.user_profiles
        FOR EACH ROW EXECUTE FUNCTION sync_user_role_to_auth();
    END IF;
END $$;
```

<!-- path: data/migrations/01_user_management/04_indexes.sql -->
```sql
-- Path: migrations/01_user_management/04_indexes.sql
-- Description: Indexes for user_profiles to improve performance.

-- Index for filtering users by their role
CREATE INDEX IF NOT EXISTS idx_user_profiles_role ON public.user_profiles (role);

-- Index for filtering users by their status (e.g., active, inactive)
CREATE INDEX IF NOT EXISTS idx_user_profiles_status ON public.user_profiles (status);

-- Composite index for efficient searching and sorting by user's full name
CREATE INDEX IF NOT EXISTS idx_user_profiles_last_name_first_name ON public.user_profiles (last_name, first_name);

-- Index on the creation timestamp to speed up date range filters
CREATE INDEX IF NOT EXISTS idx_user_profiles_created_at ON public.user_profiles (created_at);
```

<!-- path: data/migrations/01_user_management/01_tables_user_profiles.sql -->
```sql
-- Path: migrations/01_user_management/01_tables_user_profiles.sql
-- Description: Defines the user_profiles table, which extends auth.users.

CREATE TABLE IF NOT EXISTS public.user_profiles (
  id UUID NOT NULL PRIMARY KEY REFERENCES auth.users (id) ON DELETE CASCADE,
  first_name TEXT NOT NULL CHECK (first_name <> ''),
  last_name TEXT NOT NULL CHECK (last_name <> ''),
  avatar_url TEXT,
  phone_number TEXT CHECK (
    phone_number IS NULL
    OR phone_number ~ '^\+?[1-9]\d{1,14}$'
  ),
  date_of_birth DATE CHECK (
    date_of_birth IS NULL
    OR (
      date_of_birth > '1900-01-01'
      AND date_of_birth < CURRENT_DATE
    )
  ),
  role TEXT DEFAULT 'viewer' CHECK (
    role IN (
      'admin',
      'viewer',
      'cpan_admin',
      'maan_admin',
      'sdh_admin',
      'vmux_admin',
      'mng_admin'
    )
  ),
  designation TEXT,
  address JSONB DEFAULT '{}'::jsonb,
  preferences JSONB DEFAULT '{}'::jsonb,
  status TEXT DEFAULT 'inactive' CHECK (status IN ('active', 'inactive', 'suspended')),
  created_at TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP,
  updated_at TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP
);
```

<!-- path: data/migrations/01_user_management/03_functions.sql -->
```sql
-- Path: migrations/01_user_management/03_functions.sql
-- Description: All functions for the User Management module.

-- =================================================================
-- Section 1: Utility Functions
-- =================================================================

-- SUPER ADMIN CHECK FUNCTION
CREATE OR REPLACE FUNCTION public.is_super_admin()
RETURNS boolean
LANGUAGE sql
SECURITY DEFINER
SET search_path = ''
STABLE
AS $$
SELECT EXISTS (
    SELECT 1
    FROM auth.users
    WHERE id = auth.uid()
      AND is_super_admin = true
  );
$$;

-- GET MY ROLE FUNCTION
CREATE OR REPLACE FUNCTION public.get_my_role()
RETURNS text
LANGUAGE sql
STABLE
SECURITY DEFINER
SET search_path = ''
AS $$
SELECT role
FROM auth.users
WHERE id = auth.uid();
$$;

-- USER DETAILS FUNCTION
CREATE OR REPLACE FUNCTION public.get_my_user_details()
RETURNS TABLE (
    id uuid,
    email text,
    last_sign_in_at timestamptz,
    created_at timestamptz,
    is_super_admin boolean,
    is_email_verified boolean,
    first_name text,
    last_name text,
    avatar_url text,
    phone_number text,
    date_of_birth date,
    address jsonb,
    preferences jsonb,
    role text,
    designation text,
    updated_at timestamptz
)
LANGUAGE sql
SECURITY DEFINER
SET search_path = ''
AS $$
SELECT
    u.id,
    u.email,
    u.last_sign_in_at,
    u.created_at,
    u.is_super_admin,
    (u.email_confirmed_at IS NOT NULL) AS is_email_verified,
    p.first_name,
    p.last_name,
    p.avatar_url,
    p.phone_number,
    p.date_of_birth,
    p.address,
    p.preferences,
    p.role,
    p.designation,
    p.updated_at
FROM auth.users AS u
LEFT JOIN public.user_profiles AS p ON u.id = p.id
WHERE u.id = auth.uid();
$$;


-- =================================================================
-- Section 2: Admin RPC Functions
-- =================================================================

-- Enhanced admin function that returns a structured JSONB object
CREATE OR REPLACE FUNCTION public.admin_get_all_users_extended(
    search_query TEXT DEFAULT NULL,
    filter_role TEXT DEFAULT NULL,
    filter_status TEXT DEFAULT NULL,
    filter_activity TEXT DEFAULT NULL,
    date_from TIMESTAMPTZ DEFAULT NULL,
    date_to TIMESTAMPTZ DEFAULT NULL,
    page_offset INTEGER DEFAULT 0,
    page_limit INTEGER DEFAULT 50
) 
-- CORRECTED: Returns a single JSONB object
RETURNS JSONB
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public, auth
AS $$
DECLARE
    v_total_records bigint;
    v_active_count bigint;
    v_inactive_count bigint;
    v_user_data JSONB;
BEGIN
    -- Check if user is super admin
    IF NOT public.is_super_admin() THEN
        RAISE EXCEPTION 'Access denied. Super admin privileges required.';
    END IF;

    -- Calculate all three counts in a single, efficient query
    SELECT
        COUNT(*),
        COUNT(*) FILTER (WHERE v.status = 'active'),
        COUNT(*) FILTER (WHERE v.status = 'inactive')
    INTO
        v_total_records,
        v_active_count,
        v_inactive_count
    FROM v_user_profiles_extended v
    WHERE
        (search_query IS NULL OR v.full_name ILIKE '%' || search_query || '%' OR v.email ILIKE '%' || search_query || '%')
    AND (filter_role IS NULL OR filter_role = 'all' OR v.role = filter_role)
    AND (filter_status IS NULL OR filter_status = 'all' OR v.status = filter_status)
    AND (filter_activity IS NULL OR filter_activity = 'all' OR v.last_activity_period = filter_activity)
    AND (date_from IS NULL OR v.created_at >= date_from)
    AND (date_to IS NULL OR v.created_at <= date_to);

    -- Fetch the paginated user data into a JSONB array
    SELECT jsonb_agg(t)
    INTO v_user_data
    FROM (
        SELECT
            v.id, v.email, v.last_sign_in_at, v.created_at, v.is_super_admin, v.is_email_verified,
            v.first_name, v.last_name, v.avatar_url, v.phone_number, v.date_of_birth, v.address,
            v.preferences, v.role, v.designation, v.updated_at, v.status, v.full_name,
            v.computed_status, v.account_age_days, v.last_activity_period
        FROM public.v_user_profiles_extended v
        WHERE
            (search_query IS NULL OR v.full_name ILIKE '%' || search_query || '%' OR v.email ILIKE '%' || search_query || '%')
        AND (filter_role IS NULL OR filter_role = 'all' OR v.role = filter_role)
        AND (filter_status IS NULL OR filter_status = 'all' OR v.status = filter_status)
        AND (filter_activity IS NULL OR filter_activity = 'all' OR v.last_activity_period = filter_activity)
        AND (date_from IS NULL OR v.created_at >= date_from)
        AND (date_to IS NULL OR v.created_at <= date_to)
        ORDER BY v.created_at DESC
        OFFSET page_offset
        LIMIT page_limit
    ) t;

    -- CORRECTED: Combine data and counts into a single JSONB object
    RETURN jsonb_build_object(
        'data', COALESCE(v_user_data, '[]'::jsonb),
        'counts', jsonb_build_object(
            'total', COALESCE(v_total_records, 0),
            'active', COALESCE(v_active_count, 0),
            'inactive', COALESCE(v_inactive_count, 0)
        )
    );
END;
$$;


-- Function to get a single user by ID (admin only)
CREATE OR REPLACE FUNCTION public.admin_get_user_by_id ( user_id uuid )
RETURNS TABLE (
    id uuid, email text, first_name text, last_name text, avatar_url text, phone_number text, date_of_birth date, address jsonb,
    preferences jsonb, role text, designation text, status text, is_email_verified boolean, last_sign_in_at timestamptz,
    created_at timestamptz, updated_at timestamptz
) LANGUAGE plpgsql SECURITY DEFINER SET search_path = '' AS $$
BEGIN
    IF NOT (public.is_super_admin() OR auth.uid() = user_id) THEN
        RAISE EXCEPTION 'Access denied. Insufficient privileges.';
    END IF;
    RETURN QUERY
    SELECT p.id, CAST(u.email AS text) as email, p.first_name, p.last_name, p.avatar_url, p.phone_number, p.date_of_birth, p.address,
           p.preferences, p.role, p.designation, p.status, (u.email_confirmed_at IS NOT NULL) as is_email_verified, u.last_sign_in_at,
           p.created_at, p.updated_at
    FROM public.user_profiles p
    LEFT JOIN auth.users u ON p.id = u.id
    WHERE p.id = user_id;
END;
$$;

-- Function to update user profile (admin only)
CREATE OR REPLACE FUNCTION public.admin_update_user_profile (
    user_id uuid, update_first_name text DEFAULT NULL, update_last_name text DEFAULT NULL, update_avatar_url text DEFAULT NULL,
    update_phone_number text DEFAULT NULL, update_date_of_birth date DEFAULT NULL, update_address jsonb DEFAULT NULL,
    update_preferences jsonb DEFAULT NULL, update_role text DEFAULT NULL, update_designation text DEFAULT NULL, update_status text DEFAULT NULL
) RETURNS boolean LANGUAGE plpgsql SECURITY DEFINER SET search_path = '' AS $$
BEGIN
    IF NOT (public.is_super_admin() OR auth.uid() = user_id) THEN
        RAISE EXCEPTION 'Access denied. Insufficient privileges.';
    END IF;
    UPDATE public.user_profiles
    SET first_name = COALESCE(update_first_name, first_name),
        last_name = COALESCE(update_last_name, last_name),
        avatar_url = CASE WHEN update_avatar_url = '' THEN NULL ELSE COALESCE(update_avatar_url, avatar_url) END,
        phone_number = CASE WHEN update_phone_number = '' THEN NULL ELSE COALESCE(update_phone_number, phone_number) END,
        date_of_birth = COALESCE(update_date_of_birth, date_of_birth),
        address = COALESCE(update_address, address),
        preferences = COALESCE(update_preferences, preferences),
        role = COALESCE(update_role, role),
        designation = COALESCE(update_designation, designation),
        status = COALESCE(update_status, status),
        updated_at = NOW()
    WHERE id = user_id;
    RETURN FOUND;
END;
$$;

-- Function to bulk update user status (admin only)
CREATE OR REPLACE FUNCTION public.admin_bulk_update_status ( user_ids uuid[], new_status text )
RETURNS boolean LANGUAGE plpgsql SECURITY DEFINER SET search_path = '' AS $$
BEGIN
    IF NOT public.is_super_admin() THEN RAISE EXCEPTION 'Access denied. Super admin privileges required.'; END IF;
    IF new_status NOT IN ('active', 'inactive', 'suspended') THEN RAISE EXCEPTION 'Invalid status. Must be active, inactive, or suspended.'; END IF;
    UPDATE public.user_profiles SET status = new_status, updated_at = NOW() WHERE id = ANY(user_ids);
    PERFORM public.log_user_activity('BULK_UPDATE_STATUS', 'user_profiles', NULL, jsonb_build_object('user_ids', user_ids), jsonb_build_object('new_status', new_status), 'Bulk status update performed by admin');
    RETURN FOUND;
END;
$$;

-- Function to bulk update user role (admin only)
CREATE OR REPLACE FUNCTION public.admin_bulk_update_role ( user_ids uuid[], new_role text )
RETURNS boolean LANGUAGE plpgsql SECURITY DEFINER SET search_path = '' AS $$
BEGIN
    IF NOT public.is_super_admin() THEN RAISE EXCEPTION 'Access denied. Super admin privileges required.'; END IF;
    IF new_role NOT IN ('admin', 'viewer', 'cpan_admin', 'maan_admin', 'sdh_admin', 'vmux_admin', 'mng_admin') THEN RAISE EXCEPTION 'Invalid role.'; END IF;
    UPDATE public.user_profiles SET role = new_role, updated_at = NOW() WHERE id = ANY(user_ids);
    PERFORM public.log_user_activity('BULK_UPDATE_ROLE', 'user_profiles', NULL, jsonb_build_object('user_ids', user_ids), jsonb_build_object('new_role', new_role), 'Bulk role update performed by admin');
    RETURN FOUND;
END;
$$;

-- Function to bulk delete users (admin only)
CREATE OR REPLACE FUNCTION public.admin_bulk_delete_users ( user_ids uuid[] )
RETURNS boolean LANGUAGE plpgsql SECURITY DEFINER SET search_path = '' AS $$
BEGIN
    IF NOT public.is_super_admin() THEN RAISE EXCEPTION 'Access denied. Super admin privileges required.'; END IF;
    PERFORM public.log_user_activity('BULK_DELETE', 'user_profiles', NULL, jsonb_build_object('user_ids', user_ids), NULL, 'Bulk user deletion performed by admin');
    DELETE FROM public.user_profiles WHERE id = ANY(user_ids);
    RETURN FOUND;
END;
$$;


-- =================================================================
-- Section 3: Trigger Functions
-- =================================================================

-- TRIGGER FUNCTION for updating timestamps
CREATE OR REPLACE FUNCTION public.update_user_profile_timestamp()
RETURNS TRIGGER LANGUAGE plpgsql SET search_path = '' AS $$
BEGIN
    NEW.updated_at = NOW();
    RETURN NEW;
END;
$$;

-- Function that will sync the role to auth.users
CREATE OR REPLACE FUNCTION public.sync_user_role_to_auth()
RETURNS TRIGGER LANGUAGE plpgsql SECURITY DEFINER SET search_path = '' AS $$
BEGIN
    IF (TG_OP = 'INSERT' OR (TG_OP = 'UPDATE' AND NEW.role IS DISTINCT FROM OLD.role)) AND NEW.role IS NOT NULL THEN
        UPDATE auth.users SET role = NEW.role WHERE id = NEW.id;
    END IF;
    RETURN NEW;
END;
$$;

-- USER CREATION FUNCTION (UPDATED)
CREATE OR REPLACE FUNCTION public.create_public_profile_for_new_user()
RETURNS TRIGGER LANGUAGE plpgsql SECURITY DEFINER SET search_path = '' AS $$
BEGIN
    IF NOT EXISTS (SELECT 1 FROM public.user_profiles WHERE id = NEW.id) THEN
        INSERT INTO public.user_profiles (id, first_name, last_name, avatar_url, phone_number, date_of_birth, address, preferences, status)
        VALUES (
            NEW.id,
            COALESCE(NEW.raw_user_meta_data->>'first_name', NEW.raw_user_meta_data->>'name', (SELECT initcap(word) FROM regexp_split_to_table(split_part(NEW.email, '@', 1), '[^a-zA-Z]+') AS word WHERE word ~ '^[a-zA-Z]+' LIMIT 1), 'Placeholder'),
            COALESCE(NEW.raw_user_meta_data->>'last_name', SPLIT_PART(NEW.raw_user_meta_data->>'name', ' ', 2), 'User'),
            NEW.raw_user_meta_data->>'avatar_url',
            NEW.raw_user_meta_data->>'phone_number',
            CASE WHEN NEW.raw_user_meta_data->>'date_of_birth' ~ '^\d{4}-\d{2}-\d{2}$' THEN (NEW.raw_user_meta_data->>'date_of_birth')::date ELSE NULL END,
            COALESCE(NEW.raw_user_meta_data->'address', '{}'::jsonb),
            -- ** Add the needsOnboarding flag to preferences**
            COALESCE(NEW.raw_user_meta_data->'preferences', '{}'::jsonb) || '{"needsOnboarding": true}',
            'active'
        );
    END IF;
    RETURN NEW;
END;
$$;
```

<!-- path: data/migrations/02_core_infrastructure/03_views.sql -->
```sql
-- path: data/migrations/02_core_infrastructure/03_views.sql
-- Description: Defines denormalized views for the Core Infrastructure module. [PERFORMANCE OPTIMIZED]

-- View for lookup_types
CREATE OR REPLACE VIEW public.v_lookup_types WITH (security_invoker = true) AS
SELECT
  lt.*
FROM public.lookup_types lt;

-- View for maintenance_areas with joined data
CREATE OR REPLACE VIEW public.v_maintenance_areas WITH (security_invoker = true) AS
SELECT
  ma.*,
  lt_ma.name AS maintenance_area_type_name,
  lt_ma.code AS maintenance_area_type_code
FROM public.maintenance_areas ma
LEFT JOIN public.lookup_types lt_ma ON ma.area_type_id = lt_ma.id;

-- View for employee_designations
CREATE OR REPLACE VIEW public.v_employee_designations WITH (security_invoker = true) AS
SELECT
  ed.*
FROM public.employee_designations ed;

-- View for employees with joined data
CREATE OR REPLACE VIEW public.v_employees WITH (security_invoker = true) AS
SELECT
  e.*,
  ed.name AS employee_designation_name
FROM public.employees e
LEFT JOIN public.employee_designations ed ON e.employee_designation_id = ed.id;

-- View for nodes with joined data
CREATE OR REPLACE VIEW public.v_nodes_complete WITH (security_invoker = true) AS
SELECT
  n.*,
  lt_node.name AS node_type_name,
  lt_node.code AS node_type_code,
  ma.name AS maintenance_area_name
FROM public.nodes n
LEFT JOIN public.lookup_types lt_node ON n.node_type_id = lt_node.id
LEFT JOIN public.maintenance_areas ma ON n.maintenance_terminal_id = ma.id;

-- View for ofc_cables with joined data
CREATE OR REPLACE VIEW public.v_ofc_cables_complete WITH (security_invoker = true) AS
SELECT
  ofc.*,
  sn.name AS sn_name,
  en.name AS en_name,
  lt_sn_type.name as sn_node_type_name,
  lt_en_type.name as en_node_type_name,
  lt_ofc.name AS ofc_type_name,
  lt_ofc.code AS ofc_type_code,
  lt_ofc_owner.name AS ofc_owner_name,
  lt_ofc_owner.code AS ofc_owner_code,
  ma.name AS maintenance_area_name,
  ma.code AS maintenance_area_code
FROM public.ofc_cables ofc
LEFT JOIN public.nodes sn ON ofc.sn_id = sn.id
LEFT JOIN public.nodes en ON ofc.en_id = en.id
LEFT JOIN public.lookup_types lt_ofc ON ofc.ofc_type_id = lt_ofc.id
LEFT JOIN public.lookup_types lt_ofc_owner ON ofc.ofc_owner_id = lt_ofc_owner.id
LEFT JOIN public.maintenance_areas ma ON ofc.maintenance_terminal_id = ma.id
LEFT JOIN public.lookup_types lt_sn_type ON sn.node_type_id = lt_sn_type.id
LEFT JOIN public.lookup_types lt_en_type ON en.node_type_id = lt_en_type.id;


```

<!-- path: data/migrations/02_core_infrastructure/02_functions.sql -->
```sql
-- Path: migrations/02_core_infrastructure/02_functions.sql
-- Description: Contains helper and trigger functions for core tables.

-- Generic function to update the 'updated_at' column on any table.
CREATE OR REPLACE FUNCTION public.update_updated_at_column()
RETURNS TRIGGER
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public, pg_catalog
AS $$
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
$$;

-- Trigger function to update sn_dom (start node date of measurement) if OTDR distance changes significantly.
CREATE OR REPLACE FUNCTION public.update_sn_dom_on_otdr_change()
RETURNS TRIGGER
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public, pg_catalog
AS $$
BEGIN
  IF NEW.otdr_distance_sn_km IS DISTINCT FROM OLD.otdr_distance_sn_km THEN
    IF NEW.sn_dom IS NULL OR abs(coalesce(NEW.otdr_distance_sn_km, 0) - coalesce(OLD.otdr_distance_sn_km, 0)) > 0.05 THEN
      NEW.sn_dom := CURRENT_DATE;
    END IF;
  END IF;
  RETURN NEW;
END;
$$;

-- Trigger function to update en_dom (end node date of measurement) if OTDR distance changes significantly.
CREATE OR REPLACE FUNCTION public.update_en_dom_on_otdr_change()
RETURNS TRIGGER
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public, pg_catalog
AS $$
BEGIN
  IF NEW.otdr_distance_en_km IS DISTINCT FROM OLD.otdr_distance_en_km THEN
    IF NEW.en_dom IS NULL OR abs(coalesce(NEW.otdr_distance_en_km, 0) - coalesce(OLD.otdr_distance_en_km, 0)) > 0.05 THEN
      NEW.en_dom := CURRENT_DATE;
    END IF;
  END IF;
  RETURN NEW;
END;
$$;
```

<!-- path: data/migrations/02_core_infrastructure/05_rls_and_grants.sql -->
```sql
-- path: data/migrations/02_core_infrastructure/06_rls_and_grants.sql
-- Description: Applies a baseline set of RLS policies and grants to core tables. [UPDATED VIEW NAMES]

DO $$
DECLARE
  tbl TEXT;
  admin_role TEXT := 'admin';
  viewer_role TEXT := 'viewer';
BEGIN
  FOREACH tbl IN ARRAY ARRAY[
    'lookup_types', 'maintenance_areas', 'rings',
    'employee_designations', 'employees', 'nodes',
    'ofc_cables', 'ofc_connections',
    'folders', 'files'
  ]
  LOOP
    EXECUTE format('ALTER TABLE public.%I ENABLE ROW LEVEL SECURITY;', tbl);
    EXECUTE format('GRANT SELECT, INSERT, UPDATE, DELETE ON public.%I TO %I;', tbl, admin_role);
    EXECUTE format('GRANT SELECT ON public.%I TO %I;', tbl, viewer_role);

    EXECUTE format('DROP POLICY IF EXISTS "policy_admin_all_%s" ON public.%I;', tbl, tbl);
    EXECUTE format('DROP POLICY IF EXISTS "policy_viewer_select_%s" ON public.%I;', tbl, tbl);

    EXECUTE format($p$
      CREATE POLICY "policy_admin_all_%s" ON public.%I
      FOR ALL TO %I
      USING (is_super_admin() OR public.get_my_role() = %L)
      WITH CHECK (is_super_admin() OR public.get_my_role() = %L);
    $p$, tbl, tbl, admin_role, admin_role, admin_role);

    EXECUTE format($p$
      CREATE POLICY "policy_viewer_select_%s" ON public.%I
      FOR SELECT TO %I
      USING (public.get_my_role() = %L);
    $p$, tbl, tbl, viewer_role, viewer_role);

    RAISE NOTICE 'Applied baseline admin/viewer RLS policies to %', tbl;
  END LOOP;
END;
$$;


DO $$
BEGIN
  EXECUTE 'GRANT SELECT ON public.nodes TO cpan_admin, maan_admin, sdh_admin, vmux_admin, mng_admin;';
  EXECUTE 'GRANT SELECT ON public.maintenance_areas TO cpan_admin, maan_admin, sdh_admin, vmux_admin, mng_admin;';
  EXECUTE 'GRANT SELECT ON public.lookup_types TO cpan_admin, maan_admin, sdh_admin, vmux_admin, mng_admin;';
  EXECUTE 'GRANT SELECT ON public.ofc_cables TO cpan_admin, maan_admin, sdh_admin, vmux_admin, mng_admin;';
  EXECUTE 'GRANT SELECT ON public.ofc_connections TO cpan_admin, maan_admin, sdh_admin, vmux_admin, mng_admin;';
  RAISE NOTICE 'Granted SELECT on core tables to specific admin roles.';
END;
$$;

DO $$
DECLARE
  tbl TEXT;
BEGIN
  FOREACH tbl IN ARRAY ARRAY['nodes', 'maintenance_areas', 'lookup_types', 'ofc_cables', 'ofc_connections']
  LOOP
    EXECUTE format('DROP POLICY IF EXISTS "policy_system_admins_select_%s" ON public.%I;', tbl, tbl);
    EXECUTE format($p$
      CREATE POLICY "policy_system_admins_select_%s" ON public.%I
      FOR SELECT TO cpan_admin, maan_admin, sdh_admin, vmux_admin, mng_admin
      USING (
        get_my_role() IN ('cpan_admin', 'maan_admin', 'sdh_admin', 'vmux_admin', 'mng_admin')
      );
    $p$, tbl, tbl);
    RAISE NOTICE 'Applied system-admin SELECT RLS policy to %', tbl;
  END LOOP;
END;
$$;

-- CORRECTED SECTION: Grants now reference the renamed views.
DO $$
BEGIN
  GRANT SELECT ON public.v_lookup_types TO admin, viewer, cpan_admin, maan_admin, sdh_admin, vmux_admin, mng_admin;
  GRANT SELECT ON public.v_maintenance_areas TO admin, viewer, cpan_admin, maan_admin, sdh_admin, vmux_admin, mng_admin;
  GRANT SELECT ON public.v_employee_designations TO admin, viewer;
  GRANT SELECT ON public.v_employees TO admin, viewer;
  GRANT SELECT ON public.v_nodes_complete TO admin, viewer, cpan_admin, maan_admin, sdh_admin, vmux_admin, mng_admin;
  GRANT SELECT ON public.v_ofc_cables_complete TO admin, viewer, cpan_admin, maan_admin, sdh_admin, vmux_admin, mng_admin;

  RAISE NOTICE 'Applied SELECT grants on core infrastructure views for ALL relevant roles.';
END;
$$;
```

<!-- path: data/migrations/02_core_infrastructure/04_indexes.sql -->
```sql
-- Path: migrations/02_core_infrastructure/04_indexes.sql
-- Description: Creates all B-tree and GIN (FTS) indexes for the Core module.

-- =================================================================
-- Section 1: Standard B-Tree Indexes
-- =================================================================

-- Indexes for lookup_types
CREATE INDEX IF NOT EXISTS idx_lookup_types_category ON public.lookup_types (category);
CREATE INDEX IF NOT EXISTS idx_lookup_types_name ON public.lookup_types (name);

-- Indexes for maintenance_areas
CREATE INDEX IF NOT EXISTS idx_maintenance_areas_parent_id ON public.maintenance_areas (parent_id);

-- Indexes for employee_designations
CREATE INDEX IF NOT EXISTS idx_employee_designations_parent_id ON public.employee_designations (parent_id);

-- Indexes for employees
CREATE INDEX IF NOT EXISTS idx_employees_employee_designation_id ON public.employees (employee_designation_id);
CREATE INDEX IF NOT EXISTS idx_employees_maintenance_terminal_id ON public.employees (maintenance_terminal_id);

-- Indexes for nodes
CREATE INDEX IF NOT EXISTS idx_nodes_type_id ON public.nodes (node_type_id);
CREATE INDEX IF NOT EXISTS idx_nodes_maintenance_area ON public.nodes (maintenance_terminal_id);
CREATE INDEX IF NOT EXISTS idx_nodes_coordinates ON public.nodes (latitude, longitude);
CREATE INDEX IF NOT EXISTS idx_nodes_status ON public.nodes (status);

-- Indexes for ofc_connections
CREATE INDEX IF NOT EXISTS idx_ofc_connections_ofc_id ON public.ofc_connections (ofc_id);
CREATE INDEX IF NOT EXISTS idx_ofc_connections_system_id ON public.ofc_connections (system_id);
CREATE INDEX IF NOT EXISTS idx_ofc_connections_logical_path_id ON public.ofc_connections (logical_path_id);

-- Indexes for files/folders
CREATE INDEX IF NOT EXISTS idx_folders_user_id ON public.folders USING btree (user_id);
CREATE INDEX IF NOT EXISTS idx_files_user_id ON public.files USING btree (user_id);
CREATE INDEX IF NOT EXISTS idx_files_folder_id ON public.files USING btree (folder_id);

-- =================================================================
-- Section 2: Full-Text Search (FTS) GIN Indexes
-- =================================================================

CREATE INDEX IF NOT EXISTS idx_employees_remark_fts ON public.employees USING gin(to_tsvector('english', remark));
CREATE INDEX IF NOT EXISTS idx_nodes_remark_fts ON public.nodes USING gin(to_tsvector('english', remark));
CREATE INDEX IF NOT EXISTS idx_ofc_cables_remark_fts ON public.ofc_cables USING gin(to_tsvector('english', remark));
CREATE INDEX IF NOT EXISTS idx_ofc_connections_remark_fts ON public.ofc_connections USING gin(to_tsvector('english', remark));
```

<!-- path: data/migrations/02_core_infrastructure/01_tables_core.sql -->
```sql
-- Path: migrations/02_core_infrastructure/01_tables_core.sql
-- Description: Defines all core infrastructure and master data tables.

-- Centralized Lookup Types Table
CREATE TABLE IF NOT EXISTS public.lookup_types (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  category TEXT NOT NULL,
  name TEXT NOT NULL,
  code TEXT,
  description TEXT,
  sort_order INTEGER DEFAULT 0,
  is_system_default BOOLEAN DEFAULT false,
  status BOOLEAN DEFAULT true,
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW(),
  CONSTRAINT uq_lookup_types_category_name UNIQUE (category, name),
  CONSTRAINT uq_lookup_types_category_code UNIQUE (category, code)
);

-- Maintenance Areas/Terminals Master Table
CREATE TABLE IF NOT EXISTS public.maintenance_areas (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  name TEXT NOT NULL,
  code TEXT UNIQUE,
  area_type_id UUID REFERENCES public.lookup_types (id),
  parent_id UUID REFERENCES public.maintenance_areas (id),
  contact_person TEXT,
  contact_number TEXT,
  email TEXT,
  latitude DECIMAL(10, 8),
  longitude DECIMAL(11, 8),
  address TEXT,
  status BOOLEAN DEFAULT true,
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Employee Designation Table
CREATE TABLE IF NOT EXISTS public.employee_designations (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  name TEXT NOT NULL UNIQUE,
  parent_id UUID REFERENCES public.employee_designations(id) ON DELETE SET NULL,
  status BOOLEAN DEFAULT true,
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Employee Master Table
CREATE TABLE IF NOT EXISTS public.employees (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  employee_name TEXT NOT NULL,
  employee_pers_no TEXT UNIQUE,
  employee_contact TEXT,
  employee_email TEXT,
  employee_dob DATE,
  employee_doj DATE,
  employee_designation_id UUID REFERENCES public.employee_designations (id),
  employee_addr TEXT,
  maintenance_terminal_id UUID REFERENCES public.maintenance_areas (id),
  remark TEXT,
  status BOOLEAN DEFAULT true,
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Ring Master Table
CREATE TABLE IF NOT EXISTS public.rings (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  name TEXT NOT NULL,
  ring_type_id UUID REFERENCES public.lookup_types (id),
  description TEXT,
  maintenance_terminal_id UUID REFERENCES public.maintenance_areas (id),
  total_nodes INTEGER DEFAULT 0,
  status BOOLEAN DEFAULT true,
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Node List (Physical Locations/Sites)
CREATE TABLE IF NOT EXISTS public.nodes (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  name TEXT NOT NULL,
  node_type_id UUID REFERENCES public.lookup_types (id),
  latitude DECIMAL(10, 8),
  longitude DECIMAL(11, 8),
  maintenance_terminal_id UUID REFERENCES public.maintenance_areas (id),
  remark TEXT,
  status BOOLEAN DEFAULT true,
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified OFC (Optical Fiber Cable) Table
CREATE TABLE IF NOT EXISTS public.ofc_cables (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  route_name TEXT NOT NULL,
  sn_id UUID REFERENCES public.nodes (id) NOT NULL,
  en_id UUID REFERENCES public.nodes (id) NOT NULL,
  ofc_type_id UUID REFERENCES public.lookup_types (id) NOT NULL,
  capacity INTEGER NOT NULL,
  ofc_owner_id UUID REFERENCES public.lookup_types (id) NOT NULL,
  current_rkm DECIMAL(10, 3),
  transnet_id TEXT,
  transnet_rkm DECIMAL(10, 3),
  asset_no TEXT,
  maintenance_terminal_id UUID REFERENCES public.maintenance_areas (id),
  commissioned_on DATE,
  remark TEXT,
  status BOOLEAN DEFAULT true,
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- OFC Connection Details (Fiber connections between nodes)
CREATE TABLE IF NOT EXISTS public.ofc_connections (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  -- **Added ON DELETE CASCADE to this line.**
  ofc_id UUID REFERENCES public.ofc_cables (id) ON DELETE CASCADE NOT NULL,
  fiber_no_sn INTEGER NOT NULL,
  fiber_no_en INTEGER NOT NULL,
  updated_fiber_no_sn INTEGER,
  updated_fiber_no_en INTEGER,
  updated_sn_id UUID REFERENCES public.nodes (id),
  updated_en_id UUID REFERENCES public.nodes (id),
  otdr_distance_sn_km DECIMAL(10, 3),
  sn_dom DATE,
  sn_power_dbm DECIMAL(10, 3),
  system_id UUID, -- NOTE: FK constraint to systems table is added in 99_finalization
  otdr_distance_en_km DECIMAL(10, 3),
  en_dom DATE,
  en_power_dbm DECIMAL(10, 3),
  route_loss_db DECIMAL(10, 3),
  logical_path_id UUID, -- NOTE: FK constraint to logical_fiber_paths is added in 99_finalization
  fiber_role TEXT CHECK (fiber_role IN ('working', 'protection')),
  path_segment_order INTEGER DEFAULT 1,
  source_port TEXT,
  destination_port TEXT,
  connection_category TEXT NOT NULL DEFAULT 'OFC_JOINT_TYPES',
  connection_type TEXT NOT NULL DEFAULT 'straight',
  CONSTRAINT fk_connection_type FOREIGN KEY (connection_category, connection_type)
    REFERENCES public.lookup_types(category, name),
  remark TEXT,
  status BOOLEAN DEFAULT true,
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Folders table for file management
CREATE TABLE IF NOT EXISTS public.folders (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID NOT NULL REFERENCES auth.users (id),
  name TEXT NOT NULL,
  created_at TIMESTAMPTZ DEFAULT NOW()
);

-- Files table for file management
CREATE TABLE IF NOT EXISTS public.files (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID NOT NULL REFERENCES auth.users (id),
  folder_id UUID REFERENCES public.folders (id),
  file_name TEXT NOT NULL,
  file_type TEXT NOT NULL,
  file_size TEXT NOT NULL,
  file_route TEXT NOT NULL,
  file_url TEXT NOT NULL,
  uploaded_at TIMESTAMPTZ DEFAULT NOW()
);
```

<!-- path: data/migrations/02_core_infrastructure/06_triggers_ofc_connections.sql -->
```sql
-- Path: migrations/02_core_infrastructure/07_triggers_ofc_connections.sql
-- Description: Creates a trigger to automatically populate ofc_connections when a new ofc_cable is inserted.

-- 1. Define the trigger function
CREATE OR REPLACE FUNCTION public.create_initial_connections_for_cable()
RETURNS TRIGGER
LANGUAGE plpgsql
SECURITY DEFINER -- Use definer to ensure it can write to ofc_connections
SET search_path = public
AS $$
DECLARE
    i INT;
BEGIN
    -- Loop from 1 to the capacity of the newly inserted cable
    FOR i IN 1..NEW.capacity LOOP
        -- Insert a new record into ofc_connections for each fiber
        INSERT INTO public.ofc_connections (
            ofc_id,
            fiber_no_sn,
            fiber_no_en,
            -- Populate with initial logical path info
            updated_fiber_no_sn,
            updated_fiber_no_en,
            updated_sn_id,
            updated_en_id
        )
        VALUES (
            NEW.id,      -- Cable ID
            i,           -- Start fiber number
            i,           -- End fiber number
            -- Initial logical path matches the physical path
            i,           -- updated_fiber_no_sn
            i,           -- updated_fiber_no_en
            NEW.sn_id,   -- updated_sn_id
            NEW.en_id    -- updated_en_id
        );
    END LOOP;
    RETURN NEW;
END;
$$;

-- 2. Create and attach the trigger to the ofc_cables table
DROP TRIGGER IF EXISTS on_ofc_cable_created ON public.ofc_cables; -- for idempotency
CREATE TRIGGER on_ofc_cable_created
AFTER INSERT ON public.ofc_cables
FOR EACH ROW
EXECUTE FUNCTION public.create_initial_connections_for_cable();

COMMENT ON TRIGGER on_ofc_cable_created ON public.ofc_cables IS 'Automatically creates individual fiber records in ofc_connections upon the creation of a new ofc_cable.';
```

<!-- path: data/migrations/04_advanced_ofc/02_views.sql -->
```sql
-- Path: migrations/04_advanced_ofc/02_views.sql
-- Description: Defines views for analyzing OFC paths and utilization. [UPDATED]

-- View showing complete information for a junction closure.
CREATE OR REPLACE VIEW public.v_junction_closures_complete WITH (security_invoker = true) AS
SELECT
  jc.id,
  jc.node_id,
  jc.ofc_cable_id,
  jc.position_km,
  n.name,
  n.latitude,
  n.longitude
FROM public.junction_closures jc
JOIN public.nodes n ON jc.node_id = n.id;

-- NEW VIEW: This view helps find which cable segments are connected to a specific JC node.
CREATE OR REPLACE VIEW public.v_cable_segments_at_jc WITH (security_invoker = true) AS
SELECT
  cs.id,
  cs.original_cable_id,
  cs.segment_order,
  cs.fiber_count,
  cs.start_node_id,
  cs.end_node_id,
  jcs.node_id as jc_node_id
FROM public.cable_segments cs
JOIN public.junction_closures jcs ON (cs.start_node_type = 'jc' AND cs.start_node_id = jcs.node_id)
                                  OR (cs.end_node_type = 'jc' AND cs.end_node_id = jcs.node_id);


-- View showing end-to-end logical path summaries.
CREATE OR REPLACE VIEW public.v_end_to_end_paths WITH (security_invoker = true) AS
SELECT
  lfp.id AS path_id,
  lfp.path_name,
  lfp.source_system_id,
  lfp.destination_system_id,
  lfp.total_distance_km,
  lfp.total_loss_db,
  lt_status.name AS operational_status,
  COUNT(lps.id) AS segment_count,
  STRING_AGG(DISTINCT oc.route_name, ' -> ' ORDER BY oc.route_name) AS route_names
FROM public.logical_fiber_paths lfp
LEFT JOIN public.lookup_types lt_status ON lfp.operational_status_id = lt_status.id
LEFT JOIN public.logical_path_segments lps ON lfp.id = lps.logical_path_id
LEFT JOIN public.ofc_cables oc ON lps.ofc_cable_id = oc.id
GROUP BY
  lfp.id,
  lt_status.name;


-- View showing detailed segments for a given logical path.
CREATE OR REPLACE VIEW public.v_system_ring_paths_detailed WITH (security_invoker = true) AS
SELECT
  srp.id,
  srp.logical_path_id,
  lp.path_name,
  lp.source_system_id,
  srp.ofc_cable_id,
  srp.path_order,
  oc.route_name,
  oc.sn_id AS start_node_id,
  sn.name AS start_node_name,
  oc.en_id AS end_node_id,
  en.name AS end_node_name,
  srp.created_at
FROM public.logical_path_segments srp
JOIN public.logical_fiber_paths lp ON srp.logical_path_id = lp.id
JOIN public.ofc_cables oc ON srp.ofc_cable_id = oc.id
LEFT JOIN public.nodes sn ON oc.sn_id = sn.id
LEFT JOIN public.nodes en ON oc.en_id = en.id
ORDER BY
  srp.logical_path_id,
  srp.path_order;


-- View for calculating fiber utilization per cable.
CREATE OR REPLACE VIEW public.v_cable_utilization WITH (security_invoker = true) AS
SELECT
  oc.id AS cable_id,
  oc.route_name,
  oc.capacity,
  -- [THE FIX] A fiber is used if it's assigned to ANY logical path. Role doesn't matter.
  COUNT(conn.id) FILTER (WHERE conn.logical_path_id IS NOT NULL) AS used_fibers,
  -- This logic remains correct.
  COUNT(conn.id) FILTER (WHERE conn.logical_path_id IS NULL) AS available_fibers,
  -- [THE FIX] The percentage now correctly reflects all used fibers.
  ROUND(
    (COUNT(conn.id) FILTER (WHERE conn.logical_path_id IS NOT NULL)::DECIMAL / NULLIF(oc.capacity, 0)) * 100, 2
  ) AS utilization_percent
FROM public.ofc_cables oc
LEFT JOIN public.ofc_connections conn ON oc.id = conn.ofc_id
GROUP BY
  oc.id, oc.route_name, oc.capacity;
```

<!-- path: data/migrations/04_advanced_ofc/06_rls_and_grants.sql -->
```sql
-- Path: migrations/04_advanced_ofc/06_rls_and_grants.sql
-- Description: RLS policies and Grants for the Advanced OFC (Route Manager) module.

-- =================================================================
-- Step 1: Grant Table-Level Permissions to Roles
-- =================================================================
GRANT ALL ON public.junction_closures TO admin;
GRANT ALL ON public.cable_segments TO admin;
GRANT ALL ON public.fiber_splices TO admin;
GRANT ALL ON public.logical_fiber_paths TO admin;
GRANT ALL ON public.logical_path_segments TO admin; -- Added missing table grant

GRANT SELECT ON public.junction_closures TO viewer;
GRANT SELECT ON public.cable_segments TO viewer;
GRANT SELECT ON public.fiber_splices TO viewer;
GRANT SELECT ON public.logical_fiber_paths TO viewer;
GRANT SELECT ON public.logical_path_segments TO viewer; -- Added missing table grant

-- Grant select on dependent tables from other modules for views to work
GRANT SELECT ON public.ofc_cables TO viewer, authenticated;
GRANT SELECT ON public.nodes TO viewer;
GRANT SELECT ON public.junction_closures TO authenticated;
GRANT SELECT ON public.cable_segments TO authenticated;

-- =================================================================
-- Step 2: Apply RLS Policies to Tables
-- =================================================================
DO $$
DECLARE
  tbl TEXT;
BEGIN
  -- CORRECTED: Uncommented logical_path_segments
  FOREACH tbl IN ARRAY ARRAY[
    'junction_closures', 'cable_segments', 'fiber_splices',
    'logical_fiber_paths', 'logical_path_segments'
  ]
  LOOP
    EXECUTE format('ALTER TABLE public.%I ENABLE ROW LEVEL SECURITY;', tbl);
    EXECUTE format('DROP POLICY IF EXISTS "policy_admin_all_%s" ON public.%I;', tbl, tbl);
    EXECUTE format('DROP POLICY IF EXISTS "policy_viewer_select_%s" ON public.%I;', tbl, tbl);

    -- Admin Policy
    EXECUTE format($p$
      CREATE POLICY "policy_admin_all_%s" ON public.%I FOR ALL TO admin
      USING (is_super_admin() OR get_my_role() = 'admin')
      WITH CHECK (is_super_admin() OR get_my_role() = 'admin');
    $p$, tbl, tbl);

    -- Viewer Policy
    EXECUTE format($p$
      CREATE POLICY "policy_viewer_select_%s" ON public.%I FOR SELECT TO viewer
      USING (get_my_role() = 'viewer' OR is_super_admin() OR get_my_role() = 'admin');
    $p$, tbl, tbl);
  END LOOP;
END;
$$;

DROP POLICY IF EXISTS policy_authenticated_select_cable_segments ON public.cable_segments;
CREATE POLICY policy_authenticated_select_cable_segments ON public.cable_segments
FOR SELECT TO authenticated USING (true);

DROP POLICY IF EXISTS policy_authenticated_select_junction_closures ON public.junction_closures;
CREATE POLICY policy_authenticated_select_junction_closures ON public.junction_closures
FOR SELECT TO authenticated USING (true);

-- =================================================================
-- Step 3: View-Level Grants [CORRECTED]
-- =================================================================
DO $$
BEGIN
  -- CORRECTED: Added grants for specific admin roles to all relevant views in this module.
  GRANT SELECT ON public.v_junction_closures_complete TO admin, viewer, cpan_admin, maan_admin, sdh_admin, vmux_admin, mng_admin;
  GRANT SELECT ON public.v_cable_segments_at_jc TO admin, viewer, cpan_admin, maan_admin, sdh_admin, vmux_admin, mng_admin;
  GRANT SELECT ON public.v_system_ring_paths_detailed TO admin, viewer, cpan_admin, maan_admin, sdh_admin, vmux_admin, mng_admin;
  GRANT SELECT ON public.v_cable_utilization TO admin, viewer, cpan_admin, maan_admin, sdh_admin, vmux_admin, mng_admin;
  GRANT SELECT ON public.v_end_to_end_paths TO admin, viewer, cpan_admin, maan_admin, sdh_admin, vmux_admin, mng_admin;
  
  RAISE NOTICE 'Applied SELECT grants on advanced OFC views for ALL relevant roles.';
END;
$$;
```

<!-- path: data/migrations/04_advanced_ofc/03_indexes.sql -->
```sql
-- Path: migrations/04_advanced_ofc/03_indexes.sql
-- Description: Creates indexes for the Advanced OFC module tables.

CREATE INDEX IF NOT EXISTS idx_logical_fiber_paths_source_system_id ON public.logical_fiber_paths (source_system_id);
CREATE INDEX IF NOT EXISTS idx_logical_path_segments_path_id ON public.logical_path_segments(logical_path_id);
```

<!-- path: data/migrations/04_advanced_ofc/01_tables_advanced_ofc.sql -->
```sql
-- Path: migrations/04_advanced_ofc/01_tables_advanced_ofc.sql
-- Description: Defines tables for advanced OFC path and splice management. [CORRECTED FOR SEGMENTS]

CREATE TABLE IF NOT EXISTS public.junction_closures (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  node_id UUID NOT NULL REFERENCES public.nodes(id) ON DELETE CASCADE,
  ofc_cable_id UUID NOT NULL REFERENCES public.ofc_cables(id) ON DELETE CASCADE,
  position_km NUMERIC(10,3),
  created_at TIMESTAMPTZ DEFAULT now(),
  updated_at TIMESTAMPTZ DEFAULT now()
);

CREATE TABLE IF NOT EXISTS public.cable_segments (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  original_cable_id UUID NOT NULL REFERENCES public.ofc_cables(id) ON DELETE CASCADE,
  segment_order INTEGER NOT NULL,
  start_node_id UUID NOT NULL,
  end_node_id UUID NOT NULL,
  start_node_type TEXT NOT NULL CHECK (start_node_type IN ('node', 'jc')),
  end_node_type TEXT NOT NULL CHECK (end_node_type IN ('node', 'jc')),
  distance_km DECIMAL(10,3) NOT NULL,
  fiber_count INTEGER NOT NULL,
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW(),
  UNIQUE (original_cable_id, segment_order)
);

CREATE TABLE IF NOT EXISTS public.logical_fiber_paths (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  path_name TEXT,
  working_path_id UUID REFERENCES public.logical_fiber_paths(id) ON DELETE SET NULL,
  path_role TEXT NOT NULL DEFAULT 'working' CHECK (path_role IN ('working', 'protection')),
  path_type_id UUID REFERENCES public.lookup_types(id) ON DELETE SET NULL,
  source_system_id UUID,
  destination_system_id UUID,
  operational_status_id UUID REFERENCES public.lookup_types(id) ON DELETE SET NULL,
  source_port TEXT,
  destination_port TEXT,
  total_distance_km DECIMAL(10, 3),
  total_loss_db DECIMAL(10, 3),
  service_type TEXT,
  bandwidth_gbps INTEGER,
  wavelength_nm INTEGER,
  commissioned_date DATE,
  remark TEXT,
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Tracks individual fiber connections (splices) between cable segments within a junction closure.
CREATE TABLE IF NOT EXISTS public.fiber_splices (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    jc_id UUID NOT NULL REFERENCES public.junction_closures(id) ON DELETE CASCADE,
    incoming_segment_id UUID NOT NULL REFERENCES public.cable_segments(id) ON DELETE CASCADE,
    incoming_fiber_no INT NOT NULL,
    outgoing_segment_id UUID REFERENCES public.cable_segments(id) ON DELETE CASCADE,
    outgoing_fiber_no INT,
    splice_type_id UUID NOT NULL REFERENCES public.lookup_types(id),
    logical_path_id UUID REFERENCES public.logical_fiber_paths(id) ON DELETE SET NULL,
    loss_db NUMERIC(5, 2),
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ,
    CONSTRAINT unique_incoming_fiber_in_jc UNIQUE (jc_id, incoming_segment_id, incoming_fiber_no),
    CONSTRAINT unique_outgoing_fiber_in_jc UNIQUE (jc_id, outgoing_segment_id, outgoing_fiber_no)
);

CREATE TABLE IF NOT EXISTS public.logical_path_segments (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  logical_path_id UUID NOT NULL REFERENCES public.logical_fiber_paths(id) ON DELETE CASCADE,
  ofc_cable_id UUID REFERENCES public.ofc_cables(id),
  path_order INT NOT NULL,
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW(),
  UNIQUE (logical_path_id, path_order)
);

```

<!-- path: data/migrations/04_advanced_ofc/05_triggers.sql -->
```sql
-- Ensure a clean state by dropping any old triggers that might exist.
DROP TRIGGER IF EXISTS on_junction_closure_change ON public.junction_closures;


-- Trigger 1: Cable Segmentation (This one is correct and remains)
CREATE TRIGGER on_junction_closure_change
AFTER INSERT OR DELETE ON public.junction_closures
FOR EACH ROW
EXECUTE FUNCTION public.manage_cable_segments();

COMMENT ON TRIGGER on_junction_closure_change ON public.junction_closures
IS 'When a JC is added or removed, this trigger calls a function to recalculate the virtual segments of the affected OFC cable.';
```

<!-- path: data/migrations/04_advanced_ofc/04_functions.sql -->
```sql
-- path: data/migrations/04_advanced_ofc/04_functions.sql
-- Description: All functions for cable segmentation, splicing, and fiber path management. [CONSOLIDATED & CORRECTED]

-- =================================================================
-- Section 1: Junction Closure and Segmentation Management
-- =================================================================

-- This function is called by the frontend to add a new JC.
CREATE OR REPLACE FUNCTION public.add_junction_closure(
  p_ofc_cable_id UUID,
  p_position_km NUMERIC(10,3),
  p_node_id UUID
)
RETURNS TABLE (
  id UUID,
  node_id UUID,
  ofc_cable_id UUID,
  position_km NUMERIC(10,3),
  created_at TIMESTAMPTZ
)
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
DECLARE
  v_jc_id UUID;
BEGIN
  IF NOT EXISTS (SELECT 1 FROM public.nodes WHERE nodes.id = p_node_id) THEN
    RAISE EXCEPTION 'Node with ID % does not exist', p_node_id;
  END IF;
  IF NOT EXISTS (SELECT 1 FROM public.ofc_cables WHERE ofc_cables.id = p_ofc_cable_id) THEN
    RAISE EXCEPTION 'Cable with ID % does not exist', p_ofc_cable_id;
  END IF;

  INSERT INTO public.junction_closures (node_id, ofc_cable_id, position_km)
  VALUES (p_node_id, p_ofc_cable_id, p_position_km)
  RETURNING junction_closures.id INTO v_jc_id;

  RETURN QUERY
  SELECT jc.id, jc.node_id, jc.ofc_cable_id, jc.position_km, jc.created_at
  FROM public.junction_closures jc
  WHERE jc.id = v_jc_id;
END;
$$;
GRANT EXECUTE ON FUNCTION public.add_junction_closure(UUID, NUMERIC, UUID) TO authenticated;

-- This function is called by a trigger to non-destructively recalculate segments.
CREATE OR REPLACE FUNCTION public.recalculate_segments_for_cable(p_cable_id UUID)
RETURNS VOID
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
DECLARE
  v_cable RECORD;
BEGIN
  SELECT * INTO v_cable FROM public.ofc_cables WHERE id = p_cable_id;
  IF NOT FOUND THEN
    RAISE WARNING 'Cable not found for segmentation: %', p_cable_id;
    RETURN;
  END IF;

  DELETE FROM public.cable_segments WHERE original_cable_id = p_cable_id;

  CREATE TEMP TABLE route_points AS
  SELECT v_cable.sn_id AS point_id, 'node' AS point_type, 0.0 AS position_km
  UNION ALL
  SELECT jc.node_id, 'jc', jc.position_km
  FROM public.junction_closures jc
  WHERE jc.ofc_cable_id = p_cable_id
  UNION ALL
  SELECT v_cable.en_id, 'node', v_cable.current_rkm;

  INSERT INTO public.cable_segments (
    original_cable_id, segment_order,
    start_node_id, start_node_type,
    end_node_id, end_node_type,
    distance_km, fiber_count
  )
  SELECT
    p_cable_id,
    ROW_NUMBER() OVER (ORDER BY p_start.position_km),
    p_start.point_id, p_start.point_type,
    p_end.point_id, p_end.point_type,
    p_end.position_km - p_start.position_km,
    v_cable.capacity
  FROM route_points p_start
  JOIN LATERAL (
    SELECT * FROM route_points p2
    WHERE p2.position_km > p_start.position_km
    ORDER BY p2.position_km ASC
    LIMIT 1
  ) p_end ON true;

  DROP TABLE route_points;
END;
$$;

-- This is the trigger function that orchestrates segmentation.
CREATE OR REPLACE FUNCTION public.manage_cable_segments()
RETURNS TRIGGER
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
BEGIN
  IF (TG_OP = 'INSERT') THEN
    PERFORM public.recalculate_segments_for_cable(NEW.ofc_cable_id);
    RETURN NEW;
  ELSIF (TG_OP = 'DELETE') THEN
    PERFORM public.recalculate_segments_for_cable(OLD.ofc_cable_id);
    RETURN OLD;
  END IF;
  RETURN NULL;
END;
$$;

-- Description: Get a list of all cable segments present at a specific Junction Closure.
CREATE OR REPLACE FUNCTION public.get_segments_at_jc(p_jc_id UUID)
RETURNS TABLE (id UUID, original_cable_name TEXT, segment_order INT, fiber_count INT)
LANGUAGE sql
STABLE
SECURITY DEFINER
SET search_path = public
AS $$
    SELECT
        cs.id,
        oc.route_name,
        cs.segment_order,
        cs.fiber_count
    FROM public.v_cable_segments_at_jc v_cs
    JOIN public.cable_segments cs ON v_cs.id = cs.id
    JOIN public.ofc_cables oc ON cs.original_cable_id = oc.id
    WHERE v_cs.jc_node_id = (SELECT node_id FROM public.junction_closures WHERE id = p_jc_id);
$$;
GRANT EXECUTE ON FUNCTION public.get_segments_at_jc(UUID) TO authenticated;

-- =================================================================
-- Section 2: Logical Fiber Path Tracing and Splicing Management
-- =================================================================

-- NEW, SIMPLE UPDATE FUNCTION: Takes pre-calculated data from the client and applies it.
CREATE OR REPLACE FUNCTION public.apply_logical_path_update(
    p_id UUID,
    p_start_node_id UUID,
    p_end_node_id UUID,
    p_start_fiber_no INT,
    p_end_fiber_no INT
)
RETURNS VOID
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
BEGIN
    UPDATE public.ofc_connections
    SET
        updated_sn_id       = p_start_node_id,
        updated_fiber_no_sn = p_start_fiber_no,
        updated_en_id       = p_end_node_id,
        updated_fiber_no_en = p_end_fiber_no,
        updated_at          = NOW()
    WHERE id = p_id;
END;
$$;
GRANT EXECUTE ON FUNCTION public.apply_logical_path_update(UUID, UUID, INT, INT, UUID) TO authenticated;

-- ** Final, correct, robust bi-directional trace function.**
CREATE OR REPLACE FUNCTION public.trace_fiber_path(p_start_segment_id UUID, p_start_fiber_no INT)
RETURNS TABLE (
    step_order BIGINT,
    element_type TEXT,
    element_id UUID,
    element_name TEXT,
    details TEXT,
    fiber_in INT,
    fiber_out INT,
    distance_km NUMERIC,
    loss_db NUMERIC,
    original_cable_id UUID,
    start_node_id UUID,
    end_node_id UUID
)
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
BEGIN
    -- Create temp table for the path
    CREATE TEMP TABLE IF NOT EXISTS temp_path_trace (
        step BIGINT,
        current_segment_id UUID,
        current_fiber_no INT,
        previous_splice_id UUID,
        visited_segments UUID[]
    ) ON COMMIT DROP;
    
    -- Trace forward
    INSERT INTO temp_path_trace
    WITH RECURSIVE forward_trace AS (
        SELECT
            0::bigint as step,
            p_start_segment_id as current_segment_id,
            p_start_fiber_no as current_fiber_no,
            NULL::uuid as previous_splice_id,
            ARRAY[p_start_segment_id] as visited_segments
        
        UNION ALL
        
        SELECT
            p.step + 1,
            s.outgoing_segment_id,
            s.outgoing_fiber_no,
            s.id,
            p.visited_segments || s.outgoing_segment_id
        FROM forward_trace p
        JOIN public.fiber_splices s 
            ON p.current_segment_id = s.incoming_segment_id 
            AND p.current_fiber_no = s.incoming_fiber_no
        WHERE s.outgoing_segment_id IS NOT NULL
          AND NOT (s.outgoing_segment_id = ANY(p.visited_segments))
          AND p.step < 100
    )
    SELECT * FROM forward_trace;
    
    -- Trace backward
    INSERT INTO temp_path_trace
    WITH RECURSIVE backward_trace AS (
        SELECT
            0::bigint as step,
            p_start_segment_id as current_segment_id,
            p_start_fiber_no as current_fiber_no,
            NULL::uuid as previous_splice_id,
            ARRAY[p_start_segment_id] as visited_segments
        
        UNION ALL
        
        SELECT
            p.step - 1,
            s.incoming_segment_id,
            s.incoming_fiber_no,
            s.id,
            p.visited_segments || s.incoming_segment_id
        FROM backward_trace p
        JOIN public.fiber_splices s 
            ON p.current_segment_id = s.outgoing_segment_id 
            AND p.current_fiber_no = s.outgoing_fiber_no
        WHERE s.incoming_segment_id IS NOT NULL
          AND NOT (s.incoming_segment_id = ANY(p.visited_segments))
          AND p.step > -100
    )
    SELECT * FROM backward_trace WHERE step < 0;
    
    -- Return results
    RETURN QUERY
    WITH path_elements AS (
        -- Segments
        SELECT
            fp.step * 2 AS order_key,
            'SEGMENT'::text as element_type,
            fp.current_segment_id as element_id,
            fp.current_fiber_no as fiber_in,
            fp.current_fiber_no as fiber_out
        FROM temp_path_trace fp
        
        UNION ALL
        
        -- Splices
        SELECT
            fp.step * 2 - 1 AS order_key,
            'SPLICE'::text,
            fp.previous_splice_id,
            LAG(fp.current_fiber_no) OVER (ORDER BY fp.step) as fiber_in,
            fp.current_fiber_no as fiber_out
        FROM temp_path_trace fp
        WHERE fp.previous_splice_id IS NOT NULL
    )
    SELECT
        ROW_NUMBER() OVER (ORDER BY pe.order_key) AS step_order,
        pe.element_type,
        pe.element_id,
        CASE
            WHEN pe.element_type = 'SEGMENT' THEN oc.route_name
            WHEN pe.element_type = 'SPLICE' THEN n.name
        END AS element_name,
        CASE
            WHEN pe.element_type = 'SEGMENT' THEN 
                'Segment ' || cs.segment_order || ' (' || sn.name || ' → ' || en.name || ')'
            WHEN pe.element_type = 'SPLICE' THEN 
                'Junction Closure Splice'
        END AS details,
        pe.fiber_in,
        pe.fiber_out,
        cs.distance_km,
        fs.loss_db,
        cs.original_cable_id,
        cs.start_node_id,     
        cs.end_node_id        
    FROM path_elements pe
    LEFT JOIN public.cable_segments cs 
        ON pe.element_type = 'SEGMENT' AND pe.element_id = cs.id
    LEFT JOIN public.ofc_cables oc 
        ON cs.original_cable_id = oc.id
    LEFT JOIN public.nodes sn ON cs.start_node_id = sn.id
    LEFT JOIN public.nodes en ON cs.end_node_id = en.id
    LEFT JOIN public.fiber_splices fs 
        ON pe.element_type = 'SPLICE' AND pe.element_id = fs.id
    LEFT JOIN public.junction_closures jc 
        ON fs.jc_id = jc.id
    LEFT JOIN public.nodes n 
        ON jc.node_id = n.id
    ORDER BY pe.order_key;
    
    -- Cleanup
    DROP TABLE IF EXISTS temp_path_trace;
END;
$$;

GRANT EXECUTE ON FUNCTION public.trace_fiber_path(UUID, INT) TO authenticated;

-- Description: RPC function to handle creating, deleting, and updating splices.
CREATE OR REPLACE FUNCTION public.manage_splice(
    p_action TEXT, p_jc_id UUID, p_splice_id UUID DEFAULT NULL, p_incoming_segment_id UUID DEFAULT NULL,
    p_incoming_fiber_no INT DEFAULT NULL, p_outgoing_segment_id UUID DEFAULT NULL, p_outgoing_fiber_no INT DEFAULT NULL,
    p_splice_type_id UUID DEFAULT NULL, p_loss_db NUMERIC DEFAULT NULL
)
RETURNS RECORD
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
DECLARE
    result RECORD;
    v_splice_type_id UUID;
BEGIN
    IF p_splice_type_id IS NULL THEN
            SELECT public.get_lookup_type_id('SPLICE_TYPES', 'straight') INTO v_splice_type_id;
        ELSE
            v_splice_type_id := p_splice_type_id;
        END IF;
    IF p_action = 'create' THEN
        INSERT INTO public.fiber_splices (jc_id, incoming_segment_id, incoming_fiber_no, outgoing_segment_id, outgoing_fiber_no, splice_type_id, loss_db)
        VALUES (p_jc_id, p_incoming_segment_id, p_incoming_fiber_no, p_outgoing_segment_id, p_outgoing_fiber_no, v_splice_type_id, p_loss_db)
        RETURNING id, 'created' INTO result;
    ELSIF p_action = 'delete' THEN
        DELETE FROM public.fiber_splices WHERE id = p_splice_id AND jc_id = p_jc_id RETURNING id, 'deleted' INTO result;
        IF NOT FOUND THEN RAISE EXCEPTION 'Splice not found.'; END IF;
    ELSIF p_action = 'update_loss' THEN
        UPDATE public.fiber_splices SET loss_db = p_loss_db, updated_at = now()
        WHERE id = p_splice_id AND jc_id = p_jc_id RETURNING id, 'updated' INTO result;
        IF NOT FOUND THEN RAISE EXCEPTION 'Splice not found.'; END IF;
    ELSE
        RAISE EXCEPTION 'Invalid action specified.';
    END IF;
    RETURN result;
END;
$$;
GRANT EXECUTE ON FUNCTION public.manage_splice(TEXT, UUID, UUID, UUID, INT, UUID, INT, UUID, NUMERIC) TO authenticated;



-- Fetches structured JSON for the splice matrix UI, showing all connections at a physical node.
CREATE OR REPLACE FUNCTION public.get_jc_splicing_details(p_jc_id UUID)
RETURNS JSONB
LANGUAGE sql
STABLE
SECURITY DEFINER
SET search_path = public
AS $$
-- Fetches info about the requested JC
WITH jc_info AS (
  SELECT jc.id, n.name, jc.node_id 
  FROM public.junction_closures jc 
  JOIN public.nodes n ON jc.node_id = n.id 
  WHERE jc.id = p_jc_id
),
-- Finds all JCs at the same node 
all_jcs_at_node AS (
  SELECT id 
  FROM public.junction_closures 
  WHERE node_id = (SELECT node_id FROM jc_info)
), 
-- Finds all segments at the same node 
segments_at_jc AS (
  SELECT 
    cs.id as segment_id, 
    oc.route_name || ' (Seg ' || cs.segment_order || ')' as segment_name, 
    cs.fiber_count
  FROM public.cable_segments cs 
  JOIN public.ofc_cables oc ON cs.original_cable_id = oc.id
  WHERE cs.start_node_id = (SELECT node_id FROM jc_info) 
     OR cs.end_node_id = (SELECT node_id FROM jc_info)
), 
fiber_universe AS (
  SELECT s.segment_id, series.i as fiber_no 
  FROM segments_at_jc s, generate_series(1, s.fiber_count) series(i)
), 
splice_info AS (
  SELECT
    fs.id as splice_id, 
    fs.jc_id, 
    fs.incoming_segment_id, 
    fs.incoming_fiber_no, 
    fs.outgoing_segment_id, 
    fs.outgoing_fiber_no, 
    fs.loss_db,
    (SELECT oc.route_name || ' (Seg ' || cs_out.segment_order || ')' 
     FROM cable_segments cs_out 
     JOIN public.ofc_cables oc ON cs_out.original_cable_id = oc.id 
     WHERE cs_out.id = fs.outgoing_segment_id) as outgoing_segment_name,
    (SELECT oc.route_name || ' (Seg ' || cs_in.segment_order || ')' 
     FROM cable_segments cs_in 
     JOIN public.ofc_cables oc ON cs_in.original_cable_id = oc.id 
     WHERE cs_in.id = fs.incoming_segment_id) as incoming_segment_name
  FROM public.fiber_splices fs 
  WHERE fs.jc_id IN (SELECT id FROM all_jcs_at_node)
)
SELECT jsonb_build_object(
  'junction_closure', (SELECT to_jsonb(j) FROM jc_info j),
  'segments_at_jc', (
    SELECT jsonb_agg(jsonb_build_object(
      'segment_id', seg.segment_id, 
      'segment_name', seg.segment_name, 
      'fiber_count', seg.fiber_count,
      'fibers', (
        SELECT jsonb_agg(jsonb_build_object(
          'fiber_no', fu.fiber_no,
          'status', CASE 
            WHEN s_in.splice_id IS NOT NULL THEN 'used_as_incoming' 
            WHEN s_out.splice_id IS NOT NULL THEN 'used_as_outgoing' 
            ELSE 'available' 
          END,
          'splice_id', COALESCE(s_in.splice_id, s_out.splice_id),
          'connected_to_segment', COALESCE(s_in.outgoing_segment_name, s_out.incoming_segment_name),
          'connected_to_fiber', COALESCE(s_in.outgoing_fiber_no, s_out.incoming_fiber_no),
          'loss_db', COALESCE(s_in.loss_db, s_out.loss_db)
        ) ORDER BY fu.fiber_no)
        FROM fiber_universe fu
        LEFT JOIN splice_info s_in 
          ON fu.segment_id = s_in.incoming_segment_id 
          AND fu.fiber_no = s_in.incoming_fiber_no
        LEFT JOIN splice_info s_out 
          ON fu.segment_id = s_out.outgoing_segment_id 
          AND fu.fiber_no = s_out.outgoing_fiber_no
        WHERE fu.segment_id = seg.segment_id
      )
    ))
    FROM segments_at_jc seg
  )
)
FROM jc_info;
$$;
GRANT EXECUTE ON FUNCTION public.get_jc_splicing_details(UUID) TO authenticated;

-- Description: Provisions a working and protection fiber pair on a logical path.
CREATE OR REPLACE FUNCTION public.provision_logical_path(
    p_path_name TEXT,
    p_physical_path_id UUID,
    p_working_fiber_no INT,
    p_protection_fiber_no INT,
    p_system_id UUID
)
RETURNS TABLE(working_path_id UUID, protection_path_id UUID)
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
DECLARE
    v_working_path_id UUID;
    v_protection_path_id UUID;
    v_active_status_id UUID;
BEGIN
    -- Get the ID for the 'active' operational status from lookup_types
    SELECT id INTO v_active_status_id FROM public.lookup_types WHERE category = 'OFC_PATH_STATUSES' AND name = 'active' LIMIT 1;
    IF v_active_status_id IS NULL THEN
        RAISE EXCEPTION 'Operational status "active" not found in lookup_types. Please add it to continue.';
    END IF;

    -- Step 1: Create the "working" logical path record
    INSERT INTO public.logical_fiber_paths (path_name, source_system_id, path_role, operational_status_id)
    VALUES (p_path_name || ' (Working)', p_system_id, 'working', v_active_status_id) RETURNING id INTO v_working_path_id;

    -- Step 2: Create the "protection" logical path record, linking it to the working path
    INSERT INTO public.logical_fiber_paths (path_name, source_system_id, path_role, working_path_id, operational_status_id)
    VALUES (p_path_name || ' (Protection)', p_system_id, 'protection', v_working_path_id, v_active_status_id) RETURNING id INTO v_protection_path_id;

    -- Step 3: Atomically update all ofc_connections for the working fiber across all segments in the path
    UPDATE public.ofc_connections
    SET
        logical_path_id = v_working_path_id,
        fiber_role = 'working'
    WHERE
        fiber_no_sn = p_working_fiber_no AND
        ofc_id IN (
            SELECT lps.ofc_cable_id FROM public.logical_path_segments lps WHERE lps.logical_path_id = p_physical_path_id
        );

    -- Step 4: Atomically update all ofc_connections for the protection fiber across all segments in the path
    UPDATE public.ofc_connections
    SET
        logical_path_id = v_protection_path_id,
        fiber_role = 'protection'
    WHERE
        fiber_no_sn = p_protection_fiber_no AND
        ofc_id IN (
            SELECT lps.ofc_cable_id FROM public.logical_path_segments lps WHERE lps.logical_path_id = p_physical_path_id
        );

    -- Return the IDs of the newly created paths
    RETURN QUERY SELECT v_working_path_id, v_protection_path_id;
END;
$$;

GRANT EXECUTE ON FUNCTION public.provision_logical_path(TEXT, UUID, INT, INT, UUID) TO authenticated;

-- Description: Automatically create 1-to-1 "straight" splices for available fibers between two segments.
CREATE OR REPLACE FUNCTION public.auto_splice_straight_segments(
    p_jc_id UUID, 
    p_segment1_id UUID, 
    p_segment2_id UUID,
    p_loss_db NUMERIC DEFAULT 0
)
RETURNS JSONB
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
DECLARE
    segment1_fibers INT; 
    segment2_fibers INT; 
    i INT; 
    splice_count INT := 0;
    available_fibers_s1 INT[]; 
    available_fibers_s2 INT[];
    v_straight_splice_id UUID;
BEGIN
    -- Look up the UUID for the 'straight' splice type once.
    SELECT public.get_lookup_type_id('SPLICE_TYPES', 'straight') INTO v_straight_splice_id;
    IF v_straight_splice_id IS NULL THEN
        RAISE EXCEPTION 'Lookup type "straight" for category "SPLICE_TYPES" not found.';
    END IF;
    -- Get fiber counts for both segments
    SELECT fiber_count INTO segment1_fibers FROM public.cable_segments WHERE id = p_segment1_id;
    SELECT fiber_count INTO segment2_fibers FROM public.cable_segments WHERE id = p_segment2_id;
    
    IF segment1_fibers IS NULL OR segment2_fibers IS NULL THEN 
        RAISE EXCEPTION 'One or both segments not found.'; 
    END IF;

    -- Find available fibers in segment 1
    SELECT array_agg(s.i) INTO available_fibers_s1 
    FROM generate_series(1, segment1_fibers) s(i)
    WHERE NOT EXISTS (
        SELECT 1 FROM public.fiber_splices fs 
        WHERE fs.jc_id = p_jc_id 
        AND (
            (fs.incoming_segment_id = p_segment1_id AND fs.incoming_fiber_no = s.i) 
            OR (fs.outgoing_segment_id = p_segment1_id AND fs.outgoing_fiber_no = s.i)
        )
    );
    
    -- Find available fibers in segment 2
    SELECT array_agg(s.i) INTO available_fibers_s2 
    FROM generate_series(1, segment2_fibers) s(i)
    WHERE NOT EXISTS (
        SELECT 1 FROM public.fiber_splices fs 
        WHERE fs.jc_id = p_jc_id 
        AND (
            (fs.incoming_segment_id = p_segment2_id AND fs.incoming_fiber_no = s.i) 
            OR (fs.outgoing_segment_id = p_segment2_id AND fs.outgoing_fiber_no = s.i)
        )
    );

    -- Create splices for each available fiber pair
    FOR i IN 1..LEAST(cardinality(available_fibers_s1), cardinality(available_fibers_s2)) LOOP
        INSERT INTO public.fiber_splices (
            jc_id, 
            incoming_segment_id, 
            incoming_fiber_no, 
            outgoing_segment_id, 
            outgoing_fiber_no, 
            splice_type_id,
            loss_db
        )
        VALUES (
            p_jc_id, 
            p_segment1_id, 
            available_fibers_s1[i], 
            p_segment2_id, 
            available_fibers_s2[i], 
            v_straight_splice_id,
            p_loss_db
        );
        splice_count := splice_count + 1;
    END LOOP;
    
    RETURN jsonb_build_object(
        'status', 'success', 
        'splices_created', splice_count,
        'loss_db_applied', p_loss_db
    );
END;
$$;

-- Grant execute permission to authenticated users
GRANT EXECUTE ON FUNCTION public.auto_splice_straight_segments(UUID, UUID, UUID, NUMERIC) TO authenticated;

-- Optional: Keep backward compatibility with old function signature
COMMENT ON FUNCTION public.auto_splice_straight_segments(UUID, UUID, UUID, NUMERIC) IS 
'Automatically creates pass-through splices between available fibers on two segments at a junction closure. Applies specified loss_db to all created splices.';



-- Description: Get a list of all splices with their full JC and segment details.
CREATE OR REPLACE FUNCTION public.get_all_splices()
RETURNS TABLE (
    splice_id UUID, jc_id UUID, jc_name TEXT, jc_position_km NUMERIC,
    incoming_segment_id UUID, incoming_fiber_no INT, outgoing_segment_id UUID,
    outgoing_fiber_no INT, loss_db NUMERIC
)
LANGUAGE sql
STABLE
SECURITY DEFINER
SET search_path = public
AS $$
    SELECT
        s.id, s.jc_id, n.name, jc.position_km,
        s.incoming_segment_id, s.incoming_fiber_no,
        s.outgoing_segment_id, s.outgoing_fiber_no,
        s.loss_db
    FROM public.fiber_splices s
    JOIN public.junction_closures jc ON s.jc_id = jc.id
    JOIN public.nodes n ON jc.node_id = n.id;
$$;
GRANT EXECUTE ON FUNCTION public.get_all_splices() TO authenticated;


```

<!-- path: data/migrations/04_advanced_ofc/04_functions copy.sql -->
```sql
-- path: data/migrations/04_advanced_ofc/04_functions.sql
-- Description: All functions for cable segmentation, splicing, and fiber path management. [CONSOLIDATED & CORRECTED]

-- =================================================================
-- Section 1: Junction Closure and Segmentation Management
-- =================================================================

-- This function is called by the frontend to add a new JC.
CREATE OR REPLACE FUNCTION public.add_junction_closure(
  p_ofc_cable_id UUID,
  p_position_km NUMERIC(10,3),
  p_node_id UUID
)
RETURNS TABLE (
  id UUID,
  node_id UUID,
  ofc_cable_id UUID,
  position_km NUMERIC(10,3),
  created_at TIMESTAMPTZ
)
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
DECLARE
  v_jc_id UUID;
BEGIN
  IF NOT EXISTS (SELECT 1 FROM public.nodes WHERE nodes.id = p_node_id) THEN
    RAISE EXCEPTION 'Node with ID % does not exist', p_node_id;
  END IF;
  IF NOT EXISTS (SELECT 1 FROM public.ofc_cables WHERE ofc_cables.id = p_ofc_cable_id) THEN
    RAISE EXCEPTION 'Cable with ID % does not exist', p_ofc_cable_id;
  END IF;

  INSERT INTO public.junction_closures (node_id, ofc_cable_id, position_km)
  VALUES (p_node_id, p_ofc_cable_id, p_position_km)
  RETURNING junction_closures.id INTO v_jc_id;

  RETURN QUERY
  SELECT jc.id, jc.node_id, jc.ofc_cable_id, jc.position_km, jc.created_at
  FROM public.junction_closures jc
  WHERE jc.id = v_jc_id;
END;
$$;
GRANT EXECUTE ON FUNCTION public.add_junction_closure(UUID, NUMERIC, UUID) TO authenticated;

-- This function is called by a trigger to non-destructively recalculate segments.
CREATE OR REPLACE FUNCTION public.recalculate_segments_for_cable(p_cable_id UUID)
RETURNS VOID
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
DECLARE
  v_cable RECORD;
BEGIN
  SELECT * INTO v_cable FROM public.ofc_cables WHERE id = p_cable_id;
  IF NOT FOUND THEN
    RAISE WARNING 'Cable not found for segmentation: %', p_cable_id;
    RETURN;
  END IF;

  DELETE FROM public.cable_segments WHERE original_cable_id = p_cable_id;

  CREATE TEMP TABLE route_points AS
  SELECT v_cable.sn_id AS point_id, 'node' AS point_type, 0.0 AS position_km
  UNION ALL
  SELECT jc.node_id, 'jc', jc.position_km
  FROM public.junction_closures jc
  WHERE jc.ofc_cable_id = p_cable_id
  UNION ALL
  SELECT v_cable.en_id, 'node', v_cable.current_rkm;

  INSERT INTO public.cable_segments (
    original_cable_id, segment_order,
    start_node_id, start_node_type,
    end_node_id, end_node_type,
    distance_km, fiber_count
  )
  SELECT
    p_cable_id,
    ROW_NUMBER() OVER (ORDER BY p_start.position_km),
    p_start.point_id, p_start.point_type,
    p_end.point_id, p_end.point_type,
    p_end.position_km - p_start.position_km,
    v_cable.capacity
  FROM route_points p_start
  JOIN LATERAL (
    SELECT * FROM route_points p2
    WHERE p2.position_km > p_start.position_km
    ORDER BY p2.position_km ASC
    LIMIT 1
  ) p_end ON true;

  DROP TABLE route_points;
END;
$$;

-- This is the trigger function that orchestrates segmentation.
CREATE OR REPLACE FUNCTION public.manage_cable_segments()
RETURNS TRIGGER
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
BEGIN
  IF (TG_OP = 'INSERT') THEN
    PERFORM public.recalculate_segments_for_cable(NEW.ofc_cable_id);
    RETURN NEW;
  ELSIF (TG_OP = 'DELETE') THEN
    PERFORM public.recalculate_segments_for_cable(OLD.ofc_cable_id);
    RETURN OLD;
  END IF;
  RETURN NULL;
END;
$$;

-- Description: Get a list of all cable segments present at a specific Junction Closure.
CREATE OR REPLACE FUNCTION public.get_segments_at_jc(p_jc_id UUID)
RETURNS TABLE (id UUID, original_cable_name TEXT, segment_order INT, fiber_count INT)
LANGUAGE sql
STABLE
SECURITY DEFINER
SET search_path = public
AS $$
    SELECT
        cs.id,
        oc.route_name,
        cs.segment_order,
        cs.fiber_count
    FROM public.v_cable_segments_at_jc v_cs
    JOIN public.cable_segments cs ON v_cs.id = cs.id
    JOIN public.ofc_cables oc ON cs.original_cable_id = oc.id
    WHERE v_cs.jc_node_id = (SELECT node_id FROM public.junction_closures WHERE id = p_jc_id);
$$;
GRANT EXECUTE ON FUNCTION public.get_segments_at_jc(UUID) TO authenticated;

-- =================================================================
-- Section 2: Logical Fiber Path Tracing and Splicing Management
-- =================================================================

-- Fixed trace_logical_fiber_path function (used by triggers)
-- Uses temporary tables for better compatibility
CREATE OR REPLACE FUNCTION public.trace_logical_fiber_path(
    p_start_segment_id UUID,
    p_start_fiber_no INT
)
RETURNS JSONB -- Returns a JSON object: { "boundaries": { ... }, "physical_fibers": [ ... ] }
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
DECLARE
    v_path_data JSONB;
BEGIN
    WITH RECURSIVE full_path_trace AS (
        -- ANCHOR: The starting point itself.
        SELECT
            0 AS step,
            p_start_segment_id AS segment_id,
            p_start_fiber_no AS fiber_no,
            ARRAY[p_start_segment_id] AS visited

        UNION ALL

        -- RECURSIVE STEP: Find the next segment in either direction.
        SELECT
            -- If we found a forward connection, increment step. Otherwise, decrement.
            CASE WHEN fwd.id IS NOT NULL THEN prev.step + 1 ELSE prev.step - 1 END,
            -- The next segment is either the forward outgoing or the backward incoming.
            COALESCE(fwd.outgoing_segment_id, bwd.incoming_segment_id),
            -- The next fiber number.
            COALESCE(fwd.outgoing_fiber_no, bwd.incoming_fiber_no),
            -- Add the new segment to the visited array to prevent cycles.
            prev.visited || COALESCE(fwd.outgoing_segment_id, bwd.incoming_segment_id)
        FROM full_path_trace prev
        -- Attempt to join to the next FORWARD splice
        LEFT JOIN public.fiber_splices fwd ON prev.segment_id = fwd.incoming_segment_id AND prev.fiber_no = fwd.incoming_fiber_no
        -- Attempt to join to the next BACKWARD splice
        LEFT JOIN public.fiber_splices bwd ON prev.segment_id = bwd.outgoing_segment_id AND prev.fiber_no = bwd.outgoing_fiber_no
        WHERE
            -- The recursion must find a path in one direction.
            (fwd.id IS NOT NULL OR bwd.id IS NOT NULL)
            -- And the destination segment must not have been visited before.
            AND NOT (COALESCE(fwd.outgoing_segment_id, bwd.incoming_segment_id) = ANY(prev.visited))
            -- Safety break to prevent infinite loops in case of data error
            AND abs(prev.step) < 100
    ),
    path_segments_with_details AS (
        SELECT
            fp.step,
            fp.fiber_no,
            cs.original_cable_id,
            cs.start_node_id,
            cs.end_node_id
        FROM full_path_trace fp
        JOIN public.cable_segments cs ON fp.segment_id = cs.id
    ),
    path_boundaries AS (
        SELECT
            first_value(psd.start_node_id) OVER (ORDER BY psd.step ASC) AS logical_start_node_id,
            first_value(psd.fiber_no) OVER (ORDER BY psd.step ASC) AS logical_start_fiber_no,
            first_value(psd.end_node_id) OVER (ORDER BY psd.step DESC) AS logical_end_node_id,
            first_value(psd.fiber_no) OVER (ORDER BY psd.step DESC) AS logical_end_fiber_no
        FROM path_segments_with_details psd
        LIMIT 1
    )
    SELECT jsonb_build_object(
        'boundaries', (SELECT to_jsonb(pb) FROM path_boundaries pb),
        'physical_fibers', (
            SELECT jsonb_agg(
                jsonb_build_object('original_cable_id', psd.original_cable_id, 'fiber_no', psd.fiber_no)
            )
            FROM path_segments_with_details psd
        )
    ) INTO v_path_data;

    -- Handle the case where the trace finds nothing (i.e., a single, unspliced segment).
    IF v_path_data IS NULL OR (v_path_data->'boundaries') IS NULL THEN
        WITH single_segment AS (
            SELECT
                cs.start_node_id AS logical_start_node_id,
                p_start_fiber_no AS logical_start_fiber_no,
                cs.end_node_id AS logical_end_node_id,
                p_start_fiber_no AS logical_end_fiber_no,
                cs.original_cable_id
            FROM public.cable_segments cs WHERE cs.id = p_start_segment_id
        )
        SELECT jsonb_build_object(
            'boundaries', to_jsonb(ss) - 'original_cable_id', -- remove helper column
            'physical_fibers', jsonb_build_array(jsonb_build_object('original_cable_id', ss.original_cable_id, 'fiber_no', p_start_fiber_no))
        )
        INTO v_path_data
        FROM single_segment ss;
    END IF;

    RETURN v_path_data;
END;
$$;
GRANT EXECUTE ON FUNCTION public.trace_logical_fiber_path(UUID, INT) TO authenticated;

-- whenever a splice is created, updated, or deleted. It uses the trace function
-- to find the new logical endpoints and applies them to all affected fibers.
CREATE OR REPLACE FUNCTION public.update_ofc_connections_from_splice()
RETURNS TRIGGER
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
DECLARE
    trace_result JSONB;
    boundaries JSONB;
BEGIN
    -- Case 1: A splice is CREATED or UPDATED.
    IF (TG_OP = 'INSERT' OR TG_OP = 'UPDATE') THEN
        trace_result := public.trace_logical_fiber_path(NEW.incoming_segment_id, NEW.incoming_fiber_no);
        boundaries := trace_result -> 'boundaries';
        
        IF boundaries IS NOT NULL AND trace_result -> 'physical_fibers' IS NOT NULL THEN
            UPDATE public.ofc_connections
            SET
                updated_sn_id = (boundaries->>'logical_start_node_id')::UUID,
                updated_fiber_no_sn = (boundaries->>'logical_start_fiber_no')::INT,
                updated_en_id = (boundaries->>'logical_end_node_id')::UUID,
                updated_fiber_no_en = (boundaries->>'logical_end_fiber_no')::INT,
                updated_at = NOW()
            FROM jsonb_to_recordset(trace_result -> 'physical_fibers') AS fibers(original_cable_id UUID, fiber_no INT)
            WHERE ofc_connections.ofc_id = fibers.original_cable_id
              AND ofc_connections.fiber_no_sn = fibers.fiber_no;
        END IF;

    -- Case 2: A splice is DELETED.
    ELSIF (TG_OP = 'DELETE') THEN
        -- Part A: Update the path that was connected to the 'incoming' side.
        trace_result := public.trace_logical_fiber_path(OLD.incoming_segment_id, OLD.incoming_fiber_no);
        boundaries := trace_result -> 'boundaries';
        IF boundaries IS NOT NULL AND trace_result -> 'physical_fibers' IS NOT NULL THEN
             UPDATE public.ofc_connections
            SET updated_sn_id = (boundaries->>'logical_start_node_id')::UUID,
                updated_fiber_no_sn = (boundaries->>'logical_start_fiber_no')::INT,
                updated_en_id = (boundaries->>'logical_end_node_id')::UUID,
                updated_fiber_no_en = (boundaries->>'logical_end_fiber_no')::INT,
                updated_at = NOW()
            FROM jsonb_to_recordset(trace_result -> 'physical_fibers') AS fibers(original_cable_id UUID, fiber_no INT)
            WHERE ofc_connections.ofc_id = fibers.original_cable_id
              AND ofc_connections.fiber_no_sn = fibers.fiber_no;
        END IF;

        -- Part B: If there was an 'outgoing' side, update its new path as well.
        IF OLD.outgoing_segment_id IS NOT NULL THEN
            trace_result := public.trace_logical_fiber_path(OLD.outgoing_segment_id, OLD.outgoing_fiber_no);
            boundaries := trace_result -> 'boundaries';
            IF boundaries IS NOT NULL AND trace_result -> 'physical_fibers' IS NOT NULL THEN
                UPDATE public.ofc_connections
                SET updated_sn_id = (boundaries->>'logical_start_node_id')::UUID,
                    updated_fiber_no_sn = (boundaries->>'logical_start_fiber_no')::INT,
                    updated_en_id = (boundaries->>'logical_end_node_id')::UUID,
                    updated_fiber_no_en = (boundaries->>'logical_end_fiber_no')::INT,
                    updated_at = NOW()
                FROM jsonb_to_recordset(trace_result -> 'physical_fibers') AS fibers(original_cable_id UUID, fiber_no INT)
                WHERE ofc_connections.ofc_id = fibers.original_cable_id
                  AND ofc_connections.fiber_no_sn = fibers.fiber_no;
            END IF;
        END IF;
    END IF;

    RETURN NULL; -- Result is ignored for AFTER triggers.
END;
$$;


-- Description: RPC function to handle creating, deleting, and updating splices.
CREATE OR REPLACE FUNCTION public.manage_splice(
    p_action TEXT, p_jc_id UUID, p_splice_id UUID DEFAULT NULL, p_incoming_segment_id UUID DEFAULT NULL,
    p_incoming_fiber_no INT DEFAULT NULL, p_outgoing_segment_id UUID DEFAULT NULL, p_outgoing_fiber_no INT DEFAULT NULL,
    p_splice_type_id UUID DEFAULT NULL, p_loss_db NUMERIC DEFAULT NULL
)
RETURNS RECORD
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
DECLARE
    result RECORD;
    v_splice_type_id UUID;
BEGIN
    IF p_splice_type_id IS NULL THEN
            SELECT public.get_lookup_type_id('SPLICE_TYPES', 'straight') INTO v_splice_type_id;
        ELSE
            v_splice_type_id := p_splice_type_id;
        END IF;
    IF p_action = 'create' THEN
        INSERT INTO public.fiber_splices (jc_id, incoming_segment_id, incoming_fiber_no, outgoing_segment_id, outgoing_fiber_no, splice_type_id, loss_db)
        VALUES (p_jc_id, p_incoming_segment_id, p_incoming_fiber_no, p_outgoing_segment_id, p_outgoing_fiber_no, v_splice_type_id, p_loss_db)
        RETURNING id, 'created' INTO result;
    ELSIF p_action = 'delete' THEN
        DELETE FROM public.fiber_splices WHERE id = p_splice_id AND jc_id = p_jc_id RETURNING id, 'deleted' INTO result;
        IF NOT FOUND THEN RAISE EXCEPTION 'Splice not found.'; END IF;
    ELSIF p_action = 'update_loss' THEN
        UPDATE public.fiber_splices SET loss_db = p_loss_db, updated_at = now()
        WHERE id = p_splice_id AND jc_id = p_jc_id RETURNING id, 'updated' INTO result;
        IF NOT FOUND THEN RAISE EXCEPTION 'Splice not found.'; END IF;
    ELSE
        RAISE EXCEPTION 'Invalid action specified.';
    END IF;
    RETURN result;
END;
$$;
GRANT EXECUTE ON FUNCTION public.manage_splice(TEXT, UUID, UUID, UUID, INT, UUID, INT, UUID, NUMERIC) TO authenticated;

-- Fetches structured JSON for the splice matrix UI, showing all connections at a physical node.
CREATE OR REPLACE FUNCTION public.get_jc_splicing_details(p_jc_id UUID)
RETURNS JSONB
LANGUAGE sql
STABLE
SECURITY DEFINER
SET search_path = public
AS $$
-- Fetches info about the requested JC
WITH jc_info AS (
  SELECT jc.id, n.name, jc.node_id 
  FROM public.junction_closures jc 
  JOIN public.nodes n ON jc.node_id = n.id 
  WHERE jc.id = p_jc_id
),
-- Finds all JCs at the same node 
all_jcs_at_node AS (
  SELECT id 
  FROM public.junction_closures 
  WHERE node_id = (SELECT node_id FROM jc_info)
), 
-- Finds all segments at the same node 
segments_at_jc AS (
  SELECT 
    cs.id as segment_id, 
    oc.route_name || ' (Seg ' || cs.segment_order || ')' as segment_name, 
    cs.fiber_count
  FROM public.cable_segments cs 
  JOIN public.ofc_cables oc ON cs.original_cable_id = oc.id
  WHERE cs.start_node_id = (SELECT node_id FROM jc_info) 
     OR cs.end_node_id = (SELECT node_id FROM jc_info)
), 
fiber_universe AS (
  SELECT s.segment_id, series.i as fiber_no 
  FROM segments_at_jc s, generate_series(1, s.fiber_count) series(i)
), 
splice_info AS (
  SELECT
    fs.id as splice_id, 
    fs.jc_id, 
    fs.incoming_segment_id, 
    fs.incoming_fiber_no, 
    fs.outgoing_segment_id, 
    fs.outgoing_fiber_no, 
    fs.loss_db,
    (SELECT oc.route_name || ' (Seg ' || cs_out.segment_order || ')' 
     FROM cable_segments cs_out 
     JOIN public.ofc_cables oc ON cs_out.original_cable_id = oc.id 
     WHERE cs_out.id = fs.outgoing_segment_id) as outgoing_segment_name,
    (SELECT oc.route_name || ' (Seg ' || cs_in.segment_order || ')' 
     FROM cable_segments cs_in 
     JOIN public.ofc_cables oc ON cs_in.original_cable_id = oc.id 
     WHERE cs_in.id = fs.incoming_segment_id) as incoming_segment_name
  FROM public.fiber_splices fs 
  WHERE fs.jc_id IN (SELECT id FROM all_jcs_at_node)
)
SELECT jsonb_build_object(
  'junction_closure', (SELECT to_jsonb(j) FROM jc_info j),
  'segments_at_jc', (
    SELECT jsonb_agg(jsonb_build_object(
      'segment_id', seg.segment_id, 
      'segment_name', seg.segment_name, 
      'fiber_count', seg.fiber_count,
      'fibers', (
        SELECT jsonb_agg(jsonb_build_object(
          'fiber_no', fu.fiber_no,
          'status', CASE 
            WHEN s_in.splice_id IS NOT NULL THEN 'used_as_incoming' 
            WHEN s_out.splice_id IS NOT NULL THEN 'used_as_outgoing' 
            ELSE 'available' 
          END,
          'splice_id', COALESCE(s_in.splice_id, s_out.splice_id),
          'connected_to_segment', COALESCE(s_in.outgoing_segment_name, s_out.incoming_segment_name),
          'connected_to_fiber', COALESCE(s_in.outgoing_fiber_no, s_out.incoming_fiber_no),
          'loss_db', COALESCE(s_in.loss_db, s_out.loss_db)
        ) ORDER BY fu.fiber_no)
        FROM fiber_universe fu
        LEFT JOIN splice_info s_in 
          ON fu.segment_id = s_in.incoming_segment_id 
          AND fu.fiber_no = s_in.incoming_fiber_no
        LEFT JOIN splice_info s_out 
          ON fu.segment_id = s_out.outgoing_segment_id 
          AND fu.fiber_no = s_out.outgoing_fiber_no
        WHERE fu.segment_id = seg.segment_id
      )
    ))
    FROM segments_at_jc seg
  )
)
FROM jc_info;
$$;
GRANT EXECUTE ON FUNCTION public.get_jc_splicing_details(UUID) TO authenticated;

-- ** Final, correct, robust bi-directional trace function.**
CREATE OR REPLACE FUNCTION public.trace_fiber_path(p_start_segment_id UUID, p_start_fiber_no INT)
RETURNS TABLE (
    step_order BIGINT,
    element_type TEXT,
    element_id UUID,
    element_name TEXT,
    details TEXT,
    fiber_in INT,
    fiber_out INT,
    distance_km NUMERIC,
    loss_db NUMERIC
)
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
BEGIN
    -- Create temp table for the path
    CREATE TEMP TABLE IF NOT EXISTS temp_path_trace (
        step BIGINT,
        current_segment_id UUID,
        current_fiber_no INT,
        previous_splice_id UUID,
        visited_segments UUID[]
    ) ON COMMIT DROP;
    
    -- Trace forward
    INSERT INTO temp_path_trace
    WITH RECURSIVE forward_trace AS (
        SELECT
            0::bigint as step,
            p_start_segment_id as current_segment_id,
            p_start_fiber_no as current_fiber_no,
            NULL::uuid as previous_splice_id,
            ARRAY[p_start_segment_id] as visited_segments
        
        UNION ALL
        
        SELECT
            p.step + 1,
            s.outgoing_segment_id,
            s.outgoing_fiber_no,
            s.id,
            p.visited_segments || s.outgoing_segment_id
        FROM forward_trace p
        JOIN public.fiber_splices s 
            ON p.current_segment_id = s.incoming_segment_id 
            AND p.current_fiber_no = s.incoming_fiber_no
        WHERE s.outgoing_segment_id IS NOT NULL
          AND NOT (s.outgoing_segment_id = ANY(p.visited_segments))
          AND p.step < 100
    )
    SELECT * FROM forward_trace;
    
    -- Trace backward
    INSERT INTO temp_path_trace
    WITH RECURSIVE backward_trace AS (
        SELECT
            0::bigint as step,
            p_start_segment_id as current_segment_id,
            p_start_fiber_no as current_fiber_no,
            NULL::uuid as previous_splice_id,
            ARRAY[p_start_segment_id] as visited_segments
        
        UNION ALL
        
        SELECT
            p.step - 1,
            s.incoming_segment_id,
            s.incoming_fiber_no,
            s.id,
            p.visited_segments || s.incoming_segment_id
        FROM backward_trace p
        JOIN public.fiber_splices s 
            ON p.current_segment_id = s.outgoing_segment_id 
            AND p.current_fiber_no = s.outgoing_fiber_no
        WHERE s.incoming_segment_id IS NOT NULL
          AND NOT (s.incoming_segment_id = ANY(p.visited_segments))
          AND p.step > -100
    )
    SELECT * FROM backward_trace WHERE step < 0;
    
    -- Return results
    RETURN QUERY
    WITH path_elements AS (
        -- Segments
        SELECT
            fp.step * 2 AS order_key,
            'SEGMENT'::text as element_type,
            fp.current_segment_id as element_id,
            fp.current_fiber_no as fiber_in,
            fp.current_fiber_no as fiber_out
        FROM temp_path_trace fp
        
        UNION ALL
        
        -- Splices
        SELECT
            fp.step * 2 - 1 AS order_key,
            'SPLICE'::text,
            fp.previous_splice_id,
            LAG(fp.current_fiber_no) OVER (ORDER BY fp.step) as fiber_in,
            fp.current_fiber_no as fiber_out
        FROM temp_path_trace fp
        WHERE fp.previous_splice_id IS NOT NULL
    )
    SELECT
        ROW_NUMBER() OVER (ORDER BY pe.order_key) AS step_order,
        pe.element_type,
        pe.element_id,
        CASE
            WHEN pe.element_type = 'SEGMENT' THEN oc.route_name
            WHEN pe.element_type = 'SPLICE' THEN n.name
        END AS element_name,
        CASE
            WHEN pe.element_type = 'SEGMENT' THEN 
                'Segment ' || cs.segment_order || ' (' || sn.name || ' → ' || en.name || ')'
            WHEN pe.element_type = 'SPLICE' THEN 
                'Junction Closure Splice'
        END AS details,
        pe.fiber_in,
        pe.fiber_out,
        cs.distance_km,
        fs.loss_db
    FROM path_elements pe
    LEFT JOIN public.cable_segments cs 
        ON pe.element_type = 'SEGMENT' AND pe.element_id = cs.id
    LEFT JOIN public.ofc_cables oc 
        ON cs.original_cable_id = oc.id
    LEFT JOIN public.nodes sn 
        ON cs.start_node_id = sn.id
    LEFT JOIN public.nodes en 
        ON cs.end_node_id = en.id
    LEFT JOIN public.fiber_splices fs 
        ON pe.element_type = 'SPLICE' AND pe.element_id = fs.id
    LEFT JOIN public.junction_closures jc 
        ON fs.jc_id = jc.id
    LEFT JOIN public.nodes n 
        ON jc.node_id = n.id
    ORDER BY pe.order_key;
    
    -- Cleanup
    DROP TABLE IF EXISTS temp_path_trace;
END;
$$;

GRANT EXECUTE ON FUNCTION public.trace_fiber_path(UUID, INT) TO authenticated;

-- Description: Provisions a working and protection fiber pair on a logical path.
CREATE OR REPLACE FUNCTION public.provision_logical_path(
    p_path_name TEXT,
    p_physical_path_id UUID,
    p_working_fiber_no INT,
    p_protection_fiber_no INT,
    p_system_id UUID
)
RETURNS TABLE(working_path_id UUID, protection_path_id UUID)
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
DECLARE
    v_working_path_id UUID;
    v_protection_path_id UUID;
    v_active_status_id UUID;
BEGIN
    -- Get the ID for the 'active' operational status from lookup_types
    SELECT id INTO v_active_status_id FROM public.lookup_types WHERE category = 'OFC_PATH_STATUSES' AND name = 'active' LIMIT 1;
    IF v_active_status_id IS NULL THEN
        RAISE EXCEPTION 'Operational status "active" not found in lookup_types. Please add it to continue.';
    END IF;

    -- Step 1: Create the "working" logical path record
    INSERT INTO public.logical_fiber_paths (path_name, source_system_id, path_role, operational_status_id)
    VALUES (p_path_name || ' (Working)', p_system_id, 'working', v_active_status_id) RETURNING id INTO v_working_path_id;

    -- Step 2: Create the "protection" logical path record, linking it to the working path
    INSERT INTO public.logical_fiber_paths (path_name, source_system_id, path_role, working_path_id, operational_status_id)
    VALUES (p_path_name || ' (Protection)', p_system_id, 'protection', v_working_path_id, v_active_status_id) RETURNING id INTO v_protection_path_id;

    -- Step 3: Atomically update all ofc_connections for the working fiber across all segments in the path
    UPDATE public.ofc_connections
    SET
        logical_path_id = v_working_path_id,
        fiber_role = 'working'
    WHERE
        fiber_no_sn = p_working_fiber_no AND
        ofc_id IN (
            SELECT lps.ofc_cable_id FROM public.logical_path_segments lps WHERE lps.logical_path_id = p_physical_path_id
        );

    -- Step 4: Atomically update all ofc_connections for the protection fiber across all segments in the path
    UPDATE public.ofc_connections
    SET
        logical_path_id = v_protection_path_id,
        fiber_role = 'protection'
    WHERE
        fiber_no_sn = p_protection_fiber_no AND
        ofc_id IN (
            SELECT lps.ofc_cable_id FROM public.logical_path_segments lps WHERE lps.logical_path_id = p_physical_path_id
        );

    -- Return the IDs of the newly created paths
    RETURN QUERY SELECT v_working_path_id, v_protection_path_id;
END;
$$;

GRANT EXECUTE ON FUNCTION public.provision_logical_path(TEXT, UUID, INT, INT, UUID) TO authenticated;

-- Description: Automatically create 1-to-1 "straight" splices for available fibers between two segments.
CREATE OR REPLACE FUNCTION public.auto_splice_straight_segments(
    p_jc_id UUID, 
    p_segment1_id UUID, 
    p_segment2_id UUID,
    p_loss_db NUMERIC DEFAULT 0
)
RETURNS JSONB
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
DECLARE
    segment1_fibers INT; 
    segment2_fibers INT; 
    i INT; 
    splice_count INT := 0;
    available_fibers_s1 INT[]; 
    available_fibers_s2 INT[];
    v_straight_splice_id UUID;
BEGIN
    -- Look up the UUID for the 'straight' splice type once.
    SELECT public.get_lookup_type_id('SPLICE_TYPES', 'straight') INTO v_straight_splice_id;
    IF v_straight_splice_id IS NULL THEN
        RAISE EXCEPTION 'Lookup type "straight" for category "SPLICE_TYPES" not found.';
    END IF;
    -- Get fiber counts for both segments
    SELECT fiber_count INTO segment1_fibers FROM public.cable_segments WHERE id = p_segment1_id;
    SELECT fiber_count INTO segment2_fibers FROM public.cable_segments WHERE id = p_segment2_id;
    
    IF segment1_fibers IS NULL OR segment2_fibers IS NULL THEN 
        RAISE EXCEPTION 'One or both segments not found.'; 
    END IF;

    -- Find available fibers in segment 1
    SELECT array_agg(s.i) INTO available_fibers_s1 
    FROM generate_series(1, segment1_fibers) s(i)
    WHERE NOT EXISTS (
        SELECT 1 FROM public.fiber_splices fs 
        WHERE fs.jc_id = p_jc_id 
        AND (
            (fs.incoming_segment_id = p_segment1_id AND fs.incoming_fiber_no = s.i) 
            OR (fs.outgoing_segment_id = p_segment1_id AND fs.outgoing_fiber_no = s.i)
        )
    );
    
    -- Find available fibers in segment 2
    SELECT array_agg(s.i) INTO available_fibers_s2 
    FROM generate_series(1, segment2_fibers) s(i)
    WHERE NOT EXISTS (
        SELECT 1 FROM public.fiber_splices fs 
        WHERE fs.jc_id = p_jc_id 
        AND (
            (fs.incoming_segment_id = p_segment2_id AND fs.incoming_fiber_no = s.i) 
            OR (fs.outgoing_segment_id = p_segment2_id AND fs.outgoing_fiber_no = s.i)
        )
    );

    -- Create splices for each available fiber pair
    FOR i IN 1..LEAST(cardinality(available_fibers_s1), cardinality(available_fibers_s2)) LOOP
        INSERT INTO public.fiber_splices (
            jc_id, 
            incoming_segment_id, 
            incoming_fiber_no, 
            outgoing_segment_id, 
            outgoing_fiber_no, 
            splice_type_id,
            loss_db
        )
        VALUES (
            p_jc_id, 
            p_segment1_id, 
            available_fibers_s1[i], 
            p_segment2_id, 
            available_fibers_s2[i], 
            v_straight_splice_id,
            p_loss_db
        );
        splice_count := splice_count + 1;
    END LOOP;
    
    RETURN jsonb_build_object(
        'status', 'success', 
        'splices_created', splice_count,
        'loss_db_applied', p_loss_db
    );
END;
$$;

-- Grant execute permission to authenticated users
GRANT EXECUTE ON FUNCTION public.auto_splice_straight_segments(UUID, UUID, UUID, NUMERIC) TO authenticated;

-- Optional: Keep backward compatibility with old function signature
COMMENT ON FUNCTION public.auto_splice_straight_segments(UUID, UUID, UUID, NUMERIC) IS 
'Automatically creates pass-through splices between available fibers on two segments at a junction closure. Applies specified loss_db to all created splices.';



-- Description: Get a list of all splices with their full JC and segment details.
CREATE OR REPLACE FUNCTION public.get_all_splices()
RETURNS TABLE (
    splice_id UUID, jc_id UUID, jc_name TEXT, jc_position_km NUMERIC,
    incoming_segment_id UUID, incoming_fiber_no INT, outgoing_segment_id UUID,
    outgoing_fiber_no INT, loss_db NUMERIC
)
LANGUAGE sql
STABLE
SECURITY DEFINER
SET search_path = public
AS $$
    SELECT
        s.id, s.jc_id, n.name, jc.position_km,
        s.incoming_segment_id, s.incoming_fiber_no,
        s.outgoing_segment_id, s.outgoing_fiber_no,
        s.loss_db
    FROM public.fiber_splices s
    JOIN public.junction_closures jc ON s.jc_id = jc.id
    JOIN public.nodes n ON jc.node_id = n.id;
$$;
GRANT EXECUTE ON FUNCTION public.get_all_splices() TO authenticated;


```

<!-- path: next.config.ts -->
```typescript
import type { NextConfig } from "next";

const nextConfig: NextConfig = {
  /* config options here */
  images: {
    qualities: [25, 50, 75, 90, 100],
    // **Add modern formats for automatic optimization**
    formats: ['image/avif', 'image/webp'],
    remotePatterns: [
      {
        protocol: 'https',
        hostname: 'lh3.googleusercontent.com',
      },
      {
        protocol: 'https',
        hostname: 'example.com',
      },
      {
        protocol: 'https',
        hostname: 'gravatar.com',
      },
      {
        protocol: 'https',
        hostname: 'res.cloudinary.com',
      },
      {
        protocol: 'https',
        hostname: 'images.unsplash.com',
      },
      {
        protocol: 'https',
        hostname: 'cdn.pixabay.com',
      },
    ],
  },
  turbopack: {
    root: __dirname, // explicitly set project root
  },
};

export default nextConfig;

```

<!-- path: schemas/custom-schemas.ts -->
```typescript
// schemas/custom-schemas.ts

import { z } from 'zod';
import {
  v_ofc_cables_completeRowSchema,
  cable_segmentsRowSchema,
  junction_closuresRowSchema,
  fiber_splicesRowSchema,
  nodesRowSchema,
} from '@/schemas/zod-schemas';

// ============= RPC & UI-SPECIFIC SCHEMAS (ROUTE MANAGER) =============

// --- For useOfcRoutesForSelection hook ---
export const ofcForSelectionSchema = v_ofc_cables_completeRowSchema.pick({
  id: true,
  route_name: true,
  capacity: true,
}).extend({
  ofc_connections: z.array(z.object({ id: z.uuid() })),
});
export type OfcForSelection = z.infer<typeof ofcForSelectionSchema>;

// --- For useAutoSplice hook result ---
export const autoSpliceResultSchema = z.object({
  splices_created: z.number().int(),
});
export type AutoSpliceResult = z.infer<typeof autoSpliceResultSchema>;

// --- For JcSplicingDetails ---
const fiberAtSegmentSchema = z.object({
  fiber_no: z.number().int(),
  status: z.enum(['available', 'used_as_incoming', 'used_as_outgoing', 'terminated']),
  connected_to_segment: z.string().nullable(),
  connected_to_fiber: z.number().int().nullable(),
  splice_id: z.uuid().nullable(),
  loss_db: z.number().nullable(),
});

const segmentAtJcSchema = z.object({
  segment_id: cable_segmentsRowSchema.shape.id,
  segment_name: z.string(),
  fiber_count: cable_segmentsRowSchema.shape.fiber_count,
  fibers: z.array(fiberAtSegmentSchema),
});

export const jcSplicingDetailsSchema = z.object({
  junction_closure: z.object({
    id: junction_closuresRowSchema.shape.id,
    name: nodesRowSchema.shape.name,
  }),
  segments_at_jc: z.array(segmentAtJcSchema),
});
export type JcSplicingDetails = z.infer<typeof jcSplicingDetailsSchema>;

// --- For RouteDetailsPayload and its constituent parts ---

const relaxed_v_ofc_cables_completeRowSchema = v_ofc_cables_completeRowSchema.extend({
  created_at: z.string().nullable(),
  updated_at: z.string().nullable()
});

const relaxed_junction_closuresRowSchema = junction_closuresRowSchema.extend({
  created_at: z.string().nullable(),
  updated_at: z.string().nullable(),
});

const relaxed_cable_segmentsRowSchema = cable_segmentsRowSchema.extend({
  created_at: z.string().nullable(),
  updated_at: z.string().nullable(),
});

export const cableSegmentSchema = relaxed_cable_segmentsRowSchema;
export type CableSegment = z.infer<typeof cableSegmentSchema>;

export const fiberSpliceSchema = fiber_splicesRowSchema;
export type FiberSplice = z.infer<typeof fiberSpliceSchema>;

const siteSchema = z.object({
  id: nodesRowSchema.shape.id.nullable(),
  name: nodesRowSchema.shape.name.nullable(),
});

export const cableRouteSchema = relaxed_v_ofc_cables_completeRowSchema.extend({
    start_site: siteSchema,
    end_site: siteSchema,
    evolution_status: z.enum(['simple', 'with_jcs', 'fully_segmented']),
});
export type CableRoute = z.infer<typeof cableRouteSchema>;

export const jointBoxSchema = relaxed_junction_closuresRowSchema.extend({
    node: z.object({ name: nodesRowSchema.shape.name.nullable() }).nullable(),
    status: z.enum(['existing', 'planned']),
    attributes: z.object({
        position_on_route: z.number(),
        name: z.string().optional(),
    }),
});
export type JointBox = z.infer<typeof jointBoxSchema>;

export const routeDetailsPayloadSchema = z.object({
    route: cableRouteSchema,
    jointBoxes: z.array(jointBoxSchema),
    segments: z.array(cableSegmentSchema),
    splices: z.array(fiberSpliceSchema),
});
export type RouteDetailsPayload = z.infer<typeof routeDetailsPayloadSchema>;

// --- Schema for trace_fiber_path RPC ---
export const fiberTraceSegmentSchema = z.object({
  step_order: z.number(),
  element_type: z.string(),
  element_id: z.uuid(),
  element_name: z.string(),
  details: z.string(),
  fiber_in: z.number().nullable(),
  fiber_out: z.number().nullable(),
  distance_km: z.number().nullable(),
  loss_db: z.number().nullable(),
  original_cable_id: z.uuid().nullable(),
  start_node_id: z.uuid().nullable(),
  end_node_id: z.uuid().nullable(),
});
export type FiberTraceSegment = z.infer<typeof fiberTraceSegmentSchema>;

export const pathToUpdateSchema = z.object({
  p_id: z.uuid(),
  p_start_node_id: z.uuid(),
  p_end_node_id: z.uuid(),
  p_start_fiber_no: z.number(),
  p_end_fiber_no: z.number(),
});
export type PathToUpdate = z.infer<typeof pathToUpdateSchema>;


// --- For the new trace_fiber_path RPC ---
export const bsnlSearchFiltersSchema = z.object({
  query: z.string(),
  status: z.array(z.string()),
  type: z.array(z.string()),
  region: z.array(z.string()),
  nodeType: z.array(z.string()),
  priority: z.array(z.string()),
});
export type BsnlSearchFilters = z.infer<typeof bsnlSearchFiltersSchema>;
```

<!-- path: schemas/zod-schemas.ts -->
```typescript
// Auto-generated Zod schemas from flattened-types.ts

import { z } from "zod";

import { UserRole } from "@/types/user-roles";

// ============= TABLE SCHEMAS =============

export const authAudit_log_entriesRowSchema = z.object({
  created_at: z.iso.datetime().nullable(),
  id: z.uuid(),
  instance_id: z.uuid().nullable(),
  ip_address: z.string().min(5, "Address must be at least 5 characters").max(500),
  payload: z.any().nullable(),
});

export const authAudit_log_entriesInsertSchema = z.object({
  created_at: z.iso.datetime().nullable().optional(),
  id: z.uuid(),
  instance_id: z.uuid().nullable().optional(),
  ip_address: z.string().min(5, "Address must be at least 5 characters").max(500).optional(),
  payload: z.any().nullable().optional(),
});

export const authAudit_log_entriesUpdateSchema = z.object({
  created_at: z.iso.datetime().nullable().optional(),
  id: z.uuid().optional(),
  instance_id: z.uuid().nullable().optional(),
  ip_address: z.string().min(5, "Address must be at least 5 characters").max(500).optional(),
  payload: z.any().nullable().optional(),
});

export const authFlow_stateRowSchema = z.object({
  auth_code: z.string(),
  auth_code_issued_at: z.iso.datetime().nullable(),
  authentication_method: z.string(),
  code_challenge: z.string(),
  code_challenge_method: z.string(),
  created_at: z.iso.datetime().nullable(),
  id: z.uuid(),
  provider_access_token: z.jwt().nullable(),
  provider_refresh_token: z.jwt().nullable(),
  provider_type: z.string(),
  updated_at: z.iso.datetime().nullable(),
  user_id: z.uuid().nullable(),
});

export const authFlow_stateInsertSchema = z.object({
  auth_code: z.string(),
  auth_code_issued_at: z.iso.datetime().nullable().optional(),
  authentication_method: z.string(),
  code_challenge: z.string(),
  code_challenge_method: z.string(),
  created_at: z.iso.datetime().nullable().optional(),
  id: z.uuid(),
  provider_access_token: z.jwt().nullable().optional(),
  provider_refresh_token: z.jwt().nullable().optional(),
  provider_type: z.string(),
  updated_at: z.iso.datetime().nullable().optional(),
  user_id: z.uuid().nullable().optional(),
});

export const authFlow_stateUpdateSchema = z.object({
  auth_code: z.string().optional(),
  auth_code_issued_at: z.iso.datetime().nullable().optional(),
  authentication_method: z.string().optional(),
  code_challenge: z.string().optional(),
  code_challenge_method: z.string().optional(),
  created_at: z.iso.datetime().nullable().optional(),
  id: z.uuid().optional(),
  provider_access_token: z.jwt().nullable().optional(),
  provider_refresh_token: z.jwt().nullable().optional(),
  provider_type: z.string().optional(),
  updated_at: z.iso.datetime().nullable().optional(),
  user_id: z.uuid().nullable().optional(),
});

export const authIdentitiesRowSchema = z.object({
  created_at: z.iso.datetime().nullable(),
  email: z.email().nullable(),
  id: z.uuid(),
  identity_data: z.any(),
  last_sign_in_at: z.iso.datetime().nullable(),
  provider: z.string(),
  provider_id: z.uuid(),
  updated_at: z.iso.datetime().nullable(),
  user_id: z.uuid(),
});

export const authIdentitiesInsertSchema = z.object({
  created_at: z.iso.datetime().nullable().optional(),
  email: z.email().nullable().optional(),
  id: z.uuid().optional(),
  identity_data: z.any(),
  last_sign_in_at: z.iso.datetime().nullable().optional(),
  provider: z.string(),
  provider_id: z.uuid(),
  updated_at: z.iso.datetime().nullable().optional(),
  user_id: z.uuid(),
});

export const authIdentitiesUpdateSchema = z.object({
  created_at: z.iso.datetime().nullable().optional(),
  email: z.email().nullable().optional(),
  id: z.uuid().optional(),
  identity_data: z.any().optional(),
  last_sign_in_at: z.iso.datetime().nullable().optional(),
  provider: z.string().optional(),
  provider_id: z.uuid().optional(),
  updated_at: z.iso.datetime().nullable().optional(),
  user_id: z.uuid().optional(),
});

export const authInstancesRowSchema = z.object({
  created_at: z.iso.datetime().nullable(),
  id: z.uuid(),
  raw_base_config: z.string().nullable(),
  updated_at: z.iso.datetime().nullable(),
  uuid: z.uuid().nullable(),
});

export const authInstancesInsertSchema = z.object({
  created_at: z.iso.datetime().nullable().optional(),
  id: z.uuid(),
  raw_base_config: z.string().nullable().optional(),
  updated_at: z.iso.datetime().nullable().optional(),
  uuid: z.uuid().nullable().optional(),
});

export const authInstancesUpdateSchema = z.object({
  created_at: z.iso.datetime().nullable().optional(),
  id: z.uuid().optional(),
  raw_base_config: z.string().nullable().optional(),
  updated_at: z.iso.datetime().nullable().optional(),
  uuid: z.uuid().nullable().optional(),
});

export const authMfa_amr_claimsRowSchema = z.object({
  authentication_method: z.string(),
  created_at: z.iso.datetime(),
  id: z.uuid(),
  session_id: z.uuid(),
  updated_at: z.iso.datetime(),
});

export const authMfa_amr_claimsInsertSchema = z.object({
  authentication_method: z.string(),
  created_at: z.iso.datetime(),
  id: z.uuid(),
  session_id: z.uuid(),
  updated_at: z.iso.datetime(),
});

export const authMfa_amr_claimsUpdateSchema = z.object({
  authentication_method: z.string().optional(),
  created_at: z.iso.datetime().optional(),
  id: z.uuid().optional(),
  session_id: z.uuid().optional(),
  updated_at: z.iso.datetime().optional(),
});

export const authMfa_challengesRowSchema = z.object({
  created_at: z.iso.datetime(),
  factor_id: z.uuid(),
  id: z.uuid(),
  ip_address: z.string(),
  otp_code: z.string().nullable(),
  verified_at: z.iso.datetime().nullable(),
  web_authn_session_data: z.any().nullable(),
});

export const authMfa_challengesInsertSchema = z.object({
  created_at: z.iso.datetime(),
  factor_id: z.uuid(),
  id: z.uuid(),
  ip_address: z.string(),
  otp_code: z.string().nullable().optional(),
  verified_at: z.iso.datetime().nullable().optional(),
  web_authn_session_data: z.any().nullable().optional(),
});

export const authMfa_challengesUpdateSchema = z.object({
  created_at: z.iso.datetime().optional(),
  factor_id: z.uuid().optional(),
  id: z.uuid().optional(),
  ip_address: z.string().optional(),
  otp_code: z.string().nullable().optional(),
  verified_at: z.iso.datetime().nullable().optional(),
  web_authn_session_data: z.any().nullable().optional(),
});

export const authMfa_factorsRowSchema = z.object({
  created_at: z.iso.datetime(),
  factor_type: z.string(),
  friendly_name: z.string().min(1, "Name cannot be empty").max(255, "Name is too long").nullable(),
  id: z.uuid(),
  last_challenged_at: z.iso.datetime().nullable(),
  phone: z.string().regex(/^[+]?[1-9]?[0-9]{7,15}$/, "Invalid phone number").nullable(),
  secret: z.string().nullable(),
  status: z.string(),
  updated_at: z.iso.datetime(),
  user_id: z.uuid(),
  web_authn_aaguid: z.string().nullable(),
  web_authn_credential: z.any().nullable(),
});

export const authMfa_factorsInsertSchema = z.object({
  created_at: z.iso.datetime(),
  factor_type: z.string(),
  friendly_name: z.string().min(1, "Name cannot be empty").max(255, "Name is too long").nullable().optional(),
  id: z.uuid(),
  last_challenged_at: z.iso.datetime().nullable().optional(),
  phone: z.string().regex(/^[+]?[1-9]?[0-9]{7,15}$/, "Invalid phone number").nullable().optional(),
  secret: z.string().nullable().optional(),
  status: z.string(),
  updated_at: z.iso.datetime(),
  user_id: z.uuid(),
  web_authn_aaguid: z.string().nullable().optional(),
  web_authn_credential: z.any().nullable().optional(),
});

export const authMfa_factorsUpdateSchema = z.object({
  created_at: z.iso.datetime().optional(),
  factor_type: z.string().optional(),
  friendly_name: z.string().min(1, "Name cannot be empty").max(255, "Name is too long").nullable().optional(),
  id: z.uuid().optional(),
  last_challenged_at: z.iso.datetime().nullable().optional(),
  phone: z.string().regex(/^[+]?[1-9]?[0-9]{7,15}$/, "Invalid phone number").nullable().optional(),
  secret: z.string().nullable().optional(),
  status: z.string().optional(),
  updated_at: z.iso.datetime().optional(),
  user_id: z.uuid().optional(),
  web_authn_aaguid: z.string().nullable().optional(),
  web_authn_credential: z.any().nullable().optional(),
});

export const authOauth_clientsRowSchema = z.object({
  client_id: z.uuid(),
  client_name: z.string().min(1, "Name cannot be empty").max(255, "Name is too long").nullable(),
  client_secret_hash: z.string(),
  client_uri: z.string().nullable(),
  created_at: z.iso.datetime(),
  deleted_at: z.iso.datetime().nullable(),
  grant_types: z.string(),
  id: z.uuid(),
  logo_uri: z.string().nullable(),
  redirect_uris: z.string(),
  registration_type: z.string(),
  updated_at: z.iso.datetime(),
});

export const authOauth_clientsInsertSchema = z.object({
  client_id: z.uuid(),
  client_name: z.string().min(1, "Name cannot be empty").max(255, "Name is too long").nullable().optional(),
  client_secret_hash: z.string(),
  client_uri: z.string().nullable().optional(),
  created_at: z.iso.datetime().optional(),
  deleted_at: z.iso.datetime().nullable().optional(),
  grant_types: z.string(),
  id: z.uuid(),
  logo_uri: z.string().nullable().optional(),
  redirect_uris: z.string(),
  registration_type: z.string(),
  updated_at: z.iso.datetime().optional(),
});

export const authOauth_clientsUpdateSchema = z.object({
  client_id: z.uuid().optional(),
  client_name: z.string().min(1, "Name cannot be empty").max(255, "Name is too long").nullable().optional(),
  client_secret_hash: z.string().optional(),
  client_uri: z.string().nullable().optional(),
  created_at: z.iso.datetime().optional(),
  deleted_at: z.iso.datetime().nullable().optional(),
  grant_types: z.string().optional(),
  id: z.uuid().optional(),
  logo_uri: z.string().nullable().optional(),
  redirect_uris: z.string().optional(),
  registration_type: z.string().optional(),
  updated_at: z.iso.datetime().optional(),
});

export const authOne_time_tokensRowSchema = z.object({
  created_at: z.iso.datetime(),
  id: z.uuid(),
  relates_to: z.string(),
  token_hash: z.jwt(),
  token_type: z.string(),
  updated_at: z.iso.datetime(),
  user_id: z.uuid(),
});

export const authOne_time_tokensInsertSchema = z.object({
  created_at: z.iso.datetime().optional(),
  id: z.uuid(),
  relates_to: z.string(),
  token_hash: z.jwt(),
  token_type: z.string(),
  updated_at: z.iso.datetime().optional(),
  user_id: z.uuid(),
});

export const authOne_time_tokensUpdateSchema = z.object({
  created_at: z.iso.datetime().optional(),
  id: z.uuid().optional(),
  relates_to: z.string().optional(),
  token_hash: z.jwt().optional(),
  token_type: z.string().optional(),
  updated_at: z.iso.datetime().optional(),
  user_id: z.uuid().optional(),
});

export const authRefresh_tokensRowSchema = z.object({
  created_at: z.iso.datetime().nullable(),
  id: z.number().int().positive(),
  instance_id: z.uuid().nullable(),
  parent: z.string().nullable(),
  revoked: z.boolean().nullable(),
  session_id: z.uuid().nullable(),
  token: z.jwt().nullable(),
  updated_at: z.iso.datetime().nullable(),
  user_id: z.uuid().nullable(),
});

export const authRefresh_tokensInsertSchema = z.object({
  created_at: z.iso.datetime().nullable().optional(),
  id: z.number().int().positive().optional(),
  instance_id: z.uuid().nullable().optional(),
  parent: z.string().nullable().optional(),
  revoked: z.boolean().nullable().optional(),
  session_id: z.uuid().nullable().optional(),
  token: z.jwt().nullable().optional(),
  updated_at: z.iso.datetime().nullable().optional(),
  user_id: z.uuid().nullable().optional(),
});

export const authRefresh_tokensUpdateSchema = z.object({
  created_at: z.iso.datetime().nullable().optional(),
  id: z.number().int().positive().optional(),
  instance_id: z.uuid().nullable().optional(),
  parent: z.string().nullable().optional(),
  revoked: z.boolean().nullable().optional(),
  session_id: z.uuid().nullable().optional(),
  token: z.jwt().nullable().optional(),
  updated_at: z.iso.datetime().nullable().optional(),
  user_id: z.uuid().nullable().optional(),
});

export const authSaml_providersRowSchema = z.object({
  attribute_mapping: z.any().nullable(),
  created_at: z.iso.datetime().nullable(),
  entity_id: z.uuid(),
  id: z.uuid(),
  metadata_url: z.url().nullable(),
  metadata_xml: z.string(),
  name_id_format: z.string().nullable(),
  sso_provider_id: z.uuid(),
  updated_at: z.iso.datetime().nullable(),
});

export const authSaml_providersInsertSchema = z.object({
  attribute_mapping: z.any().nullable().optional(),
  created_at: z.iso.datetime().nullable().optional(),
  entity_id: z.uuid(),
  id: z.uuid(),
  metadata_url: z.url().nullable().optional(),
  metadata_xml: z.string(),
  name_id_format: z.string().nullable().optional(),
  sso_provider_id: z.uuid(),
  updated_at: z.iso.datetime().nullable().optional(),
});

export const authSaml_providersUpdateSchema = z.object({
  attribute_mapping: z.any().nullable().optional(),
  created_at: z.iso.datetime().nullable().optional(),
  entity_id: z.uuid().optional(),
  id: z.uuid().optional(),
  metadata_url: z.url().nullable().optional(),
  metadata_xml: z.string().optional(),
  name_id_format: z.string().nullable().optional(),
  sso_provider_id: z.uuid().optional(),
  updated_at: z.iso.datetime().nullable().optional(),
});

export const authSaml_relay_statesRowSchema = z.object({
  created_at: z.iso.datetime().nullable(),
  flow_state_id: z.uuid().nullable(),
  for_email: z.email().nullable(),
  id: z.uuid(),
  redirect_to: z.string().nullable(),
  request_id: z.uuid(),
  sso_provider_id: z.uuid(),
  updated_at: z.iso.datetime().nullable(),
});

export const authSaml_relay_statesInsertSchema = z.object({
  created_at: z.iso.datetime().nullable().optional(),
  flow_state_id: z.uuid().nullable().optional(),
  for_email: z.email().nullable().optional(),
  id: z.uuid(),
  redirect_to: z.string().nullable().optional(),
  request_id: z.uuid(),
  sso_provider_id: z.uuid(),
  updated_at: z.iso.datetime().nullable().optional(),
});

export const authSaml_relay_statesUpdateSchema = z.object({
  created_at: z.iso.datetime().nullable().optional(),
  flow_state_id: z.uuid().nullable().optional(),
  for_email: z.email().nullable().optional(),
  id: z.uuid().optional(),
  redirect_to: z.string().nullable().optional(),
  request_id: z.uuid().optional(),
  sso_provider_id: z.uuid().optional(),
  updated_at: z.iso.datetime().nullable().optional(),
});

export const authSchema_migrationsRowSchema = z.object({
  version: z.string(),
});

export const authSchema_migrationsInsertSchema = z.object({
  version: z.string(),
});

export const authSchema_migrationsUpdateSchema = z.object({
  version: z.string().optional(),
});

export const authSessionsRowSchema = z.object({
  aal: z.string().nullable(),
  created_at: z.iso.datetime().nullable(),
  factor_id: z.uuid().nullable(),
  id: z.uuid(),
  ip: z.string().nullable(),
  not_after: z.string().nullable(),
  refreshed_at: z.iso.datetime().nullable(),
  tag: z.string().nullable(),
  updated_at: z.iso.datetime().nullable(),
  user_agent: z.string().nullable(),
  user_id: z.uuid(),
});

export const authSessionsInsertSchema = z.object({
  aal: z.string().nullable().optional(),
  created_at: z.iso.datetime().nullable().optional(),
  factor_id: z.uuid().nullable().optional(),
  id: z.uuid(),
  ip: z.string().nullable().optional(),
  not_after: z.string().nullable().optional(),
  refreshed_at: z.iso.datetime().nullable().optional(),
  tag: z.string().nullable().optional(),
  updated_at: z.iso.datetime().nullable().optional(),
  user_agent: z.string().nullable().optional(),
  user_id: z.uuid(),
});

export const authSessionsUpdateSchema = z.object({
  aal: z.string().nullable().optional(),
  created_at: z.iso.datetime().nullable().optional(),
  factor_id: z.uuid().nullable().optional(),
  id: z.uuid().optional(),
  ip: z.string().nullable().optional(),
  not_after: z.string().nullable().optional(),
  refreshed_at: z.iso.datetime().nullable().optional(),
  tag: z.string().nullable().optional(),
  updated_at: z.iso.datetime().nullable().optional(),
  user_agent: z.string().nullable().optional(),
  user_id: z.uuid().optional(),
});

export const authSso_domainsRowSchema = z.object({
  created_at: z.iso.datetime().nullable(),
  domain: z.string(),
  id: z.uuid(),
  sso_provider_id: z.uuid(),
  updated_at: z.iso.datetime().nullable(),
});

export const authSso_domainsInsertSchema = z.object({
  created_at: z.iso.datetime().nullable().optional(),
  domain: z.string(),
  id: z.uuid(),
  sso_provider_id: z.uuid(),
  updated_at: z.iso.datetime().nullable().optional(),
});

export const authSso_domainsUpdateSchema = z.object({
  created_at: z.iso.datetime().nullable().optional(),
  domain: z.string().optional(),
  id: z.uuid().optional(),
  sso_provider_id: z.uuid().optional(),
  updated_at: z.iso.datetime().nullable().optional(),
});

export const authSso_providersRowSchema = z.object({
  created_at: z.iso.datetime().nullable(),
  disabled: z.boolean().nullable(),
  id: z.uuid(),
  resource_id: z.uuid().nullable(),
  updated_at: z.iso.datetime().nullable(),
});

export const authSso_providersInsertSchema = z.object({
  created_at: z.iso.datetime().nullable().optional(),
  disabled: z.boolean().nullable().optional(),
  id: z.uuid(),
  resource_id: z.uuid().nullable().optional(),
  updated_at: z.iso.datetime().nullable().optional(),
});

export const authSso_providersUpdateSchema = z.object({
  created_at: z.iso.datetime().nullable().optional(),
  disabled: z.boolean().nullable().optional(),
  id: z.uuid().optional(),
  resource_id: z.uuid().nullable().optional(),
  updated_at: z.iso.datetime().nullable().optional(),
});

export const authUsersRowSchema = z.object({
  aud: z.string().min(1).nullable(),
  banned_until: z.string().nullable(),
  confirmation_sent_at: z.iso.datetime().nullable(),
  confirmation_token: z.jwt().nullable(),
  confirmed_at: z.iso.datetime().nullable(),
  created_at: z.iso.datetime().nullable(),
  deleted_at: z.iso.datetime().nullable(),
  email: z.email().nullable(),
  email_change: z.email().nullable(),
  email_change_confirm_status: z.number().nullable(),
  email_change_sent_at: z.email().nullable(),
  email_change_token_current: z.email().nullable(),
  email_change_token_new: z.email().nullable(),
  email_confirmed_at: z.email().nullable(),
  encrypted_password: z.string().min(1, "Password cannot be empty").nullable(),
  id: z.uuid(),
  instance_id: z.uuid().nullable(),
  invited_at: z.iso.datetime().nullable(),
  is_anonymous: z.boolean(),
  is_sso_user: z.boolean(),
  is_super_admin: z.boolean().nullable(),
  last_sign_in_at: z.iso.datetime().nullable(),
  phone: z.string().regex(/^[+]?[1-9]?[0-9]{7,15}$/, "Invalid phone number").nullable(),
  phone_change: z.string().regex(/^[+]?[1-9]?[0-9]{7,15}$/, "Invalid phone number").nullable(),
  phone_change_sent_at: z.string().regex(/^[+]?[1-9]?[0-9]{7,15}$/, "Invalid phone number").nullable(),
  phone_change_token: z.string().regex(/^[+]?[1-9]?[0-9]{7,15}$/, "Invalid phone number").nullable(),
  phone_confirmed_at: z.string().regex(/^[+]?[1-9]?[0-9]{7,15}$/, "Invalid phone number").nullable(),
  raw_app_meta_data: z.any().nullable(),
  raw_user_meta_data: z.any().nullable(),
  reauthentication_sent_at: z.iso.datetime().nullable(),
  reauthentication_token: z.jwt().nullable(),
  recovery_sent_at: z.iso.datetime().nullable(),
  recovery_token: z.jwt().nullable(),
  role: z.enum(UserRole).nullable(),
  updated_at: z.iso.datetime().nullable(),
});

export const authUsersInsertSchema = z.object({
  aud: z.string().min(1).nullable().optional(),
  banned_until: z.string().nullable().optional(),
  confirmation_sent_at: z.iso.datetime().nullable().optional(),
  confirmation_token: z.jwt().nullable().optional(),
  confirmed_at: z.iso.datetime().nullable().optional(),
  created_at: z.iso.datetime().nullable().optional(),
  deleted_at: z.iso.datetime().nullable().optional(),
  email: z.email().nullable().optional(),
  email_change: z.email().nullable().optional(),
  email_change_confirm_status: z.number().nullable().optional(),
  email_change_sent_at: z.email().nullable().optional(),
  email_change_token_current: z.email().nullable().optional(),
  email_change_token_new: z.email().nullable().optional(),
  email_confirmed_at: z.email().nullable().optional(),
  encrypted_password: z.string().min(1, "Password cannot be empty").nullable().optional(),
  id: z.uuid(),
  instance_id: z.uuid().nullable().optional(),
  invited_at: z.iso.datetime().nullable().optional(),
  is_anonymous: z.boolean().optional(),
  is_sso_user: z.boolean().optional(),
  is_super_admin: z.boolean().nullable().optional(),
  last_sign_in_at: z.iso.datetime().nullable().optional(),
  phone: z.string().regex(/^[+]?[1-9]?[0-9]{7,15}$/, "Invalid phone number").nullable().optional(),
  phone_change: z.string().regex(/^[+]?[1-9]?[0-9]{7,15}$/, "Invalid phone number").nullable().optional(),
  phone_change_sent_at: z.string().regex(/^[+]?[1-9]?[0-9]{7,15}$/, "Invalid phone number").nullable().optional(),
  phone_change_token: z.string().regex(/^[+]?[1-9]?[0-9]{7,15}$/, "Invalid phone number").nullable().optional(),
  phone_confirmed_at: z.string().regex(/^[+]?[1-9]?[0-9]{7,15}$/, "Invalid phone number").nullable().optional(),
  raw_app_meta_data: z.any().nullable().optional(),
  raw_user_meta_data: z.any().nullable().optional(),
  reauthentication_sent_at: z.iso.datetime().nullable().optional(),
  reauthentication_token: z.jwt().nullable().optional(),
  recovery_sent_at: z.iso.datetime().nullable().optional(),
  recovery_token: z.jwt().nullable().optional(),
  role: z.enum(UserRole).nullable().optional(),
  updated_at: z.iso.datetime().nullable().optional(),
});

export const authUsersUpdateSchema = z.object({
  aud: z.string().min(1).nullable().optional(),
  banned_until: z.string().nullable().optional(),
  confirmation_sent_at: z.iso.datetime().nullable().optional(),
  confirmation_token: z.jwt().nullable().optional(),
  confirmed_at: z.iso.datetime().nullable().optional(),
  created_at: z.iso.datetime().nullable().optional(),
  deleted_at: z.iso.datetime().nullable().optional(),
  email: z.email().nullable().optional(),
  email_change: z.email().nullable().optional(),
  email_change_confirm_status: z.number().nullable().optional(),
  email_change_sent_at: z.email().nullable().optional(),
  email_change_token_current: z.email().nullable().optional(),
  email_change_token_new: z.email().nullable().optional(),
  email_confirmed_at: z.email().nullable().optional(),
  encrypted_password: z.string().min(1, "Password cannot be empty").nullable().optional(),
  id: z.uuid().optional(),
  instance_id: z.uuid().nullable().optional(),
  invited_at: z.iso.datetime().nullable().optional(),
  is_anonymous: z.boolean().optional(),
  is_sso_user: z.boolean().optional(),
  is_super_admin: z.boolean().nullable().optional(),
  last_sign_in_at: z.iso.datetime().nullable().optional(),
  phone: z.string().regex(/^[+]?[1-9]?[0-9]{7,15}$/, "Invalid phone number").nullable().optional(),
  phone_change: z.string().regex(/^[+]?[1-9]?[0-9]{7,15}$/, "Invalid phone number").nullable().optional(),
  phone_change_sent_at: z.string().regex(/^[+]?[1-9]?[0-9]{7,15}$/, "Invalid phone number").nullable().optional(),
  phone_change_token: z.string().regex(/^[+]?[1-9]?[0-9]{7,15}$/, "Invalid phone number").nullable().optional(),
  phone_confirmed_at: z.string().regex(/^[+]?[1-9]?[0-9]{7,15}$/, "Invalid phone number").nullable().optional(),
  raw_app_meta_data: z.any().nullable().optional(),
  raw_user_meta_data: z.any().nullable().optional(),
  reauthentication_sent_at: z.iso.datetime().nullable().optional(),
  reauthentication_token: z.jwt().nullable().optional(),
  recovery_sent_at: z.iso.datetime().nullable().optional(),
  recovery_token: z.jwt().nullable().optional(),
  role: z.enum(UserRole).nullable().optional(),
  updated_at: z.iso.datetime().nullable().optional(),
});

export const cable_segmentsRowSchema = z.object({
  created_at: z.iso.datetime().nullable(),
  distance_km: z.number(),
  end_node_id: z.uuid(),
  end_node_type: z.string(),
  fiber_count: z.number().int().min(0),
  id: z.uuid(),
  original_cable_id: z.uuid(),
  segment_order: z.number(),
  start_node_id: z.uuid(),
  start_node_type: z.string(),
  updated_at: z.iso.datetime().nullable(),
});

export const cable_segmentsInsertSchema = z.object({
  created_at: z.iso.datetime().nullable().optional(),
  distance_km: z.number(),
  end_node_id: z.uuid(),
  end_node_type: z.string(),
  fiber_count: z.number().int().min(0),
  id: z.uuid().optional(),
  original_cable_id: z.uuid(),
  segment_order: z.number(),
  start_node_id: z.uuid(),
  start_node_type: z.string(),
  updated_at: z.iso.datetime().nullable().optional(),
});

export const cable_segmentsUpdateSchema = z.object({
  created_at: z.iso.datetime().nullable().optional(),
  distance_km: z.number().optional(),
  end_node_id: z.uuid().optional(),
  end_node_type: z.string().optional(),
  fiber_count: z.number().int().min(0).optional(),
  id: z.uuid().optional(),
  original_cable_id: z.uuid().optional(),
  segment_order: z.number().optional(),
  start_node_id: z.uuid().optional(),
  start_node_type: z.string().optional(),
  updated_at: z.iso.datetime().nullable().optional(),
});

export const employee_designationsRowSchema = z.object({
  created_at: z.iso.datetime().nullable(),
  id: z.uuid(),
  name: z.string().min(1, "Name cannot be empty").max(255, "Name is too long"),
  parent_id: z.uuid().nullable(),
  status: z.boolean().nullable(),
  updated_at: z.iso.datetime().nullable(),
});

export const employee_designationsInsertSchema = z.object({
  created_at: z.iso.datetime().nullable().optional(),
  id: z.uuid().optional(),
  name: z.string().min(1, "Name cannot be empty").max(255, "Name is too long"),
  parent_id: z.uuid().nullable().optional(),
  status: z.boolean().nullable().optional(),
  updated_at: z.iso.datetime().nullable().optional(),
});

export const employee_designationsUpdateSchema = z.object({
  created_at: z.iso.datetime().nullable().optional(),
  id: z.uuid().optional(),
  name: z.string().min(1, "Name cannot be empty").max(255, "Name is too long").optional(),
  parent_id: z.uuid().nullable().optional(),
  status: z.boolean().nullable().optional(),
  updated_at: z.iso.datetime().nullable().optional(),
});

export const employeesRowSchema = z.object({
  created_at: z.iso.datetime().nullable(),
  employee_addr: z.string().min(5, "Address must be at least 5 characters").max(500).nullable(),
  employee_contact: z.string().nullable(),
  employee_designation_id: z.uuid().nullable(),
  employee_dob: z.iso.date().nullable(),
  employee_doj: z.iso.date().nullable(),
  employee_email: z.email().nullable(),
  employee_name: z.string().min(1, "Name cannot be empty").max(255, "Name is too long"),
  employee_pers_no: z.string().nullable(),
  id: z.uuid(),
  maintenance_terminal_id: z.uuid().nullable(),
  remark: z.string().nullable(),
  status: z.boolean().nullable(),
  updated_at: z.iso.datetime().nullable(),
});

export const employeesInsertSchema = z.object({
  created_at: z.iso.datetime().nullable().optional(),
  employee_addr: z.string().min(5, "Address must be at least 5 characters").max(500).nullable().optional(),
  employee_contact: z.string().nullable().optional(),
  employee_designation_id: z.uuid().nullable().optional(),
  employee_dob: z.iso.date().nullable().optional(),
  employee_doj: z.iso.date().nullable().optional(),
  employee_email: z.email().nullable().optional(),
  employee_name: z.string().min(1, "Name cannot be empty").max(255, "Name is too long"),
  employee_pers_no: z.string().nullable().optional(),
  id: z.uuid().optional(),
  maintenance_terminal_id: z.uuid().nullable().optional(),
  remark: z.string().nullable().optional(),
  status: z.boolean().nullable().optional(),
  updated_at: z.iso.datetime().nullable().optional(),
});

export const employeesUpdateSchema = z.object({
  created_at: z.iso.datetime().nullable().optional(),
  employee_addr: z.string().min(5, "Address must be at least 5 characters").max(500).nullable().optional(),
  employee_contact: z.string().nullable().optional(),
  employee_designation_id: z.uuid().nullable().optional(),
  employee_dob: z.iso.date().nullable().optional(),
  employee_doj: z.iso.date().nullable().optional(),
  employee_email: z.email().nullable().optional(),
  employee_name: z.string().min(1, "Name cannot be empty").max(255, "Name is too long").optional(),
  employee_pers_no: z.string().nullable().optional(),
  id: z.uuid().optional(),
  maintenance_terminal_id: z.uuid().nullable().optional(),
  remark: z.string().nullable().optional(),
  status: z.boolean().nullable().optional(),
  updated_at: z.iso.datetime().nullable().optional(),
});

export const fiber_splicesRowSchema = z.object({
  created_at: z.iso.datetime().nullable(),
  id: z.uuid(),
  incoming_fiber_no: z.number(),
  incoming_segment_id: z.uuid(),
  jc_id: z.uuid(),
  logical_path_id: z.uuid().nullable(),
  loss_db: z.number().nullable(),
  outgoing_fiber_no: z.number().nullable(),
  outgoing_segment_id: z.uuid().nullable(),
  splice_type_id: z.uuid(),
  updated_at: z.iso.datetime().nullable(),
});

export const fiber_splicesInsertSchema = z.object({
  created_at: z.iso.datetime().nullable().optional(),
  id: z.uuid().optional(),
  incoming_fiber_no: z.number(),
  incoming_segment_id: z.uuid(),
  jc_id: z.uuid(),
  logical_path_id: z.uuid().nullable().optional(),
  loss_db: z.number().nullable().optional(),
  outgoing_fiber_no: z.number().nullable().optional(),
  outgoing_segment_id: z.uuid().nullable().optional(),
  splice_type_id: z.uuid(),
  updated_at: z.iso.datetime().nullable().optional(),
});

export const fiber_splicesUpdateSchema = z.object({
  created_at: z.iso.datetime().nullable().optional(),
  id: z.uuid().optional(),
  incoming_fiber_no: z.number().optional(),
  incoming_segment_id: z.uuid().optional(),
  jc_id: z.uuid().optional(),
  logical_path_id: z.uuid().nullable().optional(),
  loss_db: z.number().nullable().optional(),
  outgoing_fiber_no: z.number().nullable().optional(),
  outgoing_segment_id: z.uuid().nullable().optional(),
  splice_type_id: z.uuid().optional(),
  updated_at: z.iso.datetime().nullable().optional(),
});

export const filesRowSchema = z.object({
  file_name: z.string().min(1, "Name cannot be empty").max(255, "Name is too long"),
  file_route: z.string(),
  file_size: z.string(),
  file_type: z.string(),
  file_url: z.url(),
  folder_id: z.uuid().nullable(),
  id: z.uuid(),
  uploaded_at: z.iso.datetime().nullable(),
  user_id: z.uuid(),
});

export const filesInsertSchema = z.object({
  file_name: z.string().min(1, "Name cannot be empty").max(255, "Name is too long"),
  file_route: z.string(),
  file_size: z.string(),
  file_type: z.string(),
  file_url: z.url(),
  folder_id: z.uuid().nullable().optional(),
  id: z.uuid().optional(),
  uploaded_at: z.iso.datetime().nullable().optional(),
  user_id: z.uuid(),
});

export const filesUpdateSchema = z.object({
  file_name: z.string().min(1, "Name cannot be empty").max(255, "Name is too long").optional(),
  file_route: z.string().optional(),
  file_size: z.string().optional(),
  file_type: z.string().optional(),
  file_url: z.url().optional(),
  folder_id: z.uuid().nullable().optional(),
  id: z.uuid().optional(),
  uploaded_at: z.iso.datetime().nullable().optional(),
  user_id: z.uuid().optional(),
});

export const foldersRowSchema = z.object({
  created_at: z.iso.datetime().nullable(),
  id: z.uuid(),
  name: z.string().min(1, "Name cannot be empty").max(255, "Name is too long"),
  user_id: z.uuid(),
});

export const foldersInsertSchema = z.object({
  created_at: z.iso.datetime().nullable().optional(),
  id: z.uuid().optional(),
  name: z.string().min(1, "Name cannot be empty").max(255, "Name is too long"),
  user_id: z.uuid(),
});

export const foldersUpdateSchema = z.object({
  created_at: z.iso.datetime().nullable().optional(),
  id: z.uuid().optional(),
  name: z.string().min(1, "Name cannot be empty").max(255, "Name is too long").optional(),
  user_id: z.uuid().optional(),
});

export const junction_closuresRowSchema = z.object({
  created_at: z.iso.datetime().nullable(),
  id: z.uuid(),
  node_id: z.uuid(),
  ofc_cable_id: z.uuid(),
  position_km: z.number().nullable(),
  updated_at: z.iso.datetime().nullable(),
});

export const junction_closuresInsertSchema = z.object({
  created_at: z.iso.datetime().nullable().optional(),
  id: z.uuid().optional(),
  node_id: z.uuid(),
  ofc_cable_id: z.uuid(),
  position_km: z.number().nullable().optional(),
  updated_at: z.iso.datetime().nullable().optional(),
});

export const junction_closuresUpdateSchema = z.object({
  created_at: z.iso.datetime().nullable().optional(),
  id: z.uuid().optional(),
  node_id: z.uuid().optional(),
  ofc_cable_id: z.uuid().optional(),
  position_km: z.number().nullable().optional(),
  updated_at: z.iso.datetime().nullable().optional(),
});

export const logical_fiber_pathsRowSchema = z.object({
  bandwidth_gbps: z.number().nullable(),
  commissioned_date: z.iso.datetime().nullable(),
  created_at: z.iso.datetime().nullable(),
  destination_port: z.string().nullable(),
  destination_system_id: z.uuid().nullable(),
  id: z.uuid(),
  operational_status_id: z.uuid().nullable(),
  path_name: z.string().min(1, "Name cannot be empty").max(255, "Name is too long").nullable(),
  path_role: z.string(),
  path_type_id: z.uuid().nullable(),
  remark: z.string().nullable(),
  service_type: z.string().nullable(),
  source_port: z.string().nullable(),
  source_system_id: z.uuid().nullable(),
  total_distance_km: z.number().nullable(),
  total_loss_db: z.number().nullable(),
  updated_at: z.iso.datetime().nullable(),
  wavelength_nm: z.number().nullable(),
  working_path_id: z.uuid().nullable(),
});

export const logical_fiber_pathsInsertSchema = z.object({
  bandwidth_gbps: z.number().nullable().optional(),
  commissioned_date: z.iso.datetime().nullable().optional(),
  created_at: z.iso.datetime().nullable().optional(),
  destination_port: z.string().nullable().optional(),
  destination_system_id: z.uuid().nullable().optional(),
  id: z.uuid().optional(),
  operational_status_id: z.uuid().nullable().optional(),
  path_name: z.string().min(1, "Name cannot be empty").max(255, "Name is too long").nullable().optional(),
  path_role: z.string().optional(),
  path_type_id: z.uuid().nullable().optional(),
  remark: z.string().nullable().optional(),
  service_type: z.string().nullable().optional(),
  source_port: z.string().nullable().optional(),
  source_system_id: z.uuid().nullable().optional(),
  total_distance_km: z.number().nullable().optional(),
  total_loss_db: z.number().nullable().optional(),
  updated_at: z.iso.datetime().nullable().optional(),
  wavelength_nm: z.number().nullable().optional(),
  working_path_id: z.uuid().nullable().optional(),
});

export const logical_fiber_pathsUpdateSchema = z.object({
  bandwidth_gbps: z.number().nullable().optional(),
  commissioned_date: z.iso.datetime().nullable().optional(),
  created_at: z.iso.datetime().nullable().optional(),
  destination_port: z.string().nullable().optional(),
  destination_system_id: z.uuid().nullable().optional(),
  id: z.uuid().optional(),
  operational_status_id: z.uuid().nullable().optional(),
  path_name: z.string().min(1, "Name cannot be empty").max(255, "Name is too long").nullable().optional(),
  path_role: z.string().optional(),
  path_type_id: z.uuid().nullable().optional(),
  remark: z.string().nullable().optional(),
  service_type: z.string().nullable().optional(),
  source_port: z.string().nullable().optional(),
  source_system_id: z.uuid().nullable().optional(),
  total_distance_km: z.number().nullable().optional(),
  total_loss_db: z.number().nullable().optional(),
  updated_at: z.iso.datetime().nullable().optional(),
  wavelength_nm: z.number().nullable().optional(),
  working_path_id: z.uuid().nullable().optional(),
});

export const logical_path_segmentsRowSchema = z.object({
  created_at: z.iso.datetime().nullable(),
  id: z.uuid(),
  logical_path_id: z.uuid(),
  ofc_cable_id: z.uuid().nullable(),
  path_order: z.number(),
  updated_at: z.iso.datetime().nullable(),
});

export const logical_path_segmentsInsertSchema = z.object({
  created_at: z.iso.datetime().nullable().optional(),
  id: z.uuid().optional(),
  logical_path_id: z.uuid(),
  ofc_cable_id: z.uuid().nullable().optional(),
  path_order: z.number(),
  updated_at: z.iso.datetime().nullable().optional(),
});

export const logical_path_segmentsUpdateSchema = z.object({
  created_at: z.iso.datetime().nullable().optional(),
  id: z.uuid().optional(),
  logical_path_id: z.uuid().optional(),
  ofc_cable_id: z.uuid().nullable().optional(),
  path_order: z.number().optional(),
  updated_at: z.iso.datetime().nullable().optional(),
});

export const lookup_typesRowSchema = z.object({
  category: z.string(),
  code: z.string().nullable(),
  created_at: z.iso.datetime().nullable(),
  description: z.string().max(10000, "Text is too long").nullable(),
  id: z.uuid(),
  is_system_default: z.boolean().nullable(),
  name: z.string().min(1, "Name cannot be empty").max(255, "Name is too long"),
  sort_order: z.number().nullable(),
  status: z.boolean().nullable(),
  updated_at: z.iso.datetime().nullable(),
});

export const lookup_typesInsertSchema = z.object({
  category: z.string(),
  code: z.string().nullable().optional(),
  created_at: z.iso.datetime().nullable().optional(),
  description: z.string().max(10000, "Text is too long").nullable().optional(),
  id: z.uuid().optional(),
  is_system_default: z.boolean().nullable().optional(),
  name: z.string().min(1, "Name cannot be empty").max(255, "Name is too long"),
  sort_order: z.number().nullable().optional(),
  status: z.boolean().nullable().optional(),
  updated_at: z.iso.datetime().nullable().optional(),
});

export const lookup_typesUpdateSchema = z.object({
  category: z.string().optional(),
  code: z.string().nullable().optional(),
  created_at: z.iso.datetime().nullable().optional(),
  description: z.string().max(10000, "Text is too long").nullable().optional(),
  id: z.uuid().optional(),
  is_system_default: z.boolean().nullable().optional(),
  name: z.string().min(1, "Name cannot be empty").max(255, "Name is too long").optional(),
  sort_order: z.number().nullable().optional(),
  status: z.boolean().nullable().optional(),
  updated_at: z.iso.datetime().nullable().optional(),
});

export const maintenance_areasRowSchema = z.object({
  address: z.string().min(5, "Address must be at least 5 characters").max(500).nullable(),
  area_type_id: z.uuid().nullable(),
  code: z.string().nullable(),
  contact_number: z.string().nullable(),
  contact_person: z.string().nullable(),
  created_at: z.iso.datetime().nullable(),
  email: z.email().nullable(),
  id: z.uuid(),
  latitude: z.number().nullable(),
  longitude: z.number().nullable(),
  name: z.string().min(1, "Name cannot be empty").max(255, "Name is too long"),
  parent_id: z.uuid().nullable(),
  status: z.boolean().nullable(),
  updated_at: z.iso.datetime().nullable(),
});

export const maintenance_areasInsertSchema = z.object({
  address: z.string().min(5, "Address must be at least 5 characters").max(500).nullable().optional(),
  area_type_id: z.uuid().nullable().optional(),
  code: z.string().nullable().optional(),
  contact_number: z.string().nullable().optional(),
  contact_person: z.string().nullable().optional(),
  created_at: z.iso.datetime().nullable().optional(),
  email: z.email().nullable().optional(),
  id: z.uuid().optional(),
  latitude: z.number().nullable().optional(),
  longitude: z.number().nullable().optional(),
  name: z.string().min(1, "Name cannot be empty").max(255, "Name is too long"),
  parent_id: z.uuid().nullable().optional(),
  status: z.boolean().nullable().optional(),
  updated_at: z.iso.datetime().nullable().optional(),
});

export const maintenance_areasUpdateSchema = z.object({
  address: z.string().min(5, "Address must be at least 5 characters").max(500).nullable().optional(),
  area_type_id: z.uuid().nullable().optional(),
  code: z.string().nullable().optional(),
  contact_number: z.string().nullable().optional(),
  contact_person: z.string().nullable().optional(),
  created_at: z.iso.datetime().nullable().optional(),
  email: z.email().nullable().optional(),
  id: z.uuid().optional(),
  latitude: z.number().nullable().optional(),
  longitude: z.number().nullable().optional(),
  name: z.string().min(1, "Name cannot be empty").max(255, "Name is too long").optional(),
  parent_id: z.uuid().nullable().optional(),
  status: z.boolean().nullable().optional(),
  updated_at: z.iso.datetime().nullable().optional(),
});

export const management_portsRowSchema = z.object({
  commissioned_on: z.iso.date().nullable(),
  created_at: z.iso.datetime().nullable(),
  id: z.uuid(),
  name: z.string().min(1, "Name cannot be empty").max(255, "Name is too long").nullable(),
  node_id: z.uuid().nullable(),
  port_no: z.string(),
  remark: z.string().nullable(),
  status: z.boolean().nullable(),
  system_id: z.uuid().nullable(),
  updated_at: z.iso.datetime().nullable(),
});

export const management_portsInsertSchema = z.object({
  commissioned_on: z.iso.date().nullable().optional(),
  created_at: z.iso.datetime().nullable().optional(),
  id: z.uuid().optional(),
  name: z.string().min(1, "Name cannot be empty").max(255, "Name is too long").nullable().optional(),
  node_id: z.uuid().nullable().optional(),
  port_no: z.string(),
  remark: z.string().nullable().optional(),
  status: z.boolean().nullable().optional(),
  system_id: z.uuid().nullable().optional(),
  updated_at: z.iso.datetime().nullable().optional(),
});

export const management_portsUpdateSchema = z.object({
  commissioned_on: z.iso.date().nullable().optional(),
  created_at: z.iso.datetime().nullable().optional(),
  id: z.uuid().optional(),
  name: z.string().min(1, "Name cannot be empty").max(255, "Name is too long").nullable().optional(),
  node_id: z.uuid().nullable().optional(),
  port_no: z.string().optional(),
  remark: z.string().nullable().optional(),
  status: z.boolean().nullable().optional(),
  system_id: z.uuid().nullable().optional(),
  updated_at: z.iso.datetime().nullable().optional(),
});

export const nodesRowSchema = z.object({
  created_at: z.iso.datetime().nullable(),
  id: z.uuid(),
  latitude: z.number().nullable(),
  longitude: z.number().nullable(),
  maintenance_terminal_id: z.uuid().nullable(),
  name: z.string().min(1, "Name cannot be empty").max(255, "Name is too long"),
  node_type_id: z.uuid().nullable(),
  remark: z.string().nullable(),
  status: z.boolean().nullable(),
  updated_at: z.iso.datetime().nullable(),
});

export const nodesInsertSchema = z.object({
  created_at: z.iso.datetime().nullable().optional(),
  id: z.uuid().optional(),
  latitude: z.number().nullable().optional(),
  longitude: z.number().nullable().optional(),
  maintenance_terminal_id: z.uuid().nullable().optional(),
  name: z.string().min(1, "Name cannot be empty").max(255, "Name is too long"),
  node_type_id: z.uuid().nullable().optional(),
  remark: z.string().nullable().optional(),
  status: z.boolean().nullable().optional(),
  updated_at: z.iso.datetime().nullable().optional(),
});

export const nodesUpdateSchema = z.object({
  created_at: z.iso.datetime().nullable().optional(),
  id: z.uuid().optional(),
  latitude: z.number().nullable().optional(),
  longitude: z.number().nullable().optional(),
  maintenance_terminal_id: z.uuid().nullable().optional(),
  name: z.string().min(1, "Name cannot be empty").max(255, "Name is too long").optional(),
  node_type_id: z.uuid().nullable().optional(),
  remark: z.string().nullable().optional(),
  status: z.boolean().nullable().optional(),
  updated_at: z.iso.datetime().nullable().optional(),
});

export const ofc_cablesRowSchema = z.object({
  asset_no: z.string().nullable(),
  capacity: z.number(),
  commissioned_on: z.iso.date().nullable(),
  created_at: z.iso.datetime().nullable(),
  current_rkm: z.number().nullable(),
  en_id: z.uuid(),
  id: z.uuid(),
  maintenance_terminal_id: z.uuid().nullable(),
  ofc_owner_id: z.uuid(),
  ofc_type_id: z.uuid(),
  remark: z.string().nullable(),
  route_name: z.string().min(1, "Name cannot be empty").max(255, "Name is too long"),
  sn_id: z.uuid(),
  status: z.boolean().nullable(),
  transnet_id: z.string().nullable().nullable(),
  transnet_rkm: z.number().nullable(),
  updated_at: z.iso.datetime().nullable(),
});

export const ofc_cablesInsertSchema = z.object({
  asset_no: z.string().nullable().optional(),
  capacity: z.number(),
  commissioned_on: z.iso.date().nullable().optional(),
  created_at: z.iso.datetime().nullable().optional(),
  current_rkm: z.number().nullable().optional(),
  en_id: z.uuid(),
  id: z.uuid().optional(),
  maintenance_terminal_id: z.uuid().nullable().optional(),
  ofc_owner_id: z.uuid(),
  ofc_type_id: z.uuid(),
  remark: z.string().nullable().optional(),
  route_name: z.string().min(1, "Name cannot be empty").max(255, "Name is too long"),
  sn_id: z.uuid(),
  status: z.boolean().nullable().optional(),
  transnet_id: z.string().nullable().nullable().optional(),
  transnet_rkm: z.number().nullable().optional(),
  updated_at: z.iso.datetime().nullable().optional(),
});

export const ofc_cablesUpdateSchema = z.object({
  asset_no: z.string().nullable().optional(),
  capacity: z.number().optional(),
  commissioned_on: z.iso.date().nullable().optional(),
  created_at: z.iso.datetime().nullable().optional(),
  current_rkm: z.number().nullable().optional(),
  en_id: z.uuid().optional(),
  id: z.uuid().optional(),
  maintenance_terminal_id: z.uuid().nullable().optional(),
  ofc_owner_id: z.uuid().optional(),
  ofc_type_id: z.uuid().optional(),
  remark: z.string().nullable().optional(),
  route_name: z.string().min(1, "Name cannot be empty").max(255, "Name is too long").optional(),
  sn_id: z.uuid().optional(),
  status: z.boolean().nullable().optional(),
  transnet_id: z.string().nullable().nullable().optional(),
  transnet_rkm: z.number().nullable().optional(),
  updated_at: z.iso.datetime().nullable().optional(),
});

export const ofc_connectionsRowSchema = z.object({
  connection_category: z.string(),
  connection_type: z.string(),
  created_at: z.iso.datetime().nullable(),
  destination_port: z.string().nullable(),
  en_dom: z.iso.date().nullable(),
  en_power_dbm: z.number().nullable(),
  fiber_no_en: z.number(),
  fiber_no_sn: z.number(),
  fiber_role: z.string().nullable(),
  id: z.uuid(),
  logical_path_id: z.uuid().nullable(),
  ofc_id: z.uuid(),
  otdr_distance_en_km: z.number().nullable(),
  otdr_distance_sn_km: z.number().nullable(),
  path_segment_order: z.number().nullable(),
  remark: z.string().nullable(),
  route_loss_db: z.number().nullable(),
  sn_dom: z.iso.date().nullable(),
  sn_power_dbm: z.number().nullable(),
  source_port: z.string().nullable(),
  status: z.boolean().nullable(),
  system_id: z.uuid().nullable(),
  updated_at: z.iso.datetime().nullable(),
  updated_en_id: z.uuid().nullable(),
  updated_fiber_no_en: z.number().nullable(),
  updated_fiber_no_sn: z.number().nullable(),
  updated_sn_id: z.uuid().nullable(),
});

export const ofc_connectionsInsertSchema = z.object({
  connection_category: z.string().optional(),
  connection_type: z.string().optional(),
  created_at: z.iso.datetime().nullable().optional(),
  destination_port: z.string().nullable().optional(),
  en_dom: z.iso.date().nullable().optional(),
  en_power_dbm: z.number().nullable().optional(),
  fiber_no_en: z.number(),
  fiber_no_sn: z.number(),
  fiber_role: z.string().nullable().optional(),
  id: z.uuid().optional(),
  logical_path_id: z.uuid().nullable().optional(),
  ofc_id: z.uuid(),
  otdr_distance_en_km: z.number().nullable().optional(),
  otdr_distance_sn_km: z.number().nullable().optional(),
  path_segment_order: z.number().nullable().optional(),
  remark: z.string().nullable().optional(),
  route_loss_db: z.number().nullable().optional(),
  sn_dom: z.iso.date().nullable().optional(),
  sn_power_dbm: z.number().nullable().optional(),
  source_port: z.string().nullable().optional(),
  status: z.boolean().nullable().optional(),
  system_id: z.uuid().nullable().optional(),
  updated_at: z.iso.datetime().nullable().optional(),
  updated_en_id: z.uuid().nullable().optional(),
  updated_fiber_no_en: z.number().nullable().optional(),
  updated_fiber_no_sn: z.number().nullable().optional(),
  updated_sn_id: z.uuid().nullable().optional(),
});

export const ofc_connectionsUpdateSchema = z.object({
  connection_category: z.string().optional(),
  connection_type: z.string().optional(),
  created_at: z.iso.datetime().nullable().optional(),
  destination_port: z.string().nullable().optional(),
  en_dom: z.iso.date().nullable().optional(),
  en_power_dbm: z.number().nullable().optional(),
  fiber_no_en: z.number().optional(),
  fiber_no_sn: z.number().optional(),
  fiber_role: z.string().nullable().optional(),
  id: z.uuid().optional(),
  logical_path_id: z.uuid().nullable().optional(),
  ofc_id: z.uuid().optional(),
  otdr_distance_en_km: z.number().nullable().optional(),
  otdr_distance_sn_km: z.number().nullable().optional(),
  path_segment_order: z.number().nullable().optional(),
  remark: z.string().nullable().optional(),
  route_loss_db: z.number().nullable().optional(),
  sn_dom: z.iso.date().nullable().optional(),
  sn_power_dbm: z.number().nullable().optional(),
  source_port: z.string().nullable().optional(),
  status: z.boolean().nullable().optional(),
  system_id: z.uuid().nullable().optional(),
  updated_at: z.iso.datetime().nullable().optional(),
  updated_en_id: z.uuid().nullable().optional(),
  updated_fiber_no_en: z.number().nullable().optional(),
  updated_fiber_no_sn: z.number().nullable().optional(),
  updated_sn_id: z.uuid().nullable().optional(),
});

export const ring_based_systemsRowSchema = z.object({
  maintenance_area_id: z.uuid().nullable(),
  ring_id: z.uuid().nullable(),
  system_id: z.uuid(),
});

export const ring_based_systemsInsertSchema = z.object({
  maintenance_area_id: z.uuid().nullable().optional(),
  ring_id: z.uuid().nullable().optional(),
  system_id: z.uuid(),
});

export const ring_based_systemsUpdateSchema = z.object({
  maintenance_area_id: z.uuid().nullable().optional(),
  ring_id: z.uuid().nullable().optional(),
  system_id: z.uuid().optional(),
});

export const ringsRowSchema = z.object({
  created_at: z.iso.datetime().nullable(),
  description: z.string().max(10000, "Text is too long").nullable(),
  id: z.uuid(),
  maintenance_terminal_id: z.uuid().nullable(),
  name: z.string().min(1, "Name cannot be empty").max(255, "Name is too long"),
  ring_type_id: z.uuid().nullable(),
  status: z.boolean().nullable(),
  total_nodes: z.number().nullable(),
  updated_at: z.iso.datetime().nullable(),
});

export const ringsInsertSchema = z.object({
  created_at: z.iso.datetime().nullable().optional(),
  description: z.string().max(10000, "Text is too long").nullable().optional(),
  id: z.uuid().optional(),
  maintenance_terminal_id: z.uuid().nullable().optional(),
  name: z.string().min(1, "Name cannot be empty").max(255, "Name is too long"),
  ring_type_id: z.uuid().nullable().optional(),
  status: z.boolean().nullable().optional(),
  total_nodes: z.number().nullable().optional(),
  updated_at: z.iso.datetime().nullable().optional(),
});

export const ringsUpdateSchema = z.object({
  created_at: z.iso.datetime().nullable().optional(),
  description: z.string().max(10000, "Text is too long").nullable().optional(),
  id: z.uuid().optional(),
  maintenance_terminal_id: z.uuid().nullable().optional(),
  name: z.string().min(1, "Name cannot be empty").max(255, "Name is too long").optional(),
  ring_type_id: z.uuid().nullable().optional(),
  status: z.boolean().nullable().optional(),
  total_nodes: z.number().nullable().optional(),
  updated_at: z.iso.datetime().nullable().optional(),
});

export const sdh_connectionsRowSchema = z.object({
  a_customer: z.string().nullable(),
  a_slot: z.string().nullable(),
  b_customer: z.string().nullable(),
  b_slot: z.string().nullable(),
  carrier: z.string().nullable(),
  stm_no: z.string().nullable(),
  system_connection_id: z.uuid(),
});

export const sdh_connectionsInsertSchema = z.object({
  a_customer: z.string().nullable().optional(),
  a_slot: z.string().nullable().optional(),
  b_customer: z.string().nullable().optional(),
  b_slot: z.string().nullable().optional(),
  carrier: z.string().nullable().optional(),
  stm_no: z.string().nullable().optional(),
  system_connection_id: z.uuid(),
});

export const sdh_connectionsUpdateSchema = z.object({
  a_customer: z.string().nullable().optional(),
  a_slot: z.string().nullable().optional(),
  b_customer: z.string().nullable().optional(),
  b_slot: z.string().nullable().optional(),
  carrier: z.string().nullable().optional(),
  stm_no: z.string().nullable().optional(),
  system_connection_id: z.uuid().optional(),
});

export const sdh_node_associationsRowSchema = z.object({
  id: z.uuid(),
  node_id: z.uuid(),
  node_ip: z.string().nullable(),
  node_position: z.string().nullable(),
  sdh_system_id: z.uuid(),
});

export const sdh_node_associationsInsertSchema = z.object({
  id: z.uuid().optional(),
  node_id: z.uuid(),
  node_ip: z.string().nullable().optional(),
  node_position: z.string().nullable().optional(),
  sdh_system_id: z.uuid(),
});

export const sdh_node_associationsUpdateSchema = z.object({
  id: z.uuid().optional(),
  node_id: z.uuid().optional(),
  node_ip: z.string().nullable().optional(),
  node_position: z.string().nullable().optional(),
  sdh_system_id: z.uuid().optional(),
});

export const sdh_systemsRowSchema = z.object({
  gne: z.string().nullable(),
  system_id: z.uuid(),
});

export const sdh_systemsInsertSchema = z.object({
  gne: z.string().nullable().optional(),
  system_id: z.uuid(),
});

export const sdh_systemsUpdateSchema = z.object({
  gne: z.string().nullable().optional(),
  system_id: z.uuid().optional(),
});

export const sfp_based_connectionsRowSchema = z.object({
  bandwidth_allocated_mbps: z.number().nullable(),
  customer_name: z.string().min(1, "Name cannot be empty").max(255, "Name is too long").nullable(),
  fiber_in: z.number().nullable(),
  fiber_out: z.number().nullable(),
  sfp_capacity: z.string().nullable(),
  sfp_port: z.string().nullable(),
  sfp_serial_no: z.string().nullable(),
  sfp_type_id: z.uuid().nullable(),
  system_connection_id: z.uuid(),
});

export const sfp_based_connectionsInsertSchema = z.object({
  bandwidth_allocated_mbps: z.number().nullable().optional(),
  customer_name: z.string().min(1, "Name cannot be empty").max(255, "Name is too long").nullable().optional(),
  fiber_in: z.number().nullable().optional(),
  fiber_out: z.number().nullable().optional(),
  sfp_capacity: z.string().nullable().optional(),
  sfp_port: z.string().nullable().optional(),
  sfp_serial_no: z.string().nullable().optional(),
  sfp_type_id: z.uuid().nullable().optional(),
  system_connection_id: z.uuid(),
});

export const sfp_based_connectionsUpdateSchema = z.object({
  bandwidth_allocated_mbps: z.number().nullable().optional(),
  customer_name: z.string().min(1, "Name cannot be empty").max(255, "Name is too long").nullable().optional(),
  fiber_in: z.number().nullable().optional(),
  fiber_out: z.number().nullable().optional(),
  sfp_capacity: z.string().nullable().optional(),
  sfp_port: z.string().nullable().optional(),
  sfp_serial_no: z.string().nullable().optional(),
  sfp_type_id: z.uuid().nullable().optional(),
  system_connection_id: z.uuid().optional(),
});

export const system_connectionsRowSchema = z.object({
  bandwidth_mbps: z.number().nullable(),
  commissioned_on: z.iso.date().nullable(),
  connected_system_id: z.uuid().nullable(),
  created_at: z.iso.datetime().nullable(),
  en_id: z.uuid().nullable(),
  en_interface: z.string().nullable(),
  en_ip: z.string().nullable(),
  id: z.uuid(),
  media_type_id: z.uuid().nullable(),
  remark: z.string().nullable(),
  sn_id: z.uuid().nullable(),
  sn_interface: z.string().nullable(),
  sn_ip: z.string().nullable(),
  status: z.boolean().nullable(),
  system_id: z.uuid(),
  updated_at: z.iso.datetime().nullable(),
  vlan: z.string().nullable(),
});

export const system_connectionsInsertSchema = z.object({
  bandwidth_mbps: z.number().nullable().optional(),
  commissioned_on: z.iso.date().nullable().optional(),
  connected_system_id: z.uuid().nullable().optional(),
  created_at: z.iso.datetime().nullable().optional(),
  en_id: z.uuid().nullable().optional(),
  en_interface: z.string().nullable().optional(),
  en_ip: z.string().nullable().optional(),
  id: z.uuid().optional(),
  media_type_id: z.uuid().nullable().optional(),
  remark: z.string().nullable().optional(),
  sn_id: z.uuid().nullable().optional(),
  sn_interface: z.string().nullable().optional(),
  sn_ip: z.string().nullable().optional(),
  status: z.boolean().nullable().optional(),
  system_id: z.uuid(),
  updated_at: z.iso.datetime().nullable().optional(),
  vlan: z.string().nullable().optional(),
});

export const system_connectionsUpdateSchema = z.object({
  bandwidth_mbps: z.number().nullable().optional(),
  commissioned_on: z.iso.date().nullable().optional(),
  connected_system_id: z.uuid().nullable().optional(),
  created_at: z.iso.datetime().nullable().optional(),
  en_id: z.uuid().nullable().optional(),
  en_interface: z.string().nullable().optional(),
  en_ip: z.string().nullable().optional(),
  id: z.uuid().optional(),
  media_type_id: z.uuid().nullable().optional(),
  remark: z.string().nullable().optional(),
  sn_id: z.uuid().nullable().optional(),
  sn_interface: z.string().nullable().optional(),
  sn_ip: z.string().nullable().optional(),
  status: z.boolean().nullable().optional(),
  system_id: z.uuid().optional(),
  updated_at: z.iso.datetime().nullable().optional(),
  vlan: z.string().nullable().optional(),
});

export const systemsRowSchema = z.object({
  commissioned_on: z.iso.date().nullable(),
  created_at: z.iso.datetime().nullable(),
  id: z.uuid(),
  ip_address: z.string().nullable(),
  maintenance_terminal_id: z.uuid().nullable(),
  make: z.string().nullable(),
  node_id: z.uuid(),
  remark: z.string().nullable(),
  s_no: z.string().nullable(),
  status: z.boolean().nullable(),
  system_name: z.string().min(1, "Name cannot be empty").max(255, "Name is too long").nullable(),
  system_type_id: z.uuid(),
  updated_at: z.iso.datetime().nullable(),
});

export const systemsInsertSchema = z.object({
  commissioned_on: z.iso.date().nullable().optional(),
  created_at: z.iso.datetime().nullable().optional(),
  id: z.uuid().optional(),
  ip_address: z.string().nullable().optional(),
  maintenance_terminal_id: z.uuid().nullable().optional(),
  make: z.string().nullable().optional(),
  node_id: z.uuid(),
  remark: z.string().nullable().optional(),
  s_no: z.string().nullable().optional(),
  status: z.boolean().nullable().optional(),
  system_name: z.string().min(1, "Name cannot be empty").max(255, "Name is too long").nullable().optional(),
  system_type_id: z.uuid(),
  updated_at: z.iso.datetime().nullable().optional(),
});

export const systemsUpdateSchema = z.object({
  commissioned_on: z.iso.date().nullable().optional(),
  created_at: z.iso.datetime().nullable().optional(),
  id: z.uuid().optional(),
  ip_address: z.string().nullable().optional(),
  maintenance_terminal_id: z.uuid().nullable().optional(),
  make: z.string().nullable().optional(),
  node_id: z.uuid().optional(),
  remark: z.string().nullable().optional(),
  s_no: z.string().nullable().optional(),
  status: z.boolean().nullable().optional(),
  system_name: z.string().min(1, "Name cannot be empty").max(255, "Name is too long").nullable().optional(),
  system_type_id: z.uuid().optional(),
  updated_at: z.iso.datetime().nullable().optional(),
});

export const user_profilesRowSchema = z.object({
  address: z.any().nullable(),
  avatar_url: z.url().nullable(),
  created_at: z.iso.datetime().nullable(),
  date_of_birth: z.iso.date().nullable(),
  designation: z.string().nullable(),
  first_name: z.string().min(1, "Name cannot be empty").max(255, "Name is too long"),
  id: z.uuid(),
  last_name: z.string().min(1, "Name cannot be empty").max(255, "Name is too long"),
  phone_number: z.string().regex(/^[+]?[1-9]?[0-9]{7,15}$/, "Invalid phone number").nullable(),
  preferences: z.any().nullable(),
  role: z.enum(UserRole).nullable(),
  status: z.string().min(1, "Status cannot be empty").nullable(),
  updated_at: z.iso.datetime().nullable(),
});

export const user_profilesInsertSchema = z.object({
  address: z.any().nullable().optional(),
  avatar_url: z.url().nullable().optional(),
  created_at: z.iso.datetime().nullable().optional(),
  date_of_birth: z.iso.date().nullable().optional(),
  designation: z.string().nullable().optional(),
  first_name: z.string().min(1, "Name cannot be empty").max(255, "Name is too long"),
  id: z.uuid(),
  last_name: z.string().min(1, "Name cannot be empty").max(255, "Name is too long"),
  phone_number: z.string().regex(/^[+]?[1-9]?[0-9]{7,15}$/, "Invalid phone number").nullable().optional(),
  preferences: z.any().nullable().optional(),
  role: z.enum(UserRole).nullable().optional(),
  status: z.string().min(1, "Status cannot be empty").nullable().optional(),
  updated_at: z.iso.datetime().nullable().optional(),
});

export const user_profilesUpdateSchema = z.object({
  address: z.any().nullable().optional(),
  avatar_url: z.url().nullable().optional(),
  created_at: z.iso.datetime().nullable().optional(),
  date_of_birth: z.iso.date().nullable().optional(),
  designation: z.string().nullable().optional(),
  first_name: z.string().min(1, "Name cannot be empty").max(255, "Name is too long").optional(),
  id: z.uuid().optional(),
  last_name: z.string().min(1, "Name cannot be empty").max(255, "Name is too long").optional(),
  phone_number: z.string().regex(/^[+]?[1-9]?[0-9]{7,15}$/, "Invalid phone number").nullable().optional(),
  preferences: z.any().nullable().optional(),
  role: z.enum(UserRole).nullable().optional(),
  status: z.string().min(1, "Status cannot be empty").nullable().optional(),
  updated_at: z.iso.datetime().nullable().optional(),
});

export const vmux_connectionsRowSchema = z.object({
  c_code: z.string().nullable(),
  channel: z.string().nullable(),
  subscriber: z.string().nullable(),
  system_connection_id: z.uuid(),
  tk: z.string().nullable(),
});

export const vmux_connectionsInsertSchema = z.object({
  c_code: z.string().nullable().optional(),
  channel: z.string().nullable().optional(),
  subscriber: z.string().nullable().optional(),
  system_connection_id: z.uuid(),
  tk: z.string().nullable().optional(),
});

export const vmux_connectionsUpdateSchema = z.object({
  c_code: z.string().nullable().optional(),
  channel: z.string().nullable().optional(),
  subscriber: z.string().nullable().optional(),
  system_connection_id: z.uuid().optional(),
  tk: z.string().nullable().optional(),
});

export const vmux_systemsRowSchema = z.object({
  system_id: z.uuid(),
  vm_id: z.uuid().nullable(),
});

export const vmux_systemsInsertSchema = z.object({
  system_id: z.uuid(),
  vm_id: z.uuid().nullable().optional(),
});

export const vmux_systemsUpdateSchema = z.object({
  system_id: z.uuid().optional(),
  vm_id: z.uuid().nullable().optional(),
});

export const v_cable_segments_at_jcRowSchema = z.object({
  end_node_id: z.uuid().nullable(),
  fiber_count: z.number().int().min(0).nullable(),
  id: z.uuid().nullable(),
  jc_node_id: z.uuid().nullable(),
  original_cable_id: z.uuid().nullable(),
  segment_order: z.number().nullable(),
  start_node_id: z.uuid().nullable(),
});

export const v_cable_utilizationRowSchema = z.object({
  available_fibers: z.number().nullable(),
  cable_id: z.uuid().nullable(),
  capacity: z.number().nullable(),
  route_name: z.string().min(1, "Name cannot be empty").max(255, "Name is too long").nullable(),
  used_fibers: z.number().nullable(),
  utilization_percent: z.number().min(0).max(100).nullable(),
});

export const v_employee_designationsRowSchema = z.object({
  created_at: z.iso.datetime().nullable(),
  id: z.uuid().nullable(),
  name: z.string().min(1, "Name cannot be empty").max(255, "Name is too long").nullable(),
  parent_id: z.uuid().nullable(),
  status: z.boolean().nullable(),
  updated_at: z.iso.datetime().nullable(),
});

export const v_employeesRowSchema = z.object({
  created_at: z.iso.datetime().nullable(),
  employee_addr: z.string().min(5, "Address must be at least 5 characters").max(500).nullable(),
  employee_contact: z.string().nullable(),
  employee_designation_id: z.uuid().nullable(),
  employee_designation_name: z.string().min(1, "Name cannot be empty").max(255, "Name is too long").nullable(),
  employee_dob: z.iso.date().nullable(),
  employee_doj: z.iso.date().nullable(),
  employee_email: z.email().nullable(),
  employee_name: z.string().min(1, "Name cannot be empty").max(255, "Name is too long").nullable(),
  employee_pers_no: z.string().nullable(),
  id: z.uuid().nullable(),
  maintenance_terminal_id: z.uuid().nullable(),
  remark: z.string().nullable(),
  status: z.boolean().nullable(),
  updated_at: z.iso.datetime().nullable(),
});

export const v_end_to_end_pathsRowSchema = z.object({
  destination_system_id: z.uuid().nullable(),
  operational_status: z.string().min(1, "Status cannot be empty").nullable(),
  path_id: z.uuid().nullable(),
  path_name: z.string().min(1, "Name cannot be empty").max(255, "Name is too long").nullable(),
  route_names: z.string().nullable(),
  segment_count: z.number().int().min(0).nullable(),
  source_system_id: z.uuid().nullable(),
  total_distance_km: z.number().nullable(),
  total_loss_db: z.number().nullable(),
});

export const v_junction_closures_completeRowSchema = z.object({
  id: z.uuid().nullable(),
  latitude: z.number().nullable(),
  longitude: z.number().nullable(),
  name: z.string().min(1, "Name cannot be empty").max(255, "Name is too long").nullable(),
  node_id: z.uuid().nullable(),
  ofc_cable_id: z.uuid().nullable(),
  position_km: z.number().nullable(),
});

export const v_lookup_typesRowSchema = z.object({
  category: z.string().nullable(),
  code: z.string().nullable(),
  created_at: z.iso.datetime().nullable(),
  description: z.string().max(10000, "Text is too long").nullable(),
  id: z.uuid().nullable(),
  is_system_default: z.boolean().nullable(),
  name: z.string().min(1, "Name cannot be empty").max(255, "Name is too long").nullable(),
  sort_order: z.number().nullable(),
  status: z.boolean().nullable(),
  updated_at: z.iso.datetime().nullable(),
});

export const v_maintenance_areasRowSchema = z.object({
  address: z.string().min(5, "Address must be at least 5 characters").max(500).nullable(),
  area_type_id: z.uuid().nullable(),
  code: z.string().nullable(),
  contact_number: z.string().nullable(),
  contact_person: z.string().nullable(),
  created_at: z.iso.datetime().nullable(),
  email: z.email().nullable(),
  id: z.uuid().nullable(),
  latitude: z.number().nullable(),
  longitude: z.number().nullable(),
  maintenance_area_type_code: z.string().nullable(),
  maintenance_area_type_name: z.string().min(1, "Name cannot be empty").max(255, "Name is too long").nullable(),
  name: z.string().min(1, "Name cannot be empty").max(255, "Name is too long").nullable(),
  parent_id: z.uuid().nullable(),
  status: z.boolean().nullable(),
  updated_at: z.iso.datetime().nullable(),
});

export const v_nodes_completeRowSchema = z.object({
  created_at: z.iso.datetime().nullable(),
  id: z.uuid().nullable(),
  latitude: z.number().nullable(),
  longitude: z.number().nullable(),
  maintenance_area_name: z.string().min(1, "Name cannot be empty").max(255, "Name is too long").nullable(),
  maintenance_terminal_id: z.uuid().nullable(),
  name: z.string().min(1, "Name cannot be empty").max(255, "Name is too long").nullable(),
  node_type_code: z.string().nullable(),
  node_type_id: z.uuid().nullable(),
  node_type_name: z.string().min(1, "Name cannot be empty").max(255, "Name is too long").nullable(),
  remark: z.string().nullable(),
  status: z.boolean().nullable(),
  updated_at: z.iso.datetime().nullable(),
});

export const v_ofc_cables_completeRowSchema = z.object({
  asset_no: z.string().nullable(),
  capacity: z.number().nullable(),
  commissioned_on: z.iso.date().nullable(),
  created_at: z.iso.datetime().nullable(),
  current_rkm: z.number().nullable(),
  en_id: z.uuid().nullable(),
  en_name: z.string().min(1, "Name cannot be empty").max(255, "Name is too long").nullable(),
  en_node_type_name: z.string().min(1, "Name cannot be empty").max(255, "Name is too long").nullable(),
  id: z.uuid().nullable(),
  maintenance_area_code: z.string().nullable(),
  maintenance_area_name: z.string().min(1, "Name cannot be empty").max(255, "Name is too long").nullable(),
  maintenance_terminal_id: z.uuid().nullable(),
  ofc_owner_code: z.string().nullable(),
  ofc_owner_id: z.uuid().nullable(),
  ofc_owner_name: z.string().min(1, "Name cannot be empty").max(255, "Name is too long").nullable(),
  ofc_type_code: z.string().nullable(),
  ofc_type_id: z.uuid().nullable(),
  ofc_type_name: z.string().min(1, "Name cannot be empty").max(255, "Name is too long").nullable(),
  remark: z.string().nullable(),
  route_name: z.string().min(1, "Name cannot be empty").max(255, "Name is too long").nullable(),
  sn_id: z.uuid().nullable(),
  sn_name: z.string().min(1, "Name cannot be empty").max(255, "Name is too long").nullable(),
  sn_node_type_name: z.string().min(1, "Name cannot be empty").max(255, "Name is too long").nullable(),
  status: z.boolean().nullable(),
  transnet_id: z.string().nullable().nullable(),
  transnet_rkm: z.number().nullable(),
  updated_at: z.iso.datetime().nullable(),
});

export const v_ofc_connections_completeRowSchema = z.object({
  connection_category: z.string().nullable(),
  connection_type: z.string().nullable(),
  created_at: z.iso.datetime().nullable(),
  destination_port: z.string().nullable(),
  en_dom: z.iso.date().nullable(),
  en_id: z.uuid().nullable(),
  en_name: z.string().min(1, "Name cannot be empty").max(255, "Name is too long").nullable(),
  en_power_dbm: z.number().nullable(),
  fiber_no_en: z.number().nullable(),
  fiber_no_sn: z.number().nullable(),
  fiber_role: z.string().nullable(),
  id: z.uuid().nullable(),
  logical_path_id: z.uuid().nullable(),
  maintenance_area_name: z.string().min(1, "Name cannot be empty").max(255, "Name is too long").nullable(),
  ofc_id: z.uuid().nullable(),
  ofc_route_name: z.string().min(1, "Name cannot be empty").max(255, "Name is too long").nullable(),
  ofc_type_name: z.string().min(1, "Name cannot be empty").max(255, "Name is too long").nullable(),
  otdr_distance_en_km: z.number().nullable(),
  otdr_distance_sn_km: z.number().nullable(),
  path_segment_order: z.number().nullable(),
  remark: z.string().nullable(),
  route_loss_db: z.number().nullable(),
  sn_dom: z.iso.date().nullable(),
  sn_id: z.uuid().nullable(),
  sn_name: z.string().min(1, "Name cannot be empty").max(255, "Name is too long").nullable(),
  sn_power_dbm: z.number().nullable(),
  source_port: z.string().nullable(),
  status: z.boolean().nullable(),
  system_id: z.uuid().nullable(),
  system_name: z.string().min(1, "Name cannot be empty").max(255, "Name is too long").nullable(),
  updated_at: z.iso.datetime().nullable(),
  updated_en_id: z.uuid().nullable(),
  updated_en_name: z.iso.datetime().nullable(),
  updated_fiber_no_en: z.number().nullable(),
  updated_fiber_no_sn: z.number().nullable(),
  updated_sn_id: z.uuid().nullable(),
  updated_sn_name: z.iso.datetime().nullable(),
});

export const v_ring_nodesRowSchema = z.object({
  id: z.uuid().nullable(),
  ip: z.ipv4().nullable(),
  lat: z.number().nullable(),
  long: z.number().nullable(),
  name: z.string().min(1, "Name cannot be empty").max(255, "Name is too long").nullable(),
  order_in_ring: z.number().nullable(),
  remark: z.string().nullable(),
  ring_id: z.uuid().nullable(),
  ring_name: z.string().min(1, "Name cannot be empty").max(255, "Name is too long").nullable(),
  ring_status: z.boolean().nullable(),
  system_status: z.boolean().nullable(),
  type: z.string().nullable(),
});

export const v_ringsRowSchema = z.object({
  created_at: z.iso.datetime().nullable(),
  description: z.string().max(10000, "Text is too long").nullable(),
  id: z.uuid().nullable(),
  maintenance_area_name: z.string().min(1, "Name cannot be empty").max(255, "Name is too long").nullable(),
  maintenance_terminal_id: z.uuid().nullable(),
  name: z.string().min(1, "Name cannot be empty").max(255, "Name is too long").nullable(),
  ring_type_code: z.string().nullable(),
  ring_type_id: z.uuid().nullable(),
  ring_type_name: z.string().min(1, "Name cannot be empty").max(255, "Name is too long").nullable(),
  status: z.boolean().nullable(),
  total_nodes: z.number().nullable(),
  updated_at: z.iso.datetime().nullable(),
});

export const v_system_connections_completeRowSchema = z.object({
  bandwidth_allocated_mbps: z.number().nullable(),
  bandwidth_mbps: z.number().nullable(),
  commissioned_on: z.iso.date().nullable(),
  connected_system_name: z.string().min(1, "Name cannot be empty").max(255, "Name is too long").nullable(),
  connected_system_type_name: z.string().min(1, "Name cannot be empty").max(255, "Name is too long").nullable(),
  created_at: z.iso.datetime().nullable(),
  customer_name: z.string().min(1, "Name cannot be empty").max(255, "Name is too long").nullable(),
  en_interface: z.string().nullable(),
  en_ip: z.string().nullable(),
  en_name: z.string().min(1, "Name cannot be empty").max(255, "Name is too long").nullable(),
  en_node_name: z.string().min(1, "Name cannot be empty").max(255, "Name is too long").nullable(),
  fiber_in: z.number().nullable(),
  fiber_out: z.number().nullable(),
  id: z.uuid().nullable(),
  media_type_name: z.string().min(1, "Name cannot be empty").max(255, "Name is too long").nullable(),
  remark: z.string().nullable(),
  sdh_a_customer: z.string().nullable(),
  sdh_a_slot: z.string().nullable(),
  sdh_b_customer: z.string().nullable(),
  sdh_b_slot: z.string().nullable(),
  sdh_carrier: z.string().nullable(),
  sdh_stm_no: z.string().nullable(),
  sfp_capacity: z.string().nullable(),
  sfp_port: z.string().nullable(),
  sfp_serial_no: z.string().nullable(),
  sfp_type_name: z.string().min(1, "Name cannot be empty").max(255, "Name is too long").nullable(),
  sn_interface: z.string().nullable(),
  sn_ip: z.string().nullable(),
  sn_name: z.string().min(1, "Name cannot be empty").max(255, "Name is too long").nullable(),
  sn_node_name: z.string().min(1, "Name cannot be empty").max(255, "Name is too long").nullable(),
  status: z.boolean().nullable(),
  system_id: z.uuid().nullable(),
  system_name: z.string().min(1, "Name cannot be empty").max(255, "Name is too long").nullable(),
  system_type_name: z.string().min(1, "Name cannot be empty").max(255, "Name is too long").nullable(),
  updated_at: z.iso.datetime().nullable(),
  vlan: z.string().nullable(),
  vmux_c_code: z.string().nullable(),
  vmux_channel: z.string().nullable(),
  vmux_subscriber: z.string().nullable(),
  vmux_tk: z.string().nullable(),
});

export const v_system_ring_paths_detailedRowSchema = z.object({
  created_at: z.iso.datetime().nullable(),
  end_node_id: z.uuid().nullable(),
  end_node_name: z.string().min(1, "Name cannot be empty").max(255, "Name is too long").nullable(),
  id: z.uuid().nullable(),
  logical_path_id: z.uuid().nullable(),
  ofc_cable_id: z.uuid().nullable(),
  path_name: z.string().min(1, "Name cannot be empty").max(255, "Name is too long").nullable(),
  path_order: z.number().nullable(),
  route_name: z.string().min(1, "Name cannot be empty").max(255, "Name is too long").nullable(),
  source_system_id: z.uuid().nullable(),
  start_node_id: z.uuid().nullable(),
  start_node_name: z.string().min(1, "Name cannot be empty").max(255, "Name is too long").nullable(),
});

export const v_systems_completeRowSchema = z.object({
  commissioned_on: z.iso.date().nullable(),
  created_at: z.iso.datetime().nullable(),
  id: z.uuid().nullable(),
  ip_address: z.string().nullable(),
  latitude: z.number().nullable(),
  longitude: z.number().nullable(),
  maintenance_terminal_id: z.uuid().nullable(),
  make: z.string().nullable(),
  node_id: z.uuid().nullable(),
  node_name: z.string().min(1, "Name cannot be empty").max(255, "Name is too long").nullable(),
  node_type_name: z.string().min(1, "Name cannot be empty").max(255, "Name is too long").nullable(),
  remark: z.string().nullable(),
  ring_id: z.uuid().nullable(),
  ring_logical_area_name: z.string().min(1, "Name cannot be empty").max(255, "Name is too long").nullable(),
  s_no: z.string().nullable(),
  sdh_gne: z.string().nullable(),
  status: z.boolean().nullable(),
  system_category: z.string().nullable(),
  system_maintenance_terminal_name: z.string().min(1, "Name cannot be empty").max(255, "Name is too long").nullable(),
  system_name: z.string().min(1, "Name cannot be empty").max(255, "Name is too long").nullable(),
  system_type_code: z.string().nullable(),
  system_type_id: z.uuid().nullable(),
  system_type_name: z.string().min(1, "Name cannot be empty").max(255, "Name is too long").nullable(),
  updated_at: z.iso.datetime().nullable(),
  vmux_vm_id: z.uuid().nullable(),
});

export const v_user_profiles_extendedRowSchema = z.object({
  account_age_days: z.number().int().min(0).max(150).nullable(),
  address: z.any().nullable(),
  auth_updated_at: z.iso.datetime().nullable(),
  avatar_url: z.url().nullable(),
  computed_status: z.string().min(1, "Status cannot be empty").nullable(),
  created_at: z.iso.datetime().nullable(),
  date_of_birth: z.iso.date().nullable(),
  designation: z.string().nullable(),
  email: z.email().nullable(),
  email_confirmed_at: z.email().nullable(),
  first_name: z.string().min(1, "Name cannot be empty").max(255, "Name is too long").nullable(),
  full_name: z.string().min(1, "Name cannot be empty").max(255, "Name is too long").nullable(),
  id: z.uuid().nullable(),
  is_email_verified: z.boolean().nullable(),
  is_phone_verified: z.boolean().nullable(),
  is_super_admin: z.boolean().nullable(),
  last_activity_period: z.string().nullable(),
  last_name: z.string().min(1, "Name cannot be empty").max(255, "Name is too long").nullable(),
  last_sign_in_at: z.iso.datetime().nullable(),
  phone_confirmed_at: z.string().regex(/^[+]?[1-9]?[0-9]{7,15}$/, "Invalid phone number").nullable(),
  phone_number: z.string().regex(/^[+]?[1-9]?[0-9]{7,15}$/, "Invalid phone number").nullable(),
  preferences: z.any().nullable(),
  raw_app_meta_data: z.any().nullable(),
  raw_user_meta_data: z.any().nullable(),
  role: z.enum(UserRole).nullable(),
  status: z.string().min(1, "Status cannot be empty").nullable(),
  updated_at: z.iso.datetime().nullable(),
});

// ============= CONVENIENCE EXPORTS =============

export const schemas = {
  authAudit_log_entriesRowSchema,
  authAudit_log_entriesInsertSchema,
  authAudit_log_entriesUpdateSchema,
  authFlow_stateRowSchema,
  authFlow_stateInsertSchema,
  authFlow_stateUpdateSchema,
  authIdentitiesRowSchema,
  authIdentitiesInsertSchema,
  authIdentitiesUpdateSchema,
  authInstancesRowSchema,
  authInstancesInsertSchema,
  authInstancesUpdateSchema,
  authMfa_amr_claimsRowSchema,
  authMfa_amr_claimsInsertSchema,
  authMfa_amr_claimsUpdateSchema,
  authMfa_challengesRowSchema,
  authMfa_challengesInsertSchema,
  authMfa_challengesUpdateSchema,
  authMfa_factorsRowSchema,
  authMfa_factorsInsertSchema,
  authMfa_factorsUpdateSchema,
  authOauth_clientsRowSchema,
  authOauth_clientsInsertSchema,
  authOauth_clientsUpdateSchema,
  authOne_time_tokensRowSchema,
  authOne_time_tokensInsertSchema,
  authOne_time_tokensUpdateSchema,
  authRefresh_tokensRowSchema,
  authRefresh_tokensInsertSchema,
  authRefresh_tokensUpdateSchema,
  authSaml_providersRowSchema,
  authSaml_providersInsertSchema,
  authSaml_providersUpdateSchema,
  authSaml_relay_statesRowSchema,
  authSaml_relay_statesInsertSchema,
  authSaml_relay_statesUpdateSchema,
  authSchema_migrationsRowSchema,
  authSchema_migrationsInsertSchema,
  authSchema_migrationsUpdateSchema,
  authSessionsRowSchema,
  authSessionsInsertSchema,
  authSessionsUpdateSchema,
  authSso_domainsRowSchema,
  authSso_domainsInsertSchema,
  authSso_domainsUpdateSchema,
  authSso_providersRowSchema,
  authSso_providersInsertSchema,
  authSso_providersUpdateSchema,
  authUsersRowSchema,
  authUsersInsertSchema,
  authUsersUpdateSchema,
  cable_segmentsRowSchema,
  cable_segmentsInsertSchema,
  cable_segmentsUpdateSchema,
  employee_designationsRowSchema,
  employee_designationsInsertSchema,
  employee_designationsUpdateSchema,
  employeesRowSchema,
  employeesInsertSchema,
  employeesUpdateSchema,
  fiber_splicesRowSchema,
  fiber_splicesInsertSchema,
  fiber_splicesUpdateSchema,
  filesRowSchema,
  filesInsertSchema,
  filesUpdateSchema,
  foldersRowSchema,
  foldersInsertSchema,
  foldersUpdateSchema,
  junction_closuresRowSchema,
  junction_closuresInsertSchema,
  junction_closuresUpdateSchema,
  logical_fiber_pathsRowSchema,
  logical_fiber_pathsInsertSchema,
  logical_fiber_pathsUpdateSchema,
  logical_path_segmentsRowSchema,
  logical_path_segmentsInsertSchema,
  logical_path_segmentsUpdateSchema,
  lookup_typesRowSchema,
  lookup_typesInsertSchema,
  lookup_typesUpdateSchema,
  maintenance_areasRowSchema,
  maintenance_areasInsertSchema,
  maintenance_areasUpdateSchema,
  management_portsRowSchema,
  management_portsInsertSchema,
  management_portsUpdateSchema,
  nodesRowSchema,
  nodesInsertSchema,
  nodesUpdateSchema,
  ofc_cablesRowSchema,
  ofc_cablesInsertSchema,
  ofc_cablesUpdateSchema,
  ofc_connectionsRowSchema,
  ofc_connectionsInsertSchema,
  ofc_connectionsUpdateSchema,
  ring_based_systemsRowSchema,
  ring_based_systemsInsertSchema,
  ring_based_systemsUpdateSchema,
  ringsRowSchema,
  ringsInsertSchema,
  ringsUpdateSchema,
  sdh_connectionsRowSchema,
  sdh_connectionsInsertSchema,
  sdh_connectionsUpdateSchema,
  sdh_node_associationsRowSchema,
  sdh_node_associationsInsertSchema,
  sdh_node_associationsUpdateSchema,
  sdh_systemsRowSchema,
  sdh_systemsInsertSchema,
  sdh_systemsUpdateSchema,
  sfp_based_connectionsRowSchema,
  sfp_based_connectionsInsertSchema,
  sfp_based_connectionsUpdateSchema,
  system_connectionsRowSchema,
  system_connectionsInsertSchema,
  system_connectionsUpdateSchema,
  systemsRowSchema,
  systemsInsertSchema,
  systemsUpdateSchema,
  user_profilesRowSchema,
  user_profilesInsertSchema,
  user_profilesUpdateSchema,
  vmux_connectionsRowSchema,
  vmux_connectionsInsertSchema,
  vmux_connectionsUpdateSchema,
  vmux_systemsRowSchema,
  vmux_systemsInsertSchema,
  vmux_systemsUpdateSchema,
  v_cable_segments_at_jcRowSchema,
  v_cable_utilizationRowSchema,
  v_employee_designationsRowSchema,
  v_employeesRowSchema,
  v_end_to_end_pathsRowSchema,
  v_junction_closures_completeRowSchema,
  v_lookup_typesRowSchema,
  v_maintenance_areasRowSchema,
  v_nodes_completeRowSchema,
  v_ofc_cables_completeRowSchema,
  v_ofc_connections_completeRowSchema,
  v_ring_nodesRowSchema,
  v_ringsRowSchema,
  v_system_connections_completeRowSchema,
  v_system_ring_paths_detailedRowSchema,
  v_systems_completeRowSchema,
  v_user_profiles_extendedRowSchema,
} as const;

// ============= TYPE EXPORTS =============

export type AuthAudit_log_entriesRowSchema = z.infer<typeof authAudit_log_entriesRowSchema>;
export type AuthAudit_log_entriesInsertSchema = z.infer<typeof authAudit_log_entriesInsertSchema>;
export type AuthAudit_log_entriesUpdateSchema = z.infer<typeof authAudit_log_entriesUpdateSchema>;
export type AuthFlow_stateRowSchema = z.infer<typeof authFlow_stateRowSchema>;
export type AuthFlow_stateInsertSchema = z.infer<typeof authFlow_stateInsertSchema>;
export type AuthFlow_stateUpdateSchema = z.infer<typeof authFlow_stateUpdateSchema>;
export type AuthIdentitiesRowSchema = z.infer<typeof authIdentitiesRowSchema>;
export type AuthIdentitiesInsertSchema = z.infer<typeof authIdentitiesInsertSchema>;
export type AuthIdentitiesUpdateSchema = z.infer<typeof authIdentitiesUpdateSchema>;
export type AuthInstancesRowSchema = z.infer<typeof authInstancesRowSchema>;
export type AuthInstancesInsertSchema = z.infer<typeof authInstancesInsertSchema>;
export type AuthInstancesUpdateSchema = z.infer<typeof authInstancesUpdateSchema>;
export type AuthMfa_amr_claimsRowSchema = z.infer<typeof authMfa_amr_claimsRowSchema>;
export type AuthMfa_amr_claimsInsertSchema = z.infer<typeof authMfa_amr_claimsInsertSchema>;
export type AuthMfa_amr_claimsUpdateSchema = z.infer<typeof authMfa_amr_claimsUpdateSchema>;
export type AuthMfa_challengesRowSchema = z.infer<typeof authMfa_challengesRowSchema>;
export type AuthMfa_challengesInsertSchema = z.infer<typeof authMfa_challengesInsertSchema>;
export type AuthMfa_challengesUpdateSchema = z.infer<typeof authMfa_challengesUpdateSchema>;
export type AuthMfa_factorsRowSchema = z.infer<typeof authMfa_factorsRowSchema>;
export type AuthMfa_factorsInsertSchema = z.infer<typeof authMfa_factorsInsertSchema>;
export type AuthMfa_factorsUpdateSchema = z.infer<typeof authMfa_factorsUpdateSchema>;
export type AuthOauth_clientsRowSchema = z.infer<typeof authOauth_clientsRowSchema>;
export type AuthOauth_clientsInsertSchema = z.infer<typeof authOauth_clientsInsertSchema>;
export type AuthOauth_clientsUpdateSchema = z.infer<typeof authOauth_clientsUpdateSchema>;
export type AuthOne_time_tokensRowSchema = z.infer<typeof authOne_time_tokensRowSchema>;
export type AuthOne_time_tokensInsertSchema = z.infer<typeof authOne_time_tokensInsertSchema>;
export type AuthOne_time_tokensUpdateSchema = z.infer<typeof authOne_time_tokensUpdateSchema>;
export type AuthRefresh_tokensRowSchema = z.infer<typeof authRefresh_tokensRowSchema>;
export type AuthRefresh_tokensInsertSchema = z.infer<typeof authRefresh_tokensInsertSchema>;
export type AuthRefresh_tokensUpdateSchema = z.infer<typeof authRefresh_tokensUpdateSchema>;
export type AuthSaml_providersRowSchema = z.infer<typeof authSaml_providersRowSchema>;
export type AuthSaml_providersInsertSchema = z.infer<typeof authSaml_providersInsertSchema>;
export type AuthSaml_providersUpdateSchema = z.infer<typeof authSaml_providersUpdateSchema>;
export type AuthSaml_relay_statesRowSchema = z.infer<typeof authSaml_relay_statesRowSchema>;
export type AuthSaml_relay_statesInsertSchema = z.infer<typeof authSaml_relay_statesInsertSchema>;
export type AuthSaml_relay_statesUpdateSchema = z.infer<typeof authSaml_relay_statesUpdateSchema>;
export type AuthSchema_migrationsRowSchema = z.infer<typeof authSchema_migrationsRowSchema>;
export type AuthSchema_migrationsInsertSchema = z.infer<typeof authSchema_migrationsInsertSchema>;
export type AuthSchema_migrationsUpdateSchema = z.infer<typeof authSchema_migrationsUpdateSchema>;
export type AuthSessionsRowSchema = z.infer<typeof authSessionsRowSchema>;
export type AuthSessionsInsertSchema = z.infer<typeof authSessionsInsertSchema>;
export type AuthSessionsUpdateSchema = z.infer<typeof authSessionsUpdateSchema>;
export type AuthSso_domainsRowSchema = z.infer<typeof authSso_domainsRowSchema>;
export type AuthSso_domainsInsertSchema = z.infer<typeof authSso_domainsInsertSchema>;
export type AuthSso_domainsUpdateSchema = z.infer<typeof authSso_domainsUpdateSchema>;
export type AuthSso_providersRowSchema = z.infer<typeof authSso_providersRowSchema>;
export type AuthSso_providersInsertSchema = z.infer<typeof authSso_providersInsertSchema>;
export type AuthSso_providersUpdateSchema = z.infer<typeof authSso_providersUpdateSchema>;
export type AuthUsersRowSchema = z.infer<typeof authUsersRowSchema>;
export type AuthUsersInsertSchema = z.infer<typeof authUsersInsertSchema>;
export type AuthUsersUpdateSchema = z.infer<typeof authUsersUpdateSchema>;
export type Cable_segmentsRowSchema = z.infer<typeof cable_segmentsRowSchema>;
export type Cable_segmentsInsertSchema = z.infer<typeof cable_segmentsInsertSchema>;
export type Cable_segmentsUpdateSchema = z.infer<typeof cable_segmentsUpdateSchema>;
export type Employee_designationsRowSchema = z.infer<typeof employee_designationsRowSchema>;
export type Employee_designationsInsertSchema = z.infer<typeof employee_designationsInsertSchema>;
export type Employee_designationsUpdateSchema = z.infer<typeof employee_designationsUpdateSchema>;
export type EmployeesRowSchema = z.infer<typeof employeesRowSchema>;
export type EmployeesInsertSchema = z.infer<typeof employeesInsertSchema>;
export type EmployeesUpdateSchema = z.infer<typeof employeesUpdateSchema>;
export type Fiber_splicesRowSchema = z.infer<typeof fiber_splicesRowSchema>;
export type Fiber_splicesInsertSchema = z.infer<typeof fiber_splicesInsertSchema>;
export type Fiber_splicesUpdateSchema = z.infer<typeof fiber_splicesUpdateSchema>;
export type FilesRowSchema = z.infer<typeof filesRowSchema>;
export type FilesInsertSchema = z.infer<typeof filesInsertSchema>;
export type FilesUpdateSchema = z.infer<typeof filesUpdateSchema>;
export type FoldersRowSchema = z.infer<typeof foldersRowSchema>;
export type FoldersInsertSchema = z.infer<typeof foldersInsertSchema>;
export type FoldersUpdateSchema = z.infer<typeof foldersUpdateSchema>;
export type Junction_closuresRowSchema = z.infer<typeof junction_closuresRowSchema>;
export type Junction_closuresInsertSchema = z.infer<typeof junction_closuresInsertSchema>;
export type Junction_closuresUpdateSchema = z.infer<typeof junction_closuresUpdateSchema>;
export type Logical_fiber_pathsRowSchema = z.infer<typeof logical_fiber_pathsRowSchema>;
export type Logical_fiber_pathsInsertSchema = z.infer<typeof logical_fiber_pathsInsertSchema>;
export type Logical_fiber_pathsUpdateSchema = z.infer<typeof logical_fiber_pathsUpdateSchema>;
export type Logical_path_segmentsRowSchema = z.infer<typeof logical_path_segmentsRowSchema>;
export type Logical_path_segmentsInsertSchema = z.infer<typeof logical_path_segmentsInsertSchema>;
export type Logical_path_segmentsUpdateSchema = z.infer<typeof logical_path_segmentsUpdateSchema>;
export type Lookup_typesRowSchema = z.infer<typeof lookup_typesRowSchema>;
export type Lookup_typesInsertSchema = z.infer<typeof lookup_typesInsertSchema>;
export type Lookup_typesUpdateSchema = z.infer<typeof lookup_typesUpdateSchema>;
export type Maintenance_areasRowSchema = z.infer<typeof maintenance_areasRowSchema>;
export type Maintenance_areasInsertSchema = z.infer<typeof maintenance_areasInsertSchema>;
export type Maintenance_areasUpdateSchema = z.infer<typeof maintenance_areasUpdateSchema>;
export type Management_portsRowSchema = z.infer<typeof management_portsRowSchema>;
export type Management_portsInsertSchema = z.infer<typeof management_portsInsertSchema>;
export type Management_portsUpdateSchema = z.infer<typeof management_portsUpdateSchema>;
export type NodesRowSchema = z.infer<typeof nodesRowSchema>;
export type NodesInsertSchema = z.infer<typeof nodesInsertSchema>;
export type NodesUpdateSchema = z.infer<typeof nodesUpdateSchema>;
export type Ofc_cablesRowSchema = z.infer<typeof ofc_cablesRowSchema>;
export type Ofc_cablesInsertSchema = z.infer<typeof ofc_cablesInsertSchema>;
export type Ofc_cablesUpdateSchema = z.infer<typeof ofc_cablesUpdateSchema>;
export type Ofc_connectionsRowSchema = z.infer<typeof ofc_connectionsRowSchema>;
export type Ofc_connectionsInsertSchema = z.infer<typeof ofc_connectionsInsertSchema>;
export type Ofc_connectionsUpdateSchema = z.infer<typeof ofc_connectionsUpdateSchema>;
export type Ring_based_systemsRowSchema = z.infer<typeof ring_based_systemsRowSchema>;
export type Ring_based_systemsInsertSchema = z.infer<typeof ring_based_systemsInsertSchema>;
export type Ring_based_systemsUpdateSchema = z.infer<typeof ring_based_systemsUpdateSchema>;
export type RingsRowSchema = z.infer<typeof ringsRowSchema>;
export type RingsInsertSchema = z.infer<typeof ringsInsertSchema>;
export type RingsUpdateSchema = z.infer<typeof ringsUpdateSchema>;
export type Sdh_connectionsRowSchema = z.infer<typeof sdh_connectionsRowSchema>;
export type Sdh_connectionsInsertSchema = z.infer<typeof sdh_connectionsInsertSchema>;
export type Sdh_connectionsUpdateSchema = z.infer<typeof sdh_connectionsUpdateSchema>;
export type Sdh_node_associationsRowSchema = z.infer<typeof sdh_node_associationsRowSchema>;
export type Sdh_node_associationsInsertSchema = z.infer<typeof sdh_node_associationsInsertSchema>;
export type Sdh_node_associationsUpdateSchema = z.infer<typeof sdh_node_associationsUpdateSchema>;
export type Sdh_systemsRowSchema = z.infer<typeof sdh_systemsRowSchema>;
export type Sdh_systemsInsertSchema = z.infer<typeof sdh_systemsInsertSchema>;
export type Sdh_systemsUpdateSchema = z.infer<typeof sdh_systemsUpdateSchema>;
export type Sfp_based_connectionsRowSchema = z.infer<typeof sfp_based_connectionsRowSchema>;
export type Sfp_based_connectionsInsertSchema = z.infer<typeof sfp_based_connectionsInsertSchema>;
export type Sfp_based_connectionsUpdateSchema = z.infer<typeof sfp_based_connectionsUpdateSchema>;
export type System_connectionsRowSchema = z.infer<typeof system_connectionsRowSchema>;
export type System_connectionsInsertSchema = z.infer<typeof system_connectionsInsertSchema>;
export type System_connectionsUpdateSchema = z.infer<typeof system_connectionsUpdateSchema>;
export type SystemsRowSchema = z.infer<typeof systemsRowSchema>;
export type SystemsInsertSchema = z.infer<typeof systemsInsertSchema>;
export type SystemsUpdateSchema = z.infer<typeof systemsUpdateSchema>;
export type User_profilesRowSchema = z.infer<typeof user_profilesRowSchema>;
export type User_profilesInsertSchema = z.infer<typeof user_profilesInsertSchema>;
export type User_profilesUpdateSchema = z.infer<typeof user_profilesUpdateSchema>;
export type Vmux_connectionsRowSchema = z.infer<typeof vmux_connectionsRowSchema>;
export type Vmux_connectionsInsertSchema = z.infer<typeof vmux_connectionsInsertSchema>;
export type Vmux_connectionsUpdateSchema = z.infer<typeof vmux_connectionsUpdateSchema>;
export type Vmux_systemsRowSchema = z.infer<typeof vmux_systemsRowSchema>;
export type Vmux_systemsInsertSchema = z.infer<typeof vmux_systemsInsertSchema>;
export type Vmux_systemsUpdateSchema = z.infer<typeof vmux_systemsUpdateSchema>;
export type V_cable_segments_at_jcRowSchema = z.infer<typeof v_cable_segments_at_jcRowSchema>;
export type V_cable_utilizationRowSchema = z.infer<typeof v_cable_utilizationRowSchema>;
export type V_employee_designationsRowSchema = z.infer<typeof v_employee_designationsRowSchema>;
export type V_employeesRowSchema = z.infer<typeof v_employeesRowSchema>;
export type V_end_to_end_pathsRowSchema = z.infer<typeof v_end_to_end_pathsRowSchema>;
export type V_junction_closures_completeRowSchema = z.infer<typeof v_junction_closures_completeRowSchema>;
export type V_lookup_typesRowSchema = z.infer<typeof v_lookup_typesRowSchema>;
export type V_maintenance_areasRowSchema = z.infer<typeof v_maintenance_areasRowSchema>;
export type V_nodes_completeRowSchema = z.infer<typeof v_nodes_completeRowSchema>;
export type V_ofc_cables_completeRowSchema = z.infer<typeof v_ofc_cables_completeRowSchema>;
export type V_ofc_connections_completeRowSchema = z.infer<typeof v_ofc_connections_completeRowSchema>;
export type V_ring_nodesRowSchema = z.infer<typeof v_ring_nodesRowSchema>;
export type V_ringsRowSchema = z.infer<typeof v_ringsRowSchema>;
export type V_system_connections_completeRowSchema = z.infer<typeof v_system_connections_completeRowSchema>;
export type V_system_ring_paths_detailedRowSchema = z.infer<typeof v_system_ring_paths_detailedRowSchema>;
export type V_systems_completeRowSchema = z.infer<typeof v_systems_completeRowSchema>;
export type V_user_profiles_extendedRowSchema = z.infer<typeof v_user_profiles_extendedRowSchema>;

```

<!-- path: schemas/system-schemas.ts -->
```typescript
// path: schemas/system-schemas.ts
import { z } from 'zod';
import {
  systemsInsertSchema,
  sdh_systemsInsertSchema,
  vmux_systemsInsertSchema,
  ring_based_systemsInsertSchema,
} from './zod-schemas';

// THIS IS THE NEW, CORRECT SCHEMA FOR THE FORM.
// It allows for optional fields and uses strings for UUIDs, which matches the form's state.
export const systemFormValidationSchema = systemsInsertSchema
  .omit({
    created_at: true,
    updated_at: true,
    id: true,
  })
  .merge(ring_based_systemsInsertSchema.pick({ ring_id: true }))
  .merge(sdh_systemsInsertSchema.pick({ gne: true }))
  .merge(vmux_systemsInsertSchema.pick({ vm_id: true }));

// This is the type that will be used by the form state.
export type SystemFormData = z.infer<typeof systemFormValidationSchema>;


```

<!-- path: hooks/useOutdatedBrowserCheck.tsx -->
```typescript
// hooks/useOutdatedBrowserCheck.tsx
import { useEffect, useState } from 'react';

const LOCAL_KEY = 'isOutdatedBrowser';

function detectOutdatedBrowser(): boolean {
  if (typeof window === 'undefined' || typeof navigator === 'undefined') {
    return false;
  }
  
  // **Priority 1: Feature Detection**
  const missingFeatures = [
    () => typeof Promise?.allSettled !== 'function', // ES2020
    () => typeof window.crypto?.subtle === 'undefined', // Web Crypto API
    () => !CSS.supports('display', 'grid'),
    () => !CSS.supports('position', 'sticky'),
    () => !('IntersectionObserver' in window),
    () => !('localStorage' in window),
    () => !('structuredClone' in window), // A more modern feature
  ].some(fn => fn());

  if (missingFeatures) {
    return true;
  }

  // **Priority 2: User-Agent Sniffing as a fallback for known legacy browsers**
  const ua = navigator.userAgent;

  // Rule out Internet Explorer immediately
  const isIE = /MSIE|Trident/.test(ua);
  if (isIE) {
    return true;
  }
  
  // Check for very old versions of other browsers
  const legacyEdgeMatch = ua.match(/Edge\/(\d+)/); // Non-Chromium Edge
  if (legacyEdgeMatch && parseInt(legacyEdgeMatch[1]) < 18) {
    return true;
  }

  // At this point, the browser is likely modern enough.
  return false;
}

export function useOutdatedBrowserCheck(): boolean | null {
  const [isOutdated, setIsOutdated] = useState<boolean | null>(null);

  useEffect(() => {
    // Only run on the client
    if (typeof window === 'undefined') return;

    const cached = localStorage.getItem(LOCAL_KEY);
    if (cached !== null) {
      setIsOutdated(cached === 'true');
      return;
    }

    const result = detectOutdatedBrowser();
    localStorage.setItem(LOCAL_KEY, String(result));
    setIsOutdated(result);
  }, []);

  return isOutdated;
}
```

<!-- path: hooks/useEntityManagement.ts -->
```typescript
"use client";

import { BaseEntity, EntityWithChildren, isHierarchicalEntity, UseEntityManagementProps } from "@/components/common/entity-management/types";
import { useCallback, useMemo, useState } from "react";

export function useEntityManagement<T extends BaseEntity>({
  entitiesQuery,
  config,
  onDelete,
  onCreateNew,
  selectedEntityId,
  onSelect,
  onToggleStatus,
}: UseEntityManagementProps<T>) {
  const [searchTerm, setSearchTerm] = useState("");
  const [viewMode, setViewMode] = useState<"tree" | "list">("list");
  const [showFilters, setShowFilters] = useState(false);
  const [filters, setFilters] = useState<Record<string, string>>({});
  const [showDetailsPanel, setShowDetailsPanel] = useState(false);
  const [expandedEntities, setExpandedEntities] = useState<Set<string>>(new Set());

  const allEntities = useMemo(() => entitiesQuery.data || [], [entitiesQuery.data]);

  const selectedEntity = useMemo(() => {
    return allEntities.find(e => e.id === selectedEntityId) || null;
  }, [allEntities, selectedEntityId]);


  const searchedEntities = useMemo(() => {
    if (!searchTerm) return allEntities;
    return allEntities.filter((entity) =>
      config.searchFields.some((field) => {
        const value = entity[field];
        return value && String(value).toLowerCase().includes(searchTerm.toLowerCase());
      })
    );
  }, [allEntities, searchTerm, config.searchFields]);

  const filteredEntities = useMemo(() => {
    return searchedEntities.filter((entity) => {
      return Object.entries(filters).every(([key, value]) => {
        if (!value) return true;
        const entityValue = key in entity ? entity[key as keyof T] : undefined;
        if (key === "status") {
          return entityValue !== undefined && entityValue?.toString() === value;
        }
        return entityValue === value;
      });
    });
  }, [searchedEntities, filters]);

  const hierarchicalEntities = useMemo((): EntityWithChildren<T>[] => {
    if (!config.isHierarchical) return filteredEntities.map((entity) => ({ ...entity, children: [] }));
    const entityMap = new Map<string, EntityWithChildren<T>>();
    filteredEntities.forEach((entity) => {
      entityMap.set(entity.id, { ...entity, children: [] });
    });
    const rootEntities: EntityWithChildren<T>[] = [];
    filteredEntities.forEach((entity) => {
      const entityWithChildren = entityMap.get(entity.id);
      if (!entityWithChildren) return;
      if (isHierarchicalEntity(entity) && entity.parent_id) {
        const parent = entityMap.get(entity.parent_id);
        if (parent) {
          parent.children.push(entityWithChildren);
        } else {
          rootEntities.push(entityWithChildren);
        }
      } else {
        rootEntities.push(entityWithChildren);
      }
    });
    return rootEntities;
  }, [filteredEntities, config.isHierarchical]);

  const handleEntitySelect = useCallback((id: string) => {
    onSelect(id);
    setShowDetailsPanel(true);
  }, [onSelect]);

  const toggleExpanded = (id: string) => {
    setExpandedEntities((prev) => {
      const newSet = new Set(prev);
      if (newSet.has(id)) newSet.delete(id);
      else newSet.add(id);
      return newSet;
    });
  };

  const handleOpenCreateForm = () => {
    onCreateNew();
  };

  return {
    // State
    searchTerm,
    viewMode,
    showFilters,
    filters,
    selectedEntity, // This is the selected entity object
    showDetailsPanel,
    expandedEntities,

    // Computed data
    allEntities,
    filteredEntities,
    hierarchicalEntities,

    // Handlers
    setSearchTerm,
    setViewMode,
    setShowFilters,
    setFilters,
    setShowDetailsPanel,
    handleEntitySelect,
    toggleExpanded,
    handleOpenCreateForm,
    onToggleStatus,
    onDelete,
  };
}
```

<!-- path: hooks/useDelete.ts -->
```typescript
import { useState } from "react";
import { useTableDelete } from "@/hooks/database";
import { createClient } from "@/utils/supabase/client";
import { TableName } from "@/hooks/database";
import { toast } from "sonner"; // <-- Import toast

export const useDelete = ({ tableName, onSuccess }: { tableName: TableName; onSuccess?: () => void }) => {
  const supabase = createClient();
  const [itemToDelete, setItemToDelete] = useState<{ id: string; name: string } | null>(null);

  const { mutate: deleteMutation, isPending } = useTableDelete(supabase, tableName as TableName, {
    onSuccess: () => {
      onSuccess?.();
      setItemToDelete(null);
    },
    // ** Add an onError handler to show a toast on failure.**
    onError: (error) => {
      toast.error(`Failed to delete: ${error.message}`);
      setItemToDelete(null); // Clear the item even on failure
    },
  });

  const deleteSingle = (item: { id: string; name: string }) => {
    setItemToDelete(item);
  };

  const handleConfirm = () => {
    if (itemToDelete) {
      deleteMutation(itemToDelete.id);
    }
  };

  const handleCancel = () => {
    setItemToDelete(null);
  };

  return {
    isConfirmModalOpen: itemToDelete !== null,
    isPending,
    itemToDelete,
    confirmationMessage: `Are you sure you want to delete "${itemToDelete?.name}"? This action cannot be undone.`,
    deleteSingle,
    handleConfirm,
    handleCancel,
  };
};
```

<!-- path: hooks/useCreateOfcConnection.ts -->
```typescript
import { useCallback, useMemo } from 'react';
import { SupabaseClient } from '@supabase/supabase-js';
import { Database } from '@/types/supabase-types';
import { useMutation, useQueryClient } from '@tanstack/react-query';
import { usePagedData} from './database';
import { Ofc_cablesRowSchema, Ofc_connectionsInsertSchema, Ofc_connectionsRowSchema } from '@/schemas/zod-schemas';


interface useCreateOfcConnectionProps {
  supabase: SupabaseClient<Database>;
  cableId: string;
  rawConnections: Ofc_connectionsInsertSchema[];
  refetchOfcConnections: () => void;
  isLoadingOfcConnections: boolean;
}

export const useCreateOfcConnection = ({
  supabase,
  cableId,
  rawConnections,
  refetchOfcConnections,
  isLoadingOfcConnections,
}: useCreateOfcConnectionProps) => {
  const queryClient = useQueryClient();

  // Get OFC cable by Id
  const { data: cable, isLoading: isLoadingCable } = usePagedData<Ofc_cablesRowSchema>(
    supabase,
    'ofc_cables',
    {
      filters: { id: cableId },
      limit: 1,
      offset: 0,
    }
  );

  // Return the appropriate data based on sorting preference
  const existingConnections = useMemo(() => {
    const connections = rawConnections || [];
    return connections;
  }, [rawConnections]);

  // Mutation for creating new connections (unchanged)
  const { mutateAsync: createConnections } = useMutation({
    mutationFn: async (newConnections: Ofc_connectionsRowSchema[]) => {
      const { data, error } = await supabase
        .from('ofc_connections')
        .insert(newConnections);
      if (error) throw error;
      return data;
    },
    onSuccess: () => {
      // Invalidate and refetch the connections query after successful insertion
      queryClient.invalidateQueries({ queryKey: ['ofc_connections'] });
      refetchOfcConnections();
    },
  });

  // createMissingConnections (unchanged)
  const createMissingConnections = useCallback(async (): Promise<void> => {
    if (!cable || !cable.data || !cable.data[0]) return;

    // Get fresh connection count to avoid stale data
    const { data: currentConnections, error } = await supabase
      .from('ofc_connections')
      .select('id')
      .eq('ofc_id', cableId);

    if (error) {
      console.error('Failed to fetch current connections:', error);
      throw error;
    }

    const currentConnectionCount = currentConnections?.length || 0;
    const cableCapacity = cable.data[0].capacity;
    const missingCount = cableCapacity - currentConnectionCount;

    if (missingCount <= 0) {
      console.log('No missing connections to create');
      return;
    }



    // Create an array of new connections to insert
    const newConnections = Array.from({ length: missingCount }, (_, index) => {
      const connection: Partial<Ofc_connectionsRowSchema> = {
        connection_category: 'OFC_JOINT_TYPES', // Or a default value
        connection_type: 'straight', // Or a default value
        destination_port: null,
        en_dom: null,
        en_power_dbm: null,
        ofc_id: cableId,
        fiber_no_sn: currentConnectionCount + index + 1,
        fiber_no_en: currentConnectionCount + index + 1,
        fiber_role: 'working', // Or a default value
        logical_path_id: null,
        status: true,
        // --- All optional fields are explicitly set to null for clarity ---
        system_id: null, // <-- The only missing field, now added
        otdr_distance_en_km: null,
        otdr_distance_sn_km: null,
        path_segment_order: null,
        source_port: null,
        remark: null,
        route_loss_db: null,
        sn_dom: null,
        sn_power_dbm: null,
        // created_at and updated_at are best handled by the database itself
      };
      return connection;
    });

    try {
      console.log(`Creating ${newConnections.length} new connections`);
      await createConnections(newConnections as Ofc_connectionsRowSchema[]);
    } catch (error) {
      console.error('Failed to create connections:', error);
      throw error;
    }
  }, [cable, cableId, createConnections, supabase]);

  // ensureConnectionsExist (unchanged)
  const ensureConnectionsExist = useCallback(async (): Promise<void> => {
    if (isLoadingCable || isLoadingOfcConnections) {
      console.log('Still loading data, skipping connection creation');
      return;
    }

    try {
      await createMissingConnections();
    } catch (error) {
      console.error('Error ensuring connections exist:', error);
      throw error;
    }
  }, [isLoadingCable, isLoadingOfcConnections, createMissingConnections]);

  return {
    cable: cable?.data?.[0],
    existingConnections, // Now optionally client-sorted, but maintains same structure
    isLoadingOfc: isLoadingCable,
    ensureConnectionsExist,
    createMissingConnections,
  };
};

```

<!-- path: hooks/useAuth.ts -->
```typescript
// path: hooks/useAuth.ts
// hooks/useAuth.ts
"use client";

import { useEffect, useMemo, useCallback } from "react";
import { createClient } from "@/utils/supabase/client";
import { useAuthStore } from "@/stores/authStore";
import { toast } from "sonner";
import { AuthError } from "@supabase/supabase-js";

// CORRECTED: Define a consistent return type for auth actions
interface AuthActionResult {
  success: boolean;
  error: AuthError | null;
}

// Auth Hook
export const useAuth = () => {
  const { user, authState, setUser, setAuthState, logout: logoutStore, executeWithLoading, isAuthenticated, isLoading, getUserId } = useAuthStore();
  const supabase = useMemo(() => createClient(), []);

  useEffect(() => {
    let isMounted = true;
    const subscription = supabase.auth.onAuthStateChange(async (event, session) => {
      if (isMounted) {
        setUser(session?.user ?? null);
      }
    }).data.subscription;

    const initAuth = async () => {
      try {
        const { data: { session: existingSession } } = await supabase.auth.getSession();
        if (existingSession?.user) {
          if (isMounted) setUser(existingSession.user);
          return;
        }
        const { data: { session }, error } = await supabase.auth.refreshSession();
        if (error) {
          if (isMounted) setAuthState("unauthenticated");
          return;
        }
        if (session?.user && isMounted) {
          setUser(session.user);
        } else if (isMounted) {
          setAuthState("unauthenticated");
        }
      } catch (error) {
        if (isMounted) {
          console.error("Failed to initialize auth:", error instanceof Error ? error.message : "Unknown error");
          setAuthState("unauthenticated");
        }
      }
    };
    initAuth();

    return () => {
      isMounted = false;
      subscription?.unsubscribe();
    };
  }, [supabase, setUser, setAuthState]);

  const signUp = useCallback(async (credentials: { email: string; password: string; firstName: string; lastName: string }): Promise<AuthActionResult> => {
    return executeWithLoading(async () => {
      try {
        const { data, error } = await supabase.auth.signUp({
          email: credentials.email,
          password: credentials.password,
          options: {
            data: {
              first_name: credentials.firstName,
              last_name: credentials.lastName,
            },
          },
        });

        if (error) throw error;
        if (data.user && !data.session) {
          toast.success("Signup successful! Please check your email for verification.");
        }
        return { success: true, error: null };
      } catch (error) {
        const authError = error as AuthError;
        toast.error(authError.message || "Signup failed");
        return { success: false, error: authError };
      }
    });
  }, [executeWithLoading, supabase.auth]);

  const signIn = useCallback(async (email: string, password: string): Promise<AuthActionResult> => {
    return executeWithLoading(async () => {
      try {
        const { error } = await supabase.auth.signInWithPassword({ email, password });
        if (error) throw error;
        toast.success("Signed in successfully!");
        return { success: true, error: null };
      } catch (error) {
        const authError = error as AuthError;
        toast.error(authError.message || "Sign in failed");
        return { success: false, error: authError };
      }
    });
  }, [executeWithLoading, supabase.auth]);

  const signInWithGoogle = useCallback(async () => {
    try {
      const { data, error } = await supabase.auth.signInWithOAuth({
        provider: "google",
        options: {
          redirectTo: `${window.location.origin}/auth/callback`,
          skipBrowserRedirect: true
        },
      });
      if (error) throw error;
      if (data?.url) {
        window.location.href = data.url;
      }
      return { success: true, error: null };
    } catch (error) {
      sessionStorage.removeItem('oauth_in_progress');
      const authError = error as AuthError;
      toast.error(authError.message || "Google sign in failed");
      return { success: false, error: authError };
    }
  }, [supabase.auth]);

  const logout = useCallback(async (): Promise<AuthActionResult> => {
    try {
      const { error } = await supabase.auth.signOut();
      if (error) throw error;
      logoutStore();
      toast.success("Signed out successfully!");
      return { success: true, error: null };
    } catch (error) {
      const authError = error as AuthError;
      toast.error(authError.message || "Logout failed");
      logoutStore();
      return { success: false, error: authError };
    }
  }, [supabase.auth, logoutStore]);

  const forgotPassword = useCallback(async (email: string): Promise<AuthActionResult> => {
    return executeWithLoading(async () => {
      try {
        const { error } = await supabase.auth.resetPasswordForEmail(email, {
          redirectTo: `${window.location.origin}/reset-password`,
        });
        if (error) throw error;
        toast.success("Password reset email sent!");
        return { success: true, error: null };
      } catch (error) {
        const authError = error as AuthError;
        toast.error(authError.message || "Failed to send reset email");
        return { success: false, error: authError };
      } finally {
        setAuthState("unauthenticated");
      }
    });
  }, [executeWithLoading, supabase.auth, setAuthState]);
  
  const resetPassword = useCallback(async (newPassword: string): Promise<AuthActionResult> => {
    return executeWithLoading(async () => {
      try {
        const { error } = await supabase.auth.updateUser({ password: newPassword });
        if (error) throw error;
        toast.success("Password updated successfully!");
        return { success: true, error: null };
      } catch (error) {
        const authError = error as AuthError;
        toast.error(authError.message || "Password update failed");
        return { success: false, error: authError };
      }
    });
  }, [executeWithLoading, supabase.auth]);

  const syncSession = useCallback(async () => {
    try {
      const { data: { session }, error } = await supabase.auth.refreshSession();
      if (error) return false;
      if (session?.user) {
        setUser(session.user);
        return true;
      }
      return false;
    } catch (error) {
      console.error("Failed to sync session:", error);
      return false;
    }
  }, [supabase.auth, setUser]);

  return useMemo(() => ({
    user, authState,
    isLoading: isLoading(),
    isAuthenticated: isAuthenticated(),
    getUserId: getUserId(),
    signUp, signIn, signInWithGoogle, logout, forgotPassword, resetPassword, syncSession
  }), [user, authState, isLoading, isAuthenticated, getUserId, signUp, signIn, signInWithGoogle, logout, forgotPassword, resetPassword, syncSession]);
};
```

<!-- path: hooks/database/bulk-queries.ts -->
```typescript
/* eslint-disable @typescript-eslint/no-explicit-any */
import { useMutation, useQueryClient } from "@tanstack/react-query";
import { SupabaseClient } from "@supabase/supabase-js";
import { Database } from "@/types/supabase-types";
import { TableName, TableRow, TableInsert, TableUpdate, Filters } from "./queries-type-helpers";
import { applyFilters } from "./utility-functions";

// Enhanced bulk operations hook with filter support
export function useTableBulkOperations<T extends TableName>(supabase: SupabaseClient<Database>, tableName: T, batchSize = 1000) {
  const queryClient = useQueryClient();

  const bulkInsert = useMutation({
    mutationFn: async (data: TableInsert<T>[]): Promise<TableRow<T>[]> => {
      const results: TableRow<T>[] = [];
      for (let i = 0; i < data.length; i += batchSize) {
        const batch = data.slice(i, i + batchSize) as any;
        const { data: batchResult, error } = await supabase.from(tableName).insert(batch).select();
        if (error) throw error;
        results.push(...(batchResult as TableRow<T>[]));
      }
      return results;
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ["table", tableName] });
      queryClient.invalidateQueries({ queryKey: ["unique", tableName] });
    },
  });

  // Enhanced bulk update with filter support
  const bulkUpdate = useMutation({
    mutationFn: async (params: {
      updates: { id: string; data: TableUpdate<T> }[];
      filters?: Filters; // Optional filters to apply to ALL updates
    }): Promise<TableRow<T>[]> => {
      const { updates, filters } = params;
      const results: TableRow<T>[] = [];

      for (let i = 0; i < updates.length; i += batchSize) {
        const batch = updates.slice(i, i + batchSize);

        const batchPromises = batch.map(async ({ id, data }) => {
          let query = supabase
            .from(tableName)
            .update(data as any)
            .eq("id" as any, id);

          // Apply additional filters if provided
          if (filters) {
            query = applyFilters(query, filters);
          }

          const { data: result, error } = await query.select();
          if (error) throw error;
          return result as TableRow<T>[];
        });

        const batchResults = await Promise.all(batchPromises);
        results.push(...batchResults.flat());
      }

      return results;
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ["table", tableName] });
      queryClient.invalidateQueries({ queryKey: ["unique", tableName] });
    },
  });

  // Enhanced bulk delete with filter support
  const bulkDelete = useMutation({
    mutationFn: async (params: {
      ids?: string[];
      filters?: Filters; // Optional: delete by filters instead of/in addition to IDs
      deleteAll?: boolean; // Safety flag for deleting all records
    }): Promise<void> => {
      const { ids, filters, deleteAll = false } = params;

      // Safety check: require either IDs, filters, or explicit deleteAll flag
      if (!ids && !filters && !deleteAll) {
        throw new Error("Must provide either ids, filters, or set deleteAll to true");
      }

      if (ids && ids.length > 0) {
        // Delete by IDs (existing behavior, but with optional additional filters)
        for (let i = 0; i < ids.length; i += batchSize) {
          const batch = ids.slice(i, i + batchSize);
          let query = supabase
            .from(tableName)
            .delete()
            .in("id" as any, batch);

          // Apply additional filters if provided
          if (filters) {
            query = applyFilters(query, filters);
          }

          const { error } = await query;
          if (error) throw error;
        }
      } else if (filters || deleteAll) {
        // Delete by filters only
        let query = supabase.from(tableName).delete();

        if (filters) {
          query = applyFilters(query, filters);
        }

        const { error } = await query;
        if (error) throw error;
      }
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ["table", tableName] });
      queryClient.invalidateQueries({ queryKey: ["unique", tableName] });
    },
  });

  const bulkUpsert = useMutation({
    mutationFn: async (data: TableInsert<T>[]): Promise<TableRow<T>[]> => {
      const results: TableRow<T>[] = [];
      for (let i = 0; i < data.length; i += batchSize) {
        const batch = data.slice(i, i + batchSize) as any;
        const { data: batchResult, error } = await supabase.from(tableName).upsert(batch).select();
        if (error) throw error;
        results.push(...(batchResult as TableRow<T>[]));
      }
      return results;
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ["table", tableName] });
      queryClient.invalidateQueries({ queryKey: ["unique", tableName] });
    },
  });

  // New: Bulk insert with conditional logic based on existing data
  const bulkInsertByFilters = useMutation({
    mutationFn: async (params: {
      data: TableInsert<T>[];
      conflictResolution?: "skip" | "update" | "error"; // How to handle conflicts
      checkFilters?: Filters; // Check if records matching these filters exist
      onConflict?: string; // Column(s) to check for conflicts (e.g., 'email' or 'email,username')
    }): Promise<TableRow<T>[]> => {
      const { data, conflictResolution = "error", checkFilters, onConflict } = params;

      if (checkFilters) {
        // Check for existing records that match the filters
        let checkQuery = supabase.from(tableName).select("id");
        checkQuery = applyFilters(checkQuery, checkFilters);

        const { data: existingRecords, error: checkError } = await checkQuery;
        if (checkError) throw checkError;

        if (existingRecords && existingRecords.length > 0) {
          switch (conflictResolution) {
            case "skip":
              return []; // Skip insertion if records exist
            case "error":
              throw new Error(`Records matching filters already exist: ${existingRecords.length} found`);
            case "update":
              // Convert to upsert operation
              const { data: upsertResult, error: upsertError } = await supabase
                .from(tableName)
                .upsert(data as any, { onConflict })
                .select();
              if (upsertError) throw upsertError;
              return upsertResult as TableRow<T>[];
          }
        }
      }

      // Proceed with normal insertion
      const results: TableRow<T>[] = [];
      for (let i = 0; i < data.length; i += batchSize) {
        const batch = data.slice(i, i + batchSize) as any;

        let insertQuery = supabase.from(tableName).insert(batch);

        // Handle conflicts at database level if onConflict is specified
        if (conflictResolution === "skip" && onConflict) {
          insertQuery = supabase.from(tableName).upsert(batch, {
            onConflict,
            ignoreDuplicates: true,
          });
        } else if (conflictResolution === "update" && onConflict) {
          insertQuery = supabase.from(tableName).upsert(batch, { onConflict });
        }

        const { data: batchResult, error } = await insertQuery.select();
        if (error) throw error;
        results.push(...(batchResult as TableRow<T>[]));
      }
      return results;
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ["table", tableName] });
      queryClient.invalidateQueries({ queryKey: ["unique", tableName] });
    },
  });

  // New: Bulk update by filters (update multiple records matching criteria)
  const bulkUpdateByFilters = useMutation({
    mutationFn: async (params: {
      data: TableUpdate<T>;
      filters: Filters;
      limit?: number; // Optional safety limit
    }): Promise<TableRow<T>[]> => {
      const { data, filters, limit } = params;

      let query = supabase.from(tableName).update(data as any);

      // Apply filters
      query = applyFilters(query, filters);

      // Apply limit if provided (for safety)
      if (limit) {
        query = query.limit(limit);
      }

      const { data: result, error } = await query.select();
      if (error) throw error;
      return result as TableRow<T>[];
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ["table", tableName] });
      queryClient.invalidateQueries({ queryKey: ["unique", tableName] });
    },
  });

  // New: Bulk upsert with filter-based conflict detection
  const bulkUpsertByFilters = useMutation({
    mutationFn: async (params: {
      data: TableInsert<T>[];
      onConflict?: string; // Column(s) for conflict detection
      checkFilters?: Filters; // Pre-check existing records
      updateColumns?: string[]; // Which columns to update on conflict (if not specified, updates all)
    }): Promise<TableRow<T>[]> => {
      const { data, onConflict, checkFilters, updateColumns } = params;

      // Optional: Check existing records first
      if (checkFilters) {
        try {
          // Create a new query builder
          let checkQuery = supabase.from(tableName).select("*", { count: "exact" });

          // Apply the filters
          checkQuery = applyFilters(checkQuery, checkFilters);

          // Execute the query
          const { data: existingRecords, error: checkError, count } = await checkQuery;

          if (checkError) {
            throw checkError;
          }

          console.log(`Found ${count || 0} existing records matching filters`);
        } catch (error) {
          throw error;
        }
      }

      const results: TableRow<T>[] = [];
      for (let i = 0; i < data.length; i += batchSize) {
        const batch = data.slice(i, i + batchSize) as any;

        const upsertOptions: any = {};
        if (onConflict) {
          upsertOptions.onConflict = onConflict;
        }
        if (updateColumns) {
          upsertOptions.columns = updateColumns;
        }

        const { data: batchResult, error } = await supabase.from(tableName).upsert(batch, upsertOptions).select();

        if (error) throw error;
        results.push(...(batchResult as TableRow<T>[]));
      }
      return results;
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ["table", tableName] });
      queryClient.invalidateQueries({ queryKey: ["unique", tableName] });
    },
  });

  // New: Conditional bulk operations (perform operation only if conditions are met)
  const conditionalBulkUpdate = useMutation({
    mutationFn: async (params: {
      updates: Array<{
        id: string;
        data: TableUpdate<T>;
        conditions?: Filters; // Conditions that must be met for this specific update
      }>;
      globalFilters?: Filters; // Filters applied to all updates
    }): Promise<TableRow<T>[]> => {
      const { updates, globalFilters } = params;
      const results: TableRow<T>[] = [];

      for (let i = 0; i < updates.length; i += batchSize) {
        const batch = updates.slice(i, i + batchSize);

        const batchPromises = batch.map(async ({ id, data, conditions }) => {
          let query = supabase
            .from(tableName)
            .update(data as any)
            .eq("id" as any, id);

          // Apply global filters
          if (globalFilters) {
            query = applyFilters(query, globalFilters);
          }

          // Apply individual conditions
          if (conditions) {
            query = applyFilters(query, conditions);
          }

          const { data: result, error } = await query.select();
          if (error) throw error;
          return result as TableRow<T>[];
        });

        const batchResults = await Promise.all(batchPromises);
        results.push(...batchResults.flat());
      }

      return results;
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ["table", tableName] });
      queryClient.invalidateQueries({ queryKey: ["unique", tableName] });
    },
  });

  return {
    bulkInsert,
    bulkUpdate,
    bulkDelete,
    bulkUpsert,
    bulkUpdateByFilters,
    bulkInsertByFilters,
    bulkUpsertByFilters,
    conditionalBulkUpdate,
  };
}

```

<!-- path: hooks/database/ring-map-queries.ts -->
```typescript
// path: hooks/database/ring-map-queries.ts
"use client";

import { useQuery } from '@tanstack/react-query';
import { createClient } from '@/utils/supabase/client';
import { V_ring_nodesRowSchema } from '@/schemas/zod-schemas';

export function useRingNodes(ringId: string | null) {
  const supabase = createClient();

  return useQuery({
    queryKey: ['ring-nodes', ringId],
    queryFn: async (): Promise<V_ring_nodesRowSchema[]> => {
      if (!ringId) return [];

      const { data, error } = await supabase
        .from('v_ring_nodes')
        .select('*')
        .eq('ring_id', ringId);

      if (error) {
        console.error("Error fetching ring nodes:", error);
        throw new Error(error.message);
      }
      return data || [];
    },
    enabled: !!ringId,
    staleTime: 5 * 60 * 1000, // 5 minutes
  });
}
```

<!-- path: hooks/database/path-queries.ts -->
```typescript
// path: hooks/database/path-queries.ts
"use client";

import { useQuery } from "@tanstack/react-query";
import { createClient } from "@/utils/supabase/client";
import { toast } from "sonner";
import { useRpcQuery } from "@/hooks/database/rpc-queries";
import { z } from 'zod';
import { fiberTraceSegmentSchema, FiberTraceSegment } from "@/schemas/custom-schemas";

const supabase = createClient();

/**
 * Fetches the detailed, ordered path segments for a given logical path.
 */
export function useSystemPath(logicalPathId: string | null) {
  return useRpcQuery(
    supabase,
    'get_system_path_details',
    { p_path_id: logicalPathId! },
    { enabled: !!logicalPathId }
  );
}

/**
 * Fetches the list of continuously available fiber numbers for a given path.
 */
export function useAvailableFibers(pathId: string | null) {
  return useRpcQuery(
    supabase,
    'get_continuous_available_fibers',
    { p_path_id: pathId! },
    { enabled: !!pathId }
  );
}

/**
 * Fetches the working and protection fiber numbers for a given path.
 */

export function useProvisionedFibers(pathId: string | null) {
  return useQuery({
      queryKey: ['provisioned-fibers', pathId],
      queryFn: async () => {
          if (!pathId) return null;

          const { data, error } = await supabase
              .from('ofc_connections')
              .select('fiber_no_sn, fiber_role')
              .eq('logical_path_id', pathId)
              .in('fiber_role', ['working', 'protection']);

          if (error) throw error;
          
          const working = data.find(f => f.fiber_role === 'working')?.fiber_no_sn || null;
          const protection = data.find(f => f.fiber_role === 'protection')?.fiber_no_sn || null;

          return { working, protection };
      },
      enabled: !!pathId,
  });
}

/**
 * Hook to trace a fiber's complete path using the recursive RPC function.
 * The new RPC returns a pre-ordered, structured list, so no client-side tree building is needed.
 */
export function useFiberTrace(startSegmentId: string | null, fiberNo: number | null) {
  return useQuery({
    queryKey: ['fiber-trace', startSegmentId, fiberNo],
    queryFn: async (): Promise<FiberTraceSegment[]> => {
      if (!startSegmentId || fiberNo === null) return [];

      // CORRECTED: Call the RPC with the segment_id parameter
      const { data, error } = await supabase.rpc('trace_fiber_path', {
        p_start_segment_id: startSegmentId,
        p_start_fiber_no: fiberNo
      });

      if (error) {
        toast.error(`Trace failed: ${error.message}`);
        throw error;
      }
      // ... (rest of the function is the same)
      if (!data || data.length === 0) {
        return [];
      }
      const parsed = z.array(fiberTraceSegmentSchema).safeParse(data);
      if (!parsed.success) {
        console.error("Zod validation error for Fiber Trace:", parsed.error);
        toast.error("Trace data from server was malformed.");
        throw new Error("Received invalid data structure for fiber trace.");
      }
      return parsed.data;
    },
    enabled: !!startSegmentId && fiberNo !== null,
  });
}
```

<!-- path: hooks/database/basic-mutation-hooks.ts -->
```typescript
/* eslint-disable @typescript-eslint/no-explicit-any */
import { useMutation, useQueryClient } from "@tanstack/react-query";
import { SupabaseClient } from "@supabase/supabase-js";
import { Database } from "@/types/supabase-types";
import { TableName, TableRow, TableInsert, TableUpdate, OptimisticContext, UseTableMutationOptions } from "./queries-type-helpers";

// Generic toggle status hook
export function useToggleStatus<T extends TableName>(supabase: SupabaseClient<Database>, tableName: T, options?: UseTableMutationOptions<TableRow<T>, { id: string; status: boolean; nameField?: keyof TableRow<T> }, OptimisticContext>) {
  const queryClient = useQueryClient();
  const { invalidateQueries = true, optimisticUpdate = true, ...mutationOptions } = options || {};

  return useMutation<TableRow<T>, Error, { id: string; status: boolean; nameField?: keyof TableRow<T> }, OptimisticContext>({
    mutationFn: async ({ id, status }): Promise<TableRow<T>> => {
      const { data, error } = await supabase
        .from(tableName)
        .update({ status, updated_at: new Date().toISOString() } as any)
        .eq("id" as any, id)
        .select()
        .single();
      if (error) throw error;
      return data as TableRow<T>;
    },
    onMutate: optimisticUpdate
      ? async ({ id, status }) => {
          await queryClient.cancelQueries({ queryKey: ["table", tableName] });
          const previousData = queryClient.getQueriesData({ queryKey: ["table", tableName] });
          queryClient.setQueriesData({ queryKey: ["table", tableName] }, (old: TableRow<T>[] | undefined) => {
            if (!old) return [];
            return old.map((item) => ("id" in item && (item as { id: unknown }).id === id ? { ...item, status, updated_at: new Date().toISOString() } : item)) as TableRow<T>[];
          });
          return { previousData };
        }
      : undefined,
    onError: optimisticUpdate
      ? (err, variables, context) => {
          context?.previousData?.forEach(([queryKey, data]) => queryClient.setQueryData(queryKey, data));
        }
      : undefined,
    onSuccess: (data, variables, context) => {
      if (invalidateQueries) {
        queryClient.invalidateQueries({ queryKey: ["table", tableName] });
        queryClient.invalidateQueries({ queryKey: ["unique", tableName] });
      }
    },
    ...mutationOptions,
  });
}

// Optimized insert mutation with batching
export function useTableInsert<T extends TableName>(supabase: SupabaseClient<Database>, tableName: T, options?: UseTableMutationOptions<TableRow<T>[], TableInsert<T> | TableInsert<T>[], OptimisticContext>) {
  const queryClient = useQueryClient();
  const { invalidateQueries = true, optimisticUpdate = false, batchSize = 1000, ...mutationOptions } = options || {};

  return useMutation<TableRow<T>[], Error, TableInsert<T> | TableInsert<T>[], OptimisticContext>({
    mutationFn: async (data: TableInsert<T> | TableInsert<T>[]): Promise<TableRow<T>[]> => {
      const payload = (Array.isArray(data) ? data : [data]) as any;

      // Batch large inserts for better performance
      if (payload.length > batchSize) {
        const batches = [];
        for (let i = 0; i < payload.length; i += batchSize) {
          batches.push(payload.slice(i, i + batchSize));
        }

        const results = await Promise.all(
          batches.map(async (batch) => {
            const { data: result, error } = await supabase.from(tableName).insert(batch).select();
            if (error) throw error;
            return result as TableRow<T>[];
          })
        );

        return results.flat();
      }

      const { data: result, error } = await supabase.from(tableName).insert(payload).select();

      if (error) throw error;
      return result as TableRow<T>[];
    },
    onMutate: optimisticUpdate
      ? async (newData) => {
          await queryClient.cancelQueries({ queryKey: ["table", tableName] });

          const previousData = queryClient.getQueriesData({
            queryKey: ["table", tableName],
          });

          queryClient.setQueriesData({ queryKey: ["table", tableName] }, (old: TableRow<T>[] | undefined) => {
            if (!old) return [];
            const newItems = Array.isArray(newData) ? newData : [newData];
            return [
              ...old,
              ...newItems.map((item, index) => ({
                ...item,
                id: `temp-${Date.now()}-${index}`,
              })),
            ] as TableRow<T>[];
          });

          return { previousData };
        }
      : undefined,
    onError: optimisticUpdate
      ? (err, newData, context) => {
          if (context?.previousData) {
            context.previousData.forEach(([queryKey, data]) => {
              queryClient.setQueryData(queryKey, data);
            });
          }
        }
      : undefined,
    onSuccess: (data, variables, context) => {
      if (invalidateQueries) {
        queryClient.invalidateQueries({ queryKey: ["table", tableName] });
        queryClient.invalidateQueries({ queryKey: ["unique", tableName] });
      }
    },
    ...mutationOptions,
  });
}

// Enhanced update mutation with optimizations
export function useTableUpdate<T extends TableName>(supabase: SupabaseClient<Database>, tableName: T, options?: UseTableMutationOptions<TableRow<T>[], { id: string; data: TableUpdate<T> }, OptimisticContext>) {
  const queryClient = useQueryClient();
  const { invalidateQueries = true, optimisticUpdate = false, ...mutationOptions } = options || {};

  return useMutation<TableRow<T>[], Error, { id: string; data: TableUpdate<T> }, OptimisticContext>({
    mutationFn: async ({ id, data }: { id: string; data: TableUpdate<T> }): Promise<TableRow<T>[]> => {
      const { data: result, error } = await supabase
        .from(tableName)
        .update(data as any)
        .eq("id" as any, id)
        .select();

      if (error) throw error;
      return result as TableRow<T>[];
    },
    onMutate: optimisticUpdate
      ? async ({ id, data: newData }) => {
          await queryClient.cancelQueries({ queryKey: ["table", tableName] });

          const previousData = queryClient.getQueriesData({
            queryKey: ["table", tableName],
          });

          queryClient.setQueriesData({ queryKey: ["table", tableName] }, (old: TableRow<T>[] | undefined) => {
            if (!old) return [];
            return old.map((item) => ("id" in item && (item as { id: unknown }).id === id ? { ...item, ...newData } : item)) as TableRow<T>[];
          });

          return { previousData };
        }
      : undefined,
    onError: optimisticUpdate
      ? (err, variables, context) => {
          if (context?.previousData) {
            context.previousData.forEach(([queryKey, data]) => {
              queryClient.setQueryData(queryKey, data);
            });
          }
        }
      : undefined,
    onSuccess: (data, variables, context) => {
      if (invalidateQueries) {
        queryClient.invalidateQueries({ queryKey: ["table", tableName] });
        queryClient.invalidateQueries({ queryKey: ["unique", tableName] });
      }
    },
    ...mutationOptions,
  });
}

// Enhanced delete mutation
export function useTableDelete<T extends TableName>(supabase: SupabaseClient<Database>, tableName: T, options?: UseTableMutationOptions<void, string | string[], OptimisticContext>) {
  const queryClient = useQueryClient();
  const { invalidateQueries = true, optimisticUpdate = false, batchSize = 1000, ...mutationOptions } = options || {};

  return useMutation<void, Error, string | string[], OptimisticContext>({
    mutationFn: async (id: string | string[]): Promise<void> => {
      const ids = Array.isArray(id) ? id : [id];

      // Batch large deletes for better performance
      if (ids.length > batchSize) {
        const batches = [];
        for (let i = 0; i < ids.length; i += batchSize) {
          batches.push(ids.slice(i, i + batchSize));
        }

        await Promise.all(
          batches.map(async (batch) => {
            const { error } = await supabase
              .from(tableName)
              .delete()
              .in("id" as any, batch);
            if (error) throw error;
          })
        );
        return;
      }

      const { error } = await supabase
        .from(tableName)
        .delete()
        .in("id" as any, ids);

      if (error) throw error;
    },
    onMutate: optimisticUpdate
      ? async (id) => {
          await queryClient.cancelQueries({ queryKey: ["table", tableName] });

          const previousData = queryClient.getQueriesData({
            queryKey: ["table", tableName],
          });
          const ids = Array.isArray(id) ? id : [id];

          queryClient.setQueriesData({ queryKey: ["table", tableName] }, (old: TableRow<T>[] | undefined) => {
            if (!old) return [];
            return old.filter((item) => !("id" in item) || !ids.includes((item as { id: string }).id)) as TableRow<T>[];
          });

          return { previousData };
        }
      : undefined,
    onError: optimisticUpdate
      ? (err, variables, context) => {
          if (context?.previousData) {
            context.previousData.forEach(([queryKey, data]) => {
              queryClient.setQueryData(queryKey, data);
            });
          }
        }
      : undefined,
    onSuccess: (data, variables, context) => {
      if (invalidateQueries) {
        queryClient.invalidateQueries({ queryKey: ["table", tableName] });
        queryClient.invalidateQueries({ queryKey: ["unique", tableName] });
      }
    },
    ...mutationOptions,
  });
}

```

<!-- path: hooks/database/file-queries.ts -->
```typescript
import { useMutation, useQuery, useQueryClient } from "@tanstack/react-query";
import { createClient } from "@/utils/supabase/client";
import { Database } from "@/types/supabase-types";

type FileRecord = Database["public"]["Tables"]["files"]["Row"];
type FileInsert = Database["public"]["Tables"]["files"]["Insert"];
type FileUpdate = Database["public"]["Tables"]["files"]["Update"];

export function useFiles(folderId?: string | null) {
  const supabase = createClient();
  
  return useQuery({
    queryKey: ["files", folderId],
    queryFn: async () => {
      let query = supabase
        .from("files")
        .select("*");
      
      if (folderId) {
        query = query.eq("folder_id", folderId);
      }
      
      const { data, error } = await query.order("uploaded_at", { ascending: false });
      
      if (error) {
        throw new Error(error.message);
      }
      
      return data || [];
    },
    enabled: true,
  });
}

export function useUploadFile() {
  const supabase = createClient();
  const queryClient = useQueryClient();
  
  return useMutation({
    mutationFn: async (fileData: FileInsert) => {
      const { data, error } = await supabase
        .from("files")
        .insert(fileData)
        .select()
        .single();
        
      if (error) {
        throw new Error(error.message);
      }
      
      return data;
    },
    onSuccess: (data, variables) => {
      queryClient.invalidateQueries({ 
        queryKey: ["files", variables.folder_id] 
      });
    },
  });
}

export function useDeleteFile() {
  const supabase = createClient();
  const queryClient = useQueryClient();
  
  return useMutation({
    mutationFn: async ({
      id,
      folderId,
    }: {
      id: string;
      folderId?: string | null;
    }) => {
      const { error } = await supabase
        .from("files")
        .delete()
        .eq("id", id);
        
      if (error) {
        throw new Error(error.message);
      }
      
      return { id };
    },
    onSuccess: (_, variables) => {
      queryClient.invalidateQueries({ 
        queryKey: ["files", variables.folderId] 
      });
    },
  });
}

export function useUpdateFile() {
  const supabase = createClient();
  const queryClient = useQueryClient();
  
  return useMutation({
    mutationFn: async ({
      id,
      updates,
    }: {
      id: string;
      updates: FileUpdate;
    }) => {
      const { data, error } = await supabase
        .from("files")
        .update(updates)
        .eq("id", id)
        .select()
        .single();
        
      if (error) {
        throw new Error(error.message);
      }
      
      return data;
    },
    onSuccess: (data) => {
      queryClient.invalidateQueries({ 
        queryKey: ["files", data.folder_id] 
      });
    },
  });
}

```

<!-- path: hooks/database/utility-functions.ts -->
```typescript
// path: hooks/database/utility-functions.ts
/* eslint-disable @typescript-eslint/no-explicit-any */
import { QueryKey } from "@tanstack/react-query";
import {
  AggregationOptions,
  DeduplicationOptions,
  EnhancedOrderBy,
  FilterOperator,
  Filters,
  OrderBy,
} from './queries-type-helpers';
import { Json } from '@/types/supabase-types';

export function buildRpcFilters(filters: Filters): Json {
  const rpcFilters: { [key: string]: Json | undefined } = {};

  for (const key in filters) {
    // --- THIS IS THE FIX ---
    // Pass the 'or' object through directly without converting it to a string.
    if (key === 'or' && typeof filters.or === 'object' && filters.or !== null) {
      rpcFilters.or = filters.or;
      continue; // Continue to the next key
    }
    // --- END FIX ---

    const filterValue = filters[key];
    if (filterValue !== null && filterValue !== undefined && filterValue !== '') {
      rpcFilters[key] = filterValue as Json;
    }
  }

  return rpcFilters;
}

export const createQueryKey = (
  tableName: string,
  filters?: Filters,
  columns?: string,
  orderBy?: OrderBy[],
  deduplication?: DeduplicationOptions,
  aggregation?: AggregationOptions,
  enhancedOrderBy?: EnhancedOrderBy[],
  limit?: number,
  offset?: number
): QueryKey => {
  const key: unknown[] = ['table', tableName];
  const params: Record<string, unknown> = { filters, columns, orderBy, deduplication, aggregation, enhancedOrderBy, limit, offset };
  const cleanParams = Object.fromEntries(Object.entries(params).filter(([, value]) => value !== undefined && value !== null));
  if (Object.keys(cleanParams).length > 0) key.push(cleanParams);
  return key;
};

export const createRpcQueryKey = (
  functionName: string,
  args?: Record<string, unknown>,
  performance?: any,
): QueryKey => {
  const key: unknown[] = ['rpc', functionName];
  const params = { args, performance };
  const cleanParams = Object.fromEntries(Object.entries(params).filter(([, value]) => value !== undefined && value !== null));
  if (Object.keys(cleanParams).length > 0) key.push(cleanParams);
  return key;
};

export const createUniqueValuesKey = (
  tableName: string,
  column: string,
  filters?: Filters,
  orderBy?: OrderBy[],
  enhancedOrderBy?: EnhancedOrderBy[]
): QueryKey => ['unique', tableName, column, { filters, orderBy, enhancedOrderBy }];

export function applyFilters(query: any, filters: Filters): any {
  let modifiedQuery = query;
  Object.entries(filters).forEach(([key, value]) => {
    if (value === undefined || value === null) return;

    if (key === 'or') {
      if (typeof value === 'object' && value !== null && !Array.isArray(value)) {
        const orConditions = Object.entries(value)
          .map(([col, val]) => `${col}.ilike.%${String(val).replace(/%/g, '')}%`)
          .join(',');
        if (orConditions) {
          modifiedQuery = modifiedQuery.or(orConditions);
        }
      }
      return;
    }

    if (typeof value === 'object' && !Array.isArray(value) && 'operator' in value) {
      const { operator, value: filterValue } = value as { operator: FilterOperator; value: unknown };
      if (operator in modifiedQuery && typeof (modifiedQuery as any)[operator] === 'function') {
        modifiedQuery = modifiedQuery[operator](key, filterValue);
      }
    } else if (Array.isArray(value)) {
      modifiedQuery = modifiedQuery.in(key, value);
    } else {
      modifiedQuery = modifiedQuery.eq(key, value);
    }
  });
  return modifiedQuery;
}

export function applyOrdering(query: any, orderBy: OrderBy[]): any {
  let modifiedQuery = query;
  orderBy.forEach(({ column, ascending = true, nullsFirst, foreignTable }) => {
    if (!column || typeof column !== 'string') return;
    const orderColumn = foreignTable ? `${foreignTable}.${column}` : column;
    const options: { ascending: boolean; nullsFirst?: boolean } = { ascending };
    if (nullsFirst !== undefined) {
      options.nullsFirst = nullsFirst;
    }
    try {
      modifiedQuery = modifiedQuery.order(orderColumn, options);
    } catch (error) {
      console.error(`Error applying order by ${orderColumn}:`, error);
    }
  });
  return modifiedQuery;
}

export function buildDeduplicationQuery(
  tableName: string,
  deduplication: DeduplicationOptions,
  filters?: Filters,
  orderBy?: OrderBy[]
): string {
  const { columns, orderBy: dedupOrderBy } = deduplication;
  const partitionBy = columns.join(', ');
  const rowNumberOrder = dedupOrderBy?.length
    ? dedupOrderBy
        .map((o) => `${o.column} ${o.ascending !== false ? 'ASC' : 'DESC'}`)
        .join(', ')
    : 'id ASC';

  let finalOrderClause = '';
  if (orderBy && orderBy.length > 0) {
    const orderParts = orderBy.map(
      (o) =>
        `${o.column} ${o.ascending !== false ? 'ASC' : 'DESC'}${
          o.nullsFirst !== undefined
            ? o.nullsFirst
              ? ' NULLS FIRST'
              : ' NULLS LAST'
            : ''
        }`
    );
    finalOrderClause = `ORDER BY ${orderParts.join(', ')}`;
  }

  let whereClause = '';
  if (filters && Object.keys(filters).length > 0) {
    const conditions = Object.entries(filters)
      .filter(([, value]) => value !== undefined && value !== null)
      .map(([key, value]) => {
        if (
          value &&
          typeof value === 'object' &&
          !Array.isArray(value) &&
          'operator' in value
        ) {
          const filterValue =
            typeof value.value === 'string'
              ? `'${value.value.toString().replace(/'/g, "''")}'`
              : value.value;
          return `${key} = ${filterValue}`;
        }
        if (Array.isArray(value)) {
          const arrayValues = value
            .map((v) =>
              typeof v === 'string' ? `'${v.replace(/'/g, "''")}'` : v
            )
            .join(',');
          return `${key} IN (${arrayValues})`;
        }
        const filterValue =
          typeof value === 'string' ? `'${value.replace(/'/g, "''")}'` : value;
        return `${key} = ${filterValue}`;
      });

    if (conditions.length > 0)
      whereClause = `WHERE ${conditions.join(' AND ')}`;
  }

  return `
    WITH deduplicated AS (
      SELECT *, ROW_NUMBER() OVER (PARTITION BY ${partitionBy} ORDER BY ${rowNumberOrder}) as rn
      FROM ${tableName}
      ${whereClause}
    )
    SELECT * FROM deduplicated WHERE rn = 1 ${finalOrderClause}
  `;
}

export function convertRichFiltersToSimpleJson(filters: Filters): Json {
  const simpleFilters: { [key: string]: Json | undefined } = {};
  for (const key in filters) {
    if (key === 'or' && typeof filters.or === 'object' && filters.or !== null) {
      const orConditions = Object.entries(filters.or)
        .map(([col, val]) => `${col}.ilike.%${String(val).replace(/%/g, '')}%`)
        .join(',');
      if (orConditions) {
        simpleFilters.or = `(${orConditions})`;
      }
      continue;
    }
    const filterValue = filters[key];
    if (
      typeof filterValue === 'string' ||
      typeof filterValue === 'number' ||
      typeof filterValue === 'boolean' ||
      filterValue === null
    ) {
      simpleFilters[key] = filterValue;
    } else if (Array.isArray(filterValue)) {
      simpleFilters[key] = filterValue;
    }
  }
  return simpleFilters;
}
```

<!-- path: hooks/database/route-manager-hooks.ts -->
```typescript
// path: hooks/database/route-manager-hooks.ts

import { useMutation, useQuery, useQueryClient } from "@tanstack/react-query";
import { createClient } from "@/utils/supabase/client";
import { toast } from "sonner";
import { z } from "zod";
import { autoSpliceResultSchema, AutoSpliceResult, jcSplicingDetailsSchema, JcSplicingDetails, ofcForSelectionSchema, OfcForSelection, routeDetailsPayloadSchema, RouteDetailsPayload, FiberTraceSegment, PathToUpdate } from "@/schemas/custom-schemas";

const supabase = createClient();

/** Fetches a list of OFC cables for the selection dropdown. */
export function useOfcRoutesForSelection() {
  return useQuery({
    queryKey: ["ofc-routes-for-selection"],
    queryFn: async (): Promise<OfcForSelection[]> => {
      const { data, error } = await supabase
        .from("ofc_cables")
        .select("id, route_name, capacity, ofc_connections!inner(id)") // Return ofc_cables that have at least one connection (ofc_connections)
        .order("route_name");
      if (error) throw error;

      const parsed = z.array(ofcForSelectionSchema).safeParse(data); // Validate that data from Supabase is an array of objects matching ofcForSelectionSchema. If valid, give me typed parsed.data. If invalid, give me an error object instead of crashing.
      if (!parsed.success) {
        console.error("Zod validation error for OfcForSelection:", parsed.error);
        throw new Error("Received invalid data structure for OFC routes.");
      }
      return parsed.data;
    },
    staleTime: 60 * 60 * 1000,
  });
}

/** Fetches detailed info for a single OFC Cable from our API route. */
export function useRouteDetails(routeId: string | null) {
  return useQuery({
    queryKey: ["route-details", routeId],
    queryFn: async (): Promise<RouteDetailsPayload | null> => {
      if (!routeId) return null;
      const res = await fetch(`/api/route/${routeId}`);
      if (!res.ok) throw new Error("Failed to fetch route details");
      const data = await res.json();

      const parsed = routeDetailsPayloadSchema.safeParse(data);
      if (!parsed.success) {
        console.error("Zod validation error for RouteDetailsPayload:", parsed.error);
        throw new Error("Received invalid data structure for route details.");
      }
      return parsed.data;
    },
    enabled: !!routeId,
    placeholderData: (previousData) => previousData,
    staleTime: 60 * 60 * 1000,
  });
}

/** Fetches all data needed for the splice matrix editor for a single JC. */
export function useJcSplicingDetails(jcId: string | null) {
  return useQuery({
    queryKey: ["jc-splicing-details", jcId],
    queryFn: async (): Promise<JcSplicingDetails | null> => {
      if (!jcId) return null;
      const { data, error } = await supabase.rpc("get_jc_splicing_details", {
        p_jc_id: jcId,
      });
      if (error) throw error;

      const parsed = jcSplicingDetailsSchema.safeParse(data);
      if (!parsed.success) {
        console.error("Zod validation error for JcSplicingDetails:", parsed.error);
        throw new Error("Received invalid data structure for JC splicing details.");
      }
      return parsed.data;
    },
    enabled: !!jcId,
    placeholderData: (previousData) => previousData,
    staleTime: 60 * 60 * 1000,
  });
}

/** Hook to call the `manage_splice` RPC function. */
export function useManageSplice() {
  const queryClient = useQueryClient();
  return useMutation({
    mutationFn: async (variables: {
      action: "create" | "delete" | "update_loss";
      jcId: string;
      spliceId?: string;
      incomingSegmentId?: string;
      incomingFiberNo?: number;
      outgoingSegmentId?: string;
      outgoingFiberNo?: number;
      spliceTypeId?: string;
      lossDb?: number;
    }) => {
      const { data, error } = await supabase.rpc("manage_splice", {
        p_action: variables.action,
        p_jc_id: variables.jcId,
        p_splice_id: variables.spliceId,
        p_incoming_segment_id: variables.incomingSegmentId,
        p_incoming_fiber_no: variables.incomingFiberNo,
        p_outgoing_segment_id: variables.outgoingSegmentId,
        p_outgoing_fiber_no: variables.outgoingFiberNo,
        p_splice_type_id: variables.spliceTypeId,
        p_loss_db: variables.lossDb || 0,
      });
      if (error) throw error;
      return data;
    },
    onSuccess: (_, variables) => {
      toast.success("Splice configuration updated!");
      queryClient.invalidateQueries({ queryKey: ["jc-splicing-details", variables.jcId] });
    },
    onError: (err) => toast.error(`Splice Error: ${err.message}`),
  });
}

/** NEW HOOK for manually syncing path data from the visualizer. */
export function useSyncPathFromTrace() {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: async (payload: PathToUpdate) => {
      const { error } = await supabase.rpc('apply_logical_path_update', payload);
      if (error) throw error;
    },
    onSuccess: () => {
      toast.success("Path data successfully synced to the database!");
      queryClient.invalidateQueries({ queryKey: ['ofc_connections'] });
      queryClient.invalidateQueries({ queryKey: ['route-details'] });
    },
    onError: (err: Error) => {
      toast.error(`Path sync failed: ${err.message}`);
    }
  });
}


/** Hook to call the `auto_splice_straight_segments` RPC function. */

export function useAutoSplice() {
  const queryClient = useQueryClient();
  return useMutation({
      mutationFn: async (variables: { 
          jcId: string; 
          segment1Id: string; 
          segment2Id: string;
          lossDb?: number;
      }): Promise<AutoSpliceResult> => {
          const { data, error } = await supabase.rpc('auto_splice_straight_segments', {
              p_jc_id: variables.jcId,
              p_segment1_id: variables.segment1Id,
              p_segment2_id: variables.segment2Id,
              p_loss_db: variables.lossDb || 0,
          });
          if (error) throw error;
    
          const parsed = autoSpliceResultSchema.safeParse(data);
          if (!parsed.success) {
              console.error("Zod validation error for AutoSpliceResult:", parsed.error);
              throw new Error("Received invalid data structure for auto-splice result.");
          }
          return parsed.data;
      },
      onSuccess: (data, variables) => {
          const count = data.splices_created || 0;
          toast.success(`${count} straight splices created successfully!`);
          queryClient.invalidateQueries({ queryKey: ['jc-splicing-details', variables.jcId] });
      },
      onError: (error) => toast.error(`Auto-splice failed: ${error.message}`),
  });
}

/** NEW HOOK for the manual "Apply Path Updates" button */
export function useSyncPathUpdates() {
  const queryClient = useQueryClient();
  
  return useMutation({
    mutationFn: async ({ jcId }: { jcId: string }) => {
      // This is now an empty placeholder as the trigger handles everything.
      // We keep it to maintain the button's functionality, but it does nothing.
      return Promise.resolve();
    },
    onSuccess: (_, { jcId }) => {
      toast.success("Path data has been refreshed.");
      // Invalidate everything to ensure the entire UI reflects the new state from the trigger
      queryClient.invalidateQueries({ queryKey: ["jc-splicing-details", jcId] });
      queryClient.invalidateQueries({ queryKey: ['ofc_connections'] });
      queryClient.invalidateQueries({ queryKey: ['route-details'] });
    },
    onError: (err: Error) => {
      toast.error(`Path sync failed: ${err.message}`);
    }
  });
}
```

<!-- path: hooks/database/advanced-bulk-queries.ts -->
```typescript
/* eslint-disable @typescript-eslint/no-explicit-any */
import { useMutation, useQueryClient } from "@tanstack/react-query";
import { SupabaseClient } from "@supabase/supabase-js";
import { Database } from "@/types/supabase-types";
import { TableName, TableRow, TableUpdate, Filters, OrderBy, PerformanceOptions } from "./queries-type-helpers";
import { applyFilters, applyOrdering } from "./utility-functions";

// Enhanced bulk operations with more advanced filtering and performance features
export function useAdvancedBulkOperations<T extends TableName>(
  supabase: SupabaseClient<Database>,
  tableName: T,
  options?: {
    batchSize?: number;
    maxRetries?: number;
    retryDelay?: number;
    onProgress?: (completed: number, total: number) => void;
  }
) {
  const queryClient = useQueryClient();
  const { maxRetries = 3, retryDelay = 1000, onProgress } = options || {};

  // Helper function for retrying operations
  const withRetry = async <TResult>(operation: () => Promise<TResult>, retries = maxRetries): Promise<TResult> => {
    try {
      return await operation();
    } catch (error) {
      if (retries > 0) {
        await new Promise((resolve) => setTimeout(resolve, retryDelay));
        return withRetry(operation, retries - 1);
      }
      throw error;
    }
  };

  // Advanced bulk update with complex filtering and progress tracking
  const advancedBulkUpdate = useMutation({
    mutationFn: async (params: {
      criteria: {
        filters: Filters;
        data: TableUpdate<T>;
        orderBy?: OrderBy[];
        limit?: number;
      }[];
      performanceOptions?: PerformanceOptions;
    }): Promise<TableRow<T>[]> => {
      const { criteria, performanceOptions } = params;
      const allResults: TableRow<T>[] = [];
      let completed = 0;
      const total = criteria.length;

      for (const { filters, data, orderBy, limit } of criteria) {
        await withRetry(async () => {
          let query = supabase.from(tableName).update(data as any);

          // Apply filters
          query = applyFilters(query, filters);

          // Apply ordering if specified
          if (orderBy && orderBy.length > 0) {
            query = applyOrdering(query, orderBy);
          }

          // Apply limit if specified
          if (limit) {
            query = query.limit(limit);
          }

          // Apply performance options
          if (performanceOptions?.timeout) {
            query = query.abortSignal(AbortSignal.timeout(performanceOptions.timeout));
          }

          const { data: result, error } = await query.select();
          if (error) throw error;

          allResults.push(...(result as TableRow<T>[]));
          completed++;
          onProgress?.(completed, total);
        });
      }

      return allResults;
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ["table", tableName] });
      queryClient.invalidateQueries({ queryKey: ["unique", tableName] });
    },
  });

  // Advanced bulk delete with complex criteria
  const advancedBulkDelete = useMutation({
    mutationFn: async (params: {
      criteria: Array<{
        filters?: Filters;
        ids?: string[];
        orderBy?: OrderBy[];
        limit?: number;
      }>;
      safetyLimit?: number; // Global safety limit
      performanceOptions?: PerformanceOptions;
    }): Promise<{ deletedCount: number; details: Array<{ criteriaIndex: number; deletedCount: number }> }> => {
      const { criteria, safetyLimit, performanceOptions } = params;
      let totalDeleted = 0;
      const details: Array<{ criteriaIndex: number; deletedCount: number }> = [];
      let completed = 0;
      const total = criteria.length;

      for (let i = 0; i < criteria.length; i++) {
        const { filters, ids, orderBy, limit } = criteria[i];

        await withRetry(async () => {
          let query = supabase.from(tableName).delete();

          // Apply ID filters if provided
          if (ids && ids.length > 0) {
            query = query.in("id" as any, ids);
          }

          // Apply other filters
          if (filters) {
            query = applyFilters(query, filters);
          }

          // Apply ordering (useful for limited deletes)
          if (orderBy && orderBy.length > 0) {
            query = applyOrdering(query, orderBy);
          }

          // Apply limit (either specified or safety limit)
          const effectiveLimit = Math.min(limit || Number.MAX_SAFE_INTEGER, safetyLimit || Number.MAX_SAFE_INTEGER);

          if (effectiveLimit < Number.MAX_SAFE_INTEGER) {
            query = query.limit(effectiveLimit);
          }

          // Apply performance options
          if (performanceOptions?.timeout) {
            query = query.abortSignal(AbortSignal.timeout(performanceOptions.timeout));
          }

          // First, count the records that will be deleted
          let countQuery = supabase.from(tableName).select("*", { count: "exact", head: true });

          if (ids && ids.length > 0) {
            countQuery = countQuery.in("id" as any, ids);
          }
          if (filters) {
            countQuery = applyFilters(countQuery, filters);
          }
          if (orderBy && orderBy.length > 0) {
            countQuery = applyOrdering(countQuery, orderBy);
          }
          if (effectiveLimit < Number.MAX_SAFE_INTEGER) {
            countQuery = countQuery.limit(effectiveLimit);
          }

          const { count: recordCount, error: countError } = await countQuery;
          if (countError) throw countError;

          // Now perform the actual delete
          const { error } = await query;
          if (error) throw error;

          const deletedInThisCriteria = recordCount || 0;
          totalDeleted += deletedInThisCriteria;
          details.push({ criteriaIndex: i, deletedCount: deletedInThisCriteria });

          completed++;
          onProgress?.(completed, total);
        });
      }

      return { deletedCount: totalDeleted, details };
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ["table", tableName] });
      queryClient.invalidateQueries({ queryKey: ["unique", tableName] });
    },
  });

  // Batch operation with transaction-like behavior (all or nothing)
  const transactionalBulkOperation = useMutation({
    mutationFn: async (params: {
      operations: Array<{
        type: "insert" | "update" | "delete";
        data?: any;
        filters?: Filters;
        ids?: string[];
      }>;
    }): Promise<{ success: boolean; results: any[]; errors?: Error[] }> => {
      const { operations } = params;
      const results: any[] = [];
      const errors: Error[] = [];

      // In a real implementation, you might want to use database transactions
      // For now, we'll simulate transaction-like behavior with rollback on error

      try {
        for (const operation of operations) {
          switch (operation.type) {
            case "insert":
              if (!operation.data) throw new Error("Insert operation requires data");
              const { data: insertData, error: insertError } = await supabase.from(tableName).insert(operation.data).select();
              if (insertError) throw insertError;
              results.push(insertData);
              break;

            case "update":
              if (!operation.data) throw new Error("Update operation requires data");
              let updateQuery = supabase.from(tableName).update(operation.data);

              if (operation.ids) {
                updateQuery = updateQuery.in("id" as any, operation.ids);
              }
              if (operation.filters) {
                updateQuery = applyFilters(updateQuery, operation.filters);
              }

              const { data: updateData, error: updateError } = await updateQuery.select();
              if (updateError) throw updateError;
              results.push(updateData);
              break;

            case "delete":
              let deleteQuery = supabase.from(tableName).delete();

              if (operation.ids) {
                deleteQuery = deleteQuery.in("id" as any, operation.ids);
              }
              if (operation.filters) {
                deleteQuery = applyFilters(deleteQuery, operation.filters);
              }

              const { error: deleteError } = await deleteQuery;
              if (deleteError) throw deleteError;
              results.push({ deleted: true });
              break;
          }
        }

        return { success: true, results };
      } catch (error) {
        errors.push(error as Error);
        // In a real database transaction, you would rollback here
        return { success: false, results: [], errors };
      }
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ["table", tableName] });
      queryClient.invalidateQueries({ queryKey: ["unique", tableName] });
    },
  });

  return {
    advancedBulkUpdate,
    advancedBulkDelete,
    transactionalBulkOperation,
  };
}

```

<!-- path: hooks/database/core-queries.ts -->
```typescript
/* eslint-disable @typescript-eslint/no-explicit-any */
import {
  useQuery,
  useInfiniteQuery,
  InfiniteData,
} from '@tanstack/react-query';
import { SupabaseClient } from '@supabase/supabase-js';
import { Database, Json } from '@/types/supabase-types';
import {
  TableOrViewName,
  TableName,
  Row,
  RowWithCount,
  DeduplicationOptions,
  InfiniteQueryPage,
  UseTableQueryOptions,
  UseTableInfiniteQueryOptions,
  UseTableRecordOptions,
  UseUniqueValuesOptions,
} from './queries-type-helpers';
import {
  applyFilters,
  applyOrdering,
  buildDeduplicationQuery,
  createQueryKey,
  createUniqueValuesKey,
} from './utility-functions';

// Generic table query hook with enhanced features
export function useTableQuery<
  T extends TableOrViewName,
  TData = RowWithCount<Row<T>>[]
>(
  supabase: SupabaseClient<Database>,
  tableName: T,
  options?: UseTableQueryOptions<T, TData>
) {
  const {
    columns = '*',
    filters,
    orderBy,
    limit,
    offset,
    deduplication,
    aggregation,
    performance,
    includeCount = false,
    ...queryOptions
  } = options || {};

  type QueryFnData = RowWithCount<Row<T>>[];

  return useQuery({
    queryKey: createQueryKey(
      tableName,
      filters,
      columns,
      orderBy,
      deduplication, // 5th argument
      aggregation,   // 6th argument
      undefined,     // 7th argument (enhancedOrderBy not used here)
      limit,         // 8th argument
      offset         // 9th argument
    ),
    queryFn: async (): Promise<QueryFnData> => {
      if (deduplication) {
        const sql = buildDeduplicationQuery(
          tableName as string,
          deduplication,
          filters,
          orderBy
        );
        const { data: rpcData, error: rpcError } = await supabase.rpc(
          'execute_sql',
          { sql_query: sql }
        );
        if (rpcError) throw rpcError;
        if (rpcData && (rpcData as any).error)
          throw new Error(`Database RPC Error: ${(rpcData as any).error}`);
        return (rpcData as any)?.result || [];
      }

      if (aggregation) {
        const { data, error } = await supabase.rpc('aggregate_query', {
          table_name: tableName,
          aggregation_options: aggregation as unknown as Json,
          filters: (filters || {}) as unknown as Json,
          order_by: (orderBy || []) as unknown as Json,
        });
        if (error) throw error;
        return (data as any)?.result || [];
      }

      // When includeCount is requested, use Supabase's metadata count to support relation selects.
      // We then project the count back onto each row as `total_count` for backward compatibility.
      let query = includeCount
        ? supabase
            .from(tableName as any)
            .select(columns as string, { count: 'exact' })
        : supabase.from(tableName as any).select(columns as string);

      if (filters) query = applyFilters(query, filters);
      if (orderBy?.length) query = applyOrdering(query, orderBy);
      if (limit !== undefined) query = query.limit(limit);
      if (offset !== undefined)
        query = query.range(offset, offset + (limit || 1000) - 1);
      if (performance?.timeout)
        query = query.abortSignal(AbortSignal.timeout(performance.timeout));

      const { data, error, count } = (await query) as any;
      if (error) throw error;
      const rows = (data as unknown as Row<T>[]) || [];
      if (!includeCount) return rows as unknown as QueryFnData;
      const total = typeof count === 'number' ? count : 0;
      // Attach total_count to each row to emulate window-count behavior
      const withCount = rows.map((r) => ({
        ...(r as any),
        total_count: total,
      }));
      return withCount as unknown as QueryFnData;
    },
    ...queryOptions,
  });
}

// Infinite scroll query hook for large datasets
export function useTableInfiniteQuery<
  T extends TableOrViewName,
  TData = InfiniteData<InfiniteQueryPage<T>>
>(
  supabase: SupabaseClient<Database>,
  tableName: T,
  options?: UseTableInfiniteQueryOptions<T, TData>
) {
  const {
    columns = '*',
    filters,
    orderBy,
    pageSize = 20,
    performance,
    ...queryOptions
  } = options || {};

  return useInfiniteQuery({
    queryKey: createQueryKey(
      tableName,
      filters,
      columns,
      orderBy,
      undefined,
      undefined,
      undefined,
      pageSize
    ),
    queryFn: async ({ pageParam = 0 }) => {
      let query = supabase
        .from(tableName as any)
        .select(columns, { count: 'exact' });

      if (filters) query = applyFilters(query, filters);
      if (orderBy?.length) query = applyOrdering(query, orderBy);

      const startIdx = pageParam * pageSize;
      query = query.range(startIdx, startIdx + pageSize - 1);

      if (performance?.timeout)
        query = query.abortSignal(AbortSignal.timeout(performance.timeout));

      const { data, error, count } = await query;
      if (error) throw error;

      const results = (data as unknown as Row<T>[]) || [];

      return {
        data: results,
        nextCursor: results.length === pageSize ? pageParam + 1 : undefined,
        count: count ?? 0,
      };
    },
    getNextPageParam: (lastPage) => lastPage.nextCursor,
    initialPageParam: 0,
    ...queryOptions,
  });
}

// Generic single record query hook (optimized)
export function useTableRecord<
  T extends TableOrViewName,
  TData = Row<T> | null
>(
  supabase: SupabaseClient<Database>,
  tableName: T,
  id: string | null,
  options?: UseTableRecordOptions<T, TData>
) {
  const { columns = '*', performance, ...queryOptions } = options || {};

  return useQuery({
    queryKey: createQueryKey(tableName, { id: id as any }, columns),
    queryFn: async (): Promise<Row<T> | null> => {
      if (!id) return null;

      let query = supabase
        .from(tableName as any)
        .select(columns)
        .eq('id', id);

      if (performance?.timeout)
        query = query.abortSignal(AbortSignal.timeout(performance.timeout));

      const { data, error } = await query.maybeSingle();

      if (error) {
        if (error.code === 'PGRST116') return null; // Not found, which is a valid null result
        throw error;
      }
      return (data as unknown as Row<T>) || null;
    },
    enabled: !!id && (queryOptions?.enabled ?? true),
    staleTime: 5 * 60 * 1000,
    ...queryOptions,
  });
}

// Get unique values for a specific column
export function useUniqueValues<T extends TableOrViewName, TData = unknown[]>(
  supabase: SupabaseClient<Database>,
  tableName: T,
  column: string,
  options?: UseUniqueValuesOptions<T, TData>
) {
  const { filters, orderBy, limit, ...queryOptions } = options || {};

  return useQuery({
    queryKey: createUniqueValuesKey(tableName, column, filters, orderBy),
    queryFn: async (): Promise<unknown[]> => {
      const { data, error } = await supabase.rpc('get_unique_values', {
        p_table_name: tableName,
        p_column_name: column,
        p_filters: (filters || {}) as unknown as Json,
        p_order_by: (orderBy || []) as unknown as Json,
        p_limit_count: limit,
      });
      if (error) {
        console.error(
          'RPC unique values failed, falling back to direct query',
          error
        );
        // Fallback implementation
        let fallbackQuery = supabase.from(tableName as any).select(column);
        if (filters) fallbackQuery = applyFilters(fallbackQuery, filters);
        if (orderBy?.length)
          fallbackQuery = applyOrdering(fallbackQuery, orderBy);
        if (limit) fallbackQuery = fallbackQuery.limit(limit);

        const { data: fallbackData, error: fallbackError } =
          await fallbackQuery;
        if (fallbackError) throw fallbackError;
        return [
          ...new Set(
            (fallbackData as any[])?.map((item) => item[column]) || []
          ),
        ];
      }
      return (data as any)?.map((item: any) => item.value) || [];
    },
    staleTime: 10 * 60 * 1000,
    ...queryOptions,
  });
}

// Deduplicated rows hook
export function useDeduplicated<T extends TableName>(
  supabase: SupabaseClient<Database>,
  tableName: T,
  deduplicationOptions: DeduplicationOptions,
  options?: Omit<UseTableQueryOptions<T>, 'deduplication'>
) {
  return useTableQuery(supabase, tableName, {
    ...options,
    deduplication: deduplicationOptions,
  });
}

// Relationship query hook with optimizations
export function useTableWithRelations<
  T extends TableName,
  TData = RowWithCount<Row<T>>[]
>(
  supabase: SupabaseClient<Database>,
  tableName: T,
  relations: string[],
  options?: UseTableQueryOptions<T, TData>
) {
  const columnsString =
    relations.length > 0 ? `*, ${relations.join(', ')}` : '*';

  return useTableQuery<T, TData>(supabase, tableName, {
    ...options,
    columns: columnsString,
  });
}

```

<!-- path: hooks/database/rpc-hook-factory.ts -->
```typescript
// path: hooks/database/rpc-hook-factory.ts
import { useQuery, UseQueryOptions, UseQueryResult } from "@tanstack/react-query";
import { SupabaseClient } from "@supabase/supabase-js";
import { Database, Json } from "@/types/supabase-types";
import { RpcFunctionName, RpcFunctionArgs, RpcFunctionReturns } from "./queries-type-helpers";
import { DEFAULTS } from "@/config/constants";

// Define a specific interface for the arguments our paged RPC functions accept.
// This solves the "is not assignable to type 'never'" error.
interface PagedRpcArgs {
  p_limit: number;
  p_offset: number;
  p_order_by: string;
  p_order_dir: 'asc' | 'desc';
  p_filters: Json;
}

// Type for the options our hook will accept. It's clean and simple.
type PagedRpcHookOptions = {
  limit?: number;
  offset?: number;
  orderBy?: string;
  orderDir?: "asc" | "desc";
  filters?: Json;
};

// Generic type for the actual query options passed to TanStack Query.
// This allows users to pass standard options like `staleTime`, `enabled`, etc.
type PagedRpcQueryOptions<TResult> = Omit<
  UseQueryOptions<TResult, Error>,
  'queryKey' | 'queryFn'
>;

/**
 * A factory function that creates a reusable and type-safe TanStack Query hook
 * for any of your paginated RPC functions.
 * @param functionName The name of the PostgreSQL RPC function.
 * @param queryKeyPrefix A unique prefix for the query key.
 * @param defaultOrderBy The default column to sort by.
 */
export function createPagedRpcHook<
  TName extends RpcFunctionName,
  TResult = RpcFunctionReturns<TName> // The result type is now correctly INFERRED from the function name
>(
  functionName: TName, // TName is now constrained to be a valid RpcFunctionName
  queryKeyPrefix: string,
  defaultOrderBy: string
) {
  // This is the returned custom hook
  return function usePagedRpc(
    supabase: SupabaseClient<Database>,
    hookOptions: PagedRpcHookOptions = {},
    queryOptions: PagedRpcQueryOptions<TResult> = {}
  ): UseQueryResult<TResult, Error> {
    const {
      limit = DEFAULTS.PAGE_SIZE,
      offset = 0,
      orderBy = defaultOrderBy,
      orderDir = "asc",
      filters = {},
    } = hookOptions;

    const queryKey = [queryKeyPrefix, { limit, offset, orderBy, orderDir, filters }];

    const queryFn = async (): Promise<TResult> => {
      const rpcArgs: PagedRpcArgs = {
        p_limit: limit,
        p_offset: offset,
        p_order_by: orderBy,
        p_order_dir: orderDir,
        p_filters: filters,
      };

      const { data, error } = await supabase.rpc(
        functionName,
        rpcArgs as RpcFunctionArgs<TName>
      );

      if (error) {
        console.error(`Error fetching from RPC '${String(functionName)}':`, error);
        throw new Error(error.message);
      }
      
      return (data ?? []) as TResult;
    };

    return useQuery<TResult, Error>({
      queryKey,
      queryFn,
      ...queryOptions,
    });
  };
}
```

<!-- path: hooks/database/index.ts -->
```typescript
// hooks/database/index.ts - Main export file
export * from './queries-type-helpers'
export * from './utility-functions'
export * from './core-queries'
export * from './basic-mutation-hooks'
export * from './bulk-queries'
export * from './advanced-bulk-queries'

// Additional specialized hooks for complex operations
export * from './rpc-queries'
// Performance and Cache hooks
export * from './cache-performance'









```

<!-- path: hooks/database/path-mutations.ts -->
```typescript
"use client";

import { useMutation, useQueryClient } from "@tanstack/react-query";
import { createClient } from "@/utils/supabase/client";
import { toast } from "sonner";

const supabase = createClient();

/**
 * Hook to call the RPC function for deleting a path segment and reordering the rest.
 */
export function useDeletePathSegment() {
  const queryClient = useQueryClient();
  return useMutation({
    mutationFn: async ({ segmentId, pathId }: { segmentId: string, pathId: string }) => {
      const { error } = await supabase.rpc('delete_path_segment_and_reorder', {
        p_segment_id: segmentId,
        p_path_id: pathId,
      });
      if (error) throw error;
    },
    onSuccess: (_, { pathId }) => {
      toast.success("Path segment deleted.");
      queryClient.invalidateQueries({ queryKey: ['system-path', pathId] });
    },
    onError: (err) => toast.error(`Failed to delete segment: ${err.message}`),
  });
}

/**
 * Hook to call the RPC function for reordering path segments via drag-and-drop.
 */
export function useReorderPathSegments() {
  const queryClient = useQueryClient();
  return useMutation({
    mutationFn: async ({ pathId, segmentIds }: { pathId: string, segmentIds: string[] }) => {
      const { error } = await supabase.rpc('reorder_path_segments', {
        p_path_id: pathId,
        p_segment_ids: segmentIds,
      });
      if (error) throw error;
    },
    onSuccess: (_, { pathId }) => {
      toast.success("Path reordered successfully.");
      queryClient.invalidateQueries({ queryKey: ['system-path', pathId] });
    },
    onError: (err) => toast.error(`Failed to reorder path: ${err.message}`),
  });
}

// ... (keep existing hooks)

/**
 * Hook to call the RPC function for provisioning a fiber onto a path.
 */
export function useProvisionFiber() {
  const queryClient = useQueryClient();
  return useMutation({
      mutationFn: async ({ pathId, fiberNo }: { pathId: string, fiberNo: number }) => {
          const { error } = await supabase.rpc('provision_fiber_on_path', {
              p_path_id: pathId,
              p_fiber_no: fiberNo
          });
          if (error) throw error;
      },
      onSuccess: (_, { pathId }) => {
          toast.success("Fiber provisioned successfully!");
          // Refetch everything related to paths and connections to update the UI state
          queryClient.invalidateQueries({ queryKey: ['system-path', pathId] });
          queryClient.invalidateQueries({ queryKey: ['available-fibers', pathId] }); 
          queryClient.invalidateQueries({ queryKey: ['ofc_connections'] });
      },
      onError: (err) => toast.error(`Provisioning failed: ${err.message}`),
  });
}

export function useProvisionRingPath() {
  const queryClient = useQueryClient();
  return useMutation({
      mutationFn: async (variables: { 
          systemId: string;
          pathName: string;
          workingFiber: number;
          protectionFiber: number;
          physicalPathId: string; 
      }) => {
          const { error } = await supabase.rpc('provision_logical_path', {
              p_system_id: variables.systemId,
              p_path_name: variables.pathName,
              p_working_fiber_no: variables.workingFiber,
              p_protection_fiber_no: variables.protectionFiber,
              p_physical_path_id: variables.physicalPathId
          });
          if (error) throw error;
      },
      onSuccess: (_, variables) => {
          toast.success("Ring path provisioned successfully!");
          // Invalidate all related queries to refresh the UI state completely
          queryClient.invalidateQueries({ queryKey: ['system-path', variables.physicalPathId] });
          queryClient.invalidateQueries({ queryKey: ['available-fibers', variables.physicalPathId] }); 
          queryClient.invalidateQueries({ queryKey: ['logical_fiber_paths'] });
          queryClient.invalidateQueries({ queryKey: ['ofc_connections'] });
          queryClient.invalidateQueries({ queryKey: ['v_cable_utilization'] });
      },
      onError: (err) => toast.error(`Provisioning failed: ${err.message}`),
  });
}

export function useDeprovisionPath() {
  const queryClient = useQueryClient();
  return useMutation({
    mutationFn: async ({ pathId }: { pathId: string }) => {
      const { error } = await supabase.rpc('deprovision_logical_path', {
        p_path_id: pathId
      });
      if (error) throw error;
    },
    onSuccess: (_, { pathId }) => {
      toast.success("Path de-provisioned successfully!");
      // Invalidate all related queries to reflect the change
      queryClient.invalidateQueries({ queryKey: ['system-path', pathId] });
      queryClient.invalidateQueries({ queryKey: ['available-fibers', pathId] });
      queryClient.invalidateQueries({ queryKey: ['logical_fiber_paths'] });
      queryClient.invalidateQueries({ queryKey: ['ofc_connections'] });
      queryClient.invalidateQueries({ queryKey: ['v_cable_utilization'] });
    },
    onError: (err) => toast.error(`De-provisioning failed: ${err.message}`),
  });
}
```

<!-- path: hooks/database/rpc-queries.ts -->
```typescript
// path: hooks/database/rpc-queries.ts
import { useQuery, useMutation, useQueryClient, UseQueryOptions } from '@tanstack/react-query';
import { SupabaseClient } from '@supabase/supabase-js';
import { Database } from '@/types/supabase-types';
import {
  RpcFunctionName,
  RpcFunctionArgs,
  RpcFunctionReturns,
  UseRpcQueryOptions,
  UseTableMutationOptions,
  Filters,
} from './queries-type-helpers';
import { buildRpcFilters, createRpcQueryKey } from './utility-functions';
import { DEFAULTS } from '@/config/constants';

// =================================================================
// Section 1: Generic & Specific RPC Hooks (Non-Paginated)
// =================================================================

// Generic RPC query hook for any non-paginated function
export function useRpcQuery<
  T extends RpcFunctionName,
  TData = RpcFunctionReturns<T>
>(
  supabase: SupabaseClient<Database>,
  functionName: T,
  args?: RpcFunctionArgs<T>,
  options?: Omit<UseQueryOptions<RpcFunctionReturns<T>, Error, TData>, 'queryKey' | 'queryFn'>
) {
  const { performance, ...queryOptions } = (options || {}) as UseRpcQueryOptions<T, TData>;

  return useQuery<RpcFunctionReturns<T>, Error, TData>({
    queryKey: createRpcQueryKey(functionName, args, performance),
    queryFn: async (): Promise<RpcFunctionReturns<T>> => {
      const { data, error } = await supabase.rpc(
        functionName,
        args || ({} as RpcFunctionArgs<T>)
      );
      if (error) throw error;
      return data as RpcFunctionReturns<T>;
    },
    staleTime: 3 * 60 * 1000,
    ...queryOptions,
  });
}

// Generic RPC mutation hook
export function useRpcMutation<T extends RpcFunctionName>(
  supabase: SupabaseClient<Database>,
  functionName: T,
  options?: UseTableMutationOptions<RpcFunctionReturns<T>, RpcFunctionArgs<T>>
) {
  const queryClient = useQueryClient();
  const { invalidateQueries = true, ...mutationOptions } = options || {};

  return useMutation({
    mutationFn: async (
      args: RpcFunctionArgs<T>
    ): Promise<RpcFunctionReturns<T>> => {
      const { data, error } = await supabase.rpc(
        functionName,
        args || ({} as RpcFunctionArgs<T>)
      );
      if (error) throw error;
      return data as RpcFunctionReturns<T>;
    },
    //  The onSuccess callback now correctly accepts all four arguments
    onSuccess: (data, variables, context, mutation) => {
      if (invalidateQueries) {
        queryClient.invalidateQueries({ queryKey: ['table'] });
        queryClient.invalidateQueries({ queryKey: ['rpc'] });
      }
      // The original onSuccess is called with the correct signature
      if (options?.onSuccess) {
        options.onSuccess(data, variables, context, mutation);
      }
    },
    ...mutationOptions,
  });
}

// Specific hook for the dashboard overview
export function useDashboardOverview(
  supabase: SupabaseClient<Database>,
  options?: UseRpcQueryOptions<'get_dashboard_overview'>
) {
  return useRpcQuery(supabase, 'get_dashboard_overview', {}, options);
}

// =================================================================
// Section 2: Efficient Generic Pagination Hook
// =================================================================

// Define the shape of the JSONB object returned by the efficient `get_paged_data` SQL function
export interface PagedDataResult<T> {
  data: T[];
  total_count: number;
  active_count: number;
  inactive_count: number;
}

// CORRECTED: The options now correctly use the `Filters` type
interface UsePagedDataOptions {
  limit?: number;
  offset?: number;
  orderBy?: string;
  orderDir?: 'asc' | 'desc';
  filters?: Filters; // <-- This now uses the correct, complex Filters type
}

function isPagedDataResult<T>(obj: unknown): obj is PagedDataResult<T> {
  if (typeof obj !== 'object' || obj === null) return false;
  const o = obj as Record<string, unknown>;
  return (
    Array.isArray(o['data']) &&
    typeof o['total_count'] === 'number' &&
    typeof o['active_count'] === 'number' &&
    typeof o['inactive_count'] === 'number'
  );
}

export function usePagedData<T>(
  supabase: SupabaseClient<Database>,
  viewName: string | null,
  hookOptions: UsePagedDataOptions = {},
  queryOptions: Omit<UseQueryOptions<PagedDataResult<T>, Error>, 'queryKey' | 'queryFn'> = {}
) {
  const {
    limit = DEFAULTS.PAGE_SIZE,
    offset = 0,
    orderBy = 'name',
    orderDir = 'asc',
    filters = {},
  } = hookOptions;

  // The hook internally converts the complex Filters object to the simple JSON the RPC expects
  const rpcFilters = buildRpcFilters(filters);
  const queryKey = ['paged-data', viewName, { limit, offset, orderBy, orderDir, filters: rpcFilters }];

  const queryFn = async (): Promise<PagedDataResult<T>> => {
    const defaultValue: PagedDataResult<T> = {
      data: [],
      total_count: 0,
      active_count: 0,
      inactive_count: 0,
    };

    if (!viewName) {
      return defaultValue;
    }

    const { data, error } = await supabase.rpc('get_paged_data', {
      p_view_name: viewName,
      p_limit: limit,
      p_offset: offset,
      p_order_by: orderBy,
      p_order_dir: orderDir,
      p_filters: rpcFilters,
    });

    if (error) {
      console.error(`Error fetching paginated data for '${viewName}':`, error);
      throw new Error(error.message);
    }

    if (isPagedDataResult<T>(data)) {
      return data;
    } else {
      console.warn(`Unexpected response structure for 'get_paged_data' on view '${viewName}'.`, data);
      return defaultValue;
    }
  };

  return useQuery<PagedDataResult<T>, Error>({
    queryKey,
    queryFn,
    enabled: !!viewName && (queryOptions.enabled ?? true),
    placeholderData: (previousData) => previousData,
    ...queryOptions,
  });
}
```

<!-- path: hooks/database/cache-performance.ts -->
```typescript
import { useQueryClient, QueryClient } from "@tanstack/react-query";
import { Filters, RpcFunctionArgs, RpcFunctionName, RpcFunctionReturns, TableName, TableRow, UseTableQueryOptions } from "./queries-type-helpers";
import { SupabaseClient } from "@supabase/supabase-js";
import { Database } from "@/types/supabase-types";
import { applyFilters, applyOrdering, createQueryKey, createRpcQueryKey } from "./utility-functions";

// Performance monitoring hook
export function useQueryPerformance() {
  const queryClient = useQueryClient();

  const getQueryStats = () => {
    const cache = queryClient.getQueryCache();
    const queries = cache.getAll();

    return {
      totalQueries: queries.length,
      staleQueries: queries.filter((q) => q.isStale()).length,
      inactiveQueries: queries.filter((q) => q.getObserversCount() === 0).length,
      fetchingQueries: queries.filter((q) => q.state.status === "pending").length,
      cacheSizeBytes: JSON.stringify(cache).length,
    };
  };

  const clearStaleQueries = () => {
    queryClient.removeQueries({
      predicate: (query) => query.isStale() && query.state.status !== "pending",
    });
  };

  const prefetchCriticalData = async (supabase: SupabaseClient<Database>, criticalTables: TableName[]) => {
    const promises = criticalTables.map((tableName) =>
      queryClient.prefetchQuery({
        queryKey: ["table", tableName],
        queryFn: async () => {
          const { data, error } = await supabase.from(tableName).select("*").limit(100);
          if (error) throw error;
          return data;
        },
        staleTime: 10 * 60 * 1000, // 10 minutes
      })
    );

    await Promise.all(promises);
  };

  return {
    getQueryStats,
    clearStaleQueries,
    prefetchCriticalData,
  };
}

// Specialized hooks for RPC functions (keeping existing ones)
// This type is generated automatically by the Supabase CLI!
// Define the return type with more precision
// Use `Array<T>` syntax for clarity and add `| null` to handle initial/error states.

// Enhanced cache utilities with performance optimizations
export const tableQueryUtils = {
  invalidateTable: (queryClient: QueryClient, tableName: string) => {
    queryClient.invalidateQueries({ queryKey: ["table", tableName] });
    queryClient.invalidateQueries({ queryKey: ["unique", tableName] });
  },

  invalidateAllTables: (queryClient: QueryClient) => {
    queryClient.invalidateQueries({ queryKey: ["table"] });
    queryClient.invalidateQueries({ queryKey: ["unique"] });
  },

  invalidateRpc: (queryClient: QueryClient, functionName: string) => {
    queryClient.invalidateQueries({ queryKey: ["rpc", functionName] });
  },

  invalidateAllRpc: (queryClient: QueryClient) => {
    queryClient.invalidateQueries({ queryKey: ["rpc"] });
  },

  prefetchTable: async <T extends TableName>(queryClient: QueryClient, supabase: SupabaseClient<Database>, tableName: T, options?: UseTableQueryOptions<T>) => {
    return queryClient.prefetchQuery({
      queryKey: createQueryKey(
        tableName,
        options?.filters,
        options?.columns,
        options?.orderBy,
        options?.deduplication, // 5th argument
        options?.aggregation,   // 6th argument
        undefined,              // 7th argument (enhancedOrderBy is not used in prefetch)
        options?.limit,         // 8th argument
        options?.offset         // 9th argument
      ),
      queryFn: async (): Promise<TableRow<T>[]> => {
        let query = supabase.from(tableName).select(options?.columns || "*");

        if (options?.filters) {
          query = applyFilters(query, options.filters);
        }

        if (options?.orderBy) {
          query = applyOrdering(query, options.orderBy);
        }

        if (options?.limit) {
          query = query.limit(options.limit);
        }

        const { data, error } = await query;
        if (error) throw error;
        return (data as TableRow<T>[]) || [];
      },
      staleTime: 5 * 60 * 1000,
    });
  },

  prefetchRpc: async <T extends RpcFunctionName>(queryClient: QueryClient, supabase: SupabaseClient<Database>, functionName: T, args?: RpcFunctionArgs<T>) => {
    return queryClient.prefetchQuery({
      queryKey: createRpcQueryKey(functionName, args),
      queryFn: async (): Promise<RpcFunctionReturns<T>> => {
        const { data, error } = await supabase.rpc(functionName, args || ({} as RpcFunctionArgs<T>));
        if (error) throw error;
        return data as RpcFunctionReturns<T>;
      },
      staleTime: 3 * 60 * 1000,
    });
  },

  // Optimized cache management
  setQueryData: <T extends TableName>(queryClient: QueryClient, tableName: T, data: TableRow<T>[], filters?: Filters, columns?: string) => {
    queryClient.setQueryData(createQueryKey(tableName, filters, columns), data);
  },

  getQueryData: <T extends TableName>(queryClient: QueryClient, tableName: T, filters?: Filters, columns?: string): TableRow<T>[] | undefined => {
    return queryClient.getQueryData(createQueryKey(tableName, filters, columns));
  },

  // Performance monitoring
  getTableCacheStats: (queryClient: QueryClient, tableName: string) => {
    const cache = queryClient.getQueryCache();
    const tableQueries = cache.findAll({
      queryKey: ["table", tableName],
    });

    return {
      queryCount: tableQueries.length,
      staleCount: tableQueries.filter((q) => q.isStale()).length,
      fetchingCount: tableQueries.filter((q) => q.state.status === "pending").length,
      errorCount: tableQueries.filter((q) => q.state.status === "error").length,
      totalDataSize: tableQueries.reduce((acc, query) => {
        const data = query.state.data;
        return acc + (data ? JSON.stringify(data).length : 0);
      }, 0),
    };
  },

  // Cleanup utilities
  removeStaleQueries: (
    queryClient: QueryClient,
    maxAge = 10 * 60 * 1000 // 10 minutes
  ) => {
    queryClient.removeQueries({
      predicate: (query) => {
        const isOld = Date.now() - query.state.dataUpdatedAt > maxAge;
        return isOld && query.isStale() && query.state.status !== "pending";
      },
    });
  },

  // Batch operations
  batchInvalidate: (queryClient: QueryClient, operations: Array<{ type: "table" | "rpc"; name: string }>) => {
    operations.forEach(({ type, name }) => {
      queryClient.invalidateQueries({ queryKey: [type, name] });
    });
  },
};

```

<!-- path: hooks/database/queries-type-helpers.ts -->
```typescript
// hooks/database/queries-type-helpers.ts
import { UseQueryOptions, UseMutationOptions, UseInfiniteQueryOptions, InfiniteData } from "@tanstack/react-query";
import { Database } from "@/types/supabase-types";
import { tableNames } from '@/types/flattened-types'; // Import auto-generated names

// --- TYPE HELPERS DERIVED FROM SUPABASE ---

export type PublicTableName = keyof Database["public"]["Tables"];
export type AuthTableName = keyof Database["auth"]["Tables"];
export type TableName = PublicTableName | AuthTableName;
export type PublicTableOrViewName = PublicTableName | ViewName;
export type ViewName = keyof Database["public"]["Views"];
export type TableOrViewName = TableName | ViewName;

// Helper to check if a name is a table (and not a view)
export const isTableName = (name: TableOrViewName): name is TableName => {
  return (tableNames as readonly string[]).includes(name);
};


// Generic row types for any read operation
export type Row<T extends TableOrViewName> = T extends keyof Database["public"]["Tables"]
  ? Database["public"]["Tables"][T]["Row"]
  : T extends keyof Database["public"]["Views"]
  ? Database["public"]["Views"][T]["Row"]
  : T extends keyof Database["auth"]["Tables"]
  ? Database["auth"]["Tables"][T]["Row"]
  : never;

export type TableRow<T extends TableName> = T extends keyof Database["public"]["Tables"]
  ? Database["public"]["Tables"][T]["Row"]
  : T extends keyof Database["auth"]["Tables"]
  ? Database["auth"]["Tables"][T]["Row"]
  : never;

export type TableInsert<T extends TableName> = T extends keyof Database["public"]["Tables"]
  ? Database["public"]["Tables"][T]["Insert"]
  : T extends keyof Database["auth"]["Tables"]
  ? Database["auth"]["Tables"][T]["Insert"]
  : never;

export type TableUpdate<T extends TableName> = T extends keyof Database["public"]["Tables"]
  ? Database["public"]["Tables"][T]["Update"]
  : T extends keyof Database["auth"]["Tables"]
  ? Database["auth"]["Tables"][T]["Update"]
  : never;

// These types now correctly infer from the robust types above.
export type TableInsertWithDates<T extends TableName> = { [K in keyof TableInsert<T>]?: TableInsert<T>[K] | Date | null; };
export type TableUpdateWithDates<T extends TableName> = { [K in keyof TableUpdate<T>]?: TableUpdate<T>[K] | Date | null; };

// RPC function type helpers (unchanged)
export type RpcFunctionName = keyof Database["public"]["Functions"];
export type RpcFunctionArgs<T extends RpcFunctionName> = Database["public"]["Functions"][T]["Args"];
export type RpcFunctionReturns<T extends RpcFunctionName> = Database["public"]["Functions"][T]["Returns"];

// --- ADVANCED TYPES FOR HOOK OPTIONS (Unchanged) ---

export type FilterOperator = "eq" | "neq" | "gt" | "gte" | "lt" | "lte" | "like" | "ilike" | "in" | "not.in" | "contains" | "containedBy" | "overlaps" | "sl" | "sr" | "nxl" | "nxr" | "adj" | "is" | "isdistinct" | "fts" | "plfts" | "phfts" | "wfts" | "or";
export type FilterValue = string | number | boolean | null | string[] | number[] | { operator: FilterOperator; value: unknown };
export type Filters = {
  or?: Record<string, string> | string;
  [key: string]: FilterValue | Record<string, string> | string | undefined;
};
export type OrderBy = { column: string; ascending?: boolean; nullsFirst?: boolean; foreignTable?: string; };
export interface EnhancedOrderBy { column: string; ascending?: boolean; nullsFirst?: boolean; foreignTable?: string; dataType?: 'text' | 'numeric' | 'date' | 'timestamp' | 'boolean' | 'json'; }
export type DeduplicationOptions = { columns: string[]; orderBy?: OrderBy[]; };
export type AggregationOptions = { count?: boolean | string; sum?: string[]; avg?: string[]; min?: string[]; max?: string[]; groupBy?: string[]; };
export type PerformanceOptions = { useIndex?: string; explain?: boolean; timeout?: number; connection?: "read" | "write"; };
export type RowWithCount<T> = T & { total_count?: number };

// --- HOOK OPTIONS INTERFACES (Unchanged) ---
export interface UseTableQueryOptions<T extends TableOrViewName, TData = RowWithCount<Row<T>>[]> extends Omit<UseQueryOptions<RowWithCount<Row<T>>[], Error, TData>, "queryKey" | "queryFn"> {
  columns?: string; filters?: Filters; orderBy?: OrderBy[]; limit?: number; offset?: number; deduplication?: DeduplicationOptions; aggregation?: AggregationOptions; performance?: PerformanceOptions; includeCount?: boolean;
}
export type InfiniteQueryPage<T extends TableOrViewName> = { data: Row<T>[]; nextCursor?: number; count?: number; };
export interface UseTableInfiniteQueryOptions<T extends TableOrViewName, TData = InfiniteData<InfiniteQueryPage<T>>> extends Omit<UseInfiniteQueryOptions<InfiniteQueryPage<T>, Error, TData, readonly unknown[], number | undefined>, "queryKey" | "queryFn" | "getNextPageParam" | "initialPageParam"> {
  columns?: string; filters?: Filters; orderBy?: OrderBy[]; pageSize?: number; performance?: PerformanceOptions;
}
export interface UseTableRecordOptions<T extends TableOrViewName, TData = Row<T> | null> extends Omit<UseQueryOptions<Row<T> | null, Error, TData>, "queryKey" | "queryFn"> {
  columns?: string; performance?: PerformanceOptions;
}
export interface UseUniqueValuesOptions<T extends TableOrViewName, TData = unknown[]> extends Omit<UseQueryOptions<unknown[], Error, TData>, "queryKey" | "queryFn"> {
  tableName: T; filters?: Filters; orderBy?: OrderBy[]; limit?: number; performance?: PerformanceOptions;
}
export interface UseRpcQueryOptions<T extends RpcFunctionName, TData = RpcFunctionReturns<T>> extends Omit<UseQueryOptions<RpcFunctionReturns<T>, Error, TData>, "queryKey" | "queryFn"> {
  performance?: PerformanceOptions;
}
export interface UseTableMutationOptions<TData = unknown, TVariables = unknown, TContext = unknown> extends Omit<UseMutationOptions<TData, Error, TVariables, TContext>, "mutationFn"> {
  invalidateQueries?: boolean; optimisticUpdate?: boolean; batchSize?: number;
}
export interface OptimisticContext { previousData?: [readonly unknown[], unknown][]; }

// ... (Excel Upload types remain the same) ...
export interface UploadColumnMapping<T extends TableName> {
    excelHeader: string;
    dbKey: keyof TableInsert<T> & string;
    transform?: (value: unknown) => unknown;
    required?: boolean;
}
export type UploadType = "insert" | "upsert";
export interface UploadOptions<T extends TableName> {
    file: File;
    columns: UploadColumnMapping<T>[];
    uploadType?: UploadType;
    conflictColumn?: keyof TableInsert<T> & string;
}
export interface UploadResult {
    successCount: number;
    errorCount: number;
    totalRows: number;
    errors: { rowIndex: number; data: unknown; error: string }[];
}
export interface UseExcelUploadOptions<T extends TableName> {
    onSuccess?: (data: UploadResult, variables: UploadOptions<T>) => void;
    onError?: (error: Error, variables: UploadOptions<T>) => void;
    showToasts?: boolean;
    batchSize?: number;
}
export type DashboardOverviewData = {
  system_status_counts: { [key: string]: number };
  node_status_counts: { [key: string]: number };
  path_operational_status: { [key: string]: number };
  cable_utilization_summary: {
    average_utilization_percent: number;
    high_utilization_count: number;
    total_cables: number;
  };
  user_activity_last_30_days: {
    date: string;
    count: number;
  }[];
  systems_per_maintenance_area: { [key: string]: number };
};
```

<!-- path: hooks/database/excel-queries/excel-download.ts -->
```typescript

import { TableOrViewName, isTableName, Row, ViewName, PublicTableName, PublicTableOrViewName } from "@/hooks/database/queries-type-helpers";
import * as ExcelJS from "exceljs";
import { SupabaseClient } from "@supabase/supabase-js";
import { Database } from "@/types/supabase-types";
import { useMutation } from "@tanstack/react-query";
import { applyCellFormatting, convertFiltersToRPCParams, DownloadOptions, ExcelDownloadResult, formatCellValue, getDefaultStyles, RPCConfig, sanitizeFileName, UseExcelDownloadOptions } from "@/hooks/database/excel-queries/excel-helpers";
import { toast } from "sonner";
import { applyFilters } from "@/hooks/database/utility-functions";

// Extended types for new functionality
interface OrderByOption {
column: string;
ascending?: boolean;
}

interface EnhancedDownloadOptions<T extends TableOrViewName> extends DownloadOptions<T> {
orderBy?: OrderByOption[];
wrapText?: boolean;
autoFitColumns?: boolean;
}

interface EnhancedUseExcelDownloadOptions<T extends TableOrViewName> extends UseExcelDownloadOptions<T> {
defaultOrderBy?: OrderByOption[];
defaultWrapText?: boolean;
defaultAutoFitColumns?: boolean;
}

// Hook for RPC-based downloads with full type safety
export function useRPCExcelDownload<T extends TableOrViewName>(
  supabase: SupabaseClient<Database>,
  options?: EnhancedUseExcelDownloadOptions<T>
) {
  const {
    showToasts = true,
    batchSize = 50000,
    defaultOrderBy,
    defaultWrapText = true,
    defaultAutoFitColumns = true,
    ...mutationOptions
  } = options || {};

  return useMutation<
    ExcelDownloadResult,
    Error,
    EnhancedDownloadOptions<T> & { rpcConfig: RPCConfig }
  >({
    mutationFn: async (downloadOptions): Promise<ExcelDownloadResult> => {
      try {
        const defaultStyles = getDefaultStyles();
        const mergedOptions = {
          sheetName: "Data",
          maxRows: batchSize,
          customStyles: defaultStyles,
          orderBy: defaultOrderBy,
          wrapText: defaultWrapText,
          autoFitColumns: defaultAutoFitColumns,
          ...downloadOptions,
        };

        const {
          fileName = `export-${new Date().toISOString().split("T")[0]}.xlsx`,
          filters,
          columns,
          sheetName,
          maxRows,
          rpcConfig,
          orderBy,
          wrapText,
          autoFitColumns,
        } = mergedOptions;

        const styles = { ...defaultStyles, ...mergedOptions.customStyles };

        if (!columns || columns.length === 0)
          throw new Error("No columns specified for export");
        if (!rpcConfig)
          throw new Error("RPC configuration is required for this hook");

        const exportColumns = columns.filter((col) => !col.excludeFromExport);
        if (exportColumns.length === 0)
          throw new Error("All columns are excluded from export");

        toast.info("Fetching data via RPC...");

        // Prepare RPC parameters
        const rpcParams = {
          ...rpcConfig.parameters,
          ...convertFiltersToRPCParams(filters),
        };

        if (maxRows) {
          rpcParams.row_limit = maxRows;
        }

        // Add ordering parameters to RPC if supported
        if (orderBy && orderBy.length > 0) {
          rpcParams.order_by = orderBy.map(order => 
            `${order.column}.${order.ascending !== false ? 'asc' : 'desc'}`
          ).join(',');
        }

        // Execute RPC call with proper error handling
        const { data, error } = await supabase.rpc(
          rpcConfig.functionName as keyof Database["public"]["Functions"],
          rpcParams
        );

        if (error) throw new Error(`RPC call failed: ${error.message}`);
        if (!data || (Array.isArray(data) && data.length === 0)) {
          throw new Error("No data returned from RPC function");
        }

        // Ensure data is an array
        let dataArray = Array.isArray(data) ? data : [data];
        
        // Apply client-side ordering if RPC doesn't support it
        if (orderBy && orderBy.length > 0) {
          dataArray = dataArray.sort((a, b) => {
            for (const order of orderBy) {
              // Safe property access with type guards
              const aVal = (a && typeof a === 'object' && !Array.isArray(a)) 
                ? (a as Record<string, unknown>)[order.column] 
                : undefined;
              const bVal = (b && typeof b === 'object' && !Array.isArray(b)) 
                ? (b as Record<string, unknown>)[order.column] 
                : undefined;
              
              if (aVal === bVal) continue;
              
              let comparison = 0;
              if (aVal == null && bVal != null) comparison = 1;
              else if (aVal != null && bVal == null) comparison = -1;
              else if (aVal != null && bVal != null) {
                if (aVal < bVal) comparison = -1;
                else if (aVal > bVal) comparison = 1;
              }
              
              return order.ascending !== false ? comparison : -comparison;
            }
            return 0;
          });
        }
        
        toast.success(
          `Fetched ${dataArray.length} records. Generating Excel file...`
        );

        const workbook = new ExcelJS.Workbook();
        const worksheet = workbook.addWorksheet(sheetName || "Data");

        // Set column properties with enhanced options
        worksheet.columns = exportColumns.map((col) => ({
          key: String(col.dataIndex),
          width: typeof col.width === "number" ? col.width / 8 : 20,
        }));

        // Add header row with enhanced styling
        const headerTitles = exportColumns.map((col) => col.title);
        const headerRow = worksheet.addRow(headerTitles);
        headerRow.height = 25;

        exportColumns.forEach((col, index) => {
          const cell = headerRow.getCell(index + 1);
          if (styles.headerFont) cell.font = styles.headerFont;
          if (styles.headerFill) cell.fill = styles.headerFill;
          
          // Enhanced header alignment with text wrapping
          cell.alignment = { 
            horizontal: "center", 
            vertical: "middle",
            wrapText: wrapText || false
          };

          if (styles.borderStyle) {
            cell.border = {
              top: styles.borderStyle.top,
              bottom: styles.borderStyle.bottom,
              right: styles.borderStyle.right,
              left: index === 0 ? styles.borderStyle.left : undefined,
            };
          }
        });

        // Add data rows with enhanced styling
        dataArray.forEach((record, rowIndex: number) => {
          // Ensure we only process object-like rows
          if (record === null || typeof record !== "object" || Array.isArray(record)) {
            return; // skip non-object rows
          }

          const obj = record as Record<string, unknown>;
          const rowData: Record<string, unknown> = {};
          exportColumns.forEach((col) => {
            const key = String(col.dataIndex);
            const value = obj[key];
            rowData[key] = formatCellValue(value, col);
          });
          const excelRow = worksheet.addRow(rowData);

          // Enhanced cell styling with wrap text support
          exportColumns.forEach((col, colIndex) => {
            const cell = excelRow.getCell(colIndex + 1);

            if (styles.dataFont) cell.font = styles.dataFont;

            if (rowIndex % 2 === 1 && styles.alternateRowFill) {
              cell.fill = styles.alternateRowFill;
            }

            // Apply text wrapping and alignment
            cell.alignment = {
              ...cell.alignment,
              wrapText: wrapText || false,
              vertical: 'top' // Better for wrapped text
            };

            applyCellFormatting(cell, col);

            if (styles.borderStyle) {
              const isLastDataRow = rowIndex === dataArray.length - 1;
              cell.border = {
                right: styles.borderStyle.right,
                left: colIndex === 0 ? styles.borderStyle.left : undefined,
                top: styles.borderStyle.top,
                bottom: isLastDataRow ? styles.borderStyle.bottom : undefined,
              };
            }
          });
        });

        // Auto-fit columns if enabled
        if (autoFitColumns) {
          exportColumns.forEach((col, index) => {
            const column = worksheet.getColumn(index + 1);
            let maxLength = col.title.length;
            
            // Calculate max content length for auto-fitting
            dataArray.forEach((record) => {
              if (record && typeof record === "object" && !Array.isArray(record)) {
                const obj = record as Record<string, unknown>;
                const key = String(col.dataIndex);
                const value = obj[key];
                const cellText = String(formatCellValue(value, col) || '');
                
                // For wrapped text, consider line breaks
                if (wrapText) {
                  const lines = cellText.split('\n');
                  const maxLineLength = Math.max(...lines.map(line => line.length));
                  maxLength = Math.max(maxLength, maxLineLength);
                } else {
                  maxLength = Math.max(maxLength, cellText.length);
                }
              }
            });
            
            // Set reasonable bounds for column width
            const calculatedWidth = Math.min(Math.max(maxLength + 2, 10), 50);
            column.width = calculatedWidth;
          });
        }

        // Freeze header row
        worksheet.views = [{ state: "frozen", ySplit: 1 }];

        // Generate and download file
        const buffer = await workbook.xlsx.writeBuffer();
        const sanitizedFileName = sanitizeFileName(fileName);
        const blob = new Blob([buffer], {
          type: "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet",
        });

        const link = document.createElement("a");
        link.href = URL.createObjectURL(blob);
        link.download = sanitizedFileName;
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
        URL.revokeObjectURL(link.href);

        toast.success(
          `Excel file "${sanitizedFileName}" downloaded successfully!`
        );
        return {
          fileName: sanitizedFileName,
          rowCount: dataArray.length,
          columnCount: exportColumns.length,
        };
      } catch (error) {
        const errorMessage =
          error instanceof Error ? error.message : "Unknown error occurred";
        if (showToasts) {
          toast.error(`Download failed: ${errorMessage}`);
        }
        throw error;
      }
    },
    ...mutationOptions,
  });
}

// Hook for traditional table/view downloads with enhanced features
export function useTableExcelDownload<T extends PublicTableOrViewName>(
  supabase: SupabaseClient<Database>,
  tableName: T,
  options?: EnhancedUseExcelDownloadOptions<T>
) {
  const {
    showToasts = true,
    batchSize = 50000,
    defaultOrderBy,
    defaultWrapText = true,
    defaultAutoFitColumns = true,
    ...mutationOptions
  } = options || {};

  return useMutation<
    ExcelDownloadResult,
    Error,
    Omit<EnhancedDownloadOptions<T>, "rpcConfig">
  >({
    mutationFn: async (downloadOptions): Promise<ExcelDownloadResult> => {
      try {
        const defaultStyles = getDefaultStyles();
        const mergedOptions = {
          sheetName: "Data",
          maxRows: batchSize,
          customStyles: defaultStyles,
          orderBy: defaultOrderBy,
          wrapText: defaultWrapText,
          autoFitColumns: defaultAutoFitColumns,
          ...downloadOptions,
        };

        const {
          fileName = `${String(tableName)}-${
            new Date().toISOString().split("T")[0]
          }.xlsx`,
          filters,
          columns,
          sheetName,
          maxRows,
          orderBy,
          wrapText,
          autoFitColumns,
        } = mergedOptions;

        const styles = { ...defaultStyles, ...mergedOptions.customStyles };

        if (!columns || columns.length === 0)
          throw new Error("No columns specified for export");
        const exportColumns = columns.filter((col) => !col.excludeFromExport);
        if (exportColumns.length === 0)
          throw new Error("All columns are excluded from export");

        toast.info("Fetching data for download...");

        const selectFields = exportColumns
          .map((col) => col.dataIndex)
          .join(",");
        let query = isTableName(tableName)
          ? supabase.from(tableName as PublicTableName).select(selectFields)
          : supabase.from(tableName as ViewName).select(selectFields);

        if (filters) query = applyFilters(query, filters);
        
        // Apply ordering to the Supabase query
        if (orderBy && orderBy.length > 0) {
          orderBy.forEach(order => {
            query = query.order(order.column, { ascending: order.ascending !== false });
          });
        }
        
        if (maxRows) query = query.limit(maxRows);

        const { data, error } = await query;

        if (error) throw new Error(`Failed to fetch data: ${error.message}`);
        if (!data || data.length === 0)
          throw new Error("No data found for the selected criteria");

        const typedData = data as Row<T>[];
        toast.success(
          `Fetched ${typedData.length} records. Generating Excel file...`
        );

        // Excel generation logic with enhanced features
        const workbook = new ExcelJS.Workbook();
        const worksheet = workbook.addWorksheet(sheetName || "Data");

        worksheet.columns = exportColumns.map((col) => ({
          key: String(col.dataIndex),
          width: typeof col.width === "number" ? col.width / 8 : 20,
        }));

        const headerTitles = exportColumns.map((col) => col.title);
        const headerRow = worksheet.addRow(headerTitles);
        headerRow.height = wrapText ? 30 : 25; // Increase height for wrapped text

        exportColumns.forEach((col, index) => {
          const cell = headerRow.getCell(index + 1);
          if (styles.headerFont) cell.font = styles.headerFont;
          if (styles.headerFill) cell.fill = styles.headerFill;
          
          // Enhanced header alignment with text wrapping
          cell.alignment = { 
            horizontal: "center", 
            vertical: "middle",
            wrapText: wrapText || false
          };

          if (styles.borderStyle) {
            cell.border = {
              top: styles.borderStyle.top,
              bottom: styles.borderStyle.bottom,
              right: styles.borderStyle.right,
              left: index === 0 ? styles.borderStyle.left : undefined,
            };
          }
        });

        // Add data rows with enhanced styling
        typedData.forEach((record, rowIndex) => {
          const rowData: Record<string, unknown> = {};
          exportColumns.forEach((col) => {
            const key = col.dataIndex as keyof Row<T> & string;
            rowData[key] = formatCellValue(record[key], col);
          });
          const excelRow = worksheet.addRow(rowData);
          
          // Set row height for wrapped text
          if (wrapText) {
            excelRow.height = 20; // Minimum height, will auto-expand
          }

          exportColumns.forEach((col, colIndex) => {
            const cell = excelRow.getCell(colIndex + 1);

            if (styles.dataFont) cell.font = styles.dataFont;

            if (rowIndex % 2 === 1 && styles.alternateRowFill) {
              cell.fill = styles.alternateRowFill;
            }

            // Apply text wrapping and alignment
            cell.alignment = {
              ...cell.alignment,
              wrapText: wrapText || false,
              vertical: 'top' // Better for wrapped text
            };

            applyCellFormatting(cell, col);

            if (styles.borderStyle) {
              const isLastDataRow = rowIndex === typedData.length - 1;
              cell.border = {
                right: styles.borderStyle.right,
                left: colIndex === 0 ? styles.borderStyle.left : undefined,
                top: styles.borderStyle.top,
                bottom: isLastDataRow ? styles.borderStyle.bottom : undefined,
              };
            }
          });
        });

        // Auto-fit columns if enabled
        if (autoFitColumns) {
          exportColumns.forEach((col, index) => {
            const column = worksheet.getColumn(index + 1);
            let maxLength = col.title.length;
            
            // Calculate max content length for auto-fitting
            typedData.forEach((record) => {
              const key = col.dataIndex as keyof Row<T> & string;
              const value = record[key];
              const cellText = String(formatCellValue(value, col) || '');
              
              // For wrapped text, consider line breaks
              if (wrapText) {
                const lines = cellText.split('\n');
                const maxLineLength = Math.max(...lines.map(line => line.length));
                maxLength = Math.max(maxLength, maxLineLength);
              } else {
                maxLength = Math.max(maxLength, cellText.length);
              }
            });
            
            // Set reasonable bounds for column width
            const calculatedWidth = Math.min(Math.max(maxLength + 2, 10), wrapText ? 30 : 50);
            column.width = calculatedWidth;
          });
        }

        worksheet.views = [{ state: "frozen", ySplit: 1 }];

        const buffer = await workbook.xlsx.writeBuffer();
        const sanitizedFileName = sanitizeFileName(fileName);
        const blob = new Blob([buffer], {
          type: "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet",
        });

        const link = document.createElement("a");
        link.href = URL.createObjectURL(blob);
        link.download = sanitizedFileName;
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
        URL.revokeObjectURL(link.href);

        toast.success(
          `Excel file "${sanitizedFileName}" downloaded successfully!`
        );
        return {
          fileName: sanitizedFileName,
          rowCount: typedData.length,
          columnCount: exportColumns.length,
        };
      } catch (error) {
        const errorMessage =
          error instanceof Error ? error.message : "Unknown error occurred";
        if (
          showToasts &&
          errorMessage !== "No data found for the selected criteria"
        ) {
          toast.error(`Download failed: ${errorMessage}`);
        }
        throw error;
      }
    },
    ...mutationOptions,
  });
}

```

<!-- path: hooks/database/excel-queries/excel-helpers.ts -->
```typescript
// hooks/database/excel-queries.ts
import * as ExcelJS from "exceljs";
import { Filters, UploadResult } from "@/hooks/database";
import { TableOrViewName, Row } from "@/hooks/database";

//================================================================================
// TYPES AND INTERFACES
//================================================================================

export interface Column<T> {
  key: string;
  title: string;
  dataIndex: string;
  width?: number | string;
  sortable?: boolean;
  searchable?: boolean;
  filterable?: boolean;
  editable?: boolean;
  render?: (value: unknown, record: T, index: number) => React.ReactNode;
  filterOptions?: { label: string; value: unknown }[];
  align?: "left" | "center" | "right";
  hidden?: boolean;
  excelFormat?: "text" | "number" | "date" | "currency" | "percentage" | "json";
  excludeFromExport?: boolean;
}

// Generic RPC Configuration that works with any function
export interface RPCConfig<TParams = Record<string, unknown>> {
  functionName: string;
  parameters?: TParams;
  selectFields?: string;
}

// NOTE: T refers to a table/view name. Columns should describe a Row<T>.
export interface DownloadOptions<
  T extends TableOrViewName = TableOrViewName
> {
  fileName?: string;
  filters?: Filters;
  columns?: Column<Row<T>>[];
  sheetName?: string;
  maxRows?: number;
  customStyles?: ExcelStyles;
  rpcConfig?: RPCConfig;
}

export interface ExcelStyles {
  headerFont?: Partial<ExcelJS.Font>;
  headerFill?: ExcelJS.FillPattern;
  dataFont?: Partial<ExcelJS.Font>;
  alternateRowFill?: ExcelJS.FillPattern;
  borderStyle?: Partial<ExcelJS.Borders>;
}

export interface ExcelDownloadResult {
  fileName: string;
  rowCount: number;
  columnCount: number;
}

export interface UseExcelDownloadOptions<
  T extends TableOrViewName = TableOrViewName
> {
  onSuccess?: (
    data: ExcelDownloadResult,
    variables: DownloadOptions<T>
  ) => void;
  onError?: (error: Error, variables: DownloadOptions<T>) => void;
  showToasts?: boolean;
  batchSize?: number;
  defaultRPCConfig?: RPCConfig;
}

// Enhanced error tracking interfaces
export interface ValidationError {
  rowIndex: number;
  column: string;
  value: unknown;
  error: string;
  data?: Record<string, unknown>;
}

export interface ProcessingLog {
  rowIndex: number;
  excelRowNumber: number;
  originalData: Record<string, unknown>;
  processedData: Record<string, unknown>;
  validationErrors: ValidationError[];
  isSkipped: boolean;
  skipReason?: string;
}

export interface EnhancedUploadResult extends UploadResult {
  processingLogs: ProcessingLog[];
  validationErrors: ValidationError[];
  skippedRows: number;
}

//================================================================================
// UTILITY FUNCTIONS
//================================================================================

export const createFillPattern = (color: string): ExcelJS.FillPattern => ({
  type: "pattern",
  pattern: "solid",
  fgColor: { argb: color },
});

export const formatCellValue = <T = unknown>(
  value: unknown,
  column: Column<T>
): unknown => {
  if (value === null || value === undefined) return "";
  
  // Handle number types first
  if (typeof value === 'number') {
    return value;
  }
  
  // Handle object values
  if (typeof value === 'object' && value !== null) {
    // If it's a Date object
    if (value instanceof Date) {
      return value;
    }
    // If it's an array, join with comma
    if (Array.isArray(value)) {
      return value.join(', ');
    }
    // For other objects, try to stringify
    try {
      const str = JSON.stringify(value);
      // If it's a JSON object string, parse and get a simple string representation
      if (str.startsWith('{') || str.startsWith('[')) {
        const parsed = JSON.parse(str);
        if (typeof parsed === 'object' && parsed !== null) {
          // For objects, get values and join
          if (Array.isArray(parsed)) {
            return parsed.join(', ');
          }
          return Object.values(parsed).filter(v => v !== undefined && v !== null).join(', ');
        }
        return String(parsed);
      }
      return str;
    } catch {
      return String(value);
    }
  }

  // Handle non-object values
  switch (column.excelFormat) {
    case "date":
      return value instanceof Date ? value : new Date(value as string);
    case "number":
      return typeof value === "string" ? parseFloat(value) || 0 : value;
    case "currency":
      return typeof value === "string"
        ? parseFloat(value.replace(/[^0-9.-]/g, "")) || 0
        : value;
    case "percentage":
      return typeof value === "number"
        ? value / 100
        : parseFloat(String(value)) / 100 || 0;
    case "json": {
      if (typeof value === "string") {
        try {
          const parsed = JSON.parse(value);
          return JSON.stringify(parsed);
        } catch {
          return value;
        }
      }
      return String(value);
    }
    default:
      return String(value);
  }
};

export const applyCellFormatting = <T = unknown>(
  cell: ExcelJS.Cell,
  column: Column<T>
): void => {
  switch (column.excelFormat) {
    case "date":
      cell.numFmt = "mm/dd/yyyy";
      break;
    case "currency":
      cell.numFmt = '"$"#,##0.00';
      break;
    case "percentage":
      cell.numFmt = "0.00%";
      break;
    case "number":
      cell.numFmt = "#,##0.00";
      break;
  }
  if (column.align) {
    cell.alignment = { horizontal: column.align };
  }
};

export const getDefaultStyles = (): ExcelStyles => ({
  headerFont: { bold: true, color: { argb: "FFFFFFFF" }, size: 12 },
  headerFill: createFillPattern("FF2563EB"),
  dataFont: { size: 11 },
  alternateRowFill: createFillPattern("FFF8F9FA"),
  borderStyle: {
    top: { style: "thin" },
    left: { style: "thin" },
    bottom: { style: "thin" },
    right: { style: "thin" },
  },
});

export const sanitizeFileName = (fileName: string): string => {
  return fileName.replace(/[^a-z0-9.-]/gi, "_").replace(/_{2,}/g, "_");
};

export const convertFiltersToRPCParams = (
  filters?: Filters
): Record<string, unknown> => {
  if (!filters) return {};

  const rpcParams: Record<string, unknown> = {};

  Object.entries(filters).forEach(([key, value]) => {
    if (value !== undefined && value !== null && value !== "") {
      rpcParams[key] = value;
    }
  });

  return rpcParams;
};

// Safe UUID generator: uses crypto.randomUUID if available, otherwise a lightweight fallback
export const generateUUID = (): string => {
  const g = globalThis as { crypto?: { randomUUID?: () => string } };
  if (g && g.crypto && typeof g.crypto.randomUUID === "function") {
    return g.crypto.randomUUID();
  }
  // RFC4122 version 4 fallback
  return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, (c) => {
    const r = (Math.random() * 16) | 0;
    const v = c === "x" ? r : (r & 0x3) | 0x8;
    return v.toString(16);
  });
};

// Enhanced logging utilities
export const logRowProcessing = (
  rowIndex: number,
  excelRowNumber: number,
  originalData: Record<string, unknown>,
  processedData: Record<string, unknown>,
  validationErrors: ValidationError[] = [],
  isSkipped = false,
  skipReason?: string
): ProcessingLog => {
  const log: ProcessingLog = {
    rowIndex,
    excelRowNumber,
    originalData,
    processedData,
    validationErrors,
    isSkipped,
    skipReason,
  };

  // console.group(`🔍 Processing Row ${excelRowNumber} (Index: ${rowIndex})`);
  // console.log("📊 Original Data:", originalData);
  // console.log("🔄 Processed Data:", processedData);

  if (validationErrors.length > 0) {
    console.warn("❌ Validation Errors:", validationErrors);
  }

  if (isSkipped) {
    console.warn("⏭️ Row Skipped:", skipReason);
  }

  console.groupEnd();

  return log;
};

export const logColumnTransformation = (
  rowIndex: number,
  column: string,
  originalValue: unknown,
  transformedValue: unknown,
  error?: string
): void => {
  // console.log(`🔧 Column "${column}" (Row ${rowIndex + 2}):`);
  // console.log(
  //   `   Original: ${JSON.stringify(originalValue)} (${typeof originalValue})`
  // );
  // console.log(
  //   `   Transformed: ${JSON.stringify(
  //     transformedValue
  //   )} (${typeof transformedValue})`
  // );

  if (error) {
    console.error(`   ❌ Error: ${error}`);
  }
};

// Enhanced value validation
export const validateValue = (
  value: unknown,
  columnName: string,
  isRequired: boolean
): ValidationError | null => {
  if (isRequired) {
    const isEmpty =
      value === null ||
      value === undefined ||
      (typeof value === "string" && value.trim() === "");

    if (isEmpty) {
      return {
        rowIndex: -1, // Will be set by caller
        column: columnName,
        value,
        error: `Required field "${columnName}" is empty`,
      };
    }
  }

  // Type-specific validations
  if (value !== null && value !== undefined && value !== "") {
    // Check for UUID format if column suggests it's an ID
    if ((columnName === "id" || columnName.endsWith("_id") ) && columnName !== "transnet_id") {
      const uuidRegex =
        /^[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i;
      const strValue = String(value).trim();
      if (strValue && !uuidRegex.test(strValue) && strValue !== "") {
        return {
          rowIndex: -1,
          column: columnName,
          value,
          error: `Invalid UUID format for "${columnName}": ${strValue}`,
        };
      }
    }

    // Check for email format
    if (columnName.toLowerCase().includes("email")) {
      const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
      const strValue = String(value).trim();
      if (strValue && !emailRegex.test(strValue)) {
        return {
          rowIndex: -1,
          column: columnName,
          value,
          error: `Invalid email format for "${columnName}": ${strValue}`,
        };
      }
    }

    // Check for IP address format
    const isIPField =
      columnName === "ip_address" ||
      columnName.endsWith("_ip") ||
      columnName.includes("ipaddr");
    if (isIPField) {
      const ipRegex =
        /^(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$/;
      const strValue = String(value).trim();
      if (strValue && !ipRegex.test(strValue)) {
        return {
          rowIndex: -1,
          column: columnName,
          value,
          error: `Invalid IP address format for "${columnName}": ${strValue}`,
        };
      }
    }
  }

  return null;
};

```

<!-- path: hooks/database/excel-queries/index.ts -->
```typescript
export * from "./excel-download";
export * from "./excel-upload";
```

<!-- path: hooks/database/excel-queries/excel-upload.ts -->
```typescript
import * as XLSX from "xlsx";
import { TableInsert, PublicTableName, UploadOptions, UseExcelUploadOptions } from "@/hooks/database/queries-type-helpers";
import { SupabaseClient } from "@supabase/supabase-js";
import { Database } from "@/types/supabase-types";
import { useMutation, useQueryClient } from "@tanstack/react-query";
import { EnhancedUploadResult, generateUUID, logColumnTransformation, logRowProcessing, ProcessingLog, validateValue, ValidationError } from "@/hooks/database/excel-queries/excel-helpers";
import { toast } from "sonner";

//================================================================================
// UPLOAD FUNCTIONS
//================================================================================

/**
 * Reads a File object and returns its contents as a 2D array using xlsx.
 * @param file The File object to read.
 * @returns A Promise that resolves to a 2D array of the sheet data.
 */
const parseExcelFile = (file: File): Promise<unknown[][]> => {
    return new Promise((resolve, reject) => {
      const reader = new FileReader();
  
      reader.onload = (event: ProgressEvent<FileReader>) => {
        try {
          if (!event.target?.result) {
            throw new Error("File reading failed.");
          }
          const buffer = event.target.result as ArrayBuffer;
          const workbook = XLSX.read(buffer, { type: "array" });
          const worksheetName = workbook.SheetNames[0];
          const worksheet = workbook.Sheets[worksheetName];
          if (!worksheet) {
            throw new Error("No worksheet found in the file.");
          }
          // header: 1 tells sheet_to_json to return an array of arrays
          // defval: '' preserves empty cells so column indices stay aligned
          const data = XLSX.utils.sheet_to_json<unknown[]>(worksheet, {
            header: 1,
            defval: "",
          });
          resolve(data);
        } catch (error) {
          reject(error);
        }
      };
  
      reader.onerror = (error) => {
        reject(new Error(`FileReader error: ${error.type}`));
      };
  
      reader.readAsArrayBuffer(file);
    });
  };
  
  //================================================================================
  // MAIN ENHANCED UPLOAD HOOK
  //================================================================================
  
  /**
   * Enhanced React hook for uploading data from an Excel file to a Supabase table using 'xlsx'.
   * Includes comprehensive logging and error tracking.
   */
  export function useExcelUpload<T extends PublicTableName>(
    supabase: SupabaseClient<Database>,
    tableName: T,
    options?: UseExcelUploadOptions<T>
  ) {
    const {
      showToasts = true,
      batchSize = 500,
      ...mutationOptions
    } = options || {};
    const queryClient = useQueryClient();
  
    return useMutation<EnhancedUploadResult, Error, UploadOptions<T>>({
      mutationFn: async (
        uploadOptions: UploadOptions<T>
      ): Promise<EnhancedUploadResult> => {
        const {
          file,
          columns,
          uploadType = "upsert",
          conflictColumn,
        } = uploadOptions;
  
        // console.group("🚀 Excel Upload Process Started");
        // console.log("📁 File:", file.name, `(${file.size} bytes)`);
        // console.log("🎯 Table:", tableName);
        // console.log("📋 Upload Type:", uploadType);
        // console.log("🔑 Conflict Column:", conflictColumn);
        // console.log("📊 Column Mappings:", columns);
  
        if (uploadType === "upsert" && !conflictColumn) {
          throw new Error(
            "A 'conflictColumn' must be specified for 'upsert' operations."
          );
        }
  
        const processingLogs: ProcessingLog[] = [];
        const allValidationErrors: ValidationError[] = [];
  
        toast.info("Reading and parsing Excel file...");
  
        // 1. Parse the Excel file using our xlsx utility function
        const jsonData = await parseExcelFile(file);
  
        // console.log("📊 Raw Excel Data:", {
        //   totalRows: jsonData.length,
        //   headers: jsonData[0],
        //   sampleData: jsonData.slice(1, 4), // Show first 3 data rows
        // });
  
        if (!jsonData || jsonData.length < 2) {
          toast.warning(
            "No data found in the Excel file. (A header row and at least one data row are required)."
          );
          console.groupEnd();
          return { 
            successCount: 0, 
            errorCount: 0, 
            totalRows: 0, 
            errors: [],
            processingLogs,
            validationErrors: allValidationErrors,
            skippedRows: 0,
          };
        }
  
        // 2. Map Excel headers to their column index for efficient lookup
        const excelHeaders: string[] = jsonData[0] as string[];
        const headerMap: Record<string, number> = {};
        // console.log("📝 Excel Headers:", excelHeaders);
        
        excelHeaders.forEach((header, index) => {
          const cleanHeader = String(header).trim().toLowerCase();
          headerMap[cleanHeader] = index;
          // console.log(`   [${index}]: "${header}" -> "${cleanHeader}"`);
        });
        
        const isFirstColumnId =
          String(excelHeaders?.[0] ?? "").toLowerCase() === "id";
        // console.log("🆔 First column is ID:", isFirstColumnId);
  
        // 3. Validate that all required columns from the mapping exist in the file
        const getHeaderIndex = (name: string): number | undefined =>
          headerMap[String(name).trim().toLowerCase()];
  
  
        toast.info(
          `Found ${jsonData.length - 1} rows. Preparing data for upload...`
        );
  
        // 4. Process rows and transform data into the format for Supabase
        const dataRows = jsonData.slice(1);
  
        // Helper: determine if a row is effectively empty (ignoring 'id')
        const isRowEffectivelyEmpty = (row: unknown[]): boolean => {
          for (const mapping of columns) {
            if (mapping.dbKey === "id") continue; // ignore id when checking emptiness
            const idx = getHeaderIndex(mapping.excelHeader);
            const v = idx !== undefined ? row[idx] : undefined;
            if (v !== undefined && String(v).trim() !== "") {
              return false; // has some non-empty value in a non-id column
            }
          }
          return true;
        };
  
        // Filter out rows that are empty across all non-id columns, keep index for error reporting
        const filteredRows = dataRows
          .map((row, idx) => ({ row: row as unknown[], idx }))
          .filter(({ row }) => !isRowEffectivelyEmpty(row));
  
        // console.log(`🎯 Filtered ${dataRows.length} rows down to ${filteredRows.length} non-empty rows`);
  
        // Initialize upload result early to record pre-insert validation errors
        const uploadResult: EnhancedUploadResult = {
          successCount: 0,
          errorCount: 0,
          totalRows: 0,
          errors: [],
          processingLogs,
          validationErrors: allValidationErrors,
          skippedRows: 0,
        };
  
        let recordsToProcess: TableInsert<T>[] = [];

        // Helpers capture the hook's generic T via closure over tableName
        const insertBatch = async (
          rows: TableInsert<T>[]
        ) => {
          // T is a generic (union of table names) here; Supabase's overloads require a concrete table literal.
          // A localized cast is used to bridge this at the single boundary to Supabase.
          // eslint-disable-next-line @typescript-eslint/no-explicit-any
          return supabase.from(tableName).insert(rows as any);
        };

        const upsertBatch = async (
          rows: TableInsert<T>[],
          onConflict: string
        ) => {
          // eslint-disable-next-line @typescript-eslint/no-explicit-any
          return supabase.from(tableName).upsert(rows as any, { onConflict });
        };

        const upsertOne = async (
          row: TableInsert<T>,
          onConflict: string
        ) => {
          // eslint-disable-next-line @typescript-eslint/no-explicit-any
          return supabase.from(tableName).upsert(row as any, { onConflict });
        };
  
        console.group("🔄 Row Processing Phase");
        
        for (let i = 0; i < filteredRows.length; i++) {
          const { row, idx } = filteredRows[i];
          const excelRowNumber = idx + 2; // +2 because Excel is 1-indexed and we skip header
          
          const originalData: Record<string, unknown> = {};
          const processedData: Record<string, unknown> = {};
          const rowValidationErrors: ValidationError[] = [];
          let isSkipped = false;
          let skipReason: string | undefined;
  
          // Build original data object for logging
          excelHeaders.forEach((header, headerIdx) => {
            originalData[header] = row[headerIdx];
          });
  
          // Secondary safeguard: determine if row has any meaningful non-id value
          const rowHasContent = columns.some((mapping) => {
            if (mapping.dbKey === "id") return false;
            const idx = getHeaderIndex(mapping.excelHeader);
            const v = idx !== undefined ? row[idx] : undefined;
            return v !== undefined && String(v).trim() !== "";
          });
  
          if (!rowHasContent) {
            // Skip rows that are effectively empty across non-id columns
            isSkipped = true;
            skipReason = "Row is empty across all non-id columns";
            uploadResult.skippedRows++;
            
            const log = logRowProcessing(
              i, 
              excelRowNumber, 
              originalData, 
              processedData, 
              rowValidationErrors, 
              isSkipped, 
              skipReason
            );
            processingLogs.push(log);
            continue;
          }
  
          // Process each column mapping
          for (const mapping of columns) {
            const colIndex = getHeaderIndex(mapping.excelHeader);
            // Guard: only index row when we have a valid column index
            let rawValue = colIndex !== undefined ? row[colIndex] : undefined;
  
            // console.group(`🔧 Processing "${mapping.dbKey}" (Excel: "${mapping.excelHeader}")`);
            // console.log(`📍 Column Index: ${colIndex}`);
            // console.log(`📊 Raw Value:`, rawValue, `(${typeof rawValue})`);
  
            try {
              // Normalize empty strings to null for UUID-like fields
              if (
                (mapping.dbKey === "id" ||
                  mapping.dbKey.endsWith("_id") ||
                  mapping.dbKey === "parent_id") &&
                (rawValue === "" || rawValue === undefined)
              ) {
                rawValue = null;
                // console.log("🔄 Normalized empty UUID field to null");
              }
  
              // Normalize IP address-like fields for inet columns: trim and empty -> null
              // Targets include: 'ip_address', any key ending with '_ip', or containing 'ipaddr'
              {
                const key = String(mapping.dbKey || "").toLowerCase();
                const isIPField =
                  key === "ip_address" ||
                  key.endsWith("_ip") ||
                  key.includes("ipaddr");
                if (isIPField && typeof rawValue === "string") {
                  const trimmed = rawValue.trim();
                  rawValue = trimmed === "" ? null : trimmed;
                  // console.log("🌐 Processed IP field:", rawValue);
                }
              }
  
              // Only generate a UUID for `id` if the row actually has content
              if (mapping.dbKey === "id" && rowHasContent) {
                // If first Excel column is id/ID and current mapping is for 'id', auto-generate UUID when empty
                if (
                  isFirstColumnId &&
                  (rawValue === null ||
                    rawValue === undefined ||
                    String(rawValue).trim() === "")
                ) {
                  rawValue = generateUUID();
                  // console.log("🆔 Generated UUID for empty ID:", rawValue);
                }
                // If 'id' header is entirely missing, still generate a UUID
                if (colIndex === undefined) {
                  rawValue = generateUUID();
                  // console.log("🆔 Generated UUID for missing ID column:", rawValue);
                }
              }
  
              // Use the transform function if available, otherwise use the raw value
              let finalValue: unknown;
              if (mapping.transform) {
                try {
                  finalValue = mapping.transform(rawValue);
                  // console.log("🔧 Transformed value:", finalValue, `(${typeof finalValue})`);
                } catch (transformError) {
                  const errorMsg = transformError instanceof Error 
                    ? transformError.message 
                    : "Transform function failed";
                  console.error("❌ Transform error:", errorMsg);
                  
                  const validationError: ValidationError = {
                    rowIndex: i,
                    column: mapping.dbKey,
                    value: rawValue,
                    error: `Transform failed for "${mapping.dbKey}": ${errorMsg}`,
                  };
                  rowValidationErrors.push(validationError);
                  allValidationErrors.push(validationError);
                  finalValue = rawValue; // Use raw value as fallback
                }
              } else {
                finalValue = rawValue;
              }
  
              // Validate the processed value
              const validationError = validateValue(
                finalValue, 
                mapping.dbKey, 
                mapping.required || false
              );
              
              if (validationError) {
                validationError.rowIndex = i;
                rowValidationErrors.push(validationError);
                allValidationErrors.push(validationError);
                console.error("❌ Validation failed:", validationError.error);
              }
  
              // Assign the processed value to the correct database key
              // Normalize empty strings to null to satisfy numeric/date/inet columns
              let assignValue =
                finalValue !== undefined
                  ? finalValue
                  : rawValue !== undefined
                  ? rawValue
                  : null;
              
              if (typeof assignValue === "string" && assignValue.trim() === "") {
                assignValue = null;
                // console.log("🧹 Normalized empty string to null");
              }
              
              processedData[mapping.dbKey] = assignValue;
              // console.log("✅ Final assigned value:", assignValue, `(${typeof assignValue})`);
  
              logColumnTransformation(
                i,
                mapping.dbKey,
                rawValue,
                assignValue
              );
  
            } catch (columnError) {
              const errorMsg = columnError instanceof Error 
                ? columnError.message 
                : "Unknown column processing error";
              console.error("💥 Column processing error:", errorMsg);
              
              const validationError: ValidationError = {
                rowIndex: i,
                column: mapping.dbKey,
                value: rawValue,
                error: `Column processing failed: ${errorMsg}`,
              };
              rowValidationErrors.push(validationError);
              allValidationErrors.push(validationError);
            } finally {
              console.groupEnd();
            }
          }
  
          // Check if row has validation errors
          const hasRequiredFieldErrors = rowValidationErrors.some(err => 
            err.error.includes("Required field") || err.error.includes("Missing required")
          );
  
          if (hasRequiredFieldErrors) {
            // Record a validation error for this row and skip it
            isSkipped = true;
            skipReason = `Validation failed: ${rowValidationErrors.map(e => e.error).join("; ")}`;
            uploadResult.errorCount += 1;
            uploadResult.skippedRows++;
            
            uploadResult.errors.push({
              rowIndex: excelRowNumber,
              data: processedData as Record<string, unknown>,
              error: skipReason,
            });
          } else {
            // Add to records to process
            recordsToProcess.push(processedData as TableInsert<T>);
          }
  
          // Log the complete row processing
          const log = logRowProcessing(
            i,
            excelRowNumber,
            originalData,
            processedData,
            rowValidationErrors,
            isSkipped,
            skipReason
          );
          processingLogs.push(log);
        }
        
        console.groupEnd(); // End Row Processing Phase
  
        // console.log(`📊 Processing Summary:`);
        // console.log(`   Total filtered rows: ${filteredRows.length}`);
        // console.log(`   Records to process: ${recordsToProcess.length}`);
        // console.log(`   Skipped rows: ${uploadResult.skippedRows}`);
        // console.log(`   Validation errors: ${allValidationErrors.length}`);
  
        // Deduplicate by conflict columns to avoid Postgres error:
        // "ON CONFLICT DO UPDATE command cannot affect row a second time"
        if (uploadType === "upsert" && conflictColumn) {
          console.group("🔄 Deduplication Process");
          
          const conflictCols = String(conflictColumn)
            .split(",")
            .map((s) => s.trim())
            .filter((s) => s.length > 0);
  
          // console.log("🎯 Conflict columns:", conflictCols);
  
          if (conflictCols.length > 0) {
            const seen = new Set<string>();
            const deduped: TableInsert<T>[] = [];
            let duplicateCount = 0;
            
            for (const rec of recordsToProcess) {
              const values = conflictCols.map((c) => (rec as Record<string, unknown>)[c]);
              const allPresent = values.every(
                (v) =>
                  v !== undefined &&
                  v !== null &&
                  !(typeof v === "string" && v === "")
              );
              
              if (!allPresent) {
                // Do not dedupe records missing conflict values; still avoid PK updates on composite keys
                if (!conflictCols.includes("id")) {
                  delete (rec as Record<string, unknown>).id;
                }
                deduped.push(rec);
                // console.log("➕ Added record with missing conflict values (no deduplication)");
                continue;
              }
  
              // Normalize strings for dedupe to match DB uniqueness (trim + lowercase)
              const normalized = values.map((v) =>
                typeof v === "string" ? v.trim().toLowerCase() : v
              );
              const key = JSON.stringify(normalized);
              
              if (!seen.has(key)) {
                seen.add(key);
                if (!conflictCols.includes("id")) {
                  delete (rec as Record<string, unknown>).id;
                }
                deduped.push(rec);
                // console.log(`➕ Added unique record with key: ${key}`);
              } else {
                duplicateCount++;
                // console.log(`⏭️  Skipped duplicate record with key: ${key}`);
              }
            }
            
            // console.log(`📊 Deduplication results:`);
            // console.log(`   Original records: ${recordsToProcess.length}`);
            // console.log(`   After deduplication: ${deduped.length}`);
            // console.log(`   Duplicates removed: ${duplicateCount}`);
            
            recordsToProcess = deduped;
          }
          
          console.groupEnd();
        }
  
        // 5. Perform batch upload to Supabase
        uploadResult.totalRows = recordsToProcess.length;
        // console.log(`🚀 Starting Supabase upload for ${uploadResult.totalRows} records`);
  
        if (recordsToProcess.length === 0) {
          // console.log("⚠️ No records to upload after processing");
          toast.warning("No valid records found to upload after processing.");
          console.groupEnd();
          return uploadResult;
        }
  
        console.group("📤 Supabase Upload Process");
  
        for (let i = 0; i < recordsToProcess.length; i += batchSize) {
          const batch = recordsToProcess.slice(i, i + batchSize);
          const progress = Math.round(
            ((i + batch.length) / recordsToProcess.length) * 100
          );
          toast.info(`Uploading batch ${Math.floor(i / batchSize) + 1}... (${progress}%)`);
          
          // console.log(`📦 Processing batch ${Math.floor(i / batchSize) + 1}:`);
          // console.log(`   Range: ${i} - ${i + batch.length - 1}`);
          // console.log(`   Batch size: ${batch.length}`);
          // console.log(`   Progress: ${progress}%`);
          // console.log("📊 Batch data sample:", batch.slice(0, 2)); // Show first 2 records
  
          // If using composite conflict keys, upsert rows one-by-one to avoid
          // "ON CONFLICT DO UPDATE command cannot affect row a second time"
          const isCompositeConflict =
            uploadType === "upsert" &&
            conflictColumn &&
            String(conflictColumn).split(",").length > 1;
            
          if (isCompositeConflict) {
            // console.log("🔄 Using individual upserts for composite conflict keys");
            
            for (let j = 0; j < batch.length; j++) {
              const row = batch[j];
              // console.log(`📝 Upserting individual record ${i + j + 1}:`, row);
              
              try {
                const { error } = await upsertOne(row as TableInsert<T>, conflictColumn as string);
                  
                if (error) {
                  console.error(`❌ Individual upsert failed for record ${i + j + 1}:`, error);
                  uploadResult.errorCount += 1;
                  uploadResult.errors.push({
                    rowIndex: i + j,
                    data: row as Record<string, unknown>,
                    error: error.message,
                  });
                  if (showToasts) {
                    toast.error(
                      `Error at record ${i + j + 1}: ${error.message}`
                    );
                  }
                } else {
                  // console.log(`✅ Individual upsert successful for record ${i + j + 1}`);
                  uploadResult.successCount += 1;
                }
              } catch (unexpectedError) {
                const errorMsg = unexpectedError instanceof Error 
                  ? unexpectedError.message 
                  : "Unexpected error during individual upsert";
                console.error(`💥 Unexpected error during individual upsert:`, unexpectedError);
                uploadResult.errorCount += 1;
                uploadResult.errors.push({
                  rowIndex: i + j,
                  data: row as Record<string, unknown>,
                  error: errorMsg,
                });
              }
            }
            continue;
          }
  
          // Regular batch processing
          // console.log(`🚀 Executing batch ${uploadType} operation`);
          
          try {
            let query;
            if (uploadType === "insert") {
              // console.log("➕ Using INSERT operation");
              query = insertBatch(batch as TableInsert<T>[]);
            } else {
              // console.log(`🔄 Using UPSERT operation with conflict: ${conflictColumn}`);
              query = upsertBatch(batch as TableInsert<T>[], conflictColumn as string);
            }
  
            const { error } = await query;
            
            if (error) {
              // Handle foreign key constraint violation specifically
              if (error.code === '23503' && error.message.includes('ofc_cables_sn_id_fkey')) {
                // Type-safe access to sn_id
                type RecordWithSnId = { sn_id?: unknown };
                const getSnId = (record: unknown): string | undefined => {
                  if (record && typeof record === 'object' && 'sn_id' in record) {
                    const value = (record as RecordWithSnId).sn_id;
                    return value !== null && value !== undefined ? String(value) : undefined;
                  }
                  return undefined;
                };
                
                // Extract all unique sn_ids from the batch that caused the error
                const invalidSnIds = [...new Set(
                  batch.map(record => getSnId(record)).filter((id): id is string => Boolean(id))
                )];
                
                // Log detailed error information
                console.error('Foreign key violation details:', {
                  table: tableName,
                  constraint: 'ofc_cables_sn_id_fkey',
                  invalidValues: invalidSnIds,
                  error: error.message
                });
                
                // Add validation errors for each affected row
                batch.forEach((record, index) => {
                  const snId = getSnId(record);
                  if (snId) {
                    uploadResult.validationErrors.push({
                      rowIndex: i + index,
                      column: 'sn_id',
                      value: snId,
                      error: `Foreign key violation: sn_id '${snId}' does not exist in the nodes table`,
                      data: { column: 'sn_id', value: snId, constraint: 'ofc_cables_sn_id_fkey' }
                    });
                  }
                });
                
                // Add a summary error to the upload result
                const errorMessage = `Foreign key violation: ${invalidSnIds.length} invalid sn_id value(s) found in batch. ` +
                  `Invalid values: ${invalidSnIds.join(', ')}`;
                uploadResult.errorCount += batch.length;
                uploadResult.errors.push({
                  rowIndex: i,
                  data: batch,
                  error: errorMessage
                });
                
                // Show user-friendly error message
                if (showToasts) {
                  toast.error(
                    `Foreign key violation: ${invalidSnIds.length} invalid sn_id value(s) found. ` +
                    'Check the console for details.',
                    { duration: 10000 }
                  );
                }
              } else {
                // Handle other types of errors
                const errorDetails: Record<string, unknown> = {};
                if (error.code === '23503') {
                  errorDetails.constraint = error.message.match(/constraint "(.*?)"/)?.[1];
                  errorDetails.detail = error.message;
                }
                
                uploadResult.errorCount += batch.length;
                uploadResult.errors.push({
                  rowIndex: i,
                  data: batch,
                  error: error.message,
                  ...(Object.keys(errorDetails).length > 0 ? { details: errorDetails } : {})
                });
                
                if (showToasts) {
                  toast.error(`Error in batch starting at record ${i + 1}: ${error.message}`);
                }
              }
            } else {
              // console.log(`✅ Batch operation successful for ${batch.length} records`);
              uploadResult.successCount += batch.length;
            }
          } catch (unexpectedError) {
            const errorMsg = unexpectedError instanceof Error 
              ? unexpectedError.message 
              : "Unexpected error during batch operation";
            console.error(`💥 Unexpected error during batch operation:`, unexpectedError);
            uploadResult.errorCount += batch.length;
            uploadResult.errors.push({
              rowIndex: i,
              data: batch,
              error: errorMsg,
            });
          }
        }
        
        console.groupEnd(); // End Supabase Upload Process
  
        // 6. Finalize and report
        // console.group("📊 Upload Results Summary");
        // console.log(`✅ Successful uploads: ${uploadResult.successCount}`);
        // console.log(`❌ Failed uploads: ${uploadResult.errorCount}`);
        // console.log(`⏭️  Skipped rows: ${uploadResult.skippedRows}`);
        // console.log(`📝 Total processing logs: ${processingLogs.length}`);
        // console.log(`⚠️  Total validation errors: ${allValidationErrors.length}`);
        
        if (uploadResult.errors.length > 0) {
          // console.log("🔍 Upload errors:", uploadResult.errors);
        }
        
        if (allValidationErrors.length > 0) {
          // console.log("🔍 Validation errors:", allValidationErrors);
        }
        console.groupEnd();
  
        if (uploadResult.errorCount > 0) {
          if (showToasts) {
            toast.warning(
              `${uploadResult.successCount} rows uploaded successfully, but ${uploadResult.errorCount} failed. Check console for details.`
            );
          }
        } else {
          if (showToasts) {
            toast.success(
              `Successfully uploaded ${uploadResult.successCount} of ${uploadResult.totalRows} records.`
            );
          }
          
          // Invalidate related queries instead of reloading the page to preserve UI state
          try {
            await queryClient.invalidateQueries({
              predicate: (q) => {
                const key = q.queryKey as unknown[];
                if (!Array.isArray(key)) return false;
                // Match if any segment equals the tableName or contains it as a substring (to catch views/RPC keys like "v_ofc_cables_complete")
                return key.some((seg) => {
                  if (seg === tableName) return true;
                  if (typeof seg === "string" && seg.toLowerCase().includes(String(tableName).toLowerCase())) return true;
                  return false;
                });
              },
            });
            // Force refetch so UI reflects changes immediately even if staleTime is large
            await queryClient.refetchQueries({
              predicate: (q) => {
                const key = q.queryKey as unknown[];
                if (!Array.isArray(key)) return false;
                return key.some((seg) => {
                  if (seg === tableName) return true;
                  if (typeof seg === "string" && seg.toLowerCase().includes(String(tableName).toLowerCase())) return true;
                  return false;
                });
              },
              type: "active",
            });
            // console.log("✅ Query cache invalidated successfully");
          } catch (err) {
            console.warn("⚠️ Failed to invalidate queries after upload", err);
          }
        }
  
        console.groupEnd(); // End Excel Upload Process
        return uploadResult;
      },
      ...mutationOptions,
    });
  }
```

<!-- path: hooks/useRoleFunctions.ts -->
```typescript
// hooks/database/functions.ts - Hooks for Supabase functions
import { useQuery, UseQueryResult } from '@tanstack/react-query'
import { createClient } from '@/utils/supabase/client'
import React from 'react'
import { useAuth } from '@/hooks/useAuth'

// Types for better type safety
type UserRole = string | null
type SuperAdminStatus = boolean | null

interface UserPermissions {
  role: UserRole
  isSuperAdmin: SuperAdminStatus
  isLoading: boolean
  error: Error | null
  isError: boolean
  refetch: () => void
}

/**
 * Hook to get the current user's role with automatic session refresh if needed
 */
export const useMyRole = (): UseQueryResult<UserRole, Error> => {
  const supabase = createClient()
  const { user, authState, syncSession } = useAuth()
  
  return useQuery({
    queryKey: ['my-role', user?.id],
    queryFn: async (): Promise<UserRole> => {
      try {
        const { data, error } = await supabase.rpc('get_my_role')

        // If we get null data, try refreshing the session and retry
        if (data === null) {
          const sessionRefreshed = await syncSession()
          if (sessionRefreshed) {
            const { data: retryData, error: retryError } = await supabase.rpc('get_my_role')
            if (retryError) throw retryError
            return retryData as UserRole
          }
        }

        if (error) {
          console.error('Role fetch error:', error)
          throw new Error(`Failed to get user role: ${error.message}`)
        }
        
        return data as UserRole
      } catch (err) {
        console.error('Role query error:', err)
        throw err
      }
    },
    staleTime: 10 * 60 * 1000, // 10 minutes
    gcTime: 15 * 60 * 1000, // 15 minutes
    retry: (failureCount, error) => {
      // Don't retry on authentication errors
      if (error.message.includes('JWT') || error.message.includes('auth')) {
        return false
      }
      return failureCount < 2
    },
    retryDelay: (attemptIndex) => Math.min(1000 * 2 ** attemptIndex, 30000),
    enabled: authState === "authenticated" && !!user?.id,
    refetchOnWindowFocus: false,
    networkMode: 'offlineFirst'
  })
}

/**
 * Hook to check if the current user is a super admin
 */
export const useIsSuperAdmin = (): UseQueryResult<SuperAdminStatus, Error> => {
  const supabase = createClient()
  const { user, authState, syncSession } = useAuth()
  
  return useQuery({
    queryKey: ['is-super-admin', user?.id],
    queryFn: async (): Promise<SuperAdminStatus> => {
      try {
        const { data, error } = await supabase.rpc('is_super_admin')

        // If we get null data, try refreshing the session and retry
        if (data === null) {
          const sessionRefreshed = await syncSession()
          if (sessionRefreshed) {
            const { data: retryData, error: retryError } = await supabase.rpc('is_super_admin')
            if (retryError) throw retryError
            return retryData as SuperAdminStatus
          }
        }
        
        if (error) {
          console.error('Super admin check error:', error)
          throw new Error(`Failed to check super admin status: ${error.message}`)
        }
        
        return data as SuperAdminStatus
      } catch (err) {
        console.error('Super admin query error:', err)
        throw err
      }
    },
    staleTime: 10 * 60 * 1000, // 10 minutes
    gcTime: 15 * 60 * 1000, // 15 minutes
    retry: (failureCount, error) => {
      if (error.message.includes('JWT') || error.message.includes('auth')) {
        return false
      }
      return failureCount < 2
    },
    retryDelay: (attemptIndex) => Math.min(1000 * 2 ** attemptIndex, 30000),
    enabled: authState === "authenticated" && !!user?.id,
    refetchOnWindowFocus: false,
    networkMode: 'offlineFirst'
  })
}

/**
 * Combined hook that returns both role and super admin status
 * with optimized refetching and error handling
 */
export const useUserPermissions = (): UserPermissions => {
  const roleQuery = useMyRole()
  const superAdminQuery = useIsSuperAdmin()
  
  const refetch = React.useCallback(() => {
    return Promise.allSettled([
      roleQuery.refetch(),
      superAdminQuery.refetch()
    ])
  }, [roleQuery, superAdminQuery])
  
  return {
    role: roleQuery.data ?? null,
    isSuperAdmin: superAdminQuery.data ?? null,
    isLoading: roleQuery.isLoading || superAdminQuery.isLoading,
    error: roleQuery.error || superAdminQuery.error || null,
    isError: roleQuery.isError || superAdminQuery.isError,
    refetch
  }
}

/**
 * Extended version of user permissions with utility methods
 */
export const useUserPermissionsExtended = () => {
  const permissions = useUserPermissions()
  
  const hasRole = React.useCallback((requiredRole: string): boolean => {
    return permissions.role === requiredRole
  }, [permissions.role])
  
  const hasAnyRole = React.useCallback((requiredRoles: string[]): boolean => {
    return permissions.role ? requiredRoles.includes(permissions.role) : false
  }, [permissions.role])
  
  const canAccess = React.useCallback((allowedRoles?: string[]): boolean => {
    // Super admin can access everything
    if (permissions.isSuperAdmin) return true
    
    // If no roles specified, just check if authenticated
    if (!allowedRoles || allowedRoles.length === 0) return !!permissions.role
    
    // Check if user has required role
    return hasAnyRole(allowedRoles)
  }, [permissions.isSuperAdmin, permissions.role, hasAnyRole])
  
  return {
    ...permissions,
    hasRole,
    hasAnyRole,
    canAccess,
    isReady: !permissions.isLoading && !permissions.error
  }
}

/**
 * Optimized hook for role-based conditional rendering
 * Uses memoization to prevent unnecessary re-renders
 */
export const useHasPermission = (allowedRoles?: string[]): boolean => {
  const { canAccess } = useUserPermissionsExtended()
  return React.useMemo(() => canAccess(allowedRoles), [canAccess, allowedRoles])
}

// Export types for use in other files
export type { UserRole, SuperAdminStatus, UserPermissions }
```

<!-- path: hooks/useDeleteManager.ts -->
```typescript
// path: hooks/useDeleteManager.ts
import { useState, useCallback } from 'react';
import { toast } from 'sonner';
import { useTableBulkOperations } from '@/hooks/database';
import { createClient } from '@/utils/supabase/client';
import { Database } from '@/types/supabase-types';
import { useAdminBulkDeleteUsers } from '@/hooks/useAdminUsers'; // <-- IMPORT THE CORRECT HOOK

interface DeleteItem {
  id: string;
  name: string;
  [key: string]: unknown;
}

interface BulkDeleteFilter {
  column: string;
  value: string | number | boolean | null;
  displayName: string;
}

interface UseDeleteManagerProps {
  tableName: keyof Database['public']['Tables'];
  onSuccess?: () => void;
}

export function useDeleteManager({ tableName, onSuccess }: UseDeleteManagerProps) {
  const [isConfirmModalOpen, setIsConfirmModalOpen] = useState(false);
  const [itemsToDelete, setItemsToDelete] = useState<DeleteItem[]>([]);
  const [bulkFilter, setBulkFilter] = useState<BulkDeleteFilter | null>(null);

  const supabase = createClient();

  // ---  USE THE CORRECT MUTATION BASED ON TABLE NAME ---

  // 1. Get the generic bulk delete for all other tables.
  const { mutate: genericBulkDelete, isPending: isGenericDeletePending } = useTableBulkOperations(supabase, tableName).bulkDelete;
  
  // 2. Get the specific, API-driven user delete mutation.
  const { mutate: userDelete, isPending: isUserDeletePending } = useAdminBulkDeleteUsers();

  // 3. The overall loading state depends on which mutation is active.
  const isPending = isGenericDeletePending || isUserDeletePending;

  const deleteSingle = useCallback((item: DeleteItem) => {
    setItemsToDelete([item]);
    setBulkFilter(null);
    setIsConfirmModalOpen(true);
  }, []);

  const deleteMultiple = useCallback((items: DeleteItem[]) => {
    setItemsToDelete(items);
    setBulkFilter(null);
    setIsConfirmModalOpen(true);
  }, []);

  const deleteBulk = useCallback((filter: BulkDeleteFilter) => {
    setItemsToDelete([]);
    setBulkFilter(filter);
    setIsConfirmModalOpen(true);
  }, []);

  const handleCancel = useCallback(() => {
    setIsConfirmModalOpen(false);
    setItemsToDelete([]);
    setBulkFilter(null);
  }, []);

  const handleConfirm = useCallback(async () => {
    const mutationOptions = {
      onSuccess: () => {
        const successMessage = itemsToDelete.length === 1
          ? `Successfully deleted "${itemsToDelete[0].name}"`
          : itemsToDelete.length > 1
            ? `Successfully deleted ${itemsToDelete.length} items.`
            : `Successfully performed bulk delete.`;
        toast.success(successMessage);
        onSuccess?.();
      },
      onError: (err: Error) => toast.error(`Deletion failed: ${err.message}`),
      onSettled: () => {
        setIsConfirmModalOpen(false);
        setItemsToDelete([]);
        setBulkFilter(null);
      }
    };

    // 4. THE CORE LOGIC: Check the table name and call the appropriate mutation.
    if (tableName === 'user_profiles') {
      if (itemsToDelete.length > 0) {
        const idsToDelete = itemsToDelete.map(item => item.id);
        userDelete({ user_ids: idsToDelete }, mutationOptions);
      } else {
        toast.error("Bulk delete by filter is not supported for users.");
        handleCancel();
      }
    } else {
      // For all other tables, use the generic client-side delete.
      if (itemsToDelete.length > 0) {
        const idsToDelete = itemsToDelete.map(item => item.id);
        genericBulkDelete({ ids: idsToDelete }, mutationOptions);
      } else if (bulkFilter) {
        genericBulkDelete({ filters: { [bulkFilter.column]: bulkFilter.value } }, mutationOptions);
      }
    }
  }, [tableName, itemsToDelete, onSuccess, userDelete, handleCancel, bulkFilter, genericBulkDelete]);

  const getConfirmationMessage = useCallback(() => {
    if (itemsToDelete.length > 0) {
      if (itemsToDelete.length === 1) {
        return `Are you sure you want to delete "${itemsToDelete[0].name}"? This action is permanent and will remove the user's login access.`;
      }
      return `Are you sure you want to delete these ${itemsToDelete.length} items? This action is permanent.`;
    }
    if (bulkFilter) {
      return `Are you sure you want to delete all items in "${bulkFilter.displayName}"? This cannot be undone.`;
    }
    return 'Are you sure you want to proceed?';
  }, [itemsToDelete, bulkFilter]);

  return {
    deleteSingle,
    deleteMultiple,
    deleteBulk,
    handleConfirm,
    handleCancel,
    isConfirmModalOpen,
    isPending,
    confirmationMessage: getConfirmationMessage(),
    deleteConfig: { items: itemsToDelete, filter: bulkFilter },
  };
}
```

<!-- path: hooks/useIsMobile.tsx -->
```typescript
// hooks/useIsMobile.tsx
import { useState, useEffect } from 'react';

const useIsMobile = (breakpoint = 768) => {
  const [isMobile, setIsMobile] = useState(false);

  useEffect(() => {
    const checkDevice = () => {
      // Check screen width
      const isSmallScreen = window.innerWidth < breakpoint;
      
      // Check user agent for mobile indicators
      const userAgent = navigator.userAgent.toLowerCase();
      const mobileKeywords = [
        'mobile', 'android', 'iphone', 'ipad', 'ipod', 
        'blackberry', 'windows phone', 'opera mini'
      ];
      const isMobileAgent = mobileKeywords.some(keyword => 
        userAgent.includes(keyword)
      );
      
      // Check for touch capability
      const hasTouch = 'ontouchstart' in window || navigator.maxTouchPoints > 0;
      
      // Combine all checks - prioritize screen size but consider other factors
      const mobile = isSmallScreen || (isMobileAgent && hasTouch);
      
      setIsMobile(mobile);
    };

    // Initial check
    checkDevice();

    // Listen for resize events
    window.addEventListener('resize', checkDevice);
    
    // Listen for orientation changes (mobile specific)
    window.addEventListener('orientationchange', checkDevice);

    // Cleanup
    return () => {
      window.removeEventListener('resize', checkDevice);
      window.removeEventListener('orientationchange', checkDevice);
    };
  }, [breakpoint]);

  return isMobile;
};

export default useIsMobile;

// Usage examples:
// const isMobile = useIsMobile(); // Uses default 768px breakpoint
// const isMobile = useIsMobile(1024); // Custom breakpoint
// const isMobile = useIsMobile(480); // Smaller breakpoint for strict mobile-only
```

<!-- path: hooks/defaultUploadConfigs.ts -->
```typescript
import { TableNames } from "@/config/helper-types";
import { buildUploadConfig, TABLES } from "@/config/table-column-keys";

// Thin adapter: build per-table upload config from SSOT
const defaultUploadConfigs = () => {
  const result: Partial<
    Record<TableNames, ReturnType<typeof buildUploadConfig<TableNames>>>
  > = {};

  (Object.keys(TABLES) as TableNames[]).forEach((tableName) => {
    result[tableName] = buildUploadConfig(tableName);
  });

  return result as Record<
    TableNames,
    ReturnType<typeof buildUploadConfig<TableNames>>
  >;
};

export default defaultUploadConfigs;

```

<!-- path: hooks/useBulkSelection.ts -->
```typescript
import { useState, useCallback } from 'react';

interface UseSelectionReturn<T> {
  selectedItems: Set<T>;
  selectedCount: number;
  toggleSelection: (id: T) => void;
  toggleAllSelection: (allIds: T[]) => void;
  setSelectedItems: (ids: T[]) => void;
  clearSelection: () => void;
  isSelected: (id: T) => boolean;
  isAllSelected: (allIds: T[]) => boolean;
  isIndeterminate: (allIds: T[]) => boolean;
}

export function useSelection<T = string>(): UseSelectionReturn<T> {
  const [selectedItems, setSelectedItems] = useState<Set<T>>(new Set());

  // Clear selection
  const clearSelection = useCallback(() => {
    setSelectedItems(new Set());
  }, []);

  // Toggle single item selection
  const toggleSelection = useCallback((id: T) => {
    setSelectedItems(prev => {
      const newSet = new Set(prev);
      if (newSet.has(id)) {
        newSet.delete(id);
      } else {
        newSet.add(id);
      }
      return newSet;
    });
  }, []);

  // Set selected items
  const setSelected = useCallback((ids: T[]) => {
    setSelectedItems(new Set(ids));
  }, []);

  // Toggle all items selection
  const toggleAllSelection = useCallback((allIds: T[]) => {
    setSelectedItems(prev => {
      if (prev.size === allIds.length) {
        return new Set(); // Clear selection
      } else {
        return new Set(allIds); // Select all
      }
    });
  }, []);

  // Check if item is selected
  const isSelected = useCallback((id: T) => {
    return selectedItems.has(id);
  }, [selectedItems]);

  // Check if all items are selected
  const isAllSelected = useCallback((allIds: T[]) => {
    return allIds.length > 0 && selectedItems.size === allIds.length;
  }, [selectedItems]);

  // Check if selection is indeterminate (some but not all selected)
  const isIndeterminate = useCallback((allIds: T[]) => {
    return selectedItems.size > 0 && selectedItems.size < allIds.length;
  }, [selectedItems]);

  return {
    selectedItems,
    selectedCount: selectedItems.size,
    toggleSelection,
    toggleAllSelection,
    setSelectedItems: setSelected,
    clearSelection,
    isSelected,
    isAllSelected,
    isIndeterminate,
  };
}
```

<!-- path: hooks/useCrudManager.ts -->
```typescript
// path: hooks/useCrudManager.ts
"use client";

import { useState, useCallback, useEffect, useMemo } from "react";
import { useDebounce } from "use-debounce";
import { createClient } from "@/utils/supabase/client";
import {
  useTableInsert,
  useTableUpdate,
  useToggleStatus,
  useTableBulkOperations,
  Filters,
  PublicTableName,
  TableInsert,
  TableUpdate,
  TableInsertWithDates,
} from "@/hooks/database";
import { toast } from "sonner";
import { useDeleteManager } from "./useDeleteManager";

// --- TYPE DEFINITIONS for the Hook's Interface ---
export type RecordWithId = {
  id: string | number | null;
  system_id?: string | number | null;
  system_connection_id?: string | number | null;
  name?: string | null;
  first_name?: string | null;
  last_name?: string | null;
  employee_name?: string | null; // <-- ADDED for type safety
  [key: string]: unknown;
};

export interface DataQueryHookParams {
  currentPage: number;
  pageLimit: number;
  searchQuery: string;
  filters: Filters;
}

export interface DataQueryHookReturn<V> {
  data: V[];
  totalCount: number;
  activeCount: number;
  inactiveCount: number;
  isLoading: boolean;
  isFetching?: boolean;
  error: Error | null;
  refetch: () => void;
}

type DataQueryHook<V> = (params: DataQueryHookParams) => DataQueryHookReturn<V>;

type BaseRecord = { id: string | null; [key: string]: unknown };

export interface CrudManagerOptions<T extends PublicTableName, V extends BaseRecord> {
  tableName: T;
  dataQueryHook: DataQueryHook<V>;
  searchColumn?: (keyof V & string) | (keyof V & string)[];
  processDataForSave?: (data: TableInsertWithDates<T>) => TableInsert<T>;
}

// --- THE HOOK ---
export function useCrudManager<T extends PublicTableName, V extends BaseRecord>({
  tableName,
  dataQueryHook,
  searchColumn,
  processDataForSave,
}: CrudManagerOptions<T, V>) {
  const supabase = createClient();

  // --- STATE MANAGEMENT ---
  const [editingRecord, setEditingRecord] = useState<V | null>(null);
  const [viewingRecord, setViewingRecord] = useState<V | null>(null);
  const [currentPage, setCurrentPage] = useState(1);
  const [pageLimit, setPageLimit] = useState(10);
  const [searchQuery, setSearchQuery] = useState("");
  const [filters, setFilters] = useState<Filters>({});
  const [isEditModalOpen, setIsEditModalOpen] = useState(false);
  const [isViewModalOpen, setIsViewModalOpen] = useState(false);
  const [selectedRowIds, setSelectedRowIds] = useState<string[]>([]);
  const [debouncedSearch] = useDebounce(searchQuery, 400);

  // Combine search query and other filters
  const combinedFilters = useMemo(() => {
    const newFilters: Filters = { ...filters };
    if (debouncedSearch && searchColumn) {
      if (Array.isArray(searchColumn)) {
        newFilters.or = searchColumn.reduce((acc, col) => {
          acc[col as string] = debouncedSearch;
          return acc;
        }, {} as Record<string, string>);
      } else {
        newFilters[searchColumn as string] = { operator: 'ilike', value: `%${debouncedSearch}%` };
      }
    }
    return newFilters;
  }, [debouncedSearch, filters, searchColumn]);

  // Reset pagination when filters change
  useEffect(() => {
    setCurrentPage(1);
  }, [debouncedSearch, filters]);

  // --- DATA FETCHING ---
  const { data, totalCount, activeCount, inactiveCount, isLoading, isFetching, error, refetch } = dataQueryHook({
    currentPage,
    pageLimit,
    searchQuery: debouncedSearch,
    filters: combinedFilters,
  });

  // --- MUTATIONS ---
  const { mutate: insertItem, isPending: isInserting } = useTableInsert(
    supabase,
    tableName,
    {
      onSuccess: () => {
        refetch();
        closeModal();
        toast.success("Record created successfully.");
      },
      onError: (error) => {
        toast.error(`Failed to create record: ${error.message}`);
      },
    }
  );

  const { mutate: updateItem, isPending: isUpdating } = useTableUpdate(
    supabase,
    tableName,
    {
      onSuccess: () => {
        refetch();
        closeModal();
        toast.success("Record updated successfully.");
      },
      onError: (error) => {
        toast.error(`Failed to update record: ${error.message}`);
      },
    }
  );

  const { mutate: toggleStatus } = useToggleStatus(supabase, tableName, {
    onSuccess: () => {
      refetch();
      toast.success("Status updated successfully.");
    },
    onError: (error) => {
      toast.error(`Failed to update status: ${error.message}`);
    },
  });

  const deleteManager = useDeleteManager({
    tableName,
    onSuccess: () => {
      refetch();
      handleClearSelection();
    }
  });

  const { bulkUpdate } = useTableBulkOperations(supabase, tableName);

  const isMutating =
    isInserting ||
    isUpdating ||
    deleteManager.isPending ||
    bulkUpdate.isPending;

  // --- MODAL HANDLERS ---
  const openAddModal = useCallback(() => {
    setEditingRecord(null);
    setIsEditModalOpen(true);
  }, []);

  const openEditModal = useCallback((record: V) => {
    setEditingRecord(record);
    setIsEditModalOpen(true);
  }, []);

  const openViewModal = useCallback((record: V) => {
    setViewingRecord(record);
    setIsViewModalOpen(true);
  }, []);

  const closeModal = useCallback(() => {
    setIsEditModalOpen(false);
    setEditingRecord(null);
    setIsViewModalOpen(false);
    setViewingRecord(null);
  }, []);

  // --- SAVE HANDLER ---
  const handleSave = useCallback(
    (formData: TableInsertWithDates<T>) => {
      const processedData = processDataForSave
        ? processDataForSave(formData)
        : (formData as TableInsert<T>);

      if (editingRecord && "id" in editingRecord && editingRecord.id) {
        updateItem({
          id: String(editingRecord.id),
          data: processedData as TableUpdate<T>,
        });
      } else {
        insertItem(processedData as TableInsert<T>);
      }
    },
    [editingRecord, insertItem, updateItem, processDataForSave]
  );

  // --- DELETE HANDLERS ---
  // **Added a check for 'employee_name'.**
  const getDisplayName = useCallback((record: RecordWithId): string => {
    if (record.employee_name) return String(record.employee_name);
    if (record.name) return String(record.name);
    if (record.first_name && record.last_name) {
      return `${record.first_name} ${record.last_name}`;
    }
    if (record.first_name) return String(record.first_name);
    return String(record.id) || 'Unknown';
  }, []);

  const handleDelete = useCallback(
    (record: RecordWithId) => {
      if (!record.id) {
        toast.error("Cannot delete record: Invalid ID");
        return;
      }
      const displayName = getDisplayName(record);
      deleteManager.deleteSingle({
        id: String(record.id),
        name: displayName,
      });
    },
    [deleteManager, getDisplayName]
  );

  // --- STATUS TOGGLE HANDLER ---
  const handleToggleStatus = useCallback(
    (record: RecordWithId & { status?: boolean | null }) => {
      if (!record.id) {
        toast.error("Cannot update status: Invalid record ID");
        return;
      }
      toggleStatus({
        id: String(record.id),
        status: !(record.status ?? false),
      });
    },
    [toggleStatus]
  );

  // --- BULK SELECTION HANDLERS ---
  const handleRowSelect = useCallback(
    (rows: Array<V & { id?: string | number }>) => {
      const validIds = rows.map(r => r.id).filter((id): id is NonNullable<typeof id> => id != null).map(String);
      setSelectedRowIds(validIds);
    },
    []
  );

  const handleClearSelection = useCallback(() => {
    setSelectedRowIds([]);
  }, []);

  // --- BULK DELETE HANDLER ---
  const handleBulkDelete = useCallback(() => {
    if (selectedRowIds.length === 0) {
      toast.error("No records selected for deletion");
      return;
    }
    const selectedRecords = data.filter(record => selectedRowIds.includes(String(record.id))).map(record => ({
      id: String(record.id),
      name: getDisplayName(record as RecordWithId),
    }));
    deleteManager.deleteMultiple(selectedRecords);
  }, [selectedRowIds, data, deleteManager, getDisplayName]);

  // --- BULK STATUS UPDATE HANDLER ---
  const handleBulkUpdateStatus = useCallback(
    (status: "active" | "inactive") => {
      if (selectedRowIds.length === 0) return;
      const updates = selectedRowIds.map((id) => ({
        id,
        data: { status: status === "active" } as unknown as TableUpdate<T>,
      }));
      bulkUpdate.mutate({ updates }, {
        onSuccess: () => {
          toast.success(`Successfully updated ${updates.length} records to ${status}`);
          setSelectedRowIds([]);
          refetch();
        },
        onError: (err) => {
          toast.error(`Failed to update status: ${err.message}`);
        },
      });
    },
    [selectedRowIds, bulkUpdate, refetch]
  );

  // --- BULK DELETE BY FILTER ---
  const handleBulkDeleteByFilter = useCallback(
    (column: string, value: string | number | boolean | null, displayName: string) => {
      deleteManager.deleteBulk({
        column,
        value,
        displayName,
      });
    },
    [deleteManager]
  );

  // --- RETURN VALUE ---
  return {
    data: data || [],
    totalCount,
    activeCount,
    inactiveCount,
    isLoading,
    isFetching,
    error,
    isMutating,
    refetch,
    pagination: { currentPage, pageLimit, setCurrentPage, setPageLimit },
    search: { searchQuery, setSearchQuery },
    filters: { filters, setFilters },
    editModal: { isOpen: isEditModalOpen, record: editingRecord, openAdd: openAddModal, openEdit: openEditModal, close: closeModal },
    viewModal: { isOpen: isViewModalOpen, record: viewingRecord, open: openViewModal, close: closeModal },
    actions: { handleSave, handleDelete, handleToggleStatus },
    bulkActions: { selectedRowIds, selectedCount: selectedRowIds.length, handleBulkDelete, handleBulkDeleteByFilter, handleBulkUpdateStatus, handleClearSelection, handleRowSelect },
    deleteModal: { isOpen: deleteManager.isConfirmModalOpen, message: deleteManager.confirmationMessage, onConfirm: deleteManager.handleConfirm, onCancel: deleteManager.handleCancel, loading: deleteManager.isPending },
    utils: { getDisplayName },
  };
}
```

<!-- path: hooks/useOrderedColumns.ts -->
```typescript
import { useMemo } from 'react';

const useOrderedColumns = <T extends { key: string }>(
  columns: T[],
  desiredOrder: string[]
): T[] => {
  return useMemo(() => {
    const ordered = desiredOrder
      .map(key => columns.find(col => col.key === key))
      .filter((col): col is T => col !== undefined);
    
    const remaining = columns.filter(col => !desiredOrder.includes(col.key));
    
    return [...ordered, ...remaining];
  }, [columns, desiredOrder]);
};

export default useOrderedColumns;
```

<!-- path: hooks/useSorting.ts -->
```typescript
import { useMemo, useState, useCallback } from 'react';

// Types
export type SortDirection = 'asc' | 'desc' | null;

export interface SortConfig<T> {
  key: keyof T | string;
  direction: SortDirection;
}

export interface SortOptions {
  caseSensitive?: boolean;
  numericSort?: boolean;
  locale?: string;
}

export interface UseSortingProps<T> {
  data: T[];
  defaultSortKey?: keyof T | string;
  defaultDirection?: SortDirection;
  options?: SortOptions;
}

export interface UseSortingReturn<T> {
  sortedData: T[];
  sortConfig: SortConfig<T>;
  setSortConfig: (config: SortConfig<T>) => void;
  handleSort: (key: keyof T | string) => void;
  resetSort: () => void;
  isSorted: boolean;
  getSortDirection: (key: keyof T | string) => SortDirection;
}

// Union type for supported sortable values
type SortableValue = string | number | Date | boolean | null | undefined;

// Helper function to get nested property value
function getNestedValue(obj: Record<string, unknown>, path: string): SortableValue {
  const keys = path.split('.');
  let current: unknown = obj;
  
  for (const key of keys) {
    if (current === null || current === undefined) {
      return undefined;
    }
    if (typeof current === 'object' && current !== null && key in current) {
      current = (current as Record<string, unknown>)[key];
    } else {
      return undefined;
    }
  }
  
  // Type guard to ensure we return only sortable values
  if (
    typeof current === 'string' ||
    typeof current === 'number' ||
    typeof current === 'boolean' ||
    current instanceof Date ||
    current === null ||
    current === undefined
  ) {
    return current as SortableValue;
  }
  
  // Convert other types to string for comparison
  return String(current);
}

// Helper function to compare values
function compareValues(
  a: SortableValue, 
  b: SortableValue, 
  direction: SortDirection, 
  options: SortOptions = {}
): number {
  const { caseSensitive = false, numericSort = true, locale = 'en' } = options;
  
  // Handle null/undefined values
  if (a == null && b == null) return 0;
  if (a == null) return direction === 'asc' ? -1 : 1;
  if (b == null) return direction === 'asc' ? 1 : -1;

  // Handle different data types
  if (typeof a === 'string' && typeof b === 'string') {
    const valueA = caseSensitive ? a : a.toLowerCase();
    const valueB = caseSensitive ? b : b.toLowerCase();
    
    // Use localeCompare for proper string sorting
    const result = valueA.localeCompare(valueB, locale, {
      numeric: numericSort,
      sensitivity: caseSensitive ? 'case' : 'base'
    });
    
    return direction === 'asc' ? result : -result;
  }

  // Handle numbers
  if (typeof a === 'number' && typeof b === 'number') {
    const result = a - b;
    return direction === 'asc' ? result : -result;
  }

  // Handle dates
  if (a instanceof Date && b instanceof Date) {
    const result = a.getTime() - b.getTime();
    return direction === 'asc' ? result : -result;
  }

  // Handle boolean values
  if (typeof a === 'boolean' && typeof b === 'boolean') {
    const result = Number(a) - Number(b);
    return direction === 'asc' ? result : -result;
  }

  // Fallback to string comparison for mixed types
  const stringA = String(a);
  const stringB = String(b);
  const result = stringA.localeCompare(stringB, locale, {
    numeric: numericSort,
    sensitivity: caseSensitive ? 'case' : 'base'
  });
  
  return direction === 'asc' ? result : -result;
}

// Main sorting hook
export function useSorting<T extends Record<string, unknown>>({
  data,
  defaultSortKey,
  defaultDirection = 'asc',
  options = {}
}: UseSortingProps<T>): UseSortingReturn<T> {
  
  const [sortConfig, setSortConfig] = useState<SortConfig<T>>({
    key: defaultSortKey || '',
    direction: defaultSortKey ? defaultDirection : null
  });

  // Memoized sorted data
  const sortedData = useMemo(() => {
    if (!sortConfig.key || !sortConfig.direction || !data.length) {
      return data;
    }

    return [...data].sort((a, b) => {
      const valueA = getNestedValue(a, String(sortConfig.key));
      const valueB = getNestedValue(b, String(sortConfig.key));
      
      return compareValues(valueA, valueB, sortConfig.direction, options);
    });
  }, [data, sortConfig, options]);

  // Handle sort column click
  const handleSort = useCallback((key: keyof T | string) => {
    setSortConfig(prevConfig => {
      if (prevConfig.key === key) {
        // Cycle through: asc -> desc -> null -> asc
        switch (prevConfig.direction) {
          case 'asc':
            return { key, direction: 'desc' };
          case 'desc':
            return { key: '', direction: null };
          default:
            return { key, direction: 'asc' };
        }
      } else {
        // New column, start with ascending
        return { key, direction: 'asc' };
      }
    });
  }, []);

  // Reset sorting
  const resetSort = useCallback(() => {
    setSortConfig({ key: '', direction: null });
  }, []);

  // Check if currently sorted
  const isSorted = Boolean(sortConfig.key && sortConfig.direction);

  // Get sort direction for a specific key
  const getSortDirection = useCallback((key: keyof T | string): SortDirection => {
    return sortConfig.key === key ? sortConfig.direction : null;
  }, [sortConfig]);

  return {
    sortedData,
    sortConfig,
    setSortConfig,
    handleSort,
    resetSort,
    isSorted,
    getSortDirection
  };
}

// Additional utility hooks for specific use cases

// Hook for multi-column sorting
export interface MultiSortConfig<T> {
  key: keyof T | string;
  direction: SortDirection;
  priority: number;
}

export function useMultiSorting<T extends Record<string, unknown>>(
  data: T[], 
  options: SortOptions = {}
) {
  const [sortConfigs, setSortConfigs] = useState<MultiSortConfig<T>[]>([]);

  const sortedData = useMemo(() => {
    if (!sortConfigs.length || !data.length) return data;

    return [...data].sort((a, b) => {
      for (const config of sortConfigs.sort((x, y) => x.priority - y.priority)) {
        if (!config.direction) continue;
        
        const valueA = getNestedValue(a, String(config.key));
        const valueB = getNestedValue(b, String(config.key));
        
        const result = compareValues(valueA, valueB, config.direction, options);
        if (result !== 0) return result;
      }
      return 0;
    });
  }, [data, sortConfigs, options]);

  const addSort = useCallback((key: keyof T | string, direction: SortDirection) => {
    if (!direction) return;
    
    setSortConfigs(prev => {
      const existing = prev.find(config => config.key === key);
      if (existing) {
        return prev.map(config => 
          config.key === key 
            ? { ...config, direction }
            : config
        );
      }
      return [...prev, { key, direction, priority: prev.length }];
    });
  }, []);

  const removeSort = useCallback((key: keyof T | string) => {
    setSortConfigs(prev => prev.filter(config => config.key !== key));
  }, []);

  const clearSort = useCallback(() => {
    setSortConfigs([]);
  }, []);

  return {
    sortedData,
    sortConfigs,
    addSort,
    removeSort,
    clearSort
  };
}

// Hook for search + sort combination
export function useSearchAndSort<T extends Record<string, unknown>>(
  data: T[],
  searchKeys: (keyof T | string)[],
  sortOptions: SortOptions = {}
) {
  const [searchTerm, setSearchTerm] = useState('');
  
  // Filter data based on search term
  const filteredData = useMemo(() => {
    if (!searchTerm.trim()) return data;
    
    return data.filter(item => 
      searchKeys.some(key => {
        const value = getNestedValue(item, String(key));
        return String(value || '').toLowerCase().includes(searchTerm.toLowerCase());
      })
    );
  }, [data, searchTerm, searchKeys]);

  // Apply sorting to filtered data
  const sortingResult = useSorting({
    data: filteredData,
    options: sortOptions
  });

  return {
    ...sortingResult,
    searchTerm,
    setSearchTerm,
    filteredCount: filteredData.length,
    totalCount: data.length
  };
}

// Utility type for extracting sortable keys from an object type
export type SortableKeys<T> = {
  [K in keyof T]: T[K] extends SortableValue ? K : never;
}[keyof T];

// Hook with strongly typed keys (optional, for better type safety)
export function useTypedSorting<T extends Record<string, unknown>>(
  data: T[],
  defaultSortKey?: SortableKeys<T>,
  defaultDirection: SortDirection = 'asc',
  options: SortOptions = {}
) {
  return useSorting({
    data,
    defaultSortKey,
    defaultDirection,
    options
  });
}
```

<!-- path: hooks/useColumnConfig.tsx -->
```typescript
import { useMemo, ReactNode } from 'react';
import { TABLE_COLUMN_KEYS } from '@/config/table-column-keys';
import { Column } from '@/hooks/database/excel-queries/excel-helpers';
import { GenericRow, TableOrViewName } from '@/config/helper-types';
// import { inferColumnWidth } from "@/config/column-width";
import {
  inferDynamicColumnWidth,
  inferExcelFormat,
  toTitleCase,
} from '@/config/helper-functions';

/**
 * This is the final, compatible Column Configuration type.
 * It is generic and includes all properties from your `Column<T>` interface.
 */
export interface ColumnConfig<T extends TableOrViewName> {
  /** The unique, type-safe column name. Used as the React key. */
  key: keyof GenericRow<T> & string;
  /** The human-readable title for the column header. */
  title: string;
  /** The key for accessing data from a row object. We set it to be the same as `key`. */
  dataIndex: keyof GenericRow<T> & string;
  /** Optional: The data format for Excel exports. */
  excelFormat?: 'text' | 'number' | 'date' | 'currency' | 'percentage' | 'json';
  /** Optional: Flag to hide the column in the UI. */
  hidden?: boolean;
  /** Optional: Column width for UI tables. Use "auto" to fit content width. */
  width?: number | string;
  /** Optional: Allow sorting on this column. */
  sortable?: boolean;
  /** Optional: Allow searching on this column. */
  searchable?: boolean;
  /** Optional: Allow filtering on this column. */
  filterable?: boolean;
  /** Optional: A custom render function for the cell. */
  render?: (value: unknown, record: GenericRow<T>, index: number) => ReactNode;
  // ... and any other properties from your master Column<T> type.
  resizable?: boolean;
}

type ColumnOverrides<T extends TableOrViewName> = {
  // [K in keyof GenericRow<T>]?: Partial<
  //   Omit<Column<GenericRow<T>>, 'key' | 'dataIndex'>
  // >;
  [K in keyof GenericRow<T>]?: Partial<ColumnConfig<T>>;
};

interface UseDynamicColumnConfigOptions<T extends TableOrViewName> {
  overrides?: ColumnOverrides<T>;
  omit?: (keyof GenericRow<T> & string)[];
  data?: GenericRow<T>[];
}

/**
 * A hook that dynamically generates a detailed and type-safe column configuration array
 * that is fully compatible with the application's standard `Column<T>` interface.
 */
// FIX: The hook is now fully generic for tables and views.
export function useDynamicColumnConfig<T extends TableOrViewName>(
  tableName: T,
  options: UseDynamicColumnConfigOptions<T> = {}
): Column<GenericRow<T>>[] {
  const { overrides = {}, omit = [], data = [] } = options;

  const dateColumns = useMemo(
    () =>
      new Set([
        'date_of_birth',
        'last_sign_in_at',
        'created_at',
        'updated_at',
        'auth_updated_at',
        'email_confirmed_at',
        'phone_confirmed_at',
      ]),
    []
  ); // Memoize once

  // generate column widths dynamically
  const columnWidths = useMemo(() => {
    const widths: Record<string, number> = {};
    if (data.length > 0) {
      for (const colName of Object.keys(data[0] || {})) {
        widths[colName] = dateColumns.has(colName)
          ? 120
          : inferDynamicColumnWidth(colName, data);
      }
    }
    return widths;
  }, [data, dateColumns]);

  const columns = useMemo(() => {
    const keysToUse = TABLE_COLUMN_KEYS[
      tableName as keyof typeof TABLE_COLUMN_KEYS
    ] as unknown as (keyof GenericRow<T> & string)[] | undefined;

    if (!keysToUse) {
      console.warn(`No column keys found for table/view: ${tableName}`);
      return [];
    }

    const omitSet = new Set(omit);

    return (keysToUse as (keyof GenericRow<T> & string)[])
      .filter((key) => !omitSet.has(key))
      .map((key) => {
        const columnOverride =
          (key in overrides ? overrides[key as keyof typeof overrides] : {}) ||
          {};
        // console.log(key + ":" + columnWidths?.[key]);
        const defaultConfig: Column<GenericRow<T>> = {
          title: toTitleCase(key),
          dataIndex: key,
          key: key,
          excelFormat: inferExcelFormat(key),
          width: columnWidths?.[key],
        };

        return { ...defaultConfig, ...columnOverride };
      });
  }, [tableName, overrides, omit, columnWidths]);

  return columns;
}

```

<!-- path: hooks/ofc/useCableSegmentation.ts -->
```typescript
import { createClient } from '@/utils/supabase/client';
import { useCallback, useState } from 'react';
import { toast } from 'sonner';

export interface JunctionClosure {
  id: string;
  node_id: string;
  name: string;
  ofc_cable_id: string;
  position_km: number;
  created_at: string;
  updated_at: string;
}

export interface CableSegment {
  id: string;
  original_cable_id: string;
  segment_order: number;
  start_node_id: string;
  end_node_id: string;
  start_node_type: 'node' | 'jc';
  end_node_type: 'node' | 'jc';
  distance_km: number;
  fiber_count: number;
  created_at: string;
  updated_at: string;
}

export interface SpliceConfiguration {
  incoming_fiber_no: number;
  outgoing_fiber_no: number;
  splice_type: 'straight' | 'cross';
}

export const useCableSegmentation = () => {
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const supabase = createClient();

  const addJunctionClosure = useCallback(async (
    cableId: string,
    positionKm: number,
    name: string
  ): Promise<JunctionClosure | null> => {
    setIsLoading(true);
    setError(null);

    try {
      const { data, error: insertError } = await supabase
        .rpc('add_junction_closure', {
          p_ofc_cable_id: cableId,
          p_position_km: positionKm,
          p_name: name
        });

      if (insertError) {
        throw insertError;
      }

      toast.success('Junction Closure added successfully');
      return data as JunctionClosure;
    } catch (err: unknown) {
      const errorMessage = err instanceof Error ? err.message : 'An unknown error occurred';
      setError(errorMessage);
      toast.error(`Failed to add Junction Closure: ${errorMessage}`);
      return null;
    } finally {
      setIsLoading(false);
    }
  }, [supabase]);

  const createCableSegments = useCallback(async (
    jcId: string,
    cableId: string
  ): Promise<CableSegment[]> => {
    console.log('=== CREATE CABLE SEGMENTS FUNCTION CALLED ===');
    console.log('Input parameters:', { jcId, cableId });
    setIsLoading(true);
    setError(null);

    console.log('=== CREATE CABLE SEGMENTS DEBUG ===');
    console.log('Calling create_cable_segments_on_jc_add with:', { p_jc_id: jcId, p_ofc_cable_id: cableId });

    try {
      const { data, error: segmentError } = await supabase
        .rpc('create_cable_segments_on_jc_add', {
          p_jc_id: jcId,
          p_ofc_cable_id: cableId
        });

      console.log('Function result:', { data, segmentError });

      if (segmentError) {
        console.error('Database function error:', segmentError);
        throw segmentError;
      }

      toast.success('Cable segments created successfully');
      return data as CableSegment[];
    } catch (err: unknown) {
      console.error('Error in createCableSegments:', err);
      const errorMessage = err instanceof Error ? err.message : 'An unknown error occurred';
      console.error('Error details:', errorMessage, (err instanceof Error && 'details' in err) ? err.details : undefined, (err instanceof Error && 'hint' in err) ? err.hint : undefined, (err instanceof Error && 'code' in err) ? err.code : undefined);
      setError(errorMessage);
      toast.error(`Failed to create cable segments: ${errorMessage}`);
      return [];
    } finally {
      setIsLoading(false);
    }
  }, [supabase]);

  const createInitialFiberConnections = useCallback(async (
    segmentId: string
  ): Promise<number> => {
    setIsLoading(true);
    setError(null);

    try {
      const { data, error: connectionError } = await supabase
        .rpc('create_initial_fiber_connections', {
          p_segment_id: segmentId
        });

      if (connectionError) {
        throw connectionError;
      }

      toast.success('Fiber connections created successfully');
      return data as number;
    } catch (err: unknown) {
      const errorMessage = err instanceof Error ? err.message : 'An unknown error occurred';
      setError(errorMessage);
      toast.error(`Failed to create fiber connections: ${errorMessage}`);
      return 0;
    } finally {
      setIsLoading(false);
    }
  }, [supabase]);

  const getFiberPath = useCallback(async (
    startNodeId: string,
    endNodeId: string,
    fiberNumber: number
  ) => {
    setIsLoading(true);
    setError(null);

    try {
      const { data, error: pathError } = await supabase
        .rpc('get_fiber_path', {
          p_start_node_id: startNodeId,
          p_end_node_id: endNodeId,
          p_fiber_number: fiberNumber
        });

      if (pathError) {
        throw pathError;
      }

      return data;
    } catch (err: unknown) {
      const errorMessage = err instanceof Error ? err.message : 'An unknown error occurred';
      setError(errorMessage);
      toast.error(`Failed to get fiber path: ${errorMessage}`);
      return [];
    } finally {
      setIsLoading(false);
    }
  }, [supabase]);

  return {
    isLoading,
    error,
    addJunctionClosure,
    createCableSegments,
    createInitialFiberConnections,
    getFiberPath,
  };
};

```

<!-- path: hooks/useDebounce.ts -->
```typescript
// @/hooks/useDebounce.ts
import { useState, useEffect } from 'react';

export function useDebounce<T>(value: T, delay: number): T {
  const [debouncedValue, setDebouncedValue] = useState<T>(value);

  useEffect(() => {
    const handler = setTimeout(() => {
      setDebouncedValue(value);
    }, delay);

    // Cleanup function to cancel the timeout if value changes before delay has passed
    return () => {
      clearTimeout(handler);
    };
  }, [value, delay]);

  return debouncedValue;
}
```

<!-- path: hooks/useCurrentTableName.ts -->
```typescript
// hooks/useCurrentTableName.ts
import { usePathname } from "next/navigation";
import { useMemo } from "react";
import { TableNames } from "@/config/helper-types";

export const useCurrentTableName = (tableName?: TableNames): TableNames | null => {
  const pathname = usePathname();

  return useMemo(() => {
    if (tableName) return tableName;

    const path = pathname || "";
    const segments = path.split("/").filter(Boolean); // Remove empty segments

    // Look for the dashboard segment and get the next segment as the route
    const dashboardIndex = segments.findIndex((segment) => segment === "dashboard");
    if (dashboardIndex === -1 || dashboardIndex >= segments.length - 1) {
      return null;
    }

    const routeSegment = segments[dashboardIndex + 1];

    // Map route segments to table names
    switch (routeSegment) {
      case "users":
        return "user_profiles";
      case "employees":
        return "employees";
      case "categories":
        return "lookup_types";
      case "designations":
        return "employee_designations";
      case "rings":
        return "rings";
      case "maintenance-areas":
        return "maintenance_areas";
      case "lookup":
        return "lookup_types";
      case "ofc":
        // Check if there's a third segment (ID) after ofc
        const hasId = segments.length > dashboardIndex + 2 && segments[dashboardIndex + 2];
        return hasId ? "ofc_connections" : "ofc_cables";
      case "ofc_connections":
        return "ofc_connections";
      case "nodes":
        return "nodes";
      case "systems":
        return "systems";
      case "cpan":
        return null;
      case "cpan_connections":
        return null;
      case "fiber-joints":
        return "fiber_joints";
      case "fiber-joint-connections":
        return null;
      case "logical-fiber-paths":
        return "logical_fiber_paths";
      case "maan":
        return null;
      case "maan_connections":
        return null;
      case "management-ports":
        return "management_ports";
      case "sdh":
        return "sdh_systems";
      case "sdh_connections":
        return "sdh_connections";
      case "sdh_node_associations":
        return "sdh_node_associations";
      case "system-connections":
        return "system_connections";
      case "user-activity-logs":
        return "user_activity_logs";
      case "vmux":
        return "vmux_systems";
      case "vmux_connections":
        return "vmux_connections";
      default:
        return null;
    }
  }, [tableName, pathname]);
};

```

<!-- path: hooks/UseRouteBasedUploadConfigOptions.tsx -->
```typescript
// src/hooks/useRouteBasedUploadConfig.ts

import { useEffect, FC, ReactNode, useRef } from "react";
// Import the simplified store and its types
import {
  useUploadConfigStore,
  UploadConfig,
} from "@/stores/useUploadConfigStore";
import { useCurrentTableName } from "./useCurrentTableName";
import { TableNames } from "@/config/helper-types";
import { buildUploadConfig } from "@/config/table-column-keys";

export interface UseRouteBasedUploadConfigOptions {
  tableName?: TableNames;
  autoSetConfig?: boolean;
  customConfig?: Partial<UploadConfig<TableNames>>;
}

export const useRouteBasedUploadConfig = (
  options: UseRouteBasedUploadConfigOptions = {}
) => {
  const { tableName, autoSetConfig = true, customConfig } = options;
  const previousTableNameRef = useRef<TableNames | null>(null);

  // Get current table name from the new hook
  const currentTableName = useCurrentTableName(tableName);

  // Get the actions from the store
  const { setUploadConfig, getUploadConfig, clearUploadConfig } =
    useUploadConfigStore();

  // Proper cleanup and config management
  useEffect(() => {
    // Clear previous config when route changes
    if (
      previousTableNameRef.current &&
      previousTableNameRef.current !== currentTableName
    ) {
      clearUploadConfig(previousTableNameRef.current);
    }

    // Set new config if applicable
    if (autoSetConfig && currentTableName) {
      const generated = buildUploadConfig(currentTableName);
      const finalConfig = {
        ...generated,
        ...customConfig,
      } as UploadConfig<TableNames>;
      setUploadConfig(currentTableName, finalConfig);
    }

    // Update the ref with current table name
    previousTableNameRef.current = currentTableName;

    // Cleanup function - runs when component unmounts
    return () => {
      if (currentTableName) {
        clearUploadConfig(currentTableName);
      }
    };
  }, [
    currentTableName,
    autoSetConfig,
    customConfig,
    setUploadConfig,
    clearUploadConfig,
  ]);

  return {
    currentTableName,
    config: currentTableName ? getUploadConfig(currentTableName) : undefined,
  };
};

/**
 * A simple Provider component to easily wrap layouts or pages,
 * activating the route-based configuration logic.
 */
export const RouteBasedUploadConfigProvider: FC<{
  children: ReactNode;
  options?: UseRouteBasedUploadConfigOptions;
}> = ({ children, options = {} }) => {
  useRouteBasedUploadConfig(options);
  return <>{children}</>;
};

```

<!-- path: hooks/useAdminUsers.ts -->
```typescript
import { useQuery, useMutation, useQueryClient } from "@tanstack/react-query";
import { toast } from "sonner";
import { Database } from "@/types/supabase-types";
import { createClient } from "@/utils/supabase/client";
import { User_profilesUpdateSchema, V_user_profiles_extendedRowSchema } from "@/schemas/zod-schemas";


type UserCreateInput = {
  id?: string;  // This will be your custom UUID, optional as it can be auto-generated
  email: string;
  password: string;
  email_confirm?: boolean;
  first_name: string;
  last_name: string;
  role: string;
};

// Define the shape of the RPC response
type UserDataResult = {
  data: V_user_profiles_extendedRowSchema[];
  counts: {
    total: number;
    active: number;
    inactive: number;
  };
};

export type { UserCreateInput };

// Types
type AdminGetAllUsersExtended =
  Database["public"]["Functions"]["admin_get_all_users_extended"]["Args"];

type AdminBulkDeleteUsersFunction =
  Database["public"]["Functions"]["admin_bulk_delete_users"]["Args"];

type AdminBulkUpdateUserRole =
  Database["public"]["Functions"]["admin_bulk_update_role"]["Args"];

type AdminBulkUpdateUserStatus =
  Database["public"]["Functions"]["admin_bulk_update_status"]["Args"];

type AdminUpdateUserProfile =
  Database["public"]["Functions"]["admin_update_user_profile"]["Args"];



// Query Keys
export const adminUserKeys = {
  all: ["admin-users"] as const,
  lists: () => [...adminUserKeys.all, "list"] as const,
  list: (filters: AdminGetAllUsersExtended) =>
    [...adminUserKeys.lists(), filters] as const,
  details: () => [...adminUserKeys.all, "detail"] as const,
  detail: (id: string) => [...adminUserKeys.details(), id] as const,
  role: () => [...adminUserKeys.all, "my-role"] as const,
  userDetails: () => [...adminUserKeys.all, "my-details"] as const,
  superAdmin: () => [...adminUserKeys.all, "super-admin"] as const,
};

export const useAdminGetAllUsersExtended = (params: AdminGetAllUsersExtended = {}) => {
  const supabase = createClient();
  return useQuery({
    queryKey: adminUserKeys.list(params),
    // CORRECTED: Update the query function to expect the new JSONB structure
    queryFn: async (): Promise<UserDataResult> => {
      const { data, error } = await supabase.rpc("admin_get_all_users_extended", params);

      if (error) {
        throw new Error(error.message);
      }

      // Return the structured data, providing defaults if the RPC returns null
      return {
        data: data?.data || [],
        counts: data?.counts || { total: 0, active: 0, inactive: 0 },
      };
    },
    staleTime: 5 * 60 * 1000, // 5 minutes
    gcTime: 10 * 60 * 1000, // 10 minutes
  });
};

// Hook to get user by ID
export const useAdminGetUserById = (userId: string, enabled = true) => {
  const supabase = createClient();
  return useQuery({
    queryKey: adminUserKeys.detail(userId),
    queryFn: async (): Promise<User_profilesUpdateSchema | null> => {
      const { data, error } = await supabase.rpc("admin_get_user_by_id", {
        user_id: userId,
      });

      if (error) {
        throw new Error(error.message);
      }

      return data?.[0] as User_profilesUpdateSchema || null;
    },
    enabled: enabled && !!userId,
    staleTime: 5 * 60 * 1000,
  });
};

// Hook to get current user's role
export const useGetMyRole = () => {
  const supabase = createClient();
  return useQuery({
    queryKey: adminUserKeys.role(),
    queryFn: async (): Promise<string> => {
      const { data, error } = await supabase.rpc("get_my_role");

      if (error) {
        throw new Error(error.message);
      }

      return data || "";
    },
    staleTime: 15 * 60 * 1000, // 15 minutes (roles don't change often)
  });
};

// Hook to get current user's details
export const useGetMyUserDetails = () => {
  const supabase = createClient();
  return useQuery({
    queryKey: adminUserKeys.userDetails(),
    queryFn: async () => {
      const { data, error } = await supabase.rpc("get_my_user_details");

      if (error) {
        throw new Error(error.message);
      }

      return data?.[0] as User_profilesUpdateSchema || null;
    },
    staleTime: 10 * 60 * 1000,
  });
};

// Hook to check if current user is super admin
export const useIsSuperAdmin = () => {
  const supabase = createClient();
  return useQuery({
    queryKey: adminUserKeys.superAdmin(),
    queryFn: async (): Promise<boolean> => {
      const { data, error } = await supabase.rpc("is_super_admin");

      if (error) {
        throw new Error(error.message);
      }

      return data || false;
    },
    staleTime: 15 * 60 * 1000,
  });
};

// Hook to update user profile
export const useAdminUpdateUserProfile = () => {
  const supabase = createClient();
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: async (params: AdminUpdateUserProfile): Promise<boolean> => {
      const { data, error } = await supabase.rpc(
        "admin_update_user_profile",
        params
      );

      if (error) {
        throw new Error(error.message);
      }

      return data || false;
    },
    onSuccess: (_, variables) => {
      toast.success("User profile updated successfully");

      // Invalidate and refetch relevant queries
      queryClient.invalidateQueries({ queryKey: adminUserKeys.lists() });
      queryClient.invalidateQueries({
        queryKey: adminUserKeys.detail(variables.user_id),
      });
    },
    onError: (error) => {
      toast.error(`Failed to update user profile: ${error.message}`);
    },
  });
};

// Hook to bulk delete users
export const useAdminBulkDeleteUsers = () => {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: async (params: { user_ids: string[] }): Promise<void> => {
      const response = await fetch('/api/admin/users', {
        method: 'DELETE',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({ userIds: params.user_ids }),
      });

      const data = await response.json();

      if (!response.ok) {
        throw new Error(data.error || 'Failed to delete users.');
      }
    },
    onSuccess: (_, variables) => {
      toast.success(
        `Successfully deleted ${variables.user_ids.length} user(s)`
      );
      queryClient.invalidateQueries({ queryKey: adminUserKeys.lists() });
      variables.user_ids.forEach((userId) => {
        queryClient.removeQueries({ queryKey: adminUserKeys.detail(userId) });
      });
    },
    onError: (error) => {
      toast.error(`Failed to delete users: ${error.message}`);
    },
  });
};


// Hook to bulk update user roles
export const useAdminBulkUpdateUserRole = () => {
  const supabase = createClient();
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: async (params: AdminBulkUpdateUserRole): Promise<boolean> => {
      const { data, error } = await supabase.rpc(
        "admin_bulk_update_role",
        params
      );

      if (error) {
        throw new Error(error.message);
      }

      return data || false;
    },
    onSuccess: (_, variables) => {
      toast.success(
        `Successfully updated role for ${variables.user_ids.length} user(s)`
      );

      // Invalidate relevant queries
      queryClient.invalidateQueries({ queryKey: adminUserKeys.lists() });

      // Invalidate individual user details
      variables.user_ids.forEach((userId) => {
        queryClient.invalidateQueries({
          queryKey: adminUserKeys.detail(userId),
        });
      });
    },
    onError: (error) => {
      toast.error(`Failed to update user roles: ${error.message}`);
    },
  });
};

// Hook to bulk update user status
export const useAdminBulkUpdateUserStatus = () => {
  const supabase = createClient();
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: async (params: AdminBulkUpdateUserStatus): Promise<boolean> => {
      const { data, error } = await supabase.rpc(
        "admin_bulk_update_status",
        params
      );

      if (error) {
        throw new Error(error.message);
      }

      return data || false;
    },
    onSuccess: (_, variables) => {
      toast.success(
        `Successfully updated status for ${variables.user_ids.length} user(s)`
      );

      // Invalidate relevant queries
      queryClient.invalidateQueries({ queryKey: adminUserKeys.lists() });

      // Invalidate individual user details
      variables.user_ids.forEach((userId) => {
        queryClient.invalidateQueries({
          queryKey: adminUserKeys.detail(userId),
        });
      });
    },
    onError: (error) => {
      toast.error(`Failed to update user status: ${error.message}`);
    },
  });
};

// Hook to create a new user
export const useAdminCreateUser = () => {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: async (userData: UserCreateInput) => {
      const res = await fetch("/api/admin/users", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify(userData),
      });

      const data = await res.json();

      if (!res.ok) {
        throw new Error(data.error || "Failed to create user");
      }

      return data;
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: adminUserKeys.lists() });
      toast.success("User created successfully");
    },
    onError: (error: Error) => {
      console.error("User creation error:", error);
      toast.error(error.message || "Failed to create user");
    },
  });
};


// Combined hook for multiple operations
interface UserOperations {
  createUser: ReturnType<typeof useAdminCreateUser>;
  updateUser: ReturnType<typeof useAdminUpdateUserProfile>;
  deleteUsers: ReturnType<typeof useAdminBulkDeleteUsers>;
  updateUserRoles: ReturnType<typeof useAdminBulkUpdateUserRole>;
  updateUserStatus: ReturnType<typeof useAdminBulkUpdateUserStatus>;
  isLoading: boolean;
}

export const useAdminUserOperations = (): UserOperations => {
  const createUser = useAdminCreateUser();
  const updateUser = useAdminUpdateUserProfile();
  const deleteUsers = useAdminBulkDeleteUsers();
  const updateUserRoles = useAdminBulkUpdateUserRole();
  const updateUserStatus = useAdminBulkUpdateUserStatus();

  return {
    createUser,
    updateUser,
    deleteUsers,
    updateUserRoles,
    updateUserStatus,
    isLoading: createUser.isPending || 
               updateUser.isPending || 
               deleteUsers.isPending || 
               updateUserRoles.isPending || 
               updateUserStatus.isPending
  };
};
```

<!-- path: hooks/useDebugSession.ts -->
```typescript
// hooks/useDebugSession.ts
import { useEffect, useState } from 'react'
import { createClient } from '@/utils/supabase/client'

export const useDebugSession = () => {
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  const [sessionInfo, setSessionInfo] = useState<any>(null)
  const supabase = createClient()

  useEffect(() => {
    const checkSession = async () => {
      // Check current session
      const { data: { session }, error } = await supabase.auth.getSession()
      
      // Check headers that would be sent with requests
      const headers = await supabase.auth.getSession().then(({ data: { session } }) => ({
        'apikey': 'present',
        'authorization': session ? `Bearer ${session.access_token}` : 'none',
        'user_id': session?.user?.id || 'none'
      }))

      setSessionInfo({
        hasSession: !!session,
        userId: session?.user?.id,
        accessToken: session?.access_token ? 'present' : 'none',
        refreshToken: session?.refresh_token ? 'present' : 'none',
        expiresAt: session?.expires_at,
        headers,
        error: error?.message
      })

      console.log('Session Debug:', {
        hasSession: !!session,
        userId: session?.user?.id,
        accessToken: session?.access_token ? 'present' : 'none',
        headers,
        error: error?.message
      })
    }

    checkSession()

    // Listen for changes
    const { data: { subscription } } = supabase.auth.onAuthStateChange(
      (event, session) => {
        console.log('Auth state change:', event, session?.user?.id)
        checkSession()
      }
    )

    return () => subscription.unsubscribe()
  // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [])

  return sessionInfo
}
```

<!-- path: hooks/useORSRouteDistances.ts -->
```typescript
// path: hooks/useORSRouteDistances.ts
import { useQuery } from '@tanstack/react-query';
import { RingMapNode } from '@/components/map/types/node';
import { useMemo } from 'react';

async function fetchRouteDistances(pairs: Array<[RingMapNode, RingMapNode]>): Promise<Record<string, string>> {
  if (pairs.length === 0) {
    return {};
  }

  // Use a Map to ensure unique pairs, preventing duplicate API calls
  const uniquePairs = new Map<string, [RingMapNode, RingMapNode]>();
  pairs.forEach(([startNode, endNode]) => {
    // Sort IDs to create a consistent key regardless of order
    const key = [startNode.id, endNode.id].sort().join('-');
    if (!uniquePairs.has(key)) {
      uniquePairs.set(key, [startNode, endNode]);
    }
  });

  const distancePromises = Array.from(uniquePairs.values()).map(async ([startNode, endNode]) => {
    try {
      const response = await fetch('/api/ors-distance', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ a: startNode, b: endNode }),
      });

      if (!response.ok) {
        console.error(`API error for pair ${startNode.id}-${endNode.id}: ${response.statusText}`);
        return null;
      }
      
      const data = await response.json();
      return {
        startId: startNode.id,
        endId: endNode.id,
        distance: data.distance_km ? `${data.distance_km} km` : 'N/A',
      };
    } catch (error) {
      console.error(`Fetch failed for pair ${startNode.id}-${endNode.id}:`, error);
      return null;
    }
  });

  const results = await Promise.all(distancePromises);
  const distances: Record<string, string> = {};

  results.forEach(result => {
    if (result) {
      //  Create keys for both directions
      distances[`${result.startId}-${result.endId}`] = result.distance;
      distances[`${result.endId}-${result.startId}`] = result.distance;
    }
  });

  return distances;
}

export default function useORSRouteDistances(pairs: Array<[RingMapNode, RingMapNode]>) {
  // The queryKey should also be consistently sorted to ensure caching works correctly
  const sortedUniqueKeys = useMemo(() => {
    const keys = pairs.map(p => [p[0].id, p[1].id].sort().join('-'));
    return [...new Set(keys)].sort();;
  }, [pairs]);

  return useQuery({
    queryKey: ['ors-distances', sortedUniqueKeys],
    queryFn: () => fetchRouteDistances(pairs),
    staleTime: Infinity,
    enabled: pairs.length > 0,
  });
}
```

<!-- path: tsconfig.json -->
```json
{
  "$schema": "https://json.schemastore.org/tsconfig",
  "compilerOptions": {
    "target": "ES2017",
    "lib": ["dom", "dom.iterable", "esnext"],
    "allowJs": true,
    "skipLibCheck": true,
    "strict": true,
    "noEmit": true,
    "esModuleInterop": true,
    "module": "esnext",
    "moduleResolution": "bundler",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "jsx": "preserve",
    "incremental": true,
    "paths": {
      "@/*": ["./*"]
    },
    "plugins": [
      {
        "name": "next"
      }
    ]
  },
  "include": ["next-env.d.ts", "**/*.ts", "**/*.tsx", ".next/types/**/*.ts"],
  "exclude": [
    "node_modules",
    "components/table/DataTableDemo.tsx",
    "components/table/ExampleModalUsage.tsx",
    "**/* copy.tsx",
    "components/debug/**"
  ]
}

```

<!-- path: eslint.config.mjs -->
```mjs
import { dirname } from "path";
import { fileURLToPath } from "url";
import { FlatCompat } from "@eslint/eslintrc";

const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);

const compat = new FlatCompat({
  baseDirectory: __dirname,
});

const eslintConfig = [
  {
    ignores: ["node_modules/**", ".next/**", "out/**", "build/**", "next-env.d.ts"],
  },
  ...compat.extends("next/core-web-vitals", "next/typescript"),
  {
    rules: {
      // '@typescript-eslint/no-explicit-any': 'warn',
      "@typescript-eslint/no-unused-vars": "warn",
      "react/no-unescaped-entities": "warn",
    },
  },
];

export default eslintConfig;

```

<!-- path: components.json -->
```json
{
  "$schema": "https://ui.shadcn.com/schema.json",
  "style": "new-york",
  "rsc": true,
  "tsx": true,
  "tailwind": {
    "config": "",
    "css": "app/globals.css",
    "baseColor": "slate",
    "cssVariables": true,
    "prefix": ""
  },
  "aliases": {
    "components": "@/components",
    "utils": "@/lib/utils",
    "ui": "@/components/ui",
    "lib": "@/lib",
    "hooks": "@/hooks"
  },
  "iconLibrary": "lucide"
}
```

<!-- path: utils/classNames.tsx -->
```typescript
import clsx from 'clsx';
import { twMerge } from 'tailwind-merge';

interface CnFunction {
    (...args: Parameters<typeof clsx>): string;
}

export const cn: CnFunction = (...args) => {
    return twMerge(clsx(...args));
};
```

<!-- path: utils/caseConverter.ts -->
```typescript
/**
 * Type-safe case conversion utilities for JavaScript objects
 * Supports deep nested objects and arrays with proper TypeScript inference
 */

// === TYPE DEFINITIONS ===

/**
 * Primitive values that don't need transformation
 * Note: Functions are treated as primitives and returned as-is
 */
type Primitive = string | number | boolean | null | undefined | Date | RegExp;

/**
 * Check if a value is a plain object (not Date, Array, etc.)
 */
type IsPlainObject<T> = T extends Primitive
  ? false
  : T extends readonly unknown[]
  ? false
  : T extends Record<string, unknown>
  ? true
  : false;

/**
 * Transform object keys while preserving type structure
 */
type TransformKeys<T, U extends string> = T extends Primitive
  ? T
  : T extends readonly (infer Item)[]
  ? readonly TransformKeys<Item, U>[]
  : IsPlainObject<T> extends true
  ? {
      [K in keyof T as K extends string ? U : K]: TransformKeys<T[K], U>
    }
  : T;

// Case transformation type mappings
type CamelCase<S extends string> = S extends `${infer P1}_${infer P2}`
  ? `${P1}${Capitalize<CamelCase<P2>>}`
  : S;

type SnakeCase<S extends string> = S extends `${infer C}${infer T}`
  ? C extends Lowercase<C>
    ? `${C}${SnakeCase<T>}`
    : `_${Lowercase<C>}${SnakeCase<T>}`
  : S;

type KebabCase<S extends string> = S extends `${infer C}${infer T}`
  ? C extends Lowercase<C>
    ? `${C}${KebabCase<T>}`
    : `-${Lowercase<C>}${KebabCase<T>}`
  : S;

type PascalCase<S extends string> = Capitalize<CamelCase<S>>;

type ScreamingSnakeCase<S extends string> = Uppercase<
  S extends `${infer C}${infer T}`
    ? C extends Lowercase<C>
      ? `${C}${ScreamingSnakeCase<T>}`
      : `_${Lowercase<C>}${ScreamingSnakeCase<T>}`
    : S
>;

// === UTILITY FUNCTIONS ===

/**
 * Type guard to check if a value is a plain object
 */
function isPlainObject(value: unknown): value is Record<string, unknown> {
  return (
    value !== null &&
    typeof value === 'object' &&
    !Array.isArray(value) &&
    !(value instanceof Date) &&
    !(value instanceof RegExp) &&
    typeof value !== 'function'
  );
}

/**
 * Type guard to check if a value is primitive
 */
function isPrimitive(value: unknown): value is Primitive {
  return (
    value === null ||
    value === undefined ||
    typeof value === 'string' ||
    typeof value === 'number' ||
    typeof value === 'boolean' ||
    value instanceof Date ||
    value instanceof RegExp ||
    typeof value === 'function'
  );
}

// === KEY TRANSFORMATION FUNCTIONS ===

/**
 * Convert string to camelCase
 */
function toCamelCaseKey(key: string): string {
  return key.replace(/_([a-z])/g, (_, letter: string) => letter.toUpperCase());
}

/**
 * Convert string to snake_case
 */
function toSnakeCaseKey(key: string): string {
  return key.replace(/[A-Z]/g, (letter: string) => `_${letter.toLowerCase()}`);
}

/**
 * Convert string to PascalCase
 */
function toPascalCaseKey(key: string): string {
  const camelKey = toCamelCaseKey(key);
  return camelKey.charAt(0).toUpperCase() + camelKey.slice(1);
}

/**
 * Convert string to kebab-case
 */
function toKebabCaseKey(key: string): string {
  return key
    .replace(/([a-z0-9])([A-Z])/g, '$1-$2')
    .replace(/_/g, '-')
    .toLowerCase();
}

/**
 * Convert string to SCREAMING_SNAKE_CASE
 */
function toScreamingSnakeCaseKey(key: string): string {
  return key
    .replace(/([a-z0-9])([A-Z])/g, '$1_$2')
    .replace(/-/g, '_')
    .toUpperCase();
}

// === GENERIC CONVERTER FACTORY ===

/**
 * Key transformation function type
 */
type KeyTransformer = (key: string) => string;

/**
 * Creates a type-safe object converter function
 */
function createConverter<T extends KeyTransformer>(transformer: T) {
  function convert<TInput>(input: TInput): TransformKeys<TInput, string> {
    if (isPrimitive(input)) {
      return input as TransformKeys<TInput, string>;
    }

    if (Array.isArray(input)) {
      return input.map(convert) as TransformKeys<TInput, string>;
    }

    if (isPlainObject(input)) {
      const result: Record<string, unknown> = {};
      
      for (const [key, value] of Object.entries(input)) {
        const transformedKey = transformer(key);
        result[transformedKey] = convert(value);
      }
      
      return result as TransformKeys<TInput, string>;
    }

    return input as TransformKeys<TInput, string>;
  }

  return convert;
}

// === EXPORTED CONVERTERS ===

/**
 * Converts object keys to camelCase
 * 
 * @example
 * ```typescript
 * const input = { user_name: 'John', user_age: 30 };
 * const output = toCamelCase(input);
 * // Result: { userName: 'John', userAge: 30 }
 * ```
 */
export const toCamelCase = createConverter(toCamelCaseKey);

/**
 * Converts object keys to snake_case
 * 
 * @example
 * ```typescript
 * const input = { userName: 'John', userAge: 30 };
 * const output = toSnakeCase(input);
 * // Result: { user_name: 'John', user_age: 30 }
 * ```
 */
export const toSnakeCase = createConverter(toSnakeCaseKey);

/**
 * Converts object keys to PascalCase
 * 
 * @example
 * ```typescript
 * const input = { user_name: 'John', user_age: 30 };
 * const output = toPascalCase(input);
 * // Result: { UserName: 'John', UserAge: 30 }
 * ```
 */
export const toPascalCase = createConverter(toPascalCaseKey);

/**
 * Converts object keys to kebab-case
 * 
 * @example
 * ```typescript
 * const input = { userName: 'John', userAge: 30 };
 * const output = toKebabCase(input);
 * // Result: { 'user-name': 'John', 'user-age': 30 }
 * ```
 */
export const toKebabCase = createConverter(toKebabCaseKey);

/**
 * Converts object keys to SCREAMING_SNAKE_CASE
 * 
 * @example
 * ```typescript
 * const input = { userName: 'John', userAge: 30 };
 * const output = toScreamingSnakeCase(input);
 * // Result: { USER_NAME: 'John', USER_AGE: 30 }
 * ```
 */
export const toScreamingSnakeCase = createConverter(toScreamingSnakeCaseKey);

// === ADVANCED USAGE ===

/**
 * Creates a custom converter with a user-defined transformation function
 * 
 * @param transformer - Function that transforms a single key
 * @returns A converter function that applies the transformation recursively
 * 
 * @example
 * ```typescript
 * const addPrefix = createCustomConverter(key => `prefix_${key}`);
 * const input = { name: 'John', age: 30 };
 * const output = addPrefix(input);
 * // Result: { prefix_name: 'John', prefix_age: 30 }
 * ```
 */
export const createCustomConverter = createConverter;

// === TYPE EXPORTS FOR ADVANCED USAGE ===

export type {
  TransformKeys,
  KeyTransformer,
  CamelCase,
  SnakeCase,
  KebabCase,
  PascalCase,
  ScreamingSnakeCase,
  Primitive,
  IsPlainObject
};

// === USAGE EXAMPLES ===

/**
 * Example usage with Supabase or similar database libraries
 * 
 * @example
 * ```typescript
 * interface UserProfile {
 *   id: string;
 *   firstName: string;
 *   lastName: string;
 *   createdAt: Date;
 * }
 * 
 * // Converting from database (snake_case) to frontend (camelCase)
 * const { data } = await supabase.from('user_profiles').select('*');
 * const profiles: UserProfile[] = data?.map(toCamelCase) ?? [];
 * 
 * // Converting from frontend (camelCase) to database (snake_case)
 * const newProfile: Partial<UserProfile> = {
 *   firstName: 'John',
 *   lastName: 'Doe'
 * };
 * await supabase.from('user_profiles').insert(toSnakeCase(newProfile));
 * ```
 */

/**
 * Example with nested objects and arrays
 * 
 * @example
 * ```typescript
 * const complexData = {
 *   user_profile: {
 *     personal_info: {
 *       first_name: 'Jane',
 *       last_name: 'Smith'
 *     },
 *     contact_methods: [
 *       { method_type: 'email', contact_value: 'jane@example.com' },
 *       { method_type: 'phone', contact_value: '+1234567890' }
 *     ]
 *   },
 *   created_at: new Date(),
 *   is_active: true
 * };
 * 
 * const camelCaseData = toCamelCase(complexData);
 * // TypeScript knows the exact shape of the result!
 * // camelCaseData.userProfile.personalInfo.firstName is properly typed
 * ```
 */
```

<!-- path: utils/hashPassword.ts -->
```typescript
import bcrypt from "bcrypt";

export async function hashPassword(password: string) {
  const saltRounds = 10; // standard
  return await bcrypt.hash(password, saltRounds);
}

```

<!-- path: utils/validationUtils.ts -->
```typescript
/**
 * Enhanced Validation Utility Functions
 * Improved security, robustness, and modern best practices
 */

// Types for better type safety
export interface ValidationResult {
  isValid: boolean;
  errors: string[];
}

export interface FileValidationOptions {
  maxSize?: number; // in bytes
  allowedTypes?: string[];
  allowedExtensions?: string[];
  minSize?: number;
}

export interface PasswordOptions {
  minLength?: number;
  requireUppercase?: boolean;
  requireLowercase?: boolean;
  requireNumbers?: boolean;
  requireSpecialChars?: boolean;
  maxLength?: number;
}

// Enhanced email validation with more comprehensive regex
export const isValidEmail = (email: string): boolean => {
  if (!email || typeof email !== 'string') return false;
  
  // More comprehensive email regex following RFC 5322 guidelines
  const emailRegex = /^[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/;
  
  // Additional checks
  if (email.length > 254) return false; // RFC 5321 limit
  if (email.includes('..')) return false; // Consecutive dots not allowed
  
  return emailRegex.test(email.trim().toLowerCase());
};

// Enhanced password validation with configurable options
export const validatePassword = (
  password: string, 
  options: PasswordOptions = {}
): ValidationResult => {
  const {
    minLength = 8,
    requireUppercase = true,
    requireLowercase = true,
    requireNumbers = true,
    requireSpecialChars = true,
    maxLength = 128
  } = options;

  const errors: string[] = [];
  
  if (!password || typeof password !== 'string') {
    errors.push('Password is required');
    return { isValid: false, errors };
  }

  if (password.length < minLength) {
    errors.push(`Password must be at least ${minLength} characters long`);
  }

  if (password.length > maxLength) {
    errors.push(`Password must be no more than ${maxLength} characters long`);
  }
  
  if (requireUppercase && !/[A-Z]/.test(password)) {
    errors.push('Password must contain at least one uppercase letter');
  }
  
  if (requireLowercase && !/[a-z]/.test(password)) {
    errors.push('Password must contain at least one lowercase letter');
  }
  
  if (requireNumbers && !/\d/.test(password)) {
    errors.push('Password must contain at least one number');
  }
  
  if (requireSpecialChars && !/[!@#$%^&*(),.?":{}|<>_+=\-\[\]\\;'\/~`]/.test(password)) {
    errors.push('Password must contain at least one special character');
  }

  // Check for common weak patterns
  if (password.toLowerCase().includes('password')) {
    errors.push('Password cannot contain the word "password"');
  }

  if (/(.)\1{2,}/.test(password)) {
    errors.push('Password cannot contain more than 2 consecutive identical characters');
  }

  return {
    isValid: errors.length === 0,
    errors
  };
};

// Enhanced phone number validation with country code support
export const isValidPhoneNumber = (phone: string, countryCode?: string): boolean => {
  if (!phone || typeof phone !== 'string') return false;
  
  // Remove all non-digit characters except +
  const cleanPhone = phone.replace(/[^\d+]/g, '');
  
  // Basic international format validation
  if (countryCode === 'US') {
    // US phone number: 10 digits
    const usPhoneRegex = /^(\+1)?[2-9]\d{2}[2-9]\d{2}\d{4}$/;
    return usPhoneRegex.test(cleanPhone);
  }
  
  // International format: + followed by 1-15 digits
  const intlPhoneRegex = /^\+[1-9]\d{1,14}$/;
  // National format: 7-15 digits
  const nationalPhoneRegex = /^[1-9]\d{6,14}$/;
  
  return intlPhoneRegex.test(cleanPhone) || nationalPhoneRegex.test(cleanPhone);
};

// Enhanced name validation
export const isValidName = (name: string, options: { minLength?: number; maxLength?: number } = {}): ValidationResult => {
  const { minLength = 2, maxLength = 50 } = options;
  const errors: string[] = [];

  if (!name || typeof name !== 'string') {
    errors.push('Name is required');
    return { isValid: false, errors };
  }

  const trimmedName = name.trim();
  
  if (trimmedName.length < minLength) {
    errors.push(`Name must be at least ${minLength} characters long`);
  }
  
  if (trimmedName.length > maxLength) {
    errors.push(`Name must be no more than ${maxLength} characters long`);
  }

  // Allow letters, spaces, hyphens, apostrophes, and common international characters
  if (!/^[a-zA-ZÀ-ÿ\u0100-\u017F\u0180-\u024F\u1E00-\u1EFF\s\-'\.]+$/.test(trimmedName)) {
    errors.push('Name can only contain letters, spaces, hyphens, and apostrophes');
  }

  // Prevent excessive consecutive spaces or special characters
  if (/\s{2,}/.test(trimmedName) || /[\-'\.]{2,}/.test(trimmedName)) {
    errors.push('Name cannot contain consecutive spaces or special characters');
  }

  return {
    isValid: errors.length === 0,
    errors
  };
};

// Enhanced URL validation
export const isValidUrl = (url: string, options: { allowedProtocols?: string[] } = {}): boolean => {
  if (!url || typeof url !== 'string') return false;
  
  const { allowedProtocols = ['http:', 'https:'] } = options;
  
  try {
    const parsedUrl = new URL(url.trim());
    
    // Check if protocol is allowed
    if (!allowedProtocols.includes(parsedUrl.protocol)) {
      return false;
    }
    
    // Additional security checks
    if (parsedUrl.hostname === '') return false;
    if (parsedUrl.hostname.includes('..')) return false;
    
    return true;
  } catch {
    return false;
  }
};

// Enhanced required field validation with better type checking
export const isRequired = (value: unknown): boolean => {
  if (value === null || value === undefined) return false;
  if (typeof value === 'string') return value.trim().length > 0;
  if (typeof value === 'number') return !isNaN(value);
  if (typeof value === 'boolean') return true;
  if (Array.isArray(value)) return value.length > 0;
  if (typeof value === 'object') return Object.keys(value).length > 0;
  return Boolean(value);
};

// Enhanced numeric validation
export const isValidNumber = (value: unknown, min?: number, max?: number): ValidationResult => {
  const errors: string[] = [];
  
  let num: number;
  if (typeof value === 'string') {
    num = parseFloat(value.trim());
  } else if (typeof value === 'number') {
    num = value;
  } else {
    errors.push('Value must be a number');
    return { isValid: false, errors };
  }
  
  if (isNaN(num) || !isFinite(num)) {
    errors.push('Value must be a valid number');
    return { isValid: false, errors };
  }
  
  if (min !== undefined && num < min) {
    errors.push(`Value must be at least ${min}`);
  }
  
  if (max !== undefined && num > max) {
    errors.push(`Value must be no more than ${max}`);
  }

  return {
    isValid: errors.length === 0,
    errors
  };
};

// Enhanced integer validation
export const isValidInteger = (value: unknown, min?: number, max?: number): ValidationResult => {
  const errors: string[] = [];
  
  let num: number;
  if (typeof value === 'string') {
    num = parseInt(value.trim(), 10);
  } else if (typeof value === 'number') {
    num = value;
  } else {
    errors.push('Value must be an integer');
    return { isValid: false, errors };
  }
  
  if (isNaN(num) || !Number.isInteger(num)) {
    errors.push('Value must be a valid integer');
    return { isValid: false, errors };
  }
  
  if (min !== undefined && num < min) {
    errors.push(`Value must be at least ${min}`);
  }
  
  if (max !== undefined && num > max) {
    errors.push(`Value must be no more than ${max}`);
  }

  return {
    isValid: errors.length === 0,
    errors
  };
};

// Enhanced time validation with format options
export const isValidTime = (time: string, format: '12' | '24' = '24'): ValidationResult => {
  const errors: string[] = [];
  
  if (!time || typeof time !== 'string') {
    errors.push('Time is required');
    return { isValid: false, errors };
  }

  const trimmedTime = time.trim();
  
  if (format === '24') {
    // 24-hour format: HH:MM or HH:MM:SS
    const timeRegex = /^([0-1]?[0-9]|2[0-3]):[0-5][0-9](:[0-5][0-9])?$/;
    if (!timeRegex.test(trimmedTime)) {
      errors.push('Time must be in HH:MM or HH:MM:SS format (24-hour)');
    }
  } else {
    // 12-hour format: HH:MM AM/PM
    const timeRegex = /^(0?[1-9]|1[0-2]):[0-5][0-9]\s?(AM|PM|am|pm)$/;
    if (!timeRegex.test(trimmedTime)) {
      errors.push('Time must be in HH:MM AM/PM format');
    }
  }

  return {
    isValid: errors.length === 0,
    errors
  };
};

// Enhanced date validation
export const isValidDate = (date: string | Date): ValidationResult => {
  const errors: string[] = [];
  
  let parsedDate: Date;
  
  if (date instanceof Date) {
    parsedDate = date;
  } else if (typeof date === 'string') {
    if (!date.trim()) {
      errors.push('Date is required');
      return { isValid: false, errors };
    }
    parsedDate = new Date(date.trim());
  } else {
    errors.push('Date must be a string or Date object');
    return { isValid: false, errors };
  }
  
  if (isNaN(parsedDate.getTime())) {
    errors.push('Invalid date format');
  }

  // Check for reasonable date range (year 1900-2100)
  const year = parsedDate.getFullYear();
  if (year < 1900 || year > 2100) {
    errors.push('Date must be between 1900 and 2100');
  }

  return {
    isValid: errors.length === 0,
    errors
  };
};

// Enhanced future date validation
export const isFutureDate = (date: string | Date, allowToday = false): ValidationResult => {
  const dateValidation = isValidDate(date);
  if (!dateValidation.isValid) {
    return dateValidation;
  }

  const errors: string[] = [];
  const inputDate = typeof date === 'string' ? new Date(date.trim()) : date;
  const now = new Date();
  
  // Set time to start of day for comparison
  const today = new Date(now.getFullYear(), now.getMonth(), now.getDate());
  const compareDate = new Date(inputDate.getFullYear(), inputDate.getMonth(), inputDate.getDate());
  
  if (allowToday ? compareDate < today : compareDate <= today) {
    errors.push(allowToday ? 'Date must be today or in the future' : 'Date must be in the future');
  }

  return {
    isValid: errors.length === 0,
    errors
  };
};

// Enhanced past date validation
export const isPastDate = (date: string | Date, allowToday = false): ValidationResult => {
  const dateValidation = isValidDate(date);
  if (!dateValidation.isValid) {
    return dateValidation;
  }

  const errors: string[] = [];
  const inputDate = typeof date === 'string' ? new Date(date.trim()) : date;
  const now = new Date();
  
  // Set time to start of day for comparison
  const today = new Date(now.getFullYear(), now.getMonth(), now.getDate());
  const compareDate = new Date(inputDate.getFullYear(), inputDate.getMonth(), inputDate.getDate());
  
  if (allowToday ? compareDate > today : compareDate >= today) {
    errors.push(allowToday ? 'Date must be today or in the past' : 'Date must be in the past');
  }

  return {
    isValid: errors.length === 0,
    errors
  };
};

// Enhanced file validation
export const validateFile = (
  file: File,
  options: FileValidationOptions = {}
): ValidationResult => {
  const errors: string[] = [];

  if (!file || !(file instanceof File)) {
    errors.push('Valid file is required');
    return { isValid: false, errors };
  }

  // Check minimum file size
  if (options.minSize && file.size < options.minSize) {
    errors.push(`File size must be at least ${formatFileSize(options.minSize)}`);
  }

  // Check maximum file size
  if (options.maxSize && file.size > options.maxSize) {
    errors.push(`File size must be less than ${formatFileSize(options.maxSize)}`);
  }

  // Check file type
  if (options.allowedTypes && options.allowedTypes.length > 0) {
    if (!options.allowedTypes.includes(file.type)) {
      errors.push(`File type "${file.type}" is not allowed. Allowed types: ${options.allowedTypes.join(', ')}`);
    }
  }

  // Check file extension
  if (options.allowedExtensions && options.allowedExtensions.length > 0) {
    const extension = file.name.split('.').pop()?.toLowerCase();
    if (!extension || !options.allowedExtensions.map(ext => ext.toLowerCase()).includes(extension)) {
      errors.push(`File extension must be one of: ${options.allowedExtensions.join(', ')}`);
    }
  }

  // Check for potentially dangerous file names
  if (/[<>:"|?*]/.test(file.name)) {
    errors.push('File name contains invalid characters');
  }

  return {
    isValid: errors.length === 0,
    errors
  };
};

// Enhanced file size formatter
export const formatFileSize = (bytes: number): string => {
  if (bytes === 0) return '0 Bytes';
  if (bytes < 0) return 'Invalid size';
  
  const k = 1024;
  const sizes = ['Bytes', 'KB', 'MB', 'GB', 'TB'];
  const i = Math.floor(Math.log(bytes) / Math.log(k));
  
  if (i >= sizes.length) return 'File too large';
  
  const size = bytes / Math.pow(k, i);
  return `${size.toFixed(i === 0 ? 0 : 2)} ${sizes[i]}`;
};

// Enhanced sanitization with more comprehensive XSS prevention
export const sanitizeInput = (input: string): string => {
  if (!input || typeof input !== 'string') return '';
  
  return input
    .replace(/&/g, '&amp;')    // Must be first
    .replace(/</g, '&lt;')
    .replace(/>/g, '&gt;')
    .replace(/"/g, '&quot;')
    .replace(/'/g, '&#x27;')
    .replace(/\//g, '&#x2F;')
    .replace(/\\/g, '&#x5C;')
    .replace(/`/g, '&#x60;')
    .replace(/=/g, '&#x3D;');
};

// Credit card validation (Luhn algorithm)
export const isValidCreditCard = (cardNumber: string): ValidationResult => {
  const errors: string[] = [];
  
  if (!cardNumber || typeof cardNumber !== 'string') {
    errors.push('Card number is required');
    return { isValid: false, errors };
  }

  // Remove spaces and hyphens
  const cleanCard = cardNumber.replace(/[\s-]/g, '');
  
  // Check if all digits
  if (!/^\d+$/.test(cleanCard)) {
    errors.push('Card number must contain only digits');
    return { isValid: false, errors };
  }

  // Check length
  if (cleanCard.length < 13 || cleanCard.length > 19) {
    errors.push('Card number must be between 13 and 19 digits');
    return { isValid: false, errors };
  }

  // Luhn algorithm
  let sum = 0;
  let alternate = false;
  
  for (let i = cleanCard.length - 1; i >= 0; i--) {
    let n = parseInt(cleanCard.charAt(i), 10);
    
    if (alternate) {
      n *= 2;
      if (n > 9) {
        n = (n % 10) + 1;
      }
    }
    
    sum += n;
    alternate = !alternate;
  }

  if (sum % 10 !== 0) {
    errors.push('Invalid card number');
  }

  return {
    isValid: errors.length === 0,
    errors
  };
};

// Enhanced validation schemas
export const validationSchemas = {
  register: {
    firstName: (value: string) => {
      const nameValidation = isValidName(value);
      return {
        isValid: isRequired(value) && nameValidation.isValid,
        error: !isRequired(value) ? 'First name is required' : nameValidation.errors[0] || ''
      };
    },
    lastName: (value: string) => {
      const nameValidation = isValidName(value);
      return {
        isValid: isRequired(value) && nameValidation.isValid,
        error: !isRequired(value) ? 'Last name is required' : nameValidation.errors[0] || ''
      };
    },
    email: (value: string) => ({
      isValid: isRequired(value) && isValidEmail(value),
      error: !isRequired(value) ? 'Email is required' : 
             !isValidEmail(value) ? 'Please enter a valid email address' : ''
    }),
    password: (value: string) => {
      const validation = validatePassword(value);
      return {
        isValid: validation.isValid,
        error: validation.errors[0] || ''
      };
    },
    confirmPassword: (value: string, password: string) => ({
      isValid: isRequired(value) && value === password,
      error: !isRequired(value) ? 'Please confirm your password' : 
             value !== password ? 'Passwords do not match' : ''
    })
  },

  login: {
    email: (value: string) => ({
      isValid: isRequired(value) && isValidEmail(value),
      error: !isRequired(value) ? 'Email is required' : 
             !isValidEmail(value) ? 'Please enter a valid email address' : ''
    }),
    password: (value: string) => ({
      isValid: isRequired(value),
      error: !isRequired(value) ? 'Password is required' : ''
    })
  }
};

// Enhanced generic form validator with better type safety
export const validateForm = <T extends Record<string, unknown>>(
  data: T,
  schema: Record<keyof T, (value: T[keyof T], ...args: unknown[]) => { isValid: boolean; error: string }>
): { isValid: boolean; errors: Record<keyof T, string> } => {
  const errors = {} as Record<keyof T, string>;
  let isValid = true;

  (Object.keys(schema) as Array<keyof T>).forEach(key => {
    try {
      const validation = schema[key](data[key]);
      if (!validation.isValid) {
        errors[key] = validation.error;
        isValid = false;
      }
    } catch (error) {
      console.error(`Validation error for field ${String(key)}:`, error);
      errors[key] = 'Validation error occurred';
      isValid = false;
    }
  });

  return { isValid, errors };
};

// Comprehensive validation utilities object
const validationUtils = {
  isValidEmail,
  validatePassword,
  isValidPhoneNumber,
  isValidName,
  isValidUrl,
  isRequired,
  isValidNumber,
  isValidInteger,
  isValidTime,
  isValidDate,
  isFutureDate,
  isPastDate,
  validateFile,
  formatFileSize,
  sanitizeInput,
  isValidCreditCard,
  validationSchemas,
  validateForm
};

export default validationUtils;
```

<!-- path: utils/formatters.ts -->
```typescript
/**
 * Professional data formatting utility library
 * Provides comprehensive formatting functions with optimizations and error handling
 */

// Types and interfaces
export interface NumberFormatOptions extends Intl.NumberFormatOptions {
  locale?: string;
}

export interface PhoneFormatOptions {
  format?: 'US' | 'international' | 'E164';
}

export interface ListFormatOptions {
  conjunction?: 'and' | 'or';
  style?: 'long' | 'short' | 'narrow';
  type?: 'conjunction' | 'disjunction' | 'unit';
}

export interface StringCaseOptions {
  preserveAcronyms?: boolean;
  delimiter?: string;
}

export interface ValidationError {
  field: string;
  message: string;
  code?: string;
}

// Performance optimizations - cached formatters
const formattersCache = new Map<string, Intl.NumberFormat | Intl.DateTimeFormat | Intl.ListFormat>();

// Overloaded function signatures for type safety
function getCachedFormatter(
  type: 'number',
  locale: string,
  options: Intl.NumberFormatOptions
): Intl.NumberFormat;
function getCachedFormatter(
  type: 'date',
  locale: string,
  options: Intl.DateTimeFormatOptions
): Intl.DateTimeFormat;
function getCachedFormatter(
  type: 'list',
  locale: string,
  options: Intl.ListFormatOptions
): Intl.ListFormat;
function getCachedFormatter(
  type: 'number' | 'date' | 'list',
  locale: string,
  options: Intl.NumberFormatOptions | Intl.DateTimeFormatOptions | Intl.ListFormatOptions
): Intl.NumberFormat | Intl.DateTimeFormat | Intl.ListFormat {
  const key = `${type}-${locale}-${JSON.stringify(options)}`;
  
  if (!formattersCache.has(key)) {
    let formatter: Intl.NumberFormat | Intl.DateTimeFormat | Intl.ListFormat;
    switch (type) {
      case 'number':
        formatter = new Intl.NumberFormat(locale, options as Intl.NumberFormatOptions);
        break;
      case 'date':
        formatter = new Intl.DateTimeFormat(locale, options as Intl.DateTimeFormatOptions);
        break;
      case 'list':
        formatter = new Intl.ListFormat(locale, options as Intl.ListFormatOptions);
        break;
      default:
        throw new Error(`Unsupported formatter type: ${type}`);
    }
    formattersCache.set(key, formatter);
  }
  
  return formattersCache.get(key)!;
}

// =============================================================================
// NUMBER FORMATTERS
// =============================================================================

/**
 * Format a number with locale-aware formatting
 */
export const formatNumber = (
  num: number,
  options: NumberFormatOptions = {}
): string => {
  if (!Number.isFinite(num)) {
    return num.toString();
  }

  const { locale = 'en-US', ...intlOptions } = options;
  const formatter = getCachedFormatter('number', locale, intlOptions);
  
  return formatter.format(num);
};

/**
 * Format a number as currency
 */
export const formatCurrency = (
  amount: number,
  currency: string = 'USD',
  locale: string = 'en-US',
  options: Intl.NumberFormatOptions = {}
): string => {
  return formatNumber(amount, {
    locale,
    style: 'currency',
    currency,
    ...options
  });
};

/**
 * Format a number as percentage
 */
export const formatPercentage = (
  value: number,
  decimals: number = 1,
  locale: string = 'en-US'
): string => {
  return formatNumber(value / 100, {
    locale,
    style: 'percent',
    minimumFractionDigits: decimals,
    maximumFractionDigits: decimals
  });
};

/**
 * Format a score with optional fraction display
 */
export const formatScore = (
  score: number,
  total: number,
  options: {
    showFraction?: boolean;
    decimals?: number;
    locale?: string;
  } = {}
): string => {
  const { showFraction = true, decimals = 1, locale = 'en-US' } = options;
  
  if (total <= 0) {
    return showFraction ? `${score}/0 (0%)` : '0%';
  }

  const percentage = (score / total) * 100;
  const formattedPercentage = formatPercentage(percentage, decimals, locale);
  
  return showFraction 
    ? `${formatNumber(score, { locale })}/${formatNumber(total, { locale })} (${formattedPercentage})`
    : formattedPercentage;
};

/**
 * Format file size in human-readable format
 */
export const formatFileSize = (
  bytes: number,
  options: {
    binary?: boolean;
    decimals?: number;
    locale?: string;
  } = {}
): string => {
  const { binary = false, decimals = 2, locale = 'en-US' } = options;
  
  if (bytes === 0) return '0 B';
  if (!Number.isFinite(bytes) || bytes < 0) return 'Invalid size';

  const base = binary ? 1024 : 1000;
  const sizes = binary 
    ? ['B', 'KiB', 'MiB', 'GiB', 'TiB', 'PiB'] 
    : ['B', 'KB', 'MB', 'GB', 'TB', 'PB'];
  
  const i = Math.floor(Math.log(bytes) / Math.log(base));
  const size = bytes / Math.pow(base, i);
  
  return `${formatNumber(size, { 
    locale,
    minimumFractionDigits: i === 0 ? 0 : decimals,
    maximumFractionDigits: i === 0 ? 0 : decimals
  })} ${sizes[i]}`;
};

// =============================================================================
// STRING FORMATTERS
// =============================================================================

/**
 * Convert string to title case with smart handling
 */
export const toTitleCase = (
  str: string,
  options: StringCaseOptions = {}
): string => {
  if (!str) return '';
  
  const { preserveAcronyms = true } = options;
  
  // Common words that should remain lowercase in titles
  const articles = new Set(['a', 'an', 'and', 'as', 'at', 'but', 'by', 'for', 'if', 'in', 'nor', 'of', 'on', 'or', 'so', 'the', 'to', 'up', 'yet']);
  
  return str
    .toLowerCase()
    .split(/\s+/)
    .map((word, index) => {
      // Always capitalize first and last word
      if (index === 0 || !articles.has(word)) {
        // Preserve acronyms if option is set
        if (preserveAcronyms && word.toUpperCase() === word && word.length <= 4) {
          return word.toUpperCase();
        }
        return word.charAt(0).toUpperCase() + word.slice(1);
      }
      return word;
    })
    .join(' ');
};

/**
 * Convert snake_case to Title Case
 */
export const snakeToTitleCase = (str: string): string => {
  if (!str) return '';
  
  return str
    .split('_')
    .map(word => word.charAt(0).toUpperCase() + word.slice(1).toLowerCase())
    .join(' ');
};

/**
 * Convert camelCase to kebab-case
 */
export const camelToKebab = (str: string): string => {
  if (!str) return '';
  
  return str
    .replace(/([a-z0-9]|(?=[A-Z]))([A-Z])/g, '$1-$2')
    .toLowerCase();
};

/**
 * Convert kebab-case to camelCase
 */
export const kebabToCamel = (str: string): string => {
  if (!str) return '';
  
  return str.replace(/-([a-z])/g, (_, letter) => letter.toUpperCase());
};

/**
 * Convert snake_case to camelCase
 */
export const snakeToCamel = (str: string): string => {
  if (!str) return '';
  
  return str.replace(/_([a-z])/g, (_, letter) => letter.toUpperCase());
};

/**
 * Convert camelCase to snake_case
 */
export const camelToSnake = (str: string): string => {
  if (!str) return '';
  
  return str.replace(/([A-Z])/g, '_$1').toLowerCase();
};

/**
 * Create URL-friendly slug from text
 */
export const createSlug = (
  text: string,
  options: {
    maxLength?: number;
    separator?: string;
    lowercase?: boolean;
  } = {}
): string => {
  const { maxLength = 50, separator = '-', lowercase = true } = options;
  
  if (!text) return '';
  
  let slug = text
    .trim()
    .replace(/[^\w\s-]/g, '') // Remove special characters
    .replace(/\s+/g, separator) // Replace spaces with separator
    .replace(new RegExp(`${separator}+`, 'g'), separator) // Replace multiple separators
    .replace(new RegExp(`^${separator}|${separator}$`, 'g'), ''); // Remove leading/trailing separators
  
  if (lowercase) {
    slug = slug.toLowerCase();
  }
  
  if (maxLength && slug.length > maxLength) {
    slug = slug.substring(0, maxLength).replace(new RegExp(`${separator}$`), '');
  }
  
  return slug;
};

/**
 * Truncate text with smart word boundaries
 */
export const truncateText = (
  text: string,
  maxLength: number,
  options: {
    suffix?: string;
    preserveWords?: boolean;
  } = {}
): string => {
  const { suffix = '...', preserveWords = true } = options;
  
  if (!text || text.length <= maxLength) return text;
  
  if (!preserveWords) {
    return text.substring(0, maxLength - suffix.length) + suffix;
  }
  
  const words = text.split(' ');
  let truncated = '';
  
  for (const word of words) {
    const nextText = truncated ? `${truncated} ${word}` : word;
    if (nextText.length > maxLength - suffix.length) {
      break;
    }
    truncated = nextText;
  }
  
  return truncated ? truncated + suffix : text.substring(0, maxLength - suffix.length) + suffix;
};

// =============================================================================
// CONTACT INFORMATION FORMATTERS
// =============================================================================

/**
 * Format user name with various display options
 */
export const formatUserName = (
  firstName: string,
  lastName: string,
  format: 'full' | 'lastFirst' | 'initials' | 'firstInitial' = 'full'
): string => {
  const first = firstName?.trim() || '';
  const last = lastName?.trim() || '';
  
  if (!first && !last) return '';
  
  switch (format) {
    case 'full':
      return `${first} ${last}`.trim();
    case 'lastFirst':
      return last ? `${last}, ${first}`.trim() : first;
    case 'initials':
      return `${first.charAt(0)}${last.charAt(0)}`.toUpperCase();
    case 'firstInitial':
      return `${first.charAt(0).toUpperCase()}. ${last}`.trim();
    default:
      return `${first} ${last}`.trim();
  }
};

/**
 * Format phone number with international support
 */
export const formatPhoneNumber = (
  phone: string,
  options: PhoneFormatOptions = {}
): string => {
  const { format = 'US' } = options;
  
  if (!phone) return '';
  
  const cleaned = phone.replace(/\D/g, '');
  
  switch (format) {
    case 'US':
      if (cleaned.length === 10) {
        return `(${cleaned.slice(0, 3)}) ${cleaned.slice(3, 6)}-${cleaned.slice(6)}`;
      }
      if (cleaned.length === 11 && cleaned.startsWith('1')) {
        return `+1 (${cleaned.slice(1, 4)}) ${cleaned.slice(4, 7)}-${cleaned.slice(7)}`;
      }
      break;
      
    case 'E164':
      if (cleaned.length === 10) {
        return `+1${cleaned}`;
      }
      if (cleaned.length === 11 && cleaned.startsWith('1')) {
        return `+${cleaned}`;
      }
      break;
      
    case 'international':
      // Basic international formatting - could be expanded
      if (cleaned.length >= 10) {
        return `+${cleaned}`;
      }
      break;
  }
  
  return phone; // Return original if can't format
};

/**
 * Format email address (basic validation and normalization)
 */
export const formatEmail = (email: string): string => {
  if (!email) return '';
  
  return email.trim().toLowerCase();
};

// =============================================================================
// DATE AND TIME FORMATTERS
// =============================================================================

/**
 * Format date with locale support
 */
type FormatDateOptions = Intl.DateTimeFormatOptions & {
  locale?: string;
  format?: 'short' | 'medium' | 'long' | 'full' | 'ddmmyyyy' | 'yyyy-mm-dd' | 'dd/mm/yyyy' | 'mm/dd/yyyy' | 'dd MMM yyyy' | 'dd-mm-yyyy';
};

const DATE_FORMATS: Record<
  'short' | 'medium' | 'long' | 'full',
  Intl.DateTimeFormatOptions
> = {
  short: { year: '2-digit', month: 'numeric', day: 'numeric' },
  medium: { year: 'numeric', month: 'short', day: 'numeric' },
  long: { year: 'numeric', month: 'long', day: 'numeric' },
  full: {
    weekday: 'long',
    year: 'numeric',
    month: 'long',
    day: 'numeric',
  },
};

export const formatDate = (
  date: Date | string | number,
  options: FormatDateOptions = {}
): string => {
  const {
    locale = 'en-US',
    format,
    ...intlOptions
  } = options;

  try {
    // Pre-validate string inputs before creating Date object
    if (typeof date === 'string') {
      const trimmed = date.trim();
      if (trimmed === '' || trimmed === 'null' || trimmed === 'undefined') {
        return 'No Date';
      }
    }

    const dateObj = new Date(date);
    
    // Check for invalid dates (NaN) or suspicious Unix epoch dates
    if (isNaN(dateObj.getTime()) || isSuspiciousUnixEpoch(date, dateObj)) {
      return 'No Date';
    }

    // Handle custom string formats
    if (typeof format === 'string') {
      const day = dateObj.getDate().toString().padStart(2, '0');
      const month = (dateObj.getMonth() + 1).toString().padStart(2, '0');
      const year = dateObj.getFullYear().toString();
      const monthNames = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
      const monthName = monthNames[dateObj.getMonth()];

      switch (format) {
        case 'ddmmyyyy':
          return `${day}${month}${year}`;
        case 'yyyy-mm-dd':
          return `${year}-${month}-${day}`;
        case 'dd-mm-yyyy':
          return `${day}-${month}-${year}`;
        case 'dd/mm/yyyy':
          return `${day}/${month}/${year}`;
        case 'mm/dd/yyyy':
          return `${month}/${day}/${year}`;
        case 'dd MMM yyyy':
          return `${day} ${monthName} ${year}`;
        // Fall through to Intl formats below
      }
    }

    // Use Intl for short/medium/long/full/custom Intl options
    const mergedOptions = {
      ...(format && DATE_FORMATS[format as keyof typeof DATE_FORMATS]),
      ...intlOptions,
    };

    const formatter = getCachedFormatter('date', locale, mergedOptions);
    return formatter.format(dateObj);
  } catch {
    return 'No Date';
  }
};

/**
 * Detects if we got Unix epoch from invalid input that was coerced
 * This is very aggressive - assumes most Unix epoch dates are from invalid coercion
 */
function isSuspiciousUnixEpoch(originalInput: Date | string | number, dateObj: Date): boolean {
  const time = dateObj.getTime();
  const isUnixEpoch = time === 0; // January 1, 1970 00:00:00 UTC
  
  if (!isUnixEpoch) return false;
  
  // If input is a Date object that's already Unix epoch, it might be valid
  if (originalInput instanceof Date) {
    return false;
  }
  
  // If input is exactly the number 0, it's intentional
  if (originalInput === 0) {
    return false;
  }
  
  // For any other number, if it results in Unix epoch, it's suspicious
  if (typeof originalInput === 'number') {
    return true;
  }
  
  // For strings - be VERY strict. Most Unix epoch results from strings are invalid
  if (typeof originalInput === 'string') {
    const trimmed = originalInput.trim();
    
    // Only these exact strings are considered valid Unix epoch
    const validUnixEpochStrings = [
      '0',
      '1970-01-01',
      '01/01/1970',
      '1/1/1970', 
      '01-01-1970',
      '1970-01-01T00:00:00.000Z',
      '1970-01-01T00:00:00Z'
    ];
    
    // Exact match only - no partial matches
    const isExactMatch = validUnixEpochStrings.includes(trimmed) || 
                        validUnixEpochStrings.includes(trimmed.toLowerCase());
    
    // If it's not an exact match but resulted in Unix epoch, it's from invalid input
    return !isExactMatch;
  }
  
  // Default to suspicious for any other type
  return true;
}


/**
 * Format time range
 */
export const formatTimeRange = (
  startTime: Date | string,
  endTime: Date | string,
  options: Intl.DateTimeFormatOptions & { locale?: string } = {}
): string => {
  const { locale = 'en-US', ...intlOptions } = options;
  
  const formatOptions = {
    hour: 'numeric' as const,
    minute: '2-digit' as const,
    ...intlOptions
  };
  
  const start = formatDate(startTime, { locale, ...formatOptions });
  const end = formatDate(endTime, { locale, ...formatOptions });
  
  return `${start} - ${end}`;
};

/**
 * Format relative time (e.g., "2 hours ago")
 */
export const formatRelativeTime = (
  date: Date | string | number,
  locale: string = 'en-US'
): string => {
  try {
    const dateObj = new Date(date);
    const now = new Date();
    const diffMs = now.getTime() - dateObj.getTime();
    const diffSec = Math.floor(diffMs / 1000);
    const diffMin = Math.floor(diffSec / 60);
    const diffHour = Math.floor(diffMin / 60);
    const diffDay = Math.floor(diffHour / 24);
    
    if (diffSec < 60) return 'just now';
    if (diffMin < 60) return `${diffMin} minute${diffMin !== 1 ? 's' : ''} ago`;
    if (diffHour < 24) return `${diffHour} hour${diffHour !== 1 ? 's' : ''} ago`;
    if (diffDay < 30) return `${diffDay} day${diffDay !== 1 ? 's' : ''} ago`;
    
    // For older dates, return formatted date
    return formatDate(dateObj, { locale, dateStyle: 'medium' });
  } catch {
    return 'No Date';
  }
};

// =============================================================================
// LIST AND ARRAY FORMATTERS
// =============================================================================

/**
 * Format array as a grammatically correct list
 */
export const formatList = (
  items: (string | number)[],
  options: ListFormatOptions & { locale?: string } = {}
): string => {
  const { locale = 'en-US', conjunction = 'and', ...intlOptions } = options;
  
  if (!Array.isArray(items) || items.length === 0) return '';
  
  const stringItems = items.map(String).filter(Boolean);
  
  if (stringItems.length === 0) return '';
  if (stringItems.length === 1) return stringItems[0];
  
  try {
    const listFormatOptions: Intl.ListFormatOptions = {
      style: 'long',
      type: conjunction === 'or' ? 'disjunction' : 'conjunction',
      ...intlOptions
    };
    
    const formatter = getCachedFormatter('list', locale, listFormatOptions);
    
    return formatter.format(stringItems);
  } catch {
    // Fallback for older browsers
    if (stringItems.length === 2) {
      return `${stringItems[0]} ${conjunction} ${stringItems[1]}`;
    }
    
    const lastItem = stringItems[stringItems.length - 1];
    const otherItems = stringItems.slice(0, -1);
    return `${otherItems.join(', ')}, ${conjunction} ${lastItem}`;
  }
};

/**
 * Format array with truncation support
 */
export const formatArrayWithLimit = (
  items: (string | number)[],
  options: {
    maxItems?: number;
    moreText?: string;
    conjunction?: 'and' | 'or';
    locale?: string;
  } = {}
): string => {
  const { maxItems = 5, moreText = 'more', conjunction = 'and', locale = 'en-US' } = options;
  
  if (!Array.isArray(items) || items.length === 0) return '';
  
  const stringItems = items.map(String).filter(Boolean);
  
  if (stringItems.length <= maxItems) {
    return formatList(stringItems, { conjunction, locale });
  }
  
  const visibleItems = stringItems.slice(0, maxItems);
  const remainingCount = stringItems.length - maxItems;
  
  return `${formatList(visibleItems, { conjunction, locale })} and ${remainingCount} ${moreText}`;
};

// =============================================================================
// ERROR AND VALIDATION FORMATTERS
// =============================================================================

/**
 * Format error messages consistently
 */
export const formatErrorMessage = (error: unknown): string => {
  if (typeof error === 'string') return error;
  if (error instanceof Error) return error.message;
  if (error && typeof error === 'object') {
    if ('message' in error && typeof error.message === 'string') {
      return error.message;
    }
    if ('error' in error && typeof error.error === 'string') {
      return error.error;
    }
  }
  return 'An unexpected error occurred';
};

/**
 * Format validation errors with field names
 */
export const formatValidationErrors = (
  errors: ValidationError[] | Record<string, string>
): string[] => {
  if (Array.isArray(errors)) {
    return errors
      .filter(error => error.message?.trim())
      .map(error => `${toTitleCase(error.field.replace(/([A-Z])/g, ' $1'))}: ${error.message}`);
  }
  
  return Object.entries(errors)
    .filter(([, message]) => message?.trim())
    .map(([field, message]) => `${toTitleCase(field.replace(/([A-Z])/g, ' $1'))}: ${message}`);
};

// =============================================================================
// SEARCH AND UTILITY FORMATTERS
// =============================================================================

/**
 * Normalize search query
 */
export const normalizeSearchQuery = (query: string): string => {
  if (!query) return '';
  
  return query
    .trim()
    .replace(/\s+/g, ' ') // Replace multiple spaces with single space
    .toLowerCase();
};

/**
 * Highlight search terms in text
 */
export const highlightSearchTerms = (
  text: string,
  searchTerms: string | string[],
  options: {
    className?: string;
    caseSensitive?: boolean;
    wholeWords?: boolean;
  } = {}
): string => {
  const { className = 'highlight', caseSensitive = false, wholeWords = false } = options;
  
  if (!text || !searchTerms) return text;
  
  const terms = Array.isArray(searchTerms) ? searchTerms : [searchTerms];
  const flags = caseSensitive ? 'g' : 'gi';
  
  let result = text;
  
  terms.forEach(term => {
    if (!term.trim()) return;
    
    const escapedTerm = term.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
    const pattern = wholeWords ? `\\b${escapedTerm}\\b` : escapedTerm;
    const regex = new RegExp(pattern, flags);
    
    result = result.replace(regex, `<span class="${className}">$&</span>`);
  });
  
  return result;
};

// =============================================================================
// EXPORTS
// =============================================================================

const formatters = {
  // Numbers
  formatNumber,
  formatCurrency,
  formatPercentage,
  formatScore,
  formatFileSize,
  
  // Strings
  toTitleCase,
  snakeToTitleCase,
  camelToKebab,
  kebabToCamel,
  snakeToCamel,
  camelToSnake,
  createSlug,
  truncateText,
  
  // Contact
  formatUserName,
  formatPhoneNumber,
  formatEmail,
  
  // Dates
  formatDate,
  formatTimeRange,
  formatRelativeTime,
  
  // Lists
  formatList,
  formatArrayWithLimit,
  
  // Errors
  formatErrorMessage,
  formatValidationErrors,
  
  // Search
  normalizeSearchQuery,
  highlightSearchTerms,
};

export default formatters;
```

<!-- path: utils/imageOptimization.ts -->
```typescript
// utils/imageOptimization.ts
"use client";

import Uppy from "@uppy/core";
import ImageEditor from "@uppy/image-editor";
import { useRef, useEffect } from "react";

// Types for better type safety
interface CompressionOptions {
  maxWidth?: number;
  maxHeight?: number;
  quality?: number;
}

interface OptimizedUppyOptions {
  folderId: string | null;
  maxFileSize?: number;
  maxNumberOfFiles?: number;
}

// 1. Improved ImageEditor configuration with better compression
export const enhancedImageEditorConfig = {
  quality: 0.85,
  cropperOptions: {
    viewMode: 1 as 0 | 1 | 2 | 3,
    background: false,
    autoCropArea: 1,
    responsive: true,
    checkOrientation: false,
    guides: true,
    highlight: false,
    dragMode: "crop" as const,
  },
  actions: {
    revert: true,
    rotate: true,
    granularRotate: true,
    flip: true,
    zoomIn: true,
    zoomOut: true,
    cropSquare: true,
    cropWidescreen: true,
    cropWidescreenVertical: true,
  },
};

// 2. Enhanced image compression utility function
export const compressImage = (
  file: File,
  options: CompressionOptions = {},
): Promise<File> => {
  const { maxWidth = 1920, maxHeight = 1080, quality = 0.8 } = options;

  return new Promise((resolve) => {
    // Check if it's actually an image
    if (!file.type.startsWith("image/")) {
      resolve(file);
      return;
    }

    const canvas = document.createElement("canvas");
    const ctx = canvas.getContext("2d");

    if (!ctx) {
      console.warn("Could not get canvas context");
      resolve(file);
      return;
    }

    const img = new Image();

    img.onload = () => {
      try {
        // Calculate new dimensions while maintaining aspect ratio
        let { width, height } = img;

        if (width > maxWidth || height > maxHeight) {
          const aspectRatio = width / height;

          if (width > height) {
            width = Math.min(width, maxWidth);
            height = width / aspectRatio;
          } else {
            height = Math.min(height, maxHeight);
            width = height * aspectRatio;
          }
        }

        canvas.width = width;
        canvas.height = height;

        // Clear canvas and draw image
        ctx.clearRect(0, 0, width, height);
        ctx.drawImage(img, 0, 0, width, height);

        canvas.toBlob(
          (blob) => {
            if (blob && blob.size > 0) {
              try {
                const compressedFile = new File([blob], file.name, {
                  type: file.type,
                  lastModified: Date.now(),
                });
                resolve(compressedFile);
              } catch (error) {
                console.warn("Error creating compressed file:", error);
                resolve(file);
              }
            } else {
              console.warn("Canvas toBlob produced empty result");
              resolve(file);
            }
          },
          file.type,
          quality,
        );
      } catch (error) {
        console.warn("Error compressing image:", error);
        resolve(file);
      }
    };

    img.onerror = () => {
      console.warn("Error loading image for compression");
      resolve(file);
    };

    img.src = URL.createObjectURL(file);
  });
};

// 3. Enhanced Uppy configuration with compression
export const createOptimizedUppy = (options: OptimizedUppyOptions) => {
  const {
    folderId,
    maxFileSize = 50 * 1024 * 1024, // 50MB
    maxNumberOfFiles = 20,
  } = options;

  const uppy = new Uppy({
    id: "file-uploader",
    autoProceed: false,
    allowMultipleUploads: true,
    restrictions: {
      maxFileSize,
      maxNumberOfFiles,
      allowedFileTypes: [
        "image/*",
        "application/pdf",
        ".doc",
        ".docx",
        ".txt",
        ".rtf",
        "video/*",
        "audio/*",
      ],
    },
    meta: {
      folderId: folderId,
    },
    onBeforeFileAdded: (currentFile, files) => {
      // Additional validation
      if (currentFile.size === 0) {
        uppy.log(`Skipping file ${currentFile.name} - file is empty`);
        return false;
      }

      // Check for duplicate files
      const existingFile = Object.values(files).find(
        (file) =>
          file.name === currentFile.name && file.size === currentFile.size,
      );

      if (existingFile) {
        uppy.log(`Skipping file ${currentFile.name} - duplicate file`);
        return false;
      }

      return true;
    },
  });

  // Add ImageEditor plugin with error handling
  try {
    uppy.use(ImageEditor, enhancedImageEditorConfig);
  } catch (error) {
    console.warn("Failed to add ImageEditor plugin:", error);
  }

  return uppy;
};

// 4. WebP conversion utility (for modern browsers)
export const convertToWebP = (file: File, quality = 0.8): Promise<File> => {
  return new Promise((resolve) => {
    if (!file.type.startsWith("image/") || file.type === "image/webp") {
      resolve(file);
      return;
    }

    // Check if browser supports WebP
    const canvas = document.createElement("canvas");
    const testBlob = canvas.toDataURL("image/webp");

    if (!testBlob.startsWith("data:image/webp")) {
      resolve(file);
      return;
    }

    const ctx = canvas.getContext("2d");
    if (!ctx) {
      resolve(file);
      return;
    }

    const img = new Image();

    img.onload = () => {
      try {
        canvas.width = img.width;
        canvas.height = img.height;
        ctx.drawImage(img, 0, 0);

        canvas.toBlob(
          (blob) => {
            if (blob && blob.size > 0 && blob.size < file.size) {
              const webpFile = new File(
                [blob],
                file.name.replace(/\.[^/.]+$/, ".webp"),
                {
                  type: "image/webp",
                  lastModified: Date.now(),
                },
              );
              resolve(webpFile);
            } else {
              resolve(file);
            }
          },
          "image/webp",
          quality,
        );
      } catch (error) {
        console.warn("Error converting to WebP:", error);
        resolve(file);
      }
    };

    img.onerror = () => resolve(file);
    img.src = URL.createObjectURL(file);
  });
};

// 5. Progressive JPEG utility
export const createProgressiveJPEG = (file: File): Promise<File> => {
  return new Promise((resolve) => {
    if (file.type !== "image/jpeg") {
      resolve(file);
      return;
    }

    const canvas = document.createElement("canvas");
    const ctx = canvas.getContext("2d");

    if (!ctx) {
      resolve(file);
      return;
    }

    const img = new Image();

    img.onload = () => {
      try {
        canvas.width = img.width;
        canvas.height = img.height;
        ctx.drawImage(img, 0, 0);

        canvas.toBlob(
          (blob) => {
            if (blob && blob.size > 0) {
              const progressiveFile = new File([blob], file.name, {
                type: "image/jpeg",
                lastModified: Date.now(),
              });
              resolve(progressiveFile);
            } else {
              resolve(file);
            }
          },
          "image/jpeg",
          0.85,
        );
      } catch (error) {
        console.warn("Error creating progressive JPEG:", error);
        resolve(file);
      }
    };

    img.onerror = () => resolve(file);
    img.src = URL.createObjectURL(file);
  });
};

// 6. FIXED Smart compression based on image content
export const smartCompress = async (file: File): Promise<File> => {
  if (!file.type.startsWith("image/")) {
    return file;
  }

  return new Promise((resolve) => {
    const img = new Image();
    const canvas = document.createElement("canvas");
    const ctx = canvas.getContext("2d");

    if (!ctx) {
      console.warn("Could not get canvas context for smart compression");
      resolve(file);
      return;
    }

    img.onload = () => {
      try {
        // Get optimal settings based on file size
        const { quality, maxWidth, maxHeight } = getOptimalImageSettings(file);

        // Calculate new dimensions while maintaining aspect ratio
        let { width, height } = img;

        if (width > maxWidth || height > maxHeight) {
          const aspectRatio = width / height;

          if (width > height) {
            width = Math.min(width, maxWidth);
            height = width / aspectRatio;
          } else {
            height = Math.min(height, maxHeight);
            width = height * aspectRatio;
          }
        }

        canvas.width = width;
        canvas.height = height;

        // Clear canvas and draw image
        ctx.clearRect(0, 0, width, height);
        ctx.drawImage(img, 0, 0, width, height);

        canvas.toBlob(
          (blob) => {
            if (blob && blob.size > 0) {
              try {
                const optimizedFile = new File([blob], file.name, {
                  type: file.type,
                  lastModified: Date.now(),
                });

                console.log(`Smart compression result: ${file.name}`, {
                  original: (file.size / 1024 / 1024).toFixed(2) + "MB",
                  compressed:
                    (optimizedFile.size / 1024 / 1024).toFixed(2) + "MB",
                  reduction:
                    (
                      ((file.size - optimizedFile.size) / file.size) *
                      100
                    ).toFixed(1) + "%",
                });

                resolve(optimizedFile);
              } catch (error) {
                console.warn("Error creating optimized file:", error);
                resolve(file);
              }
            } else {
              console.warn(
                "Smart compression produced empty result, using original file",
              );
              resolve(file);
            }
          },
          file.type,
          quality,
        );
      } catch (error) {
        console.warn("Error in smart compression:", error);
        resolve(file);
      }
    };

    img.onerror = (error) => {
      console.warn("Error loading image for smart compression:", error);
      resolve(file);
    };

    img.src = URL.createObjectURL(file);
  });
};

// 7. Custom hook for optimized file uploader
export const useOptimizedFileUploader = (
  folderId: string | null,
): Uppy<{ folderId: string | null }, Record<string, never>> | null => {
  const uppyRef = useRef<Uppy<
    { folderId: string | null },
    Record<string, never>
  > | null>(null);

  useEffect(() => {
    // Clean up previous instance
    if (uppyRef.current) {
      uppyRef.current.destroy();
    }

    const uppy = createOptimizedUppy({ folderId });

    // Add comprehensive image optimization preprocessor
    uppy.addPreProcessor(async (fileIDs) => {
      const optimizationPromises = fileIDs.map(async (fileID) => {
        const file = uppy.getFile(fileID);

        if (file && file.type && file.type.startsWith("image/")) {
          try {
            let optimizedFile = file.data as File;

            // Validate original file
            if (optimizedFile.size === 0) {
              console.warn(
                `Skipping optimization for ${file.name} - empty file`,
              );
              return;
            }

            // Apply smart compression with fallback
            try {
              const compressedFile = await smartCompress(optimizedFile);
              if (
                compressedFile.size > 0 &&
                compressedFile.size < optimizedFile.size
              ) {
                optimizedFile = compressedFile;
              }
            } catch (compressionError) {
              console.warn(
                `Compression failed for ${file.name}:`,
                compressionError,
              );
            }

            // Convert to WebP if beneficial (with validation)
            try {
              const webpFile = await convertToWebP(optimizedFile);
              if (webpFile.size > 0 && webpFile.size < optimizedFile.size) {
                optimizedFile = webpFile;
              }
            } catch (webpError) {
              console.warn(
                `WebP conversion failed for ${file.name}:`,
                webpError,
              );
            }

            // For JPEGs, make them progressive (with validation)
            try {
              if (optimizedFile.type === "image/jpeg") {
                const progressiveFile =
                  await createProgressiveJPEG(optimizedFile);
                if (progressiveFile.size > 0) {
                  optimizedFile = progressiveFile;
                }
              }
            } catch (progressiveError) {
              console.warn(
                `Progressive JPEG creation failed for ${file.name}:`,
                progressiveError,
              );
            }

            // Final validation before updating Uppy
            if (optimizedFile.size === 0) {
              console.error(
                `Optimization resulted in empty file for ${file.name}, using original`,
              );
              return; // Don't update Uppy, keep original
            }

            // Update the file in Uppy
            uppy.setFileState(fileID, {
              data: optimizedFile,
              size: optimizedFile.size,
            });

            const originalSizeMB = ((file.size ?? 0) / 1024 / 1024).toFixed(2);
            const optimizedSizeMB = (optimizedFile.size / 1024 / 1024).toFixed(
              2,
            );
            const compressionRatio = (
              (((file.size ?? 0) - optimizedFile.size) / (file.size ?? 1)) *
              100
            ).toFixed(1);

            console.log(
              `Optimized ${file.name}: ${originalSizeMB}MB → ${optimizedSizeMB}MB (${compressionRatio}% reduction)`,
            );
          } catch (error) {
            console.warn(`Failed to optimize ${file.name}:`, error);
            // Keep original file in case of any error
          }
        }
      });

      await Promise.all(optimizationPromises);
    });

    uppyRef.current = uppy;

    return () => {
      if (uppyRef.current) {
        uppyRef.current.destroy();
        uppyRef.current = null;
      }
    };
  }, [folderId]);

  return uppyRef.current;
};

// 8. Utility function to get optimal image settings
export const getOptimalImageSettings = (file: File) => {
  const sizeInMB = file.size / (1024 * 1024);

  if (sizeInMB > 10) {
    return { quality: 0.6, maxWidth: 1600, maxHeight: 1200 };
  } else if (sizeInMB > 5) {
    return { quality: 0.7, maxWidth: 1800, maxHeight: 1350 };
  } else if (sizeInMB > 2) {
    return { quality: 0.75, maxWidth: 1920, maxHeight: 1440 };
  } else {
    return { quality: 0.85, maxWidth: 1920, maxHeight: 1440 };
  }
};

// 9. Batch optimization function
export const optimizeFilesBatch = async (files: File[]): Promise<File[]> => {
  const optimizationPromises = files.map(async (file) => {
    console.log(
      "Original file:",
      file.name,
      "Size:",
      file.size,
      "Type:",
      file.type,
    );

    if (file.type.startsWith("image/") && file.size > 0) {
      try {
        const optimized = await smartCompress(file);
        return optimized.size > 0 ? optimized : file; // Fallback to original if compression fails
      } catch (error) {
        console.warn(`Batch optimization failed for ${file.name}:`, error);
        return file; // Return original on error
      }
    }

    return file;
  });

  return Promise.all(optimizationPromises);
};

```

<!-- path: utils/zod-validation.config.ts -->
```typescript
// Configuration for smart Zod validation rules
export interface ValidationConfig {
  stringRules: StringValidationRule[];
  numberRules: NumberValidationRule[];
  customRules: CustomValidationRule[];
}

export interface StringValidationRule {
  fieldPatterns: string[]; // Field names that match this rule (supports regex)
  validation: string; // Zod validation string
  description?: string;
}

export interface NumberValidationRule {
  fieldPatterns: string[];
  validation: string;
  description?: string;
}

export interface CustomValidationRule {
  fieldName: string; // Exact field name
  tableName?: string; // Supports partial matching (e.g., "user" matches "user_profiles")
  validation: string;
  description?: string;
}

export const defaultValidationConfig: ValidationConfig = {
  stringRules: [
    {
      fieldPatterns: ["email"],
      validation: "z.email()",
      description: "Email format validation",
    },
    {
      fieldPatterns: ["encrypted_password"],
      validation: 'z.string().min(1, "Password cannot be empty")',
      description: "Passwords just need presence check",
    },
    {
      fieldPatterns: ["password", "pwd"],
      validation: `z.string()
        .min(6, "Password must be at least 6 characters long")
        .max(50, "Password must not exceed 50 characters")
        .regex(
          /^(?=.*[a-z])(?=.*[A-Z])(?=.*\\d)(?=.*[@$!%*?&])[A-Za-z\\d@$!%*?&]/,
          "Password must contain at least one uppercase letter, one lowercase letter, one number and one special character"
        )`,
      description: "Basic password strength",
    },
    {
      fieldPatterns: ["^id$", ".*_id$", ".*uuid.*"],
      validation: "z.uuid()",
      description: "UUID format validation",
    },
    {
      fieldPatterns: ["url", "website", "link"],
      validation: "z.url()",
      description: "URL format validation",
    },
    {
      fieldPatterns: ["phone", "mobile", "tel"],
      validation: 'z.string().regex(/^[+]?[1-9]?[0-9]{7,15}$/, "Invalid phone number")',
      description: "International phone number format",
    },
    {
      fieldPatterns: ['date_of_birth', '.*dob.*', '.*doj.*', 'commissioned_on', "sn_dom", "en_dom"],
      validation: 'z.iso.date()',
      description: 'ISO date string validation (e.g., YYYY-MM-DD)',
    },
    {
      fieldPatterns: [".*_at$", ".*date.*", ".*time.*"],
      validation: "z.iso.datetime()",
      description: "ISO datetime string validation",
    },
    {
      fieldPatterns: ["token", "jwt"],
      validation: "z.jwt()",
      description: "Token presence validation",
    },
    {
      fieldPatterns: ["slug"],
      validation: 'z.string().regex(/^[a-z0-9]+(?:-[a-z0-9]+)*$/, "Invalid slug format")',
      description: "URL-friendly slug format",
    },
    {
      fieldPatterns: ["username", "user_name"],
      validation: 'z.string().min(3).max(50).regex(/^[a-zA-Z0-9_]+$/, "Username can only contain letters, numbers and underscores")',
      description: "Username format validation",
    },
    {
      fieldPatterns: [".*name$", "title"],
      validation: 'z.string().min(1, "Name cannot be empty").max(255, "Name is too long")',
      description: "Name fields validation",
    },
    {
      fieldPatterns: ["description", "content", "text", "message"],
      validation: 'z.string().max(10000, "Text is too long")',
      description: "Long text fields validation",
    },
    {
      fieldPatterns: [".*address.*", ".*addr.*"],
      validation: 'z.string().min(5, "Address must be at least 5 characters").max(500)',
      description: "Address fields validation",
    },
    {
      fieldPatterns: ["ip.*", ".*ip_address.*"],
      validation: "z.ipv4()",
      description: "IP address format validation",
    },
    {
      fieldPatterns: ["status"],
      validation: 'z.string().min(1, "Status cannot be empty")',
      description: "Status fields validation",
    },
  ],

  numberRules: [
    {
      fieldPatterns: ["age"],
      validation: "z.number().int().min(0).max(150)",
      description: "Age validation",
    },
    {
      fieldPatterns: ["count", "quantity", "qty"],
      validation: "z.number().int().min(0)",
      description: "Count/quantity validation",
    },
    {
      fieldPatterns: ["price", "amount", "cost", "fee"],
      validation: "z.number().min(0)",
      description: "Monetary amount validation",
    },
    {
      fieldPatterns: ["rating", "score"],
      validation: "z.number().min(0).max(10)",
      description: "Rating/score validation",
    },
    {
      fieldPatterns: ["percent.*", ".*_rate$"],
      validation: "z.number().min(0).max(100)",
      description: "Percentage validation",
    },
    {
      fieldPatterns: ["^id$", ".*_id$"],
      validation: "z.number().int().positive()",
      description: "Numeric ID validation",
    },
  ],

  customRules: [
    {
      fieldName: "aud",
      tableName: "user", // Will match "user_profiles", "users", etc.
      validation: "z.string().min(1)",
      description: "Supabase auth audience field",
    },
    {
      fieldName: "role",
      tableName: "user", // Will match "user_profiles", "users", etc.
      validation: "z.enum(UserRole)",
      description: "User role field using native enum",
    },
    {
      fieldName: "transnet_id",
      tableName: "ofc_cables",  // Specific numeric foreign key
      validation: "z.string().nullable()",
      description: "Numeric order ID",
    },
  ],
};

export function loadValidationConfig(): ValidationConfig {
  // You can load from file, environment, or database
  return defaultValidationConfig;
}

```

<!-- path: utils/distance.ts -->
```typescript
// utils/distance.ts

// Straight-Line Distance (Haversine Formula)
export function haversineDistance(
    lat1: number,
    lon1: number,
    lat2: number,
    lon2: number
  ): number {
    const R = 6371; // Radius of the Earth in km
    const dLat = (lat2 - lat1) * (Math.PI / 180);
    const dLon = (lon2 - lon1) * (Math.PI / 180);
  
    const a =
      Math.sin(dLat / 2) * Math.sin(dLat / 2) +
      Math.cos(lat1 * (Math.PI / 180)) *
        Math.cos(lat2 * (Math.PI / 180)) *
        Math.sin(dLon / 2) *
        Math.sin(dLon / 2);
  
    const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
    return R * c; // in kilometers
  }
```

<!-- path: utils/renderKeyValueCell.tsx -->
```typescript
import React, { JSX } from "react";

export function renderKeyValueCell(value: unknown): JSX.Element {
  let elements: JSX.Element[] = [];

  if (value) {
    try {
      const parsedValue = typeof value === "string" ? JSON.parse(value) : value;

      if (typeof parsedValue === "object" && parsedValue !== null) {
        elements = Object.entries(parsedValue)
          .filter(([_, val]) => val !== null && val !== undefined && val !== "")
          .map(([key, val]) => (
            <div key={key} className='flex text-sm text-gray-500'>
              <span className='font-medium mr-1'>{key}:</span>
              <span>{String(val)}</span>
            </div>
          ));
      } else {
        elements = [
          <div key='single' className='text-sm text-gray-500'>
            {String(parsedValue)}
          </div>,
        ];
      }
    } catch (error) {
      elements = [
        <div key='error' className='text-sm text-gray-500'>
          {String(value)}
        </div>,
      ];
    }
  }

  return elements.length > 0 ? <div className='text-sm text-gray-500'>{elements}</div> : <div className='text-sm text-gray-500'>N/A</div>;
}

```

<!-- path: utils/getNodeIcons.ts -->
```typescript
import L from "leaflet";

// --- ICONS ---
export const MaanIcon = L.icon({ iconUrl: "/images/switch_image.png", iconSize: [40, 40], iconAnchor: [20, 20] });
export const BTSIcon = L.icon({ iconUrl: "/images/bts_image.png", iconSize: [40, 40], iconAnchor: [20, 20] });
export const BTSRLIcon = L.icon({ iconUrl: "/images/bts_rl_image.png", iconSize: [40, 40], iconAnchor: [20, 20] });
export const DefaultIcon = L.icon({ iconUrl: "/images/marker-icon.png", shadowUrl: "/images/marker-shadow.png", iconSize: [25, 41], iconAnchor: [12, 41] });
export const HighlightedIcon = L.icon({ iconUrl: "/images/marker-icon-highlight.png", shadowUrl: "/images/marker-shadow.png", iconSize: [28, 46], iconAnchor: [14, 46] });

export const getNodeIcon = (nodeType: string | null | undefined, isHighlighted: boolean) => {
    if (isHighlighted) return HighlightedIcon;
    switch (nodeType) {
      case 'Metro Access Aggregation Node': case 'Compact Passive Access Node': case 'Terminal Node': case 'Telephone Exchange (Exch.)': case 'Transmission Nodes': return MaanIcon;
      case 'Base Transceiver Station' : return BTSIcon;
      case 'BTS (running over radiolink)': return BTSRLIcon;
      default: return DefaultIcon;
    }
  };
```

<!-- path: utils/index.ts -->
```typescript
// Core utilities
export { cn } from './classNames';
export { default as formatters } from './formatters';
export { default as validation } from './validationUtils';
export * from './caseConverter';

// Supabase
export { createClient } from './supabase/server';
export { createClient as createBrowserClient } from './supabase/client';

```

<!-- path: utils/supabase/admin.ts -->
```typescript
import { createClient as createAdminClient } from '@supabase/supabase-js';

// This is a server-side only client that uses the service role key
// It should only be used in API routes or server components

export function createAdmin() {
  // These environment variables should be set in your deployment environment
  const supabaseUrl = process.env.NEXT_PUBLIC_SUPABASE_URL;
  const supabaseServiceRoleKey = process.env.SUPABASE_SERVICE_ROLE_KEY;

  console.log('URL:', process.env.NEXT_PUBLIC_SUPABASE_URL);
  console.log('Service key:', process.env.SUPABASE_SERVICE_ROLE_KEY ? 'exists' : 'missing');

  if (!supabaseUrl || !supabaseServiceRoleKey) {
    throw new Error(
      'Missing required environment variables: NEXT_PUBLIC_SUPABASE_URL and SUPABASE_SERVICE_ROLE_KEY must be set'
    );
  }

  return createAdminClient(supabaseUrl, supabaseServiceRoleKey, {
    auth: {
      autoRefreshToken: false,
      persistSession: false,
      detectSessionInUrl: false,
    },
  });
}

```

<!-- path: utils/supabase/client.ts -->
```typescript
// utils/supabase/client.ts

import { createBrowserClient } from '@supabase/ssr'

export function createClient() {
  return createBrowserClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!
  )
}
```

<!-- path: utils/supabase/server.ts -->
```typescript
 
import { createServerClient } from '@supabase/ssr'
import { cookies } from 'next/headers'
 
export async function createClient() {
  const cookieStore = await cookies()
 
  // Create a server's supabase client with newly configured cookie,
  // which could be used to maintain user's session
  return createServerClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,
    {
      cookies: {
        getAll() {
          return cookieStore.getAll()
        },
        setAll(cookiesToSet) {
          try {
            cookiesToSet.forEach(({ name, value, options }) =>
              cookieStore.set(name, value, options)
            )
          } catch {
            // The `setAll` method was called from a Server Component.
            // This can be ignored if you have middleware refreshing
            // user sessions.
          }
        },
      },
    }
  )
}
```

<!-- path: utils/supabase/middleware.ts -->
```typescript
 
import { createServerClient } from '@supabase/ssr'
import { NextResponse, type NextRequest } from 'next/server'
 
export async function updateSession(request: NextRequest) {
  let supabaseResponse = NextResponse.next({
    request,
  })
 
  const supabase = createServerClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,
    {
      cookies: {
        getAll() {
          return request.cookies.getAll()
        },
        setAll(cookiesToSet) {
          // eslint-disable-next-line @typescript-eslint/no-unused-vars
          cookiesToSet.forEach(({ name, value, options }) => request.cookies.set(name, value))
          supabaseResponse = NextResponse.next({
            request,
          })
          cookiesToSet.forEach(({ name, value, options }) =>
            supabaseResponse.cookies.set(name, value, options)
          )
        },
      },
    }
  )
 
  // refreshing the auth token
  await supabase.auth.getUser()
 
  return supabaseResponse
}
```

<!-- path: next-env.d.ts -->
```typescript
/// <reference types="next" />
/// <reference types="next/image-types/global" />
/// <reference path="./.next/types/routes.d.ts" />

// NOTE: This file should not be edited
// see https://nextjs.org/docs/app/api-reference/config/typescript for more information.

```

<!-- path: public/sw.js -->
```javascript
self.addEventListener('push', function (event) {
  if (event.data) {
    const data = event.data.json()
    const options = {
      body: data.body,
      icon: data.icon || '/icon.png',
      badge: '/badge.png',
      vibrate: [100, 50, 100],
      data: {
        dateOfArrival: Date.now(),
        primaryKey: '2',
      },
    }
    event.waitUntil(self.registration.showNotification(data.title, options))
  }
})
 
self.addEventListener('notificationclick', function (event) {
  // console.log('Notification click received.')
  event.notification.close()
  event.waitUntil(clients.openWindow('<https://hnvtx.vercel.app>'))
})
```

<!-- path: components/lookup/lookup-hooks.ts -->
```typescript
import { useRouter, useSearchParams } from "next/navigation";
import { useCallback, useState } from "react";
import { toast } from "sonner";
import { createClient } from "@/utils/supabase/client";
import { useDeduplicated, useTableDelete, useTableQuery, useToggleStatus } from "@/hooks/database";
import { Lookup_typesUpdateSchema } from "@/schemas/zod-schemas";

export function useLookupTypes(initialCategory = "") {
  const router = useRouter();
  const searchParams = useSearchParams();
  const [selectedCategory, setSelectedCategory] = useState(initialCategory || searchParams.get("category") || "");
  const [isLookupModalOpen, setIsLookupModalOpen] = useState(false);
  const [searchTerm, setSearchTerm] = useState("");
  const [editingLookup, setEditingLookup] = useState<Lookup_typesUpdateSchema | null>(null);

  const supabase = createClient();

  // Database hooks
  const {
    data: categories = [],
    isLoading: categoriesLoading,
    error: categoriesError,
    refetch: refetchCategories
  } = useDeduplicated(supabase, "lookup_types", {
    columns: ["category"],
    orderBy: [{ column: "created_at", ascending: true }],
  });

  const {
    data: lookupTypes = [],
    isLoading: lookupLoading,
    error: lookupError,
    refetch: refetchLookups
  } = useTableQuery(supabase, "lookup_types", {
    orderBy: [{ column: "name", ascending: true }],
    filters: {
      name: { operator: "neq", value: "DEFAULT" },
      ...(selectedCategory && { 
        category: { operator: "eq", value: selectedCategory } 
      })
    }
  });

  const { mutate: toggleStatus } = useToggleStatus(supabase, "lookup_types");
  const { mutate: deleteRowsById } = useTableDelete(supabase, "lookup_types");

  // Derived state
  const hasCategories = categories.length > 0;
  const hasSelectedCategory = !!selectedCategory;
  const isLoading = categoriesLoading || lookupLoading;
  
  const filteredLookups = lookupTypes
    .filter(lookup => 
      lookup.name.toLowerCase().includes(searchTerm.toLowerCase()) ||
      lookup.code?.toLowerCase().includes(searchTerm.toLowerCase()) ||
      lookup.description?.toLowerCase().includes(searchTerm.toLowerCase())
    );

  // Handlers
  const handleCategoryChange = useCallback((category: string) => {
    setSelectedCategory(category);
    setSearchTerm("");
    router.push(`/dashboard/lookup${category ? `?category=${category}` : ''}`);
  }, [router]);

  const handleRefresh = useCallback(async () => {
    try {
      await Promise.all([refetchCategories(), refetchLookups()]);
      toast.success("Data refreshed successfully");
    } catch (error) {
      console.log(error);
      toast.error("Failed to refresh data");
    }
  }, [refetchCategories, refetchLookups]);

  const handleAddNew = useCallback(() => {
    if (!hasSelectedCategory) {
      toast.error("Please select a category first");
      return;
    }
    setEditingLookup(null);
    setIsLookupModalOpen(true);
  }, [hasSelectedCategory]);

  const handleEdit = useCallback((lookup: Lookup_typesUpdateSchema) => {
    setEditingLookup(lookup);
    setIsLookupModalOpen(true);
  }, []);

  const handleDelete = useCallback((id: string) => {
    deleteRowsById([id], {
      onSuccess: () => {
        toast.success("Lookup type deleted successfully");
        refetchLookups();
      },
      onError: (error: Error) => {
        toast.error(`Failed to delete lookup type: ${error.message}`);
      }
    });
  }, [deleteRowsById, refetchLookups]);

  const handleToggleStatus = useCallback((id: string, currentStatus: boolean) => {
    toggleStatus({ id, status: !currentStatus }, {
      onSuccess: () => {
        toast.success(`Lookup type ${currentStatus ? 'deactivated' : 'activated'} successfully`);
        refetchLookups();
      },
      onError: (error: Error) => {
        toast.error(`Failed to toggle status: ${error.message}`);
      }
    });
  }, [toggleStatus, refetchLookups]);

  const handleModalClose = useCallback(() => {
    setIsLookupModalOpen(false);
    setEditingLookup(null);
  }, []);

  const handleLookupCreated = useCallback(() => {
    toast.success("Lookup type created successfully");
    refetchLookups();
    handleModalClose();
  }, [refetchLookups, handleModalClose]);

  const handleLookupUpdated = useCallback(() => {
    toast.success("Lookup type updated successfully");
    refetchLookups();
    handleModalClose();
  }, [refetchLookups, handleModalClose]);

  return {
    state: {
      selectedCategory,
      isLookupModalOpen,
      searchTerm,
      editingLookup,
      categories,
      lookupTypes: filteredLookups,
      isLoading,
      hasCategories,
      hasSelectedCategory,
      categoriesError,
      lookupError
    },
    handlers: {
      setSearchTerm,
      handleCategoryChange,
      handleRefresh,
      handleAddNew,
      handleEdit,
      handleDelete,
      handleToggleStatus,
      handleModalClose,
      handleLookupCreated,
      handleLookupUpdated
    }
  };
}
```

<!-- path: components/lookup/LookupModal.tsx -->
```typescript
"use client";

import { Button } from "@/components/common/ui/Button";
import { Input } from "@/components/common/ui/Input";
import { Modal } from "@/components/common/ui/Modal";
import { useTableInsert, useTableUpdate } from "@/hooks/database";
import { lookup_typesInsertSchema, Lookup_typesInsertSchema, Lookup_typesRowSchema, Lookup_typesUpdateSchema } from "@/schemas/zod-schemas";
import { snakeToTitleCase } from "@/utils/formatters";
import { createClient } from "@/utils/supabase/client";
import { zodResolver } from "@hookform/resolvers/zod";
import { useCallback, useEffect, useState } from "react";
import { useForm } from "react-hook-form";
import { toast } from "sonner";
import z from "zod";
import { generateCodeFromName } from "@/config/helper-functions";

interface LookupModalProps {
  isOpen: boolean;
  onClose: () => void;
  onLookupCreated?: (lookupData: Lookup_typesInsertSchema) => void;
  onLookupUpdated?: (lookupData: Lookup_typesUpdateSchema) => void;
  editingLookup?: Lookup_typesUpdateSchema | null;
  category?: string;
  categories?: Lookup_typesRowSchema[];
}

const getUniqueCategories = (data?: Lookup_typesRowSchema[]) => {
  if (!data) return [];
  const categoriesSet = new Set<string>();
  data.forEach(item => {
    if (item.category) {
      categoriesSet.add(item.category);
    }
  });
  return Array.from(categoriesSet).sort();
};

export function LookupModal({
  isOpen,
  onClose,
  onLookupCreated,
  onLookupUpdated,
  editingLookup,
  category,
  categories,
}: LookupModalProps) {
  const supabase = createClient();
  const { mutate: createLookup } = useTableInsert(supabase, "lookup_types");
  const { mutate: updateLookup } = useTableUpdate(supabase, "lookup_types");

  const [isCodeManuallyEdited, setIsCodeManuallyEdited] = useState(false);
  const isEditMode = Boolean(editingLookup);
  const uniqueCategories = getUniqueCategories(categories);

  const lookupTypeFormSchema = lookup_typesInsertSchema.pick({
    category: true, code: true, description: true, name: true,
    sort_order: true, is_system_default: true, status: true,
  });
  type LookupTypeFormData = z.infer<typeof lookupTypeFormSchema>;

  const {
    register, handleSubmit, formState: { errors, isSubmitting },
    reset, watch, setValue,
  } = useForm<LookupTypeFormData>({
    resolver: zodResolver(lookupTypeFormSchema),
    defaultValues: {
      category: "", code: "", description: "", name: "",
      sort_order: 0, is_system_default: false, status: true,
    },
  });
  
  const watchedName = watch('name');

  useEffect(() => {
    if (isOpen) {
      setIsCodeManuallyEdited(isEditMode); // Lock auto-generation in edit mode initially
      const resetData: LookupTypeFormData = {
        category: editingLookup?.category || category || "",
        code: editingLookup?.code || "",
        description: editingLookup?.description || "",
        name: editingLookup?.name || "",
        sort_order: editingLookup?.sort_order || 0,
        is_system_default: editingLookup?.is_system_default || false,
        status: editingLookup?.status !== false,
      };
      reset(resetData);
    }
  }, [isOpen, editingLookup, category, reset, isEditMode]);

  useEffect(() => {
    if (!isCodeManuallyEdited && !isEditMode) {
      const generatedCode = generateCodeFromName(watchedName);
      setValue('code', generatedCode, { shouldValidate: true });
    }
  }, [watchedName, isCodeManuallyEdited, isEditMode, setValue]);

  const onValidSubmit = useCallback(
    (data: LookupTypeFormData) => {
      const submissionData = { ...data, code: data.code?.trim() || null, description: data.description?.trim() || null, name: data.name?.trim(), category: data.category?.trim(), };
      if (isEditMode && editingLookup?.id) {
        updateLookup({ id: editingLookup.id, data: submissionData }, {
          onSuccess: (updatedData) => { onLookupUpdated?.(updatedData as Lookup_typesUpdateSchema); onClose(); },
          onError: (error) => toast.error(`Failed to update lookup type: ${error.message}`),
        });
      } else {
        createLookup(submissionData, {
          onSuccess: (createdData) => { onLookupCreated?.(createdData as unknown as Lookup_typesInsertSchema); onClose(); },
          onError: (error) => toast.error(`Failed to create lookup type: ${error.message}`),
        });
      }
    },
    [isEditMode, editingLookup, updateLookup, createLookup, onLookupUpdated, onLookupCreated, onClose]
  );

  const modalTitle = isEditMode ? "Edit Lookup Type" : "Add Lookup Type";
  const submitButtonText = isEditMode ? (isSubmitting ? "Updating..." : "Update") : (isSubmitting ? "Creating..." : "Create");
  const canSubmit = Boolean(watch("category")?.trim() && watch("name")?.trim() && !isSubmitting);
  const watchedCategory = watch("category");
  const watchedCode = watch("code");

  return (
    <Modal isOpen={isOpen} onClose={onClose} title={modalTitle} visible={false} className="transparent bg-gray-700 rounded-2xl">
      <form onSubmit={handleSubmit(onValidSubmit)} className="space-y-4">
        <div className="grid grid-cols-1 gap-4 md:grid-cols-2">
          <div className="md:col-span-2">
            <label htmlFor="category" className="mb-2 block text-sm font-medium text-gray-700 dark:text-gray-300">Category <span className="text-red-500 dark:text-red-400">*</span></label>
            {isEditMode || category ? (
              <Input type="text" {...register("category")} readOnly className="bg-gray-50 dark:bg-gray-700" value={watchedCategory || ""} />
            ) : (
              <select {...register("category")} className="w-full rounded-md border px-3 py-2 bg-white dark:bg-gray-800 text-gray-900 dark:text-gray-100 focus:ring-2 focus:ring-blue-500 focus:outline-none border-gray-300 dark:border-gray-600" disabled={isSubmitting} value={watchedCategory || ""} onChange={(e) => setValue("category", e.target.value)}>
                <option value="">Select category...</option>
                {uniqueCategories.map((cat) => (<option key={cat} value={cat}>{snakeToTitleCase(cat)}</option>))}
              </select>
            )}
            {errors.category && <p className="text-xs text-red-500 dark:text-red-400 mt-1">{errors.category.message}</p>}
          </div>
          <div className="md:col-span-2">
            <label htmlFor="name" className="mb-2 block text-sm font-medium text-gray-700 dark:text-gray-300">Name <span className="text-red-500 dark:text-red-400">*</span></label>
            <Input type="text" {...register("name")} placeholder="Enter lookup name" disabled={isSubmitting} className="dark:bg-gray-800" />
            {errors.name && <p className="text-xs text-red-500 dark:text-red-400 mt-1">{errors.name.message}</p>}
          </div>
          <div>
            <label htmlFor="code" className="mb-2 block text-sm font-medium text-gray-700 dark:text-gray-300">Code</label>
            <Input
              type="text"
              id="code"
              {...register("code")}
              placeholder="Auto-generated or manual"
              value={watchedCode || ""}
              disabled={isSubmitting}
              onChange={(e) => {
                setIsCodeManuallyEdited(true);
                setValue("code", e.target.value);
              }}
              className="dark:bg-gray-800"
            />
            {errors.code && <p className="text-xs text-red-500 dark:text-red-400 mt-1">{errors.code.message}</p>}
          </div>
          <div>
            <label htmlFor="sort_order" className="mb-2 block text-sm font-medium text-gray-700 dark:text-gray-300">Sort Order</label>
            <Input type="number" id="sort_order" {...register("sort_order", { valueAsNumber: true })} placeholder="0" disabled={isSubmitting} min="0" className="dark:bg-gray-800" />
            {errors.sort_order && <p className="text-xs text-red-500 dark:text-red-400 mt-1">{errors.sort_order.message}</p>}
          </div>
          <div className="md:col-span-2">
            <label htmlFor="description" className="mb-2 block text-sm font-medium text-gray-700 dark:text-gray-300">Description</label>
            <textarea className="w-full rounded-md border dark:border-gray-600 bg-white dark:bg-gray-800 text-gray-900 dark:text-gray-100 px-3 py-2" rows={3} {...register("description")} placeholder="Enter description (optional)" disabled={isSubmitting} />
            {errors.description && <p className="text-xs text-red-500 dark:text-red-400 mt-1">{errors.description.message}</p>}
          </div>
          <div className="md:col-span-2 space-y-3">
            <div className="flex items-center">
              <input type="checkbox" id="is_system_default" {...register("is_system_default")} disabled={isSubmitting || (isEditMode && !!editingLookup?.is_system_default)} className="h-4 w-4 rounded border-gray-300 dark:border-gray-600 bg-white dark:bg-gray-800 text-blue-600" />
              <label htmlFor="is_system_default" className="ml-2 text-sm text-gray-700 dark:text-gray-300">System Default</label>
            </div>
            <div className="flex items-center">
              <input type="checkbox" id="status" {...register("status")} disabled={isSubmitting} className="h-4 w-4 rounded border-gray-300 dark:border-gray-600 bg-white dark:bg-gray-800 text-blue-600" />
              <label htmlFor="status" className="ml-2 text-sm text-gray-700 dark:text-gray-300">Active Status</label>
            </div>
          </div>
        </div>
        <div className="flex justify-end gap-2 pt-4">
          <Button type="button" variant="outline" onClick={onClose} disabled={isSubmitting}>Cancel</Button>
          <Button type="submit" disabled={!canSubmit}>{submitButtonText}</Button>
        </div>
      </form>
    </Modal>
  );
}
```

<!-- path: components/lookup/LookupTypesEmptyStates.tsx -->
```typescript
"use client";

import { Card } from "@/components/common/ui/card";
import { Button } from "@/components/common/ui/Button";
import { FiPlus } from "react-icons/fi";
import { useRouter } from "next/navigation";
import { LoadingSpinner } from "@/components/common/ui/LoadingSpinner";

export function NoCategoriesState({ error, isLoading }: { error?: Error; isLoading: boolean }) {
  const router = useRouter();
  
  return (
    <Card className="p-8 text-center ">
      <p className="mb-4 text-gray-500 dark:text-gray-400">
        {isLoading ? "Loading categories..." : "No categories found."}
      </p>
      {error && (
        <p className="mb-4 text-red-500 dark:text-red-400">
          Error: {error.message}
        </p>
      )}
      <Button onClick={() => router.push('/dashboard/categories')}>
        <FiPlus className="mr-2 h-4 w-4" />
        Manage Categories
      </Button>
    </Card>
  );
}

export function SelectCategoryPrompt() {
  return (
    <Card className="p-8 text-center dark:bg-gray-800">
      <p className="text-gray-500 dark:text-gray-400">
        Please select a category to view lookup types.
      </p>
    </Card>
  );
}

export function LoadingState({ selectedCategory }: { selectedCategory: string }) {
  return (
    <div className="flex justify-center py-8">
      <LoadingSpinner />
      <span className="ml-2 text-gray-600 dark:text-gray-400">
        Loading lookup types for {`"${selectedCategory}"`}...
      </span>
    </div>
  );
}

export function ErrorState({ error, onRetry }: { error: Error; onRetry: () => void }) {
  return (
    <Card className="border-red-200 dark:border-red-800 bg-red-50 dark:bg-red-900/20 p-4">
      <p className="text-red-600 dark:text-red-400">
        Error loading lookup types: {error.message}
      </p>
      <Button
        onClick={onRetry}
        variant="outline"
        className="mt-2"
      >
        Retry
      </Button>
    </Card>
  );
}
```

<!-- path: components/lookup/LookupTypesTable.tsx -->
```typescript
"use client";

import { Button } from "@/components/common/ui/Button";
import { FiEdit2, FiTrash2, FiChevronUp, FiChevronDown } from "react-icons/fi";
import { useMemo } from "react";
import { SortDirection } from "@/hooks/useSorting";
import { Lookup_typesRowSchema } from "@/schemas/zod-schemas";

interface LookupTypesTableProps {
  lookups: Lookup_typesRowSchema[];
  onEdit: (lookup: Lookup_typesRowSchema) => void;
  onDelete: (id: string) => void;
  onToggleStatus: (id: string, currentStatus: boolean) => void;
  selectedCategory: string;
  searchTerm: string;
  onSort?: (key: string) => void;
  getSortDirection?: (key: string) => SortDirection;
}

interface SortableHeaderProps {
  children: React.ReactNode;
  sortKey: string;
  onSort?: (key: string) => void;
  getSortDirection?: (key: string) => SortDirection;
  className?: string;
}

function SortableHeader({ 
  children, 
  sortKey, 
  onSort, 
  getSortDirection, 
  className = "" 
}: SortableHeaderProps) {
  const sortDirection = getSortDirection?.(sortKey);
  const isSortable = onSort && getSortDirection;

  const handleClick = () => {
    if (onSort) {
      onSort(sortKey);
    }
  };

  if (!isSortable) {
    return (
      <th className={`px-6 py-3 text-left text-xs font-medium tracking-wider text-gray-500 dark:text-gray-400 uppercase ${className}`}>
        {children}
      </th>
    );
  }

  return (
    <th 
      className={`px-6 py-3 text-left text-xs font-medium tracking-wider text-gray-500 dark:text-gray-400 uppercase cursor-pointer hover:bg-gray-100 dark:hover:bg-gray-700 transition-colors select-none ${className}`}
      onClick={handleClick}
      role="button"
      tabIndex={0}
      onKeyDown={(e) => {
        if (e.key === 'Enter' || e.key === ' ') {
          e.preventDefault();
          handleClick();
        }
      }}
      title={`Sort by ${String(children).toLowerCase()}`}
    >
      <div className="flex items-center justify-between group">
        <span>{children}</span>
        <div className="flex flex-col ml-1">
          {sortDirection === 'asc' ? (
            <FiChevronUp className="h-3 w-3 text-blue-500" />
          ) : sortDirection === 'desc' ? (
            <FiChevronDown className="h-3 w-3 text-blue-500" />
          ) : (
            <div className="opacity-0 group-hover:opacity-50 transition-opacity">
              <FiChevronUp className="h-3 w-3" />
            </div>
          )}
        </div>
      </div>
    </th>
  );
}

export function LookupTypesTable({
  lookups,
  onEdit,
  onDelete,
  onToggleStatus,
  selectedCategory,
  searchTerm,
  onSort,
  getSortDirection
}: LookupTypesTableProps) {

  // Filter lookups based on search term (if not already filtered externally)
  const filteredLookups = useMemo(() => {
    if (!searchTerm.trim()) return lookups;
    
    const lowerSearchTerm = searchTerm.toLowerCase();
    return lookups.filter(lookup => 
      lookup.name?.toLowerCase().includes(lowerSearchTerm) ||
      lookup.code?.toLowerCase().includes(lowerSearchTerm) ||
      lookup.description?.toLowerCase().includes(lowerSearchTerm)
    );
  }, [lookups, searchTerm]);

  const displayedLookups = searchTerm ? filteredLookups : lookups;

  return (
    <div className="overflow-x-auto">
      <table className="w-full">
        <thead className="bg-gray-50 dark:bg-gray-800">
          <tr>
            <SortableHeader 
              sortKey="name" 
              onSort={onSort} 
              getSortDirection={getSortDirection}
            >
              Name
            </SortableHeader>
            <SortableHeader 
              sortKey="code" 
              onSort={onSort} 
              getSortDirection={getSortDirection}
            >
              Short Code
            </SortableHeader>
            <SortableHeader 
              sortKey="description" 
              onSort={onSort} 
              getSortDirection={getSortDirection}
            >
              Description
            </SortableHeader>
            <SortableHeader 
              sortKey="status" 
              onSort={onSort} 
              getSortDirection={getSortDirection}
            >
              Status
            </SortableHeader>
            <th className="px-6 py-3 text-left text-xs font-medium tracking-wider text-gray-500 dark:text-gray-400 uppercase">
              Actions
            </th>
          </tr>
        </thead>
        <tbody className="divide-y divide-gray-200 dark:divide-gray-700 bg-white dark:bg-gray-900">
          {displayedLookups.map((lookup) => (
            <tr key={lookup.id} className="hover:bg-gray-50 dark:hover:bg-gray-800">
              <td className="px-6 py-4 text-sm font-medium text-gray-900 dark:text-gray-100 max-w-[150px] break-words">
                {lookup.name ?? "-"}
              </td>
              <td className="px-6 py-4 text-sm whitespace-nowrap text-gray-500 dark:text-gray-400">
                {lookup.code || "-"}
              </td>
              <td className="px-6 py-4 text-sm text-gray-500 dark:text-gray-400 max-w-xs break-words">
                {lookup.description || "-"}
              </td>
              <td className="px-6 py-4 whitespace-nowrap">
                <Button
                  variant="ghost"
                  onClick={() => onToggleStatus(lookup.id!, !!lookup.status)}
                  className={`inline-flex rounded-full px-2 py-1 text-xs font-semibold ${
                    lookup.status
                      ? "bg-green-100 dark:bg-green-900/30 text-green-800 dark:text-green-300 hover:bg-green-200 dark:hover:bg-green-900/50"
                      : "bg-red-100 dark:bg-red-900/30 text-red-800 dark:text-red-300 hover:bg-red-200 dark:hover:bg-red-900/50"
                  }`}
                  disabled={!!lookup.is_system_default}
                >
                  {lookup.status ? "Active" : "Inactive"}
                </Button>
              </td>
              <td className="px-6 py-4 text-sm font-medium whitespace-nowrap">
                <div className="flex items-center gap-2">
                  <Button
                    size="sm"
                    variant="outline"
                    disabled={!!lookup.is_system_default}
                    onClick={() => onEdit(lookup)}
                    title={
                      lookup.is_system_default
                        ? "Cannot edit system default"
                        : "Edit"
                    }
                    className="hover:text-blue-600 dark:hover:text-blue-400"
                  >
                    <FiEdit2 className="h-4 w-4" />
                  </Button>
                  <Button
                    size="sm"
                    variant="outline"
                    onClick={() => {
                      if (confirm(`Are you sure you want to delete "${lookup.name}"?`)) {
                        onDelete(lookup.id!);
                      }
                    }}
                    className="text-red-600 dark:text-red-400 hover:text-red-800 dark:hover:text-red-300"
                    disabled={!!lookup.is_system_default}
                    title={
                      lookup.is_system_default
                        ? "Cannot delete system default"
                        : "Delete"
                    }
                  >
                    <FiTrash2 className="h-4 w-4" />
                  </Button>
                </div>
              </td>
            </tr>
          ))}
        </tbody>
      </table>

      {displayedLookups.length === 0 && (
        <div className="py-8 text-center text-gray-500 dark:text-gray-400">
          {searchTerm
            ? `No lookup types found matching "${searchTerm}" in category "${selectedCategory}".`
            : `No lookup types found for category "${selectedCategory}".`}
        </div>
      )}

      {/* Optional: Show sorting/filtering info */}
      {(searchTerm || (getSortDirection && Object.values(['name', 'code', 'description', 'status']).some(key => getSortDirection(key)))) && (
        <div className="px-6 py-2 text-xs text-gray-500 dark:text-gray-400 bg-gray-50 dark:bg-gray-800 border-t border-gray-200 dark:border-gray-700">
          {searchTerm && (
            <span>Filtered by: &quot;{searchTerm}&quot; • </span>
          )}
          {getSortDirection && (() => {
            const sortedColumn = ['name', 'code', 'description', 'status'].find(key => getSortDirection(key));
            const sortDirection = sortedColumn ? getSortDirection(sortedColumn) : null;
            return sortedColumn && sortDirection ? (
              <span>Sorted by: {sortedColumn} ({sortDirection})</span>
            ) : null;
          })()}
        </div>
      )}
    </div>
  );
}
```

<!-- path: components/lookup/index.tsx -->
```typescript
export * from "./lookup-types";
export * from "./lookup-hooks";
export * from "./LookupModal";
export * from "./LookupTypesEmptyStates";
export * from "./LookupTypesFilters";

```

<!-- path: components/lookup/LookupTypesFilters.tsx -->
```typescript
"use client";

import { Input } from "@/components/common/ui/Input";
import { FiSearch } from "react-icons/fi";
import { snakeToTitleCase } from "@/utils/formatters";

interface LookupTypesFiltersProps {
  categories: Array<{ id: string; category: string }>;
  selectedCategory: string;
  onCategoryChange: (category: string) => void;
  searchTerm: string;
  onSearchTermChange: (term: string) => void;
  hasSelectedCategory: boolean;
}

export function LookupTypesFilters({
  categories,
  selectedCategory,
  onCategoryChange,
  searchTerm,
  onSearchTermChange,
  hasSelectedCategory
}: LookupTypesFiltersProps) {
  return (
    <div className="flex flex-col gap-4 sm:flex-row">
      <div className="flex-1">
        <label className="mb-2 block text-sm font-medium text-gray-700 dark:text-gray-300">
          Select Category
        </label>
        <select
          value={selectedCategory}
          onChange={(e) => onCategoryChange(e.target.value)}
          className="w-full rounded-md border border-gray-300 dark:border-gray-600 bg-white dark:bg-gray-800 px-3 py-2 text-gray-900 dark:text-gray-100 focus:ring-2 focus:ring-blue-500 focus:outline-none"
        >
          <option value="">Select a category</option>
          {categories.map((category) => (
            <option key={category.id} value={category.category}>
              {snakeToTitleCase(category.category)} ({category.category})
            </option>
          ))}
        </select>
      </div>

      <div className="flex-1">
        <label className="mb-2 block text-sm font-medium text-gray-700 dark:text-gray-300">
          Search
        </label>
        <div className="relative">
          <FiSearch className="absolute top-1/2 left-3 h-4 w-4 -translate-y-1/2 transform text-gray-400 dark:text-gray-500" />
          <Input
            type="text"
            placeholder="Search lookup types..."
            value={searchTerm}
            onChange={(e) => onSearchTermChange(e.target.value)}
            className="pl-10 dark:bg-gray-800 dark:text-gray-100"
            disabled={!hasSelectedCategory}
          />
        </div>
      </div>
    </div>
  );
}
```

<!-- path: components/navigation/sidebar.tsx -->
```typescript
"use client";

import { AnimatePresence, motion } from "framer-motion";
import { usePathname } from "next/navigation";
import { memo, useState, useCallback, useEffect } from "react";
import useIsMobile from "@/hooks/useIsMobile";

import { NavItem } from "@/components/navigation/sidebar-components/NavItem";
import { QuickActions } from "@/components/navigation/sidebar-components/QuickActions";
import { HoverMenu } from "@/components/navigation/sidebar-components/HoverMenu";
import { MobileSidebar } from "@/components/navigation/sidebar-components/MobileSidebar";
import { SidebarProps, NavItem as NavItemType, sidebarVariants, contentVariants } from "@/components/navigation/sidebar-components/sidebar-types";
import NavItems from "./sidebar-components/NavItems";
import { FiHelpCircle, FiMenu, FiX } from "react-icons/fi";
import { UserRole } from "@/types/user-roles";

const Sidebar = memo(({ isCollapsed, setIsCollapsed, showMenuFeatures }: SidebarProps) => {
  const pathname = usePathname();
  const [expandedItems, setExpandedItems] = useState<string[]>([]);
  const [hoveredItem, setHoveredItem] = useState<NavItemType | null>(null);
  const isMobile = useIsMobile();

  // Define the Help NavItem data
  const helpNavItem: NavItemType = {
    id: 'help',
    label: 'Help',
    icon: <FiHelpCircle className="h-5 w-5" />,
    href: '/dashboard/doc',
    roles: [
      UserRole.ADMIN,
      UserRole.VIEWER,
      UserRole.AUTHENTICATED,
      UserRole.CPANADMIN,
      UserRole.MAANADMIN,
      UserRole.SDHADMIN,
      UserRole.VMUXADMIN,
      UserRole.MNGADMIN,
    ],
  };

  // Close mobile sidebar on route changes
  useEffect(() => {
    if (isMobile) {
      setIsCollapsed(true);
    }
  }, [pathname, isMobile, setIsCollapsed]);

  // Close hover menu when sidebar expands
  useEffect(() => {
    if (!isCollapsed) {
      setHoveredItem(null);
    }
  }, [isCollapsed]);

  

  const toggleExpanded = useCallback((id: string) => {
    setExpandedItems((prev) => (prev.includes(id) ? prev.filter((item) => item !== id) : [...prev, id]));
  }, []);


  if (isMobile) {
    return (
      <MobileSidebar
        isCollapsed={isCollapsed}
        setIsCollapsed={setIsCollapsed}
        navItems={NavItems()}
        expandedItems={expandedItems}
        toggleExpanded={toggleExpanded}
        setHoveredItem={setHoveredItem}
        pathname={pathname}
      />
    );
  }

  return (
    <motion.aside
      initial={false}
      animate={isCollapsed ? "collapsed" : "expanded"}
      variants={sidebarVariants}
      transition={{ duration: 0.3, ease: "easeInOut" }}
      className='fixed top-0 left-0 z-50 flex h-full flex-col border-r border-gray-200 bg-white shadow-lg dark:border-gray-800 dark:bg-gray-900 dark:text-white'>
      <div className='flex h-16 items-center justify-between border-b border-gray-200 px-4 dark:border-gray-800'>
        <AnimatePresence mode='wait'>
          {!isCollapsed && (
            <motion.h2 initial='hidden' animate='visible' exit='exit' variants={contentVariants} transition={{ duration: 0.2 }} className='text-lg font-semibold text-gray-900 dark:text-gray-100'>
              Navigation
            </motion.h2>
          )}
        </AnimatePresence>

        <button onClick={() => setIsCollapsed(!isCollapsed)} className='rounded-lg p-2 transition-colors hover:bg-gray-100 dark:hover:bg-gray-800' aria-label={isCollapsed ? "Expand sidebar" : "Collapse sidebar"}>
          <motion.div animate={{ rotate: isCollapsed ? 180 : 0 }} transition={{ duration: 0.2 }}>
            {isCollapsed ? <FiMenu className='h-5 w-5' /> : <FiX className='h-5 w-5' />}
          </motion.div>
        </button>
      </div>

      <div className='flex-1 overflow-y-auto py-4'>
        <nav className='space-y-1' role='navigation'>
          {NavItems().map((item) => (
            <NavItem key={item.id} item={item} isCollapsed={isCollapsed} expandedItems={expandedItems} toggleExpanded={toggleExpanded} setHoveredItem={setHoveredItem} />
          ))}
        </nav>
        {showMenuFeatures && <QuickActions isCollapsed={isCollapsed} pathname={pathname} />}
      </div>

      {/* --- ADDED: Help section at the bottom --- */}
      <div className="py-2 border-t border-gray-200 dark:border-gray-700">
        <NavItem
          item={helpNavItem}
          isCollapsed={isCollapsed}
          expandedItems={expandedItems}
          toggleExpanded={toggleExpanded}
          setHoveredItem={setHoveredItem}
        />
      </div>

      <HoverMenu hoveredItem={hoveredItem} setHoveredItem={setHoveredItem} />
    </motion.aside>
  );
});

Sidebar.displayName = "Sidebar";
export default Sidebar;

```

<!-- path: components/navigation/sidebar-components/NavItem.tsx -->
```typescript
"use client";

import { motion, AnimatePresence } from "framer-motion";
import { usePathname, useRouter } from "next/navigation";
import { FiChevronDown } from "react-icons/fi";
import { NavItem as NavItemType, submenuVariants } from "./sidebar-types";
import { useUserPermissions } from "@/hooks/useRoleFunctions";
import { toast } from "sonner";
import { UserRole } from "@/types/user-roles";
import { ButtonSpinner } from "@/components/common/ui/LoadingSpinner";
import { useState, useEffect } from "react";

interface NavItemProps {
  item: NavItemType;
  isCollapsed: boolean;
  depth?: number;
  expandedItems: string[];
  toggleExpanded: (id: string) => void;
  setHoveredItem: (item: NavItemType | null) => void;
}

export const NavItem = ({
  item,
  isCollapsed,
  depth = 0,
  expandedItems,
  toggleExpanded,
  setHoveredItem,
}: NavItemProps) => {
  const router = useRouter();
  const pathname = usePathname();
  const { isSuperAdmin, role } = useUserPermissions();
  const [isLoading, setIsLoading] = useState(false);
  const [navigatingTo, setNavigatingTo] = useState<string | null>(null);

  const hasPermission = (roles: UserRole[]) => {
    if (isSuperAdmin) return true;
    if (!roles || roles.length === 0) return false;
    return roles.includes(role as UserRole);
  };

  const isActive = () => {
    if (!item.href) return false;
    if (item.href === "/dashboard") {
      return pathname === "/dashboard";
    }
    return pathname.startsWith(item.href);
  };

  const handleItemClick = async (e: React.MouseEvent) => {
    if (!hasPermission(item.roles)) {
      e.preventDefault();
      toast.error("You are not authorized to access this section.");
      return;
    }
    
    if (item.children && item.children.length > 0) {
      e.preventDefault();
      toggleExpanded(item.id);
      return;
    }
    
    if (item.href) {
      try {
        setNavigatingTo(item.href);
        setIsLoading(true);
        if (item.external) {
          window.open(item.href, "_blank", "noopener,noreferrer");
          setIsLoading(false);
        } else {
          await router.push(item.href);
          // The loading state will be cleared by the effect below
        }
      } catch (error) {
        console.error("Navigation error:", error);
        toast.error("Failed to navigate. Please try again.");
        setIsLoading(false);
        setNavigatingTo(null);
      }
    }
  };

  // Clear loading state when the route changes
  useEffect(() => {
    if (pathname === navigatingTo) {
      setIsLoading(false);
      setNavigatingTo(null);
    }
  }, [pathname, navigatingTo]);

  if (!hasPermission(item.roles)) return null;

  const active = isActive();
  const hasChildren = item.children && item.children.length > 0;
  const isExpanded = expandedItems.includes(item.id);

  return (
    <div 
      key={item.id} 
      className="relative" 
      onMouseEnter={() => isCollapsed && hasChildren && setHoveredItem(item)} 
      onMouseLeave={() => isCollapsed && hasChildren && setHoveredItem(null)}
    >
      <div
        onClick={handleItemClick}
        className={`
          flex cursor-pointer items-center justify-between py-3 text-sm font-medium 
          transition-all duration-200 rounded-lg mx-2 mb-1
          ${active 
            ? "bg-blue-100 text-blue-800 dark:bg-blue-900/30 dark:text-blue-300 shadow-sm" 
            : "text-gray-700 hover:bg-gray-50 dark:text-gray-300 dark:hover:bg-gray-800 hover:shadow-sm"
          } 
          ${isCollapsed ? "justify-center px-4" : `pr-4 ${depth > 0 ? "pl-8" : "pl-4"}`}
        `}
        role="button"
        tabIndex={0}
        onKeyDown={(e) => {
          if (e.key === "Enter" || e.key === " ") {
            e.preventDefault();
            handleItemClick(e as unknown as React.MouseEvent);
          }
        }}
      >
        <div className="flex items-center space-x-3">
          <span className="flex-shrink-0">
            {isLoading && pathname !== item.href ? <ButtonSpinner size="xs" /> : item.icon}
          </span>
          {!isCollapsed && (
            <span className="truncate">
              {isLoading && pathname !== item.href ? 'Loading...' : item.label}
            </span>
          )}
        </div>
        {!isCollapsed && hasChildren && (
          <button
            onClick={(e) => {
              e.stopPropagation();
              toggleExpanded(item.id);
            }}
            className="p-1 rounded-md transition-colors hover:bg-gray-200 dark:hover:bg-gray-700"
            aria-label={isExpanded ? "Collapse" : "Expand"}
          >
            <motion.div 
              animate={{ rotate: isExpanded ? 0 : -90 }} 
              transition={{ duration: 0.2 }}
            >
              <FiChevronDown className="w-4 h-4" />
            </motion.div>
          </button>
        )}
      </div>
      
      {!isCollapsed && hasChildren && (
        <AnimatePresence initial={false}>
          {isExpanded && (
            <motion.div 
              initial="hidden"
              animate="visible"
              exit="hidden"
              variants={submenuVariants}
              transition={{ duration: 0.2 }}
              className="overflow-hidden"
            >
              <div className="ml-6 border-l-2 border-gray-200 dark:border-gray-700 pl-2">
                {item.children?.map((child) => (
                  <NavItem
                    key={child.id}
                    item={child}
                    isCollapsed={isCollapsed}
                    depth={depth + 1}
                    expandedItems={expandedItems}
                    toggleExpanded={toggleExpanded}
                    setHoveredItem={setHoveredItem}
                  />
                ))}
              </div>
            </motion.div>
          )}
        </AnimatePresence>
      )}
    </div>
  );
};
```

<!-- path: components/navigation/sidebar-components/sidebar-types.ts -->
```typescript
import { Database } from "@/types/supabase-types";
import { UserRole } from "@/types/user-roles";
import { ReactNode } from "react";

export type TableName = keyof Database["public"]["Tables"];

export interface SidebarProps {
  isCollapsed: boolean;
  setIsCollapsed: (collapsed: boolean) => void;
  showMenuFeatures: boolean;
}

export interface NavItem {
  id: string;
  label: string;
  icon: ReactNode;
  href?: string;
  children?: NavItem[];
  roles: UserRole[];
  external?: boolean;
}

// Animation variants
export const sidebarVariants = {
  expanded: { width: 260 },
  collapsed: { width: 64 }
};

export const mobileOverlayVariants = {
  hidden: { opacity: 0 },
  visible: { opacity: 1 }
};

export const mobileSidebarVariants = {
  hidden: { x: -260 },
  visible: { x: 0 }
};

export const contentVariants = {
  hidden: { opacity: 0, x: -10 },
  visible: { opacity: 1, x: 0 },
  exit: { opacity: 0, x: -10 }
};

export const submenuVariants = {
  hidden: { height: 0, opacity: 0 },
  visible: { height: "auto", opacity: 1 }
};
```

<!-- path: components/navigation/sidebar-components/HoverMenu.tsx -->
```typescript
"use client";

import { motion, AnimatePresence } from "framer-motion";
import { NavItem as NavItemType } from "./sidebar-types";
import { useUserPermissions } from "@/hooks/useRoleFunctions";
import { useRouter } from "next/navigation";
import { toast } from "sonner";
import { UserRole } from "@/types/user-roles";

interface HoverMenuProps {
  hoveredItem: NavItemType | null;
  setHoveredItem: (item: NavItemType | null) => void;
}

export const HoverMenu = ({ hoveredItem, setHoveredItem }: HoverMenuProps) => {
  const router = useRouter();
  const { isSuperAdmin, role } = useUserPermissions();

  const hasPermission = (roles: UserRole[]) => {
    if (isSuperAdmin) return true;
    if (!roles || roles.length === 0) return false;
    return roles.includes(role as UserRole);
  };

  const handleChildClick = (e: React.MouseEvent, child: NavItemType) => {
    e.stopPropagation();
    if (!hasPermission(child.roles)) {
      toast.error("You are not authorized to access this section.");
      return;
    }
    if (child.href) {
      router.push(child.href);
      setHoveredItem(null);
    }
  };

  return (
    <AnimatePresence>
      {hoveredItem?.children && (
        <motion.div
          initial={{ opacity: 0, x: 10, scale: 0.95 }}
          animate={{ opacity: 1, x: 0, scale: 1 }}
          exit={{ opacity: 0, x: 10, scale: 0.95 }}
          transition={{ duration: 0.15 }}
          className="fixed left-16 z-[60] min-w-48 overflow-hidden rounded-lg bg-white shadow-xl ring-1 ring-black/5 dark:bg-gray-800 dark:ring-white/10"
          style={{
            top: `${Math.max(80, Math.min(window.innerHeight - 200, 160))}px`,
          }}
          onMouseEnter={() => setHoveredItem(hoveredItem)}
          onMouseLeave={() => setHoveredItem(null)}
        >
          <div className="py-2">
            {hoveredItem.children.map((child) => (
              <button
                key={child.id}
                onClick={(e) => handleChildClick(e, child)}
                disabled={!hasPermission(child.roles)}
                className={`
                  flex w-full items-center space-x-3 px-4 py-2 text-left text-sm transition-colors
                  ${hasPermission(child.roles) 
                    ? "text-gray-700 hover:bg-gray-100 dark:text-gray-300 dark:hover:bg-gray-700" 
                    : "text-gray-400 cursor-not-allowed dark:text-gray-600"
                  }
                `}
              >
                <span className="flex-shrink-0">{child.icon}</span>
                <span className="truncate">{child.label}</span>
              </button>
            ))}
          </div>
        </motion.div>
      )}
    </AnimatePresence>
  );
};
```

<!-- path: components/navigation/sidebar-components/NavItems.tsx -->
```typescript
import { UserRole } from '@/types/user-roles';
import { NavItem as NavItemType } from '@/components/navigation/sidebar-components/sidebar-types';
import { useMemo } from 'react';
import {
  FiDatabase,
  FiHome,
  FiMap,
  FiUsers,
  FiServer,
  FiLayers,
  FiCpu,
  FiMapPin,
  FiList,
  FiGitBranch,
} from 'react-icons/fi';
import { FaDiagramNext } from 'react-icons/fa6';
import { BsPeople } from 'react-icons/bs';
import { ImUserTie } from 'react-icons/im';
import { GiElectric, GiLinkedRings} from 'react-icons/gi';
import { AiFillMerge } from 'react-icons/ai';
import {FaRoute } from 'react-icons/fa';

function NavItems() {
  const items: NavItemType[] = useMemo(
    () => [
      {
        id: 'home',
        label: 'Home',
        icon: <FiHome className="h-5 w-5" />,
        href: '/dashboard',
        roles: [
          UserRole.ADMIN,
          UserRole.VIEWER,
          UserRole.AUTHENTICATED,
          UserRole.CPANADMIN,
          UserRole.MAANADMIN,
          UserRole.SDHADMIN,
          UserRole.VMUXADMIN,
        ],
      },
      {
        id: 'user-management',
        label: 'User Management',
        icon: <FiUsers className="h-5 w-5" />,
        href: '/dashboard/users',
        roles: [],
      },
      {
        id: 'employees',
        label: 'Employees',
        icon: <BsPeople className="h-5 w-5" />,
        href: '/dashboard/employees',
        roles: [UserRole.ADMIN],
      },
      {
        id: 'base-menu',
        label: 'Base Structure',
        icon: <FiServer className="h-5 w-5" />,
        roles: [
          UserRole.ADMIN,
          UserRole.VIEWER,
          UserRole.AUTHENTICATED,
          UserRole.CPANADMIN,
          UserRole.MAANADMIN,
          UserRole.SDHADMIN,
          UserRole.VMUXADMIN,
        ],
        children: [
          {
            id: 'designations',
            label: 'Designations',
            icon: <ImUserTie className="h-5 w-5" />,
            href: '/dashboard/designations',
            roles: [],
          },
          {
            id: 'categories',
            label: 'Categories',
            icon: <FiLayers className="h-5 w-5" />,
            href: '/dashboard/categories',
            roles: [UserRole.ADMIN],
          },
          {
            id: 'lookups',
            label: 'Lookups',
            icon: <FiList className="h-5 w-5" />,
            href: '/dashboard/lookup',
            roles: [UserRole.ADMIN],
          },
          {
            id: 'maintenance-areas',
            label: 'Maintenance Areas',
            icon: <FiMapPin className="h-5 w-5" />,
            href: '/dashboard/maintenance-areas',
            roles: [UserRole.ADMIN],
          },
          {
            id: 'nodes',
            label: 'Nodes',
            icon: <FiCpu className="h-5 w-5" />,
            href: '/dashboard/nodes',
            roles: [UserRole.ADMIN],
          },
          {
            id: 'rings',
            label: 'Rings',
            icon: <GiLinkedRings className="h-5 w-5" />,
            href: '/dashboard/rings',
            roles: [UserRole.ADMIN],
          },
        ],
      },
      {
        id: 'ofc-menu',
        label: 'Ofc & Routes',
        icon: <GiElectric className="h-5 w-5" />,
        roles: [
          UserRole.ADMIN,
          UserRole.VIEWER,
          UserRole.AUTHENTICATED,
          UserRole.CPANADMIN,
          UserRole.MAANADMIN,
          UserRole.SDHADMIN,
          UserRole.VMUXADMIN,
        ],
        children: [
          {
            id: 'ofc-menu',
            label: 'Optical Fiber Cable',
            href: '/dashboard/ofc',
            icon: <AiFillMerge className="h-5 w-5" />, // replaced non-existent TbCableData with a valid icon
            roles: [UserRole.ADMIN],
          },
          {
            id: 'route-manager',
            label: 'RouteManager',
            icon: <FaRoute className="h-5 w-5" />,
            href: '/dashboard/route-manager',
            roles: [UserRole.ADMIN],
          },
          {
            id: 'logical-paths',
            label: 'Logical Paths',
            icon: <FiGitBranch className="h-5 w-5" />,
            href: '/dashboard/logical-paths',
            roles: [UserRole.ADMIN, UserRole.VIEWER], // Accessible to admins and viewers
          },
        ],
      },
      {
        id: 'systems',
        label: 'Systems',
        icon: <FiDatabase className="h-5 w-5" />,
        href: '/dashboard/systems',
        roles: [UserRole.ADMIN],
      },
      {
        id: 'diagrams',
        label: 'Diagrams',
        icon: <FaDiagramNext className="h-5 w-5" />,
        href: '/dashboard/diagrams',
        roles: [UserRole.ADMIN],
      },
      {
        id: 'map',
        label: 'BTS Map',
        icon: <FiMap className="h-5 w-5" />,
        href: 'https://www.google.com/maps/d/u/0/embed?mid=1dpO2c3Qt2EmLFxovZ14rcqkjrN6uqlvP&ehbc=2E312F&ll=22.485295672038035%2C88.3701163022461&z=14',
        roles: [
          UserRole.ADMIN,
          UserRole.VIEWER,
          UserRole.MAANADMIN,
          UserRole.SDHADMIN,
          UserRole.VMUXADMIN,
        ],
        external: true,
      },
    ],
    []
  );
  return items;
}

export default NavItems;

```

<!-- path: components/navigation/sidebar-components/QuickActions.tsx -->
```typescript
"use client";

import { motion, AnimatePresence } from "framer-motion";
import { FiChevronDown, FiSettings, FiUpload } from "react-icons/fi";
import { Input } from "@/components/common/ui/Input";
import { useRef, useState } from "react";
import { submenuVariants } from "./sidebar-types";
import { createClient } from "@/utils/supabase/client";
import { useUploadConfigStore } from "@/stores/useUploadConfigStore";
import { useExcelUpload } from "@/hooks/database/excel-queries";
import { toast } from "sonner";
import { TableName } from "@/hooks/database/queries-type-helpers";
import { useCurrentTableName } from "@/hooks/useCurrentTableName";

interface QuickActionsProps {
  isCollapsed: boolean;
  pathname: string;
}

export const QuickActions = ({ isCollapsed, pathname }: QuickActionsProps) => {
  const [showMenuSection, setShowMenuSection] = useState(true);
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  const [file, setFile] = useState<File | null>(null);
  const currentTableName = useCurrentTableName();

  // Don't show on dashboard or when collapsed
  const shouldHideFeatures =
    pathname === "/dashboard" || isCollapsed || !currentTableName;

  // Zustand integration
  const supabase = createClient();
  const fileInputRef = useRef<HTMLInputElement>(null);
  // const pageKey = currentTableName as string;

  // Get the config for this specific context from the store.
  const { configs } = useUploadConfigStore();
  const storeConfig = configs[currentTableName as string];
  // console.log("storeConfig", storeConfig);

  // Initialize the upload hook. Note that we don't know the table name here yet.
  const { mutate, isPending } = useExcelUpload(
    supabase,
    currentTableName as TableName,
    {
      onSuccess: (result) => {
        // ... success handler
        console.log("result", result);
        return result.successCount > 0
          ? toast.success(
              `Successfully uploaded ${result.successCount} of ${result.totalRows} records.`
            )
          : toast.error(`Failed to upload ${result.totalRows} records.`);
      },
      onError: (error) => {
        // ... error handler
        console.log(error);
      },
    }
  );

  const handleFileChange = (event: React.ChangeEvent<HTMLInputElement>) => {
    const selectedFile = event.target.files?.[0];

    if (!selectedFile) {
      alert("Please select a file first!");
      return;
    }

    setFile(selectedFile);

    if (!storeConfig) {
      toast.error("Upload configuration is missing. Cannot proceed.");
      return;
    }

    mutate({
      file: selectedFile,
      columns: storeConfig.columnMapping,
      uploadType: storeConfig.uploadType,
      conflictColumn: storeConfig.conflictColumn,
    });

    if (fileInputRef.current) {
      fileInputRef.current.value = "";
    }
  };

  // Don't show on dashboard or when collapsed
  if (shouldHideFeatures) return null;

  return (
    <div className="mt-4 border-t border-gray-200 pt-4 dark:border-gray-700">
      <div
        onClick={() => setShowMenuSection(!showMenuSection)}
        className="flex cursor-pointer items-center justify-between py-2 px-4 mx-2 rounded-lg text-sm font-medium text-gray-700 transition-colors duration-200 hover:bg-gray-50 dark:text-gray-300 dark:hover:bg-gray-800"
      >
        <div className="flex items-center space-x-3">
          <FiSettings className="h-5 w-5 flex-shrink-0" />
          <span>Quick Actions</span>
        </div>
        <motion.div
          animate={{ rotate: showMenuSection ? 0 : -90 }}
          transition={{ duration: 0.2 }}
        >
          <FiChevronDown className="h-4 w-4" />
        </motion.div>
      </div>

      <AnimatePresence initial={false}>
        {showMenuSection && storeConfig?.isUploadEnabled && (
          <motion.div
            initial="hidden"
            animate="visible"
            exit="hidden"
            variants={submenuVariants}
            transition={{ duration: 0.2 }}
            className="overflow-hidden"
          >
            <div className="space-y-3 px-4 py-3">
              <div className="space-y-2">
                <h4 className="px-2 text-xs font-medium uppercase tracking-wide text-gray-500 dark:text-gray-400">
                  Upload data for:
                  <div className="flex">
                    <div className="font-bold ml-1 lowercase px-2 ">
                      {currentTableName}{" "}
                    </div>
                    <div className="uppercase">table</div>
                  </div>
                </h4>

                {/* Upload Excel Button */}
                <>
                  <Input
                    type="file"
                    accept=".xlsx, .xls"
                    ref={fileInputRef}
                    onChange={handleFileChange}
                    className="hidden"
                  />
                  <button
                    onClick={() => fileInputRef.current?.click()}
                    disabled={isPending || !currentTableName}
                    className="flex w-full items-center gap-2 rounded-md border border-gray-300 p-2 text-left text-xs transition-colors hover:bg-gray-50 disabled:cursor-not-allowed disabled:opacity-50 dark:border-gray-600 dark:hover:bg-gray-800"
                  >
                    <FiUpload className="h-3 w-3" />
                    <span>{isPending ? "Uploading..." : "Upload Excel"}</span>
                  </button>
                </>
              </div>
            </div>
          </motion.div>
        )}
      </AnimatePresence>
    </div>
  );
};

```

<!-- path: components/navigation/sidebar-components/MobileSidebar.tsx -->
```typescript
"use client";

import { motion } from "framer-motion";
import { FiX } from "react-icons/fi";
import { NavItem } from "./NavItem";
import { QuickActions } from "./QuickActions";
import { mobileOverlayVariants, mobileSidebarVariants } from "./sidebar-types";
import { NavItem as NavItemType } from "./sidebar-types";

interface MobileSidebarProps {
  isCollapsed: boolean;
  setIsCollapsed: (collapsed: boolean) => void;
  navItems: NavItemType[];
  expandedItems: string[];
  toggleExpanded: (id: string) => void;
  setHoveredItem: (item: NavItemType | null) => void;
  pathname: string;
}

export const MobileSidebar = ({
  isCollapsed,
  setIsCollapsed,
  navItems,
  expandedItems,
  toggleExpanded,
  setHoveredItem,
  pathname,
}: MobileSidebarProps) => {
  const handleBackdropClick = () => {
    setIsCollapsed(true);
  };

  if (isCollapsed) return null;

  return (
    <>
      <motion.div 
        initial="hidden"
        animate="visible"
        exit="hidden"
        variants={mobileOverlayVariants}
        className="fixed inset-0 z-40 bg-black/50 backdrop-blur-sm" 
        aria-label="Sidebar backdrop" 
        onClick={handleBackdropClick}
      />
      <motion.aside
        initial="hidden"
        animate="visible"
        exit="hidden"
        variants={mobileSidebarVariants}
        transition={{ type: "spring", damping: 30, stiffness: 300 }}
        className="fixed top-0 left-0 z-50 flex h-full w-64 flex-col border-r border-gray-200 bg-white shadow-xl dark:border-gray-800 dark:bg-gray-900 dark:text-white"
      >
        <div className="flex h-16 items-center justify-between border-b border-gray-200 px-4 dark:border-gray-800">
          <h2 className="text-lg font-semibold text-gray-900 dark:text-gray-100">
            Navigation
          </h2>
          <button 
            onClick={() => setIsCollapsed(true)} 
            className="rounded-lg p-2 transition-colors hover:bg-gray-100 dark:hover:bg-gray-800" 
            aria-label="Close sidebar"
          >
            <FiX className="h-5 w-5" />
          </button>
        </div>
        
        <div className="flex-1 overflow-y-auto py-4">
          <nav className="space-y-1" role="navigation">
            {navItems.map((item) => (
              <NavItem
                key={item.id}
                item={item}
                isCollapsed={false}
                expandedItems={expandedItems}
                toggleExpanded={toggleExpanded}
                setHoveredItem={setHoveredItem}
              />
            ))}
          </nav>
          <QuickActions
            isCollapsed={false}
            pathname={pathname}
          />
        </div>
      </motion.aside>
    </>
  );
};
```

<!-- path: components/ofc-details/OfcConnectionsFormModal.tsx -->
```typescript
// path: components/ofc-details/OfcConnectionsFormModal.tsx
"use client";

import React, { useCallback, useEffect, useMemo } from "react";
import { Modal } from "@/components/common/ui/Modal";
import { createClient } from "@/utils/supabase/client";
import { useTableInsert, useTableUpdate } from "@/hooks/database";
import { useForm } from "react-hook-form";
import { zodResolver } from "@hookform/resolvers/zod";
import { FormCard } from "@/components/common/form/FormCard";
import { FormInput, FormTextarea, FormSwitch } from "@/components/common/form/FormControls";
import { ofc_connectionsInsertSchema, Ofc_connectionsInsertSchema, Ofc_connectionsRowSchema } from "@/schemas/zod-schemas";


interface OfcConnectionsFormModalProps {
  isOpen: boolean;
  onClose: () => void;
  editingOfcConnections?: Ofc_connectionsRowSchema | null;
  onCreated?: (ofcConnections: Ofc_connectionsRowSchema) => void;
  onUpdated?: (ofcConnections: Ofc_connectionsRowSchema) => void;
}

export function OfcConnectionsFormModal({ isOpen, onClose, editingOfcConnections, onCreated, onUpdated }: OfcConnectionsFormModalProps) {
  const {
    register,
    handleSubmit,
    formState: { errors, isSubmitting },
    reset,
    control,
  } = useForm<Ofc_connectionsInsertSchema>({
    resolver: zodResolver(ofc_connectionsInsertSchema),
    defaultValues: {
      connection_category: "",
      connection_type: "",
      destination_port: null,
      en_dom: null,
      en_power_dbm: null,
      fiber_no_en: 1,
      fiber_no_sn: 1,
      fiber_role: null,
      logical_path_id: null,
      ofc_id: "",
      otdr_distance_en_km: null,
      otdr_distance_sn_km: null,
      path_segment_order: null,
      remark: null,
      route_loss_db: null,
      sn_dom: null,
      sn_power_dbm: null,
      source_port: null,
      status: null,
      system_id: null,
    },
  });

  const supabase = createClient();
  const { mutate: insertOfcConnections, isPending: creating } = useTableInsert(supabase, "ofc_connections");
  const { mutate: updateOfcConnections, isPending: updating } = useTableUpdate(supabase, "ofc_connections");

  const isEdit = useMemo(() => Boolean(editingOfcConnections), [editingOfcConnections]);

  useEffect(() => {
    if (!isOpen) return;
    if (editingOfcConnections) {
      reset({
        ...editingOfcConnections,
        sn_dom: editingOfcConnections.sn_dom,
        en_dom: editingOfcConnections.en_dom,
        en_power_dbm: editingOfcConnections.en_power_dbm ?? null,
        sn_power_dbm: editingOfcConnections.sn_power_dbm ?? null,
        otdr_distance_sn_km: editingOfcConnections.otdr_distance_sn_km ?? null,
        otdr_distance_en_km: editingOfcConnections.otdr_distance_en_km ?? null,
        route_loss_db: editingOfcConnections.route_loss_db ?? null,
      });
    } else {
      reset({
        ofc_id: "",
        logical_path_id: null,
        system_id: null,
        fiber_role: "",
        fiber_no_sn: 1,
        fiber_no_en: 1,
        path_segment_order: null,
        connection_category: "",
        connection_type: "",
        source_port: null,
        destination_port: null,
        sn_dom: undefined,
        otdr_distance_sn_km: null,
        sn_power_dbm: null,
        en_dom: undefined,
        otdr_distance_en_km: null,
        en_power_dbm: null,
        route_loss_db: undefined,
        status: true,
        remark: null,
      });
    }
  }, [isOpen, editingOfcConnections, reset]);

  const handleClose = useCallback(() => {
    if (creating || updating) return;
    onClose();
  }, [creating, updating, onClose]);

  const onValidSubmit = useCallback(
    (formData: Ofc_connectionsInsertSchema) => {
      if (isEdit && editingOfcConnections) {
        updateOfcConnections(
          { id: editingOfcConnections.id, data: formData as Partial<Ofc_connectionsInsertSchema> },
          {
            onSuccess: (data: unknown) => {
              onUpdated?.(Array.isArray(data) ? data[0] : data);
              onClose();
            },
          }
        );
      } else {
        insertOfcConnections(formData as Ofc_connectionsInsertSchema, {
          onSuccess: (data: unknown) => {
            onCreated?.(Array.isArray(data) ? data[0] : data);
            onClose();
          },
        });
      }
    },
    [isEdit, editingOfcConnections, updateOfcConnections, insertOfcConnections, onUpdated, onCreated, onClose]
  );

  const submitting = creating || updating || isSubmitting;

  return (
    <Modal isOpen={isOpen} onClose={handleClose} title={isEdit ? "Edit OFC Connection" : "Add OFC Connection"} size='full' visible={false} className='h-screen w-screen transparent bg-gray-700 rounded-2xl'>
      <FormCard title={isEdit ? "Edit OFC Connection" : "Add OFC Connection"} onSubmit={handleSubmit(onValidSubmit)} onCancel={handleClose} standalone>
        <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
            <FormInput name='fiber_no_sn' label='Start Node Fiber No. *' register={register} error={errors.fiber_no_sn} disabled={true} />
            <FormInput name='fiber_no_en' label='End Node Fiber No.' register={register} error={errors.fiber_no_en} disabled={submitting} />
            <FormInput name='path_segment_order' label='Path Segment Order' register={register} error={errors.path_segment_order} disabled={submitting} />
            <FormInput name='otdr_distance_sn_km' label='OTDR Distance SN (km)' register={register} type="number" step='0.001' error={errors.otdr_distance_sn_km} disabled={submitting} />
            <FormInput name='sn_power_dbm' label='SN Power (dBm)' register={register} type="number" step='0.01' error={errors.sn_power_dbm} disabled={submitting} />
            <FormInput name='otdr_distance_en_km' label='OTDR Distance EN (km)' register={register} type="number" step='0.001' error={errors.otdr_distance_en_km} disabled={submitting} />
            <FormInput name='en_power_dbm' label='EN Power (dBm)' register={register} type="number" step='0.01' error={errors.en_power_dbm} disabled={submitting} />
            <FormInput name='route_loss_db' label='Route Loss (dB)' register={register} type="number" step='0.01' error={errors.route_loss_db} disabled={submitting} />
        </div>
        <div className='flex items-center mt-4'>
          <FormSwitch name='status' label='Active' control={control} error={errors.status} className='my-2' />
        </div>
        <div className="mt-4">
            <FormTextarea name='remark' label='Remark' control={control} error={errors.remark} disabled={submitting} />
        </div>
      </FormCard>
    </Modal>
  );
}
```

<!-- path: components/ofc-details/CableNotFound.tsx -->
```typescript
import { ButtonSpinner } from '@/components/common/ui';
import { motion } from 'framer-motion';

// Define animation variants outside for better portability and to resolve TypeScript inference issues

const containerVariants = {
  hidden: { opacity: 0, y: -20 },
  visible: {
    opacity: 1,
    y: 0,
    transition: {
      duration: 0.5,
      staggerChildren: 0.1, // for seamless animation orchestration.
    },
  },
} as const; // Add 'as const' to enforce literal types and resolve TS errors, as variants are objects of arbitrary string keys

const bannerVariants = {
  hidden: { x: -100, opacity: 0 },
  visible: {
    x: 0,
    opacity: 1,
    transition: {
      duration: 0.6,
      delay: 0.2,
      type: 'spring', // Specify as string literal; TypeScript may infer 'string' without 'as const', but 'spring' with stiffness/damping ensures proper typing.
      stiffness: 300,
      damping: 30,
    },
  },
} as const;

const textVariants = {
  hidden: { opacity: 0 },
  visible: {
    opacity: 1,
    transition: { duration: 0.8, delay: 0.4 },
  },
} as const;

const buttonVariants = {
  hidden: { scale: 0.8, opacity: 0 },
  visible: {
    scale: 1,
    opacity: 1,
    transition: {
      duration: 0.5,
      delay: 0.6,
      type: 'spring',
      stiffness: 400,
      damping: 25,
    },
  },
  hover: {
    scale: 1.05,
    transition: { duration: 0.2 },
  },
  tap: {
    scale: 0.95,
    transition: { duration: 0.1 },
  },
} as const;

const CableNotFound = ({
  id,
  handleBackToOfcList,
  isBackClicked,
}: {
  id: string;
  handleBackToOfcList: () => void;
  isBackClicked: boolean;
}) => {
  return (
    <motion.div
      className="p-6"
      variants={containerVariants}
      initial="hidden"
      animate="visible"
    >
      <motion.div
        className="bg-gradient-to-r from-red-50 to-red-100 border-l-4 border-red-400 p-4 rounded-lg shadow-lg"
        variants={bannerVariants}
        initial="hidden"
        animate="visible"
      >
        <div className="flex">
          <div className="flex-shrink-0">
            <motion.svg
              className="h-5 w-5 text-red-400"
              viewBox="0 0 20 20"
              fill="currentColor"
              variants={bannerVariants}
              whileHover={{
                scale: 1.1,
                rotate: 5,
              }}
              whileTap={{ scale: 0.9 }}
            >
              <path
                fillRule="evenodd"
                d="M10 18a8 8 0 100-16 8 8 0 000 16zM8.28 7.22a.75.75 0 00-1.06 1.06L8.94 10l-1.72 1.72a.75.75 0 101.06 1.06L10 11.06l1.72 1.72a.75.75 0 101.06-1.06L11.06 10l1.72-1.72a.75.75 0 00-1.06-1.06L10 8.94 8.28 7.22z"
                clipRule="evenodd"
              />
            </motion.svg>
          </div>
          <div className="ml-3">
            <motion.p
              className="text-sm text-red-700 font-semibold"
              variants={textVariants}
              initial="hidden"
              animate="visible"
            >
              OFC cable with ID {id} not found.
            </motion.p>
            <motion.button
              onClick={handleBackToOfcList}
              className="mt-2 text-sm text-blue-600 hover:text-blue-800 transition-colors duration-200 flex items-center gap-2"
              variants={buttonVariants}
              initial="hidden"
              animate="visible"
              whileHover="hover"
              whileTap="tap"
            >
              {isBackClicked ? <ButtonSpinner /> : ' Back to OFC List'}
            </motion.button>
          </div>
        </div>
      </motion.div>
    </motion.div>
  );
};

export default CableNotFound;

```

<!-- path: components/ofc-details/FiberTraceModal.tsx -->
```typescript
// path: components/ofc-details/FiberTraceModal.tsx
'use client';

import { Modal, PageSpinner } from '@/components/common/ui';
import { useFiberTrace } from '@/hooks/database/path-queries';
import { FiberTraceVisualizer } from './FiberTraceVisualizer'; // Import the new visualizer
import { OfcForSelection, PathToUpdate } from '@/schemas/custom-schemas';
import { V_ofc_connections_completeRowSchema } from '@/schemas/zod-schemas';
import { useCallback } from 'react';
import { toast } from 'sonner';
import { useSyncPathFromTrace } from '@/hooks/database/route-manager-hooks';

interface FiberTraceModalProps {
  isOpen: boolean;
  onClose: () => void;
  startSegmentId: string | null; 
  fiberNo: number | null;
  allCables: OfcForSelection[] | undefined;
  record?: V_ofc_connections_completeRowSchema;
  refetch: () => void;
}

export const FiberTraceModal: React.FC<FiberTraceModalProps> = ({ isOpen, onClose, startSegmentId, fiberNo, allCables, record, refetch }) => {
  const { data: traceData, isLoading, isError, error } = useFiberTrace(startSegmentId, fiberNo);

  console.log("traceData", traceData);

  const syncPathMutation = useSyncPathFromTrace();

  // The sync logic now moves into the action definition
  const handleSyncPath = async () => {

    if (!traceData || !record?.id) {
      toast.error("Cannot sync: Trace data or record ID is missing.");
      return;
    }

      const firstSegment = traceData.find((s) => s.element_type === "SEGMENT");
      const lastSegment = [...traceData].reverse().find((s) => s.element_type === "SEGMENT");
      // Find start Node Id and Fiber Number
      const updated_start_fiber_no = firstSegment?.fiber_in;
      const updated_end_fiber_no = lastSegment?.fiber_out;

      if (!firstSegment?.start_node_id || !lastSegment?.end_node_id) {
        toast.error("Cannot sync: Trace is incomplete.");
        return;
    }

      // Ensure fiber numbers are valid numbers
      const startFiberNo = updated_start_fiber_no ?? 0;
      const endFiberNo = updated_end_fiber_no ?? 0;

      if (startFiberNo === 0 || endFiberNo === 0) {
        toast.error("Cannot sync: Invalid fiber numbers in trace.");
        return;
      }

      // Step 2: Manually construct the payload for the update RPC
      const payload: PathToUpdate = {
        p_id: record.id,
        p_start_node_id: firstSegment.start_node_id,
        p_start_fiber_no: startFiberNo,
        p_end_node_id: lastSegment.end_node_id,
        p_end_fiber_no: endFiberNo,
      };

      // Step 3: Call the sync mutation with the constructed payload
      syncPathMutation.mutate(payload, {
        onSuccess: () => {
            refetch(); // Refetch the main data table
            onClose(); // Close the modal on success
        }
    });
  };

  const startingCableName = allCables?.find(c => c.id === startSegmentId)?.route_name || 'Selected Route';

  const renderContent = () => {
    if (isLoading) return <PageSpinner text="Tracing fiber path..." />;
    if (isError) return <div className="p-4 text-red-500">Error tracing path: {error.message}</div>;
    if (!traceData) return <div className="p-4 text-gray-500">Path could not be traced.</div>;

    return <FiberTraceVisualizer traceData={traceData} onSync={handleSyncPath} isSyncing={syncPathMutation.isPending} />;
  };

  return (
    <Modal
      isOpen={isOpen}
      onClose={onClose}
      title={`End-to-End Trace for Fiber #${fiberNo} on ${startingCableName}`}
      size="xl"
    >
      <div className="overflow-y-auto py-4 max-h-[70vh]">
        {renderContent()}
      </div>
    </Modal>
  );
};
```

<!-- path: components/ofc-details/FiberTraceVisualizer.tsx -->
```typescript
// path: components/ofc-details/FiberTraceVisualizer.tsx
"use client";

import { Button } from "@/components/common/ui";
import { useSyncPathFromTrace, useSyncPathUpdates } from "@/hooks/database/route-manager-hooks";
import { FiberTraceSegment, PathToUpdate } from "@/schemas/custom-schemas";
import { Cable, GitBranch, MapPin, Milestone, RefreshCw, Route } from "lucide-react";

interface FiberTraceVisualizerProps {
  traceData: FiberTraceSegment[];
  onSync: () => void;
  isSyncing: boolean;
}

const SegmentStep = ({ item }: { item: FiberTraceSegment }) => {
  return (
    <li className='mb-10 ml-8'>
      <span className='absolute -left-4 flex h-8 w-8 items-center justify-center rounded-full bg-blue-100 ring-8 ring-white dark:bg-blue-900 dark:ring-gray-900'>
        <Route className='h-4 w-4 text-blue-600 dark:text-blue-300' />
      </span>
      <div className='rounded-lg border border-gray-200 bg-white p-4 shadow-sm dark:border-gray-700 dark:bg-gray-800'>
        <div className='mb-2 flex items-center justify-between'>
          <h3 className='text-md font-semibold text-gray-900 dark:text-white'>{item.element_name}</h3>
          <span className='rounded-full bg-blue-100 px-2.5 py-0.5 text-xs font-semibold text-blue-800 dark:bg-blue-900 dark:text-blue-300'>SEGMENT</span>
        </div>
        <p className='mb-3 text-sm font-normal text-gray-500 dark:text-gray-400'>{item.details}</p>
        <div className='grid grid-cols-2 gap-2 text-xs text-gray-700 dark:text-gray-300'>
          <span>
            <strong>Fiber:</strong> <span className='font-mono'>{item.fiber_in}</span>
          </span>
          <span>
            <strong>Length:</strong> <span className='font-mono'>{item.distance_km?.toFixed(2)} km</span>
          </span>
        </div>
      </div>
    </li>
  );
};

// Small helper component for rendering a single SPLICE step
const SpliceStep = ({ item, prevStep }: { item: FiberTraceSegment; prevStep: FiberTraceSegment | undefined }) => {
  // Gracefully handle the case where the first fiber_in is null
  const fiberIn = item.fiber_in ?? prevStep?.fiber_out;

  return (
    <li className='mb-10 ml-8'>
      <span className='absolute -left-4 flex h-8 w-8 items-center justify-center rounded-full bg-gray-100 ring-8 ring-white dark:bg-gray-700 dark:ring-gray-900'>
        <GitBranch className='h-4 w-4 text-gray-600 dark:text-gray-300' />
      </span>
      <div className='rounded-lg border border-dashed border-gray-300 bg-gray-50 p-4 dark:border-gray-600 dark:bg-gray-800/50'>
        <div className='mb-2 flex items-center justify-between'>
          <h3 className='text-md font-semibold text-gray-900 dark:text-white'>{item.element_name}</h3>
          <span className='rounded-full bg-gray-200 px-2.5 py-0.5 text-xs font-semibold text-gray-800 dark:bg-gray-700 dark:text-gray-300'>SPLICE</span>
        </div>
        <p className='mb-3 text-sm font-normal text-gray-500 dark:text-gray-400'>{item.details}</p>
        <div className='grid grid-cols-2 gap-2 text-xs text-gray-700 dark:text-gray-300'>
          <span>
            <strong>In → Out:</strong>{" "}
            <span className='font-mono font-bold'>
              {fiberIn} → {item.fiber_out}
            </span>
          </span>
          <span>
            <strong>Loss:</strong> <span className='font-mono'>{item.loss_db?.toFixed(2)} dB</span>
          </span>
        </div>
      </div>
    </li>
  );
};

export const FiberTraceVisualizer: React.FC<FiberTraceVisualizerProps> = ({ traceData, onSync, isSyncing }) => {
  const syncPathMutation = useSyncPathFromTrace();

  // Extract start and end node names from the details of the first and last segments
  const firstSegment = traceData.find((s) => s.element_type === "SEGMENT");
  const lastSegment = [...traceData].reverse().find((s) => s.element_type === "SEGMENT");
  const startNodeName = firstSegment?.details.match(/^(?:Segment \d+ \()(.+?)(?: →)/)?.[1] || "Unknown Start";
  const endNodeName = lastSegment?.details.match(/(?:→ )(.+?)(?:\))$/)?.[1] || "Unknown End";

  if (!traceData || traceData.length === 0) {
    return (
      <div className='p-8 text-center text-gray-500 dark:text-gray-400'>
        <Cable className='mx-auto h-12 w-12 text-gray-400 dark:text-gray-500' />
        <h4 className='mt-4 text-lg font-semibold text-gray-800 dark:text-gray-200'>No Trace Data</h4>
        <p className='mt-2 text-sm'>Could not find a path for this fiber.</p>
      </div>
    );
  }

  return (
    <div className='p-4 font-sans relative'>
      <Button 
        className='absolute top-0 right-10 z-10 animate-pulse' 
        onClick={onSync}
        disabled={isSyncing}
        leftIcon={isSyncing ? <RefreshCw className="animate-spin" /> : <RefreshCw />}
      >
        {isSyncing ? "Syncing..." : "Sync Path to DB"}
      </Button>
      <ol className='relative border-l-2 border-gray-300 dark:border-gray-700 ml-4'>
        {/* START POINT */}
        <li className='mb-10 ml-8'>
          <span className='absolute -left-4 flex h-8 w-8 items-center justify-center rounded-full bg-green-100 ring-8 ring-white dark:bg-green-900 dark:ring-gray-900'>
            <MapPin className='h-4 w-4 text-green-600 dark:text-green-300' />
          </span>
          <h3 className='text-lg font-semibold text-gray-900 dark:text-white'>{startNodeName}</h3>
          <p className='text-sm text-gray-500 dark:text-gray-400'>Path Start</p>
        </li>

        {/* DYNAMIC PATH STEPS */}
        {traceData.map((item, index) => {
          if (item.element_type === "SEGMENT") {
            return <SegmentStep key={`${item.element_id}-${index}`} item={item} />;
          } else if (item.element_type === "SPLICE") {
            const prevStep = traceData[index - 1];
            return <SpliceStep key={`${item.element_id}-${index}`} item={item} prevStep={prevStep} />;
          }
          return null;
        })}

        {/* END POINT */}
        <li className='ml-8'>
          <span className='absolute -left-4 flex h-8 w-8 items-center justify-center rounded-full bg-red-100 ring-8 ring-white dark:bg-red-900 dark:ring-gray-900'>
            <Milestone className='h-4 w-4 text-red-600 dark:text-red-300' />
          </span>
          <h3 className='text-lg font-semibold text-gray-900 dark:text-white'>{endNodeName}</h3>
          <p className='text-sm text-gray-500 dark:text-gray-400'>Path End</p>
        </li>
      </ol>
    </div>
  );
};

```

<!-- path: components/ofc-details/OfcDetailsHeader.tsx -->
```typescript
import React from 'react';
import { motion, Variants } from 'framer-motion';
import { Cable, Calendar, MapPin, Settings, Hash, Route, LucideIcon } from 'lucide-react';
import { StatusBadge } from '@/components/common/ui/badges/StatusBadge';
import { Row } from '@/hooks/database';

interface OfcDetailsHeaderProps {
    cable: Row<'v_ofc_cables_complete'>;
}
  
  const OfcDetailsHeader: React.FC<OfcDetailsHeaderProps> = ({ cable }) => {
    const containerVariants: Variants = {
      hidden: { opacity: 0 },
      visible: {
        opacity: 1,
        transition: {
          staggerChildren: 0.1,
          delayChildren: 0.2
        }
      }
    };
  
    const cardVariants: Variants = {
      hidden: { 
        opacity: 0, 
        y: 20,
        scale: 0.95
      },
      visible: { 
        opacity: 1, 
        y: 0,
        scale: 1,
        transition: {
          type: "spring" as const,
          stiffness: 100,
          damping: 15
        }
      }
    };
  
    const itemVariants: Variants = {
      hidden: { opacity: 0, x: -10 },
      visible: { 
        opacity: 1, 
        x: 0,
        transition: {
          type: "spring" as const,
          stiffness: 150,
          damping: 20
        }
      }
    };
  
    interface InfoItemProps {
      icon: LucideIcon;
      label: string;
      value: string;
      delay?: number;
    }
  
    const InfoItem: React.FC<InfoItemProps> = ({ icon: Icon, label, value }) => (
      <motion.div 
        variants={itemVariants}
        className="flex items-center justify-between py-3 px-1 rounded-lg hover:bg-gray-50 dark:hover:bg-gray-800/50 transition-colors duration-200"
      >
        <div className="flex items-center gap-3">
          <div className="p-1.5 rounded-lg bg-blue-50 dark:bg-blue-900/20 text-blue-600 dark:text-blue-400">
            <Icon size={16} />
          </div>
          <span className="text-gray-600 dark:text-gray-400 font-medium text-sm">
            {label}
          </span>
        </div>
        <span className="font-semibold text-gray-900 dark:text-gray-100 text-sm max-w-[60%] text-right truncate">
          {value}
        </span>
      </motion.div>
    );
  
    return (
      <motion.div 
        variants={containerVariants}
        initial="hidden"
        animate="visible"
        className="grid grid-cols-1 lg:grid-cols-2 gap-6 mb-8"
      >
        {/* Summary Card */}
        <motion.div 
          variants={cardVariants}
          whileHover={{ 
            y: -2,
            boxShadow: "0 10px 25px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05)"
          }}
          className="group relative overflow-hidden rounded-xl border border-gray-200 dark:border-gray-700 bg-white dark:bg-gray-800 shadow-sm hover:shadow-lg transition-all duration-300"
        >
          {/* Gradient Background */}
          <div className="absolute inset-0 bg-gradient-to-br from-blue-50/50 via-transparent to-indigo-50/30 dark:from-blue-900/10 dark:via-transparent dark:to-indigo-900/10" />
          
          {/* Decorative Element */}
          <div className="absolute top-0 right-0 w-32 h-32 bg-gradient-to-bl from-blue-100/20 to-transparent dark:from-blue-800/10 rounded-bl-full" />
          
          <div className="relative p-6">
            <motion.div 
              className="flex items-center gap-3 mb-6"
              initial={{ opacity: 0, y: -10 }}
              animate={{ opacity: 1, y: 0 }}
              transition={{ delay: 0.3 }}
            >
              <div className="p-2.5 rounded-xl bg-gradient-to-r from-blue-500 to-indigo-600 text-white shadow-lg">
                <Cable size={20} />
              </div>
              <h2 className="text-xl font-bold bg-gradient-to-r from-gray-900 to-gray-700 dark:from-gray-100 dark:to-gray-300 bg-clip-text text-transparent">
                Summary
              </h2>
            </motion.div>
            
            <motion.div 
              variants={containerVariants}
              className="space-y-1"
            >
              <InfoItem 
                icon={Hash}
                label="Asset No."
                value={String(cable.asset_no ?? '-')}
              />
              <InfoItem 
                icon={Route}
                label="Route Name"
                value={String(cable.route_name ?? '-')}
              />
              <motion.div 
                variants={itemVariants}
                className="flex items-center justify-between py-3 px-1 rounded-lg hover:bg-gray-50 dark:hover:bg-gray-800/50 transition-colors duration-200"
              >
                <div className="flex items-center gap-3">
                  <div className="p-1.5 rounded-lg bg-blue-50 dark:bg-blue-900/20 text-blue-600 dark:text-blue-400">
                    <Settings size={16} />
                  </div>
                  <span className="text-gray-600 dark:text-gray-400 font-medium text-sm">
                    Status
                  </span>
                </div>
                <StatusBadge status={cable.status || 'Unknown'} />
              </motion.div>
            </motion.div>
          </div>
        </motion.div>
  
        {/* Metadata Card */}
        <motion.div 
          variants={cardVariants}
          whileHover={{ 
            y: -2,
            boxShadow: "0 10px 25px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05)"
          }}
          className="group relative overflow-hidden rounded-xl border border-gray-200 dark:border-gray-700 bg-white dark:bg-gray-800 shadow-sm hover:shadow-lg transition-all duration-300"
        >
          {/* Gradient Background */}
          <div className="absolute inset-0 bg-gradient-to-br from-emerald-50/50 via-transparent to-teal-50/30 dark:from-emerald-900/10 dark:via-transparent dark:to-teal-900/10" />
          
          {/* Decorative Element */}
          <div className="absolute top-0 right-0 w-32 h-32 bg-gradient-to-bl from-emerald-100/20 to-transparent dark:from-emerald-800/10 rounded-bl-full" />
          
          <div className="relative p-6">
            <motion.div 
              className="flex items-center gap-3 mb-6"
              initial={{ opacity: 0, y: -10 }}
              animate={{ opacity: 1, y: 0 }}
              transition={{ delay: 0.4 }}
            >
              <div className="p-2.5 rounded-xl bg-gradient-to-r from-emerald-500 to-teal-600 text-white shadow-lg">
                <Settings size={20} />
              </div>
              <h2 className="text-xl font-bold bg-gradient-to-r from-gray-900 to-gray-700 dark:from-gray-100 dark:to-gray-300 bg-clip-text text-transparent">
                Metadata
              </h2>
            </motion.div>
            
            <motion.div 
              variants={containerVariants}
              className="space-y-1"
            >
              <InfoItem 
                icon={Cable}
                label="OFC Type"
                value={cable?.ofc_type_name || '-'}
              />
              <InfoItem 
                icon={MapPin}
                label="Maintenance Area"
                value={cable?.maintenance_area_name || '-'}
              />
              <InfoItem 
                icon={Calendar}
                label="Commissioned On"
                value={
                  cable.commissioned_on
                    ? new Date(String(cable.commissioned_on)).toLocaleDateString('en-US', {
                        year: 'numeric',
                        month: 'short',
                        day: 'numeric'
                      })
                    : '-'
                }
              />
            </motion.div>
          </div>
        </motion.div>
      </motion.div>
    );
  };
  
  export default OfcDetailsHeader;
```

<!-- path: components/home/HeroContent.tsx -->
```typescript
import {
  motion,
  MotionValue,
  TargetAndTransition,
  Variants,
} from "framer-motion";
import { useRouter } from "next/navigation";
import { useState } from "react";
import { LoadingSpinner } from "../common/ui/LoadingSpinner";

interface HeroContentProps {
  variants: {
    containerVariants: Variants;
    titleVariants: Variants;
    subtitleVariants: Variants;
    highlightVariants: Variants;
    ctaVariants: Variants;
  };
  floatingAnimation: TargetAndTransition;
  textY: MotionValue<number>;
}

export default function HeroContent({
  variants,
  floatingAnimation,
  textY,
}: HeroContentProps) {
  const [loading, setLoading] = useState(false);
  const router = useRouter();

  const handleGetStarted = (e: React.MouseEvent<HTMLButtonElement>) => {
    e.preventDefault();
    setLoading(true);
    router.push("/dashboard");
    // setTimeout(() => {
    //   router.push("/dashboard");
    // }, 1000); // Simulate loading for 1 second
  };
  return (
    <motion.div
      className="mx-auto flex max-w-6xl flex-col items-center justify-center px-4 text-center sm:px-6 overflow-hidden"
      style={{ y: textY }}
      variants={variants.containerVariants}
      initial="hidden"
      animate="visible"
    >
      {/* Floating badge */}
      <motion.div
        variants={variants.ctaVariants}
        animate={floatingAnimation}
        className="mb-6 rounded-full border border-red-400/40 bg-gradient-to-r from-red-500/20 to-purple-500/20 px-4 py-2 text-red-200 shadow-lg backdrop-blur-md sm:mb-8 sm:px-6 sm:py-3 dark:border-blue-400/40 dark:from-blue-500/20 dark:to-cyan-500/20 dark:text-blue-200"
      >
        <span className="text-xs font-semibold tracking-wide sm:text-sm">
          🚀 Advanced Database Management
        </span>
      </motion.div>

      {/* Title */}
      <motion.h1
        variants={variants.titleVariants}
        className="relative mb-4 text-3xl leading-tight font-black text-white sm:mb-6 sm:text-4xl md:text-5xl lg:text-6xl xl:text-7xl dark:text-gray-100"
      >
        <span className="mb-1 block text-2xl sm:mb-2 sm:text-3xl md:text-4xl lg:text-5xl xl:text-6xl">
          Welcome to
        </span>
        <span className="block bg-gradient-to-r from-red-400 via-red-500 to-orange-500 bg-clip-text text-3xl font-extrabold text-transparent sm:text-4xl md:text-5xl lg:text-6xl xl:text-7xl dark:from-blue-400 dark:via-purple-500 dark:to-cyan-400">
          Harinavi Transmission
        </span>
        <span className="mt-1 block text-2xl font-semibold text-gray-200 sm:mt-2 sm:text-3xl md:text-4xl lg:text-5xl xl:text-6xl dark:text-gray-300">
          Record Database
        </span>
      </motion.h1>

      {/* Subtitle */}
      <motion.p
        variants={variants.subtitleVariants}
        className="mb-6 max-w-xs px-2 text-base leading-relaxed text-gray-300 sm:mb-8 sm:max-w-2xl sm:px-0 sm:text-lg md:text-xl lg:max-w-3xl lg:text-2xl dark:text-gray-400"
      >
        Secure, reliable, and efficient database management for transmission
        records
      </motion.p>

      {/* CTA buttons */}
      <motion.div
        variants={variants.ctaVariants}
        className="mt-2 flex w-full max-w-xs flex-col gap-3 px-4 sm:mt-4 sm:max-w-md sm:flex-row sm:gap-4 sm:px-0"
      >
        <motion.button
          whileHover={{
            scale: 1.02,
            boxShadow: "0 10px 30px rgba(239, 68, 68, 0.3)",
          }}
          whileTap={{ scale: 0.98 }}
          className="flex w-full items-center justify-center gap-2 rounded-xl border border-red-400/30 bg-gradient-to-r from-red-500 to-red-600 px-6 py-3 text-base font-bold text-white shadow-xl transition-all hover:from-red-600 hover:to-red-700 sm:px-8 sm:py-4 sm:text-lg dark:from-red-600 dark:to-red-700 dark:hover:from-red-700 dark:hover:to-red-800"
          disabled={loading}
          onClick={handleGetStarted}
        >
          {loading ? (
            <LoadingSpinner size="sm" color="white" />
          ) : (
            "Get Started"
          )}
        </motion.button>
      </motion.div>
    </motion.div>
  );
}

```

<!-- path: components/home/ParticlesOverlay.tsx -->
```typescript
"use client"
import { motion } from "framer-motion";
import { useEffect, useState } from "react";

export default function ParticlesOverlay() {
  const [isDarkMode, setIsDarkMode] = useState(false);

  useEffect(() => {
    const mediaQuery = window.matchMedia('(prefers-color-scheme: dark)');
    setIsDarkMode(mediaQuery.matches);
    
    const handler = (e: MediaQueryListEvent) => setIsDarkMode(e.matches);
    mediaQuery.addEventListener('change', handler);
    
    return () => mediaQuery.removeEventListener('change', handler);
  }, []);

  // Colors that adapt to dark/light mode
  const colors = {
    red: isDarkMode 
      ? { gradient: 'rgba(239, 68, 68, 0.8)' } 
      : { gradient: 'rgba(220, 38, 38, 0.6)' },
    purple: isDarkMode 
      ? { gradient: 'rgba(168, 85, 247, 0.8)' } 
      : { gradient: 'rgba(147, 51, 234, 0.6)' },
    white: isDarkMode 
      ? { gradient: 'rgba(255, 255, 255, 0.4)' } 
      : { gradient: 'rgba(255, 255, 255, 0.2)' }
  };

  return (
    <div className="fixed inset-0 z-5 pointer-events-none">
      {/* Animated particles */}
      {[...Array(12)].map((_, i) => (
        <motion.div
          key={i}
          className="absolute rounded-full"
          style={{
            left: `${Math.random() * 100}%`,
            top: `${Math.random() * 100}%`,
            width: `${4 + Math.random() * 8}px`,
            height: `${4 + Math.random() * 8}px`,
            background: i % 3 === 0 
              ? `radial-gradient(circle, ${colors.red.gradient}, transparent 70%)`
              : i % 3 === 1
              ? `radial-gradient(circle, ${colors.purple.gradient}, transparent 70%)`
              : `radial-gradient(circle, ${colors.white.gradient}, transparent 70%)`,
            boxShadow: i % 3 === 0 
              ? `0 0 20px rgba(239, 68, 68, ${isDarkMode ? 0.6 : 0.4})`
              : i % 3 === 1
              ? `0 0 20px rgba(168, 85, 247, ${isDarkMode ? 0.6 : 0.4})`
              : `0 0 15px rgba(255, 255, 255, ${isDarkMode ? 0.5 : 0.3})`,
          }}
          animate={{
            scale: [1, 1.5, 1],
            opacity: [0.3, 0.8, 0.3],
            x: [0, Math.random() * 50 - 25, 0],
            y: [0, Math.random() * 50 - 25, 0],
          }}
          transition={{
            duration: 4 + Math.random() * 3,
            repeat: Infinity,
            delay: Math.random() * 2,
            ease: "easeInOut",
          }}
        />
      ))}
      
      {/* Floating geometric shapes */}
      {[...Array(6)].map((_, i) => (
        <motion.div
          key={`shape-${i}`}
          className="absolute"
          style={{
            left: `${20 + i * 12}%`,
            top: `${20 + (i % 3) * 20}%`,
            width: `${isDarkMode ? 3 : 2}px`,
            height: `${isDarkMode ? 3 : 2}px`,
          }}
          animate={{
            rotate: [0, 360],
            scale: [1, 1.5, 1],
            opacity: [0.2, 0.6, 0.2],
          }}
          transition={{
            duration: 8 + i,
            repeat: Infinity,
            delay: i * 0.5,
          }}
        >
          <div 
            className="w-full h-full rounded-full"
            style={{
              background: `radial-gradient(circle, ${colors.white.gradient}, transparent 70%)`,
              boxShadow: `0 0 ${isDarkMode ? 15 : 10}px ${colors.white.gradient}`
            }}
          />
        </motion.div>
      ))}
    </div>
  );
}
```

<!-- path: components/home/ScrollIndicator.tsx -->
```typescript
"use client";
import { motion } from "framer-motion";
import { useEffect, useState } from "react";

export default function ScrollIndicator() {
  const [isDarkMode, setIsDarkMode] = useState(false);

  useEffect(() => {
    const mediaQuery = window.matchMedia('(prefers-color-scheme: dark)');
    setIsDarkMode(mediaQuery.matches);
    
    const handler = (e: MediaQueryListEvent) => setIsDarkMode(e.matches);
    mediaQuery.addEventListener('change', handler);
    
    return () => mediaQuery.removeEventListener('change', handler);
  }, []);

  return (
    <motion.div
      initial={{ opacity: 0, y: 20 }}
      animate={{ opacity: 1, y: 0 }}
      transition={{ delay: 3.5, duration: 1 }}
      className="fixed bottom-4 left-1/2 z-30 hidden -translate-x-1/2 transform sm:bottom-8 md:block"
    >
      <motion.div
        animate={{ y: [0, 8, 0] }}
        transition={{
          duration: 2,
          repeat: Infinity,
          ease: "easeInOut",
        }}
        className="flex flex-col items-center space-y-2"
      >
        {/* Mouse indicator */}
        <div className={`
          relative flex justify-center rounded-full border-2 shadow-lg backdrop-blur-sm
          h-8 w-5 sm:h-10 sm:w-6
          ${isDarkMode 
            ? "border-gray-300/70 bg-gray-800/30" 
            : "border-white/70 bg-white/20"}
        `}>
          <motion.div
            animate={{ 
              y: [2, 10, 2], 
              opacity: [1, 0.3, 1] 
            }}
            transition={{
              duration: 2,
              repeat: Infinity,
              ease: "easeInOut",
            }}
            className={`
              mt-1 rounded-full shadow-sm
              h-2 w-0.5 sm:h-3 sm:w-1
              ${isDarkMode ? "bg-gray-300" : "bg-white"}
            `}
          />
        </div>
        
        {/* Scroll text */}
        <motion.span
          initial={{ opacity: 0 }}
          animate={{ opacity: 1 }}
          transition={{ delay: 4.5 }}
          className={`text-xs font-medium tracking-wider ${
            isDarkMode ? "text-gray-300/80" : "text-white/80"
          }`}
        >
          <small>Harinavi Transmission</small>
        </motion.span>
      </motion.div>
    </motion.div>
  );
}
```

<!-- path: components/home/StatsHighlights.tsx -->
```typescript
"use client"
import { motion } from "framer-motion";

export default function StatsHighlights() {
  const stats = [
    { number: "99.9%", label: "Uptime Guarantee", icon: "⚡" },
    { number: "256-bit", label: "AES Encryption", icon: "🔒" },
    { number: "Real-Time", label: "Data Insights", icon: "📈" }
  ];

  return (
    <motion.div
      initial={{ opacity: 0, y: 40 }}
      animate={{ opacity: 1, y: 0 }}
      transition={{ duration: 0.8, delay: 2.2 }}
      className="mt-8 sm:mt-16 grid grid-cols-1 sm:grid-cols-3 gap-4 sm:gap-6 max-w-xs sm:max-w-4xl w-full px-4"
    >
      {stats.map((stat, index) => (
        <motion.div
          key={index}
          initial={{ opacity: 0, y: 20, scale: 0.9 }}
          animate={{ opacity: 1, y: 0, scale: 1 }}
          transition={{ 
            duration: 0.6, 
            delay: 2.5 + index * 0.15,
            type: "spring",
            stiffness: 100
          }}
          whileHover={{ 
            scale: 1.05, 
            y: -5,
            transition: { duration: 0.2 }
          }}
          className="group relative p-4 sm:p-6 rounded-2xl backdrop-blur-lg border bg-gradient-to-br from-white/10 to-white/5 dark:from-gray-800/40 dark:to-gray-900/20 border-white/20 dark:border-gray-600/30 shadow-xl hover:shadow-2xl transition-all duration-300"
        >
          {/* Background glow effect */}
          <div className="absolute inset-0 rounded-2xl bg-gradient-to-r from-red-500/10 to-purple-500/10 dark:from-blue-500/10 dark:to-cyan-500/10 opacity-0 group-hover:opacity-100 transition-opacity duration-300" />
          
          <div className="relative z-10 text-center">
            {/* Icon */}
            <motion.div
              initial={{ scale: 0, rotate: -180 }}
              animate={{ scale: 1, rotate: 0 }}
              transition={{ 
                duration: 0.6, 
                delay: 2.7 + index * 0.1,
                type: "spring",
                stiffness: 200
              }}
              className="text-2xl sm:text-3xl mb-2 sm:mb-3"
            >
              {stat.icon}
            </motion.div>
            
            {/* Number */}
            <motion.div
              initial={{ scale: 0 }}
              animate={{ scale: 1 }}
              transition={{ 
                duration: 0.5, 
                delay: 2.8 + index * 0.1, 
                type: "spring", 
                stiffness: 200 
              }}
              className="text-2xl sm:text-3xl md:text-4xl font-black bg-gradient-to-r from-red-400 to-orange-500 dark:from-blue-400 dark:to-cyan-400 bg-clip-text text-transparent mb-1 sm:mb-2"
            >
              {stat.number}
            </motion.div>
            
            {/* Label */}
            <div className="text-xs sm:text-sm font-semibold text-gray-200 dark:text-gray-300 tracking-wide">
              {stat.label}
            </div>
          </div>
        </motion.div>
      ))}
    </motion.div>
  );
}
```

<!-- path: components/home/variants.ts -->
```typescript
import { TargetAndTransition, Variants } from "framer-motion";

export const containerVariants: Variants = {
  hidden: { opacity: 0 },
  visible: {
    opacity: 1,
    transition: {
      duration: 0.8,
      staggerChildren: 0.3,
      ease: "easeOut"
    },
  },
};

export const titleVariants: Variants = {
  hidden: { 
    opacity: 0, 
    y: 60, 
    scale: 0.8 
  },
  visible: {
    opacity: 1,
    y: 0,
    scale: 1,
    transition: { 
      duration: 1.2,
      type: "spring",
      stiffness: 100,
      damping: 12
    },
  },
};

export const subtitleVariants: Variants = {
  hidden: { 
    opacity: 0, 
    y: 40 
  },
  visible: {
    opacity: 1,
    y: 0,
    transition: {
      duration: 0.8,
      delay: 0.2,
      ease: [0.25, 0.1, 0.25, 1] as [number, number, number, number],
    },
  },
};

export const highlightVariants: Variants = {
  hidden: { 
    opacity: 0,
    scaleX: 0,
    transformOrigin: "left"
  },
  visible: {
    opacity: 1,
    scaleX: 1,
    transition: {
      duration: 1.2,
      delay: 1.5,
      ease: [0.25, 0.1, 0.25, 1] as [number, number, number, number],
    },
  },
};

export const ctaVariants: Variants = {
  hidden: { 
    opacity: 0, 
    y: 30, 
    scale: 0.9 
  },
  visible: {
    opacity: 1,
    y: 0,
    scale: 1,
    transition: { 
      duration: 0.8, 
      delay: 0.5,
      type: "spring",
      stiffness: 120,
      damping: 10
    },
  },
};

export const floatingAnimation: TargetAndTransition = {
  y: [-8, 8, -8],
  rotate: [-1, 1, -1],
  transition: {
    duration: 6,
    repeat: Infinity,
    ease: "easeInOut",
  },
};
```

<!-- path: components/home/AnimatedBackground.tsx -->
```typescript
"use client"
import Image from "next/image";
import { motion, useScroll, useTransform } from "framer-motion";
import { useState, useEffect } from "react";
import HnvImg from "@/public/hnv.webp";
import HnvImgMobile from "@/public/hnvmobile.webp";
import useIsMobile from "@/hooks/useIsMobile";

export default function AnimatedBackground() {
  const { scrollY } = useScroll();
  const backgroundY = useTransform(scrollY, [0, 500], [0, 150]);
  const isMobile = useIsMobile();
  const [isDarkMode, setIsDarkMode] = useState(false);

  useEffect(() => {
    // Check for dark mode preference
    const mediaQuery = window.matchMedia('(prefers-color-scheme: dark)');
    setIsDarkMode(mediaQuery.matches);
    
    const handler = (e: MediaQueryListEvent) => setIsDarkMode(e.matches);
    mediaQuery.addEventListener('change', handler);
    
    return () => mediaQuery.removeEventListener('change', handler);
  }, []);

  return (
    <>
      {/* Dynamic gradient overlay that adjusts for dark mode */}
      <div className={`fixed inset-0 z-0 transition-opacity duration-500 ${
        isDarkMode 
          ? "bg-gradient-to-b from-black/70 via-black/40 to-black/70" 
          : "bg-gradient-to-b from-black/40 via-transparent to-black/40"
      }`} />
      
      <motion.div 
        className="fixed inset-0 -z-10" 
        style={{ y: backgroundY }}
      >
        <Image
          src={isMobile ? HnvImgMobile : HnvImg}
          alt="Harinavi Transmission Background"
          fill
          className={`transition-all duration-700 object-cover ${
            isDarkMode ? "opacity-50" : "opacity-80"
          }`}
          priority
          quality={90}
          sizes="100vw"
          placeholder="blur"
          blurDataURL="data:image/jpeg;base64,/9j/4AAQSkZJRgABAQAAAQABAAD/2wBDAAYEBQYFBAYGBQYHBwYIChAKCgkJChQODwwQFxQYGBcUFhYaHSUfGhsjHBYWICwgIyYnKSopGR8tMC0oMCUoKSj/2wBDAQcHBwoIChMKChMoGhYaKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCj/wAARCAABAAEDASIAAhEBAxEB/8QAFQABAQAAAAAAAAAAAAAAAAAAAAv/xAAhEAACAQMDBQAAAAAAAAAAAAABAgMABAUGIWGRkqGx0f/EABUBAQEAAAAAAAAAAAAAAAAAAAMF/8QAGhEAAgIDAAAAAAAAAAAAAAAAAAECEgMRkf/aAAwDAQACEQMRAD8AltJagyeH0AthI5xdrLcNM91BF5pX2HaH9bcfaSXWGaRmknyJckliyjqTzSlT54b6bk+h0R//2Q=="
        />
      </motion.div>
    </>
  );
}
```

<!-- path: components/route-manager/JcFormModal.tsx -->
```typescript
// path: components/route-manager/JcFormModal.tsx
'use client';

import { useEffect, useMemo } from 'react';
import { z } from 'zod';
import { useForm } from 'react-hook-form';
import { zodResolver } from '@hookform/resolvers/zod';
import { Modal } from '@/components/common/ui';
import { FormCard, FormInput, FormSearchableSelect } from '@/components/common/form';
import { createClient } from '@/utils/supabase/client';
import { toast } from 'sonner';
import { junction_closuresInsertSchema } from '@/schemas/zod-schemas';
import { Filters, useTableQuery } from '@/hooks/database';
import { Option } from '@/components/common/ui/select/SearchableSelect';
import { JointBox } from '@/schemas/custom-schemas';


interface JcFormModalProps {
  isOpen: boolean;
  onClose: () => void;
  onSave: () => void; // Callback to trigger a refetch
  routeId: string | null;
  editingJc: JointBox | null;
  rkm: number | null;
}

export const JcFormModal: React.FC<JcFormModalProps> = ({ isOpen, onClose, onSave, routeId, editingJc, rkm }) => {
  const supabase = createClient();
  const isEditMode = !!editingJc;

  // Get the JC Lists
  const serverFilters = useMemo(() => {
      const f: Filters = {
        // Filter to download only categories with name not equal to "DEFAULT" and NODE_TYPES equal to "Joint / Splice Point"
        node_type_code: { operator: 'eq', value: 'BJC' },
        name: { operator: 'neq', value: 'DEFAULT' },
      };
      return f;
    }, []);
  const { data: jcLists } = useTableQuery(supabase, 'v_nodes_complete', { filters: serverFilters, columns: 'id, name, latitude, longitude' });

  // Local form schema: only validate the fields this form actually collects
  const junction_closuresFormSchema = junction_closuresInsertSchema.pick({
    node_id: true,
    position_km: true,
  });
  type JcFormValues = z.infer<typeof junction_closuresFormSchema>;

  const {
    register,
    handleSubmit,
    reset,
    control,
    watch,
    formState: { errors, isSubmitting },
  } = useForm<JcFormValues>({
    resolver: zodResolver(junction_closuresFormSchema),
    defaultValues: {
      node_id: '',
      position_km: null,
    },
  });

  useEffect(() => {
    if (isOpen) {
      if (editingJc) {
        // For planned equipment, we need to map the fields appropriately
        // Since JointBox doesn't have node_id, we'll need to handle this differently
        reset({
          node_id: editingJc.node_id,
          position_km: editingJc.attributes.position_on_route
            ? (editingJc.attributes.position_on_route / 100) * (rkm || 0)
            : null,
        });
      } else {
        // Start with no selection for node; leave node_id undefined
        reset({
          node_id: '',
          position_km: null,
        });
      }
    }
  }, [isOpen, editingJc, reset, jcLists, rkm]);

  const jcOptions: Option[] = (jcLists || [])
  .filter(d => d.id != null && d.name != null)
  .map((d) => ({
    value: d.id as string,    // We've filtered out nulls, so it's safe to assert
    label: d.name as string,
  }));

  // Watch selected JC (node) id
  const selectedNodeId = watch("node_id");

  // If needed, you can derive latitude/longitude from selectedNodeId for display purposes
  // but they are not part of the form schema, so we do not set them in form state.
  useEffect(() => {
    if (!selectedNodeId) return;
    // Placeholder for any side effects when node changes
  }, [selectedNodeId]);

  const handleValidSubmit = async (formData: JcFormValues) => {
    if (!routeId) {
      toast.error("No route selected to add the JC to.");
      return;
    }

    if (formData.position_km && rkm && Number(formData.position_km) > Number(rkm)) {
      toast.error("Position on route (km) cannot be greater than Cable length.");
      return;
    }

    const payload = {
      ...formData,
      ofc_cable_id: routeId,
    };

    try {
      let jcData, insertError;

      if (isEditMode && editingJc) {
        // UPDATE existing junction closure
        const { data, error } = await supabase
          .from('junction_closures')
          .update({
            node_id: payload.node_id,
            position_km: payload.position_km,
          })
          .eq('id', editingJc.id)
          .select();

        jcData = data;
        insertError = error;
      } else {
        // CREATE new junction closure using the RPC function
        const result = await supabase
          .rpc('add_junction_closure', {
            p_node_id: payload.node_id,
            p_ofc_cable_id: payload.ofc_cable_id,
            p_position_km: payload.position_km
          });

        jcData = result.data;
        insertError = result.error;
      }

      // console.log('Function result:', { jcData, insertError });

      if (insertError) {
        console.error('Database error:', insertError);
        toast.error(`Failed to ${isEditMode ? 'update' : 'create'} JC: ${insertError.message}`);
        return;
      }

      // If this is a new junction closure (not an edit), cable segments will be created automatically by database trigger
      if (!isEditMode && jcData) {
        // jcData is returned as an array from the database function
        const dataArray = Array.isArray(jcData) ? jcData : [jcData];
        if (dataArray && dataArray.length > 0) {
          const newJc = dataArray[0];
        } else {
          console.error('No JC data returned from database function');
        }
      }

      onSave(); // Trigger refetch on the parent page
      toast.success(`Junction Closure ${isEditMode ? 'updated' : 'created'} successfully!`);
      onClose();
    } catch (error) {
      console.error('Error in handleValidSubmit:', error);
    
      if (error instanceof Error) {
        toast.error(
          `Failed to ${isEditMode ? 'update' : 'create'} JC: ${error.message}`
        );
      } else {
        toast.error(
          `Failed to ${isEditMode ? 'update' : 'create'} JC: Unknown error`
        );
      }
    }
  };

  // console.log('=== JcFormModal RENDERED ===');
  // console.log('isOpen:', isOpen);
  // console.log('routeId:', routeId);
  // console.log('editingJc:', editingJc);

  return (
    <Modal isOpen={isOpen} onClose={onClose} title={isEditMode ? 'Edit Junction Closure' : 'Add Junction Closure'} >
      <FormCard
        title={isEditMode ? 'Edit Junction Closure' : 'Add Junction Closure'}
        onSubmit={handleSubmit(
          handleValidSubmit,
          () => toast.error('Please fix the highlighted fields')
        )}
        onCancel={onClose}
        isLoading={isSubmitting}
        heightClass="max-h-[80vh]"
        standalone
      >
        <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
          <FormSearchableSelect
            name="node_id"
            label="Junction Closure"
            control={control}
            options={jcOptions || []}
            error={errors.node_id}
            required
            placeholder="Select a Junction Closure"
          />
          <FormInput
            name="position_km"
            label="Position on Route (km)"
            type="number"
            step="0.01"
            register={register}
            error={errors.position_km}
            placeholder="e.g., 12.5"
          />
        </div>
      </FormCard>
    </Modal>
  );
};
```

<!-- path: components/route-manager/CableSegmentationManager.tsx -->
```typescript
// components/ofc/CableSegmentationManager.tsx
'use client';

import { useState, useEffect, useCallback } from 'react';
import { Button } from '@/components/common/ui';
import { Card, CardHeader, CardBody } from '@/components/common/ui';
import { useCableSegmentation, JunctionClosure, CableSegment, SpliceConfiguration } from '@/hooks/ofc/useCableSegmentation';
import { createClient } from '@/utils/supabase/client';
import { toast } from 'sonner';
import { AlertCircle, Check, Info, Link, Loader2, MapPin, Plus, Settings, X } from 'lucide-react';

interface CableSegmentationManagerProps {
  cableId: string;
  cableName: string;
  onSegmentationComplete?: () => void;
}

export const CableSegmentationManager = ({
  cableId,
  cableName,
  onSegmentationComplete
}: CableSegmentationManagerProps) => {
  const [junctionClosures, setJunctionClosures] = useState<JunctionClosure[]>([]);
  const [cableSegments, setCableSegments] = useState<CableSegment[]>([]);
  const [showAddJCForm, setShowAddJCForm] = useState(false);
  const [newJCData, setNewJCData] = useState({
    name: '',
    position_km: 0,
  });

  const supabase = createClient();
  const {
    isLoading,
    error,
    addJunctionClosure,
    createCableSegments,
    createInitialFiberConnections,
  } = useCableSegmentation();

  const loadExistingData = useCallback(async () => {
    // Don't load if no cable is selected
    if (!cableId || cableId === '') {
      setJunctionClosures([]);
      setCableSegments([]);
      return;
    }
  
    try {
      // Load junction closures
      const { data: jcData, error: jcError } = await supabase
        .from('junction_closures')
        .select('*')
        .eq('ofc_cable_id', cableId)
        .order('position_km');
  
      if (jcError) throw jcError;
      setJunctionClosures(jcData || []);
  
      // Load cable segments
      const { data: segmentData, error: segmentError } = await supabase
        .from('cable_segments')
        .select('*')
        .eq('original_cable_id', cableId)
        .order('segment_order');
  
      if (segmentError) throw segmentError;
      setCableSegments(segmentData || []);
    } catch (err) {
      if (err instanceof Error) {
        toast.error(`Failed to load data: ${err.message}`);
      } else {
        toast.error(`Failed to load data: Unknown error`);
      }
    }
  }, [cableId, supabase]);



  // Load existing junction closures and segments
  useEffect(() => {
    loadExistingData();
  }, [cableId, loadExistingData]);



  const handleAddJunctionClosure = async () => {
    if (!newJCData.name || newJCData.position_km <= 0) {
      toast.error('Please provide valid JC name and position');
      return;
    }

    try {
      const jc = await addJunctionClosure(cableId, newJCData.position_km, newJCData.name);
      if (jc) {

        // Create cable segments (this will recreate all segments for the cable)
        const segments = await createCableSegments(jc.id, cableId);

        if (segments.length > 0) {
          // Create initial fiber connections for each segment
          for (const segment of segments) {
            await createInitialFiberConnections(segment.id);
          }

          await loadExistingData();
          setShowAddJCForm(false);
          setNewJCData({ name: '', position_km: 0 });
          onSegmentationComplete?.();
        } else {
          console.warn('No segments were created');
          toast.error('No cable segments were created. Please check the cable configuration.');
        }
      }
    } catch (error) {
      console.error('Error in handleAddJunctionClosure:', error);
      toast.error(`Failed to add junction closure: ${error}`);
    }
  };

  const handleApplySplices = async (segmentId: string, spliceConfig: SpliceConfiguration[]) => {
    // Find the junction closure between segments
    const segment = cableSegments.find(s => s.id === segmentId);
    if (!segment || segment.end_node_type !== 'jc') return;

    const nextSegment = cableSegments.find(s =>
      s.original_cable_id === segment.original_cable_id &&
      s.segment_order === segment.segment_order + 1
    );

    if (!nextSegment) return;

    toast.success('Splice configuration applied successfully');
  };

    // Don't render if no cable is selected
    if (!cableId || cableId === '') {
      return (
        <div className="space-y-6">
          <Card>
            <CardHeader>
              <h2 className="text-lg font-semibold">Cable Segmentation Management</h2>
              <p className="text-sm text-gray-600 dark:text-gray-400">
                Please select a cable first
              </p>
            </CardHeader>
            <CardBody>
              <div className="text-center py-8">
                <p className="text-gray-500 dark:text-gray-400">
                  Select an OFC route above to manage its cable segmentation.
                </p>
              </div>
            </CardBody>
          </Card>
        </div>
      );
    }

  return (
    <div className="space-y-6">
  <Card className="bg-white dark:bg-gray-800 border border-gray-200 dark:border-gray-700 shadow-sm">
    <CardHeader className="pb-4">
      <h2 className="text-xl font-semibold text-gray-900 dark:text-white">Cable Segmentation Management</h2>
      <p className="text-sm text-gray-600 dark:text-gray-300">
        Cable: <span className="font-medium">{cableName}</span> (<span className="font-mono">{cableId}</span>)
      </p>
    </CardHeader>
    
    <CardBody className="pt-4">
      <div className="space-y-6">
        {/* Add JC Button */}
        <Button
          onClick={() => setShowAddJCForm(!showAddJCForm)}
          disabled={isLoading}
          className="w-full sm:w-auto bg-blue-600 hover:bg-blue-700 disabled:bg-gray-400 dark:disabled:bg-gray-600 text-white font-medium py-2.5 px-4 rounded-lg transition-colors duration-200"
        >
          {showAddJCForm ? (
            <span className="flex items-center justify-center">
              <X className="w-4 h-4 mr-2" />
              Cancel
            </span>
          ) : (
            <span className="flex items-center justify-center">
              <Plus className="w-4 h-4 mr-2" />
              Add Junction Closure
            </span>
          )}
        </Button>

        {/* Add JC Form */}
        {showAddJCForm && (
          <Card className="border-2 border-dashed border-gray-300 dark:border-gray-600 bg-gray-50 dark:bg-gray-900/50">
            <CardBody className="p-6">
              <div className="space-y-4">
                <div>
                  <label className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2">
                    Junction Closure Name
                  </label>
                  <input
                    type="text"
                    value={newJCData.name}
                    onChange={(e) => setNewJCData({ ...newJCData, name: e.target.value })}
                    placeholder="JC-001"
                    className="w-full p-3 border border-gray-300 dark:border-gray-600 rounded-lg bg-white dark:bg-gray-800 text-gray-900 dark:text-white placeholder-gray-500 dark:placeholder-gray-400 focus:ring-2 focus:ring-blue-500 focus:border-transparent transition-all duration-200"
                  />
                </div>
                <div>
                  <label className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2">
                    Position (km from start)
                  </label>
                  <input
                    type="number"
                    step="0.1"
                    min="0.1"
                    value={newJCData.position_km || ''}
                    onChange={(e) => setNewJCData({ ...newJCData, position_km: parseFloat(e.target.value) || 0 })}
                    placeholder="5.5"
                    className="w-full p-3 border border-gray-300 dark:border-gray-600 rounded-lg bg-white dark:bg-gray-800 text-gray-900 dark:text-white placeholder-gray-500 dark:placeholder-gray-400 focus:ring-2 focus:ring-blue-500 focus:border-transparent transition-all duration-200"
                  />
                </div>
                <Button
                  onClick={handleAddJunctionClosure}
                  disabled={isLoading || !newJCData.name || newJCData.position_km <= 0}
                  className="w-full bg-green-600 hover:bg-green-700 disabled:bg-gray-400 dark:disabled:bg-gray-600 text-white font-medium py-2.5 px-4 rounded-lg transition-colors duration-200"
                >
                  {isLoading ? (
                    <span className="flex items-center justify-center">
                      <Loader2 className="w-4 h-4 mr-2 animate-spin" />
                      Adding...
                    </span>
                  ) : (
                    <span className="flex items-center justify-center">
                      <Check className="w-4 h-4 mr-2" />
                      Add Junction Closure
                    </span>
                  )}
                </Button>
              </div>
            </CardBody>
          </Card>
        )}

        {/* Existing Junction Closures */}
        {junctionClosures.length > 0 && (
          <div>
            <h3 className="text-lg font-semibold text-gray-900 dark:text-white mb-4 flex items-center">
              <MapPin className="w-5 h-5 mr-2 text-blue-500" />
              Junction Closures ({junctionClosures.length})
            </h3>
            <div className="grid gap-3 sm:grid-cols-1 md:grid-cols-2 lg:grid-cols-1">
              {junctionClosures.map((jc) => (
                <Card key={jc.node_id} className="bg-white dark:bg-gray-800 border border-gray-200 dark:border-gray-700 hover:shadow-md transition-shadow duration-200">
                  <CardBody className="p-4">
                    <div className="flex flex-col sm:flex-row sm:justify-between sm:items-center gap-3">
                      <div className="flex-1">
                        <div className="flex items-center gap-2 mb-1">
                          <h4 className="font-medium text-gray-900 dark:text-white">{jc.name}</h4>
                          <span className="inline-flex items-center px-2 py-1 rounded-full text-xs font-medium bg-blue-100 dark:bg-blue-900 text-blue-800 dark:text-blue-200">
                            {jc.position_km} km
                          </span>
                        </div>
                        <p className="text-sm text-gray-600 dark:text-gray-400">
                          Created: {new Date(jc.created_at).toLocaleDateString()}
                        </p>
                      </div>
                      <div className="text-sm text-gray-500 dark:text-gray-400 bg-gray-50 dark:bg-gray-900 px-3 py-1 rounded-md">
                        ID: {jc.node_id.slice(0, 8)}...
                      </div>
                    </div>
                  </CardBody>
                </Card>
              ))}
            </div>
          </div>
        )}

        {/* Cable Segments */}
        {cableSegments.length > 0 && (
          <div>
            <h3 className="text-lg font-semibold text-gray-900 dark:text-white mb-4 flex items-center">
              <Link className="w-5 h-5 mr-2 text-green-500" />
              Cable Segments ({cableSegments.length})
            </h3>
            <div className="grid gap-3 sm:grid-cols-1 lg:grid-cols-2">
              {cableSegments.map((segment) => (
                <Card key={segment.id} className="bg-white dark:bg-gray-800 border border-gray-200 dark:border-gray-700 hover:shadow-md transition-shadow duration-200">
                  <CardBody className="p-4">
                    <div className="flex flex-col gap-3">
                      <div className="flex justify-between items-start">
                        <div>
                          <h4 className="font-medium text-gray-900 dark:text-white mb-1">
                            Segment #{segment.segment_order}
                          </h4>
                          <div className="flex items-center gap-2 text-sm text-gray-600 dark:text-gray-400 mb-2">
                            <span className="bg-gray-100 dark:bg-gray-700 px-2 py-1 rounded">
                              {segment.start_node_type === 'node' ? 'Node' : 'JC'} → {segment.end_node_type === 'node' ? 'Node' : 'JC'}
                            </span>
                          </div>
                          <div className="text-sm text-gray-600 dark:text-gray-400 space-y-1">
                            <p>Distance: <span className="font-medium">{segment.distance_km} km</span></p>
                            <p>Fibers: <span className="font-medium">{segment.fiber_count}</span></p>
                          </div>
                        </div>
                      </div>
                      <Button
                        size="sm"
                        onClick={() => handleApplySplices(segment.id, [])}
                        disabled={isLoading}
                        className="w-full sm:w-auto bg-gray-600 hover:bg-gray-700 disabled:bg-gray-400 dark:disabled:bg-gray-600 text-white font-medium py-2 px-4 rounded-lg transition-colors duration-200"
                      >
                        <Settings className="w-4 h-4 mr-2" />
                        Configure Splices
                      </Button>
                    </div>
                  </CardBody>
                </Card>
              ))}
            </div>
          </div>
        )}

        {/* Empty States */}
        {junctionClosures.length === 0 && cableSegments.length === 0 && !showAddJCForm && (
          <div className="text-center py-8">
            <div className="mx-auto w-16 h-16 bg-gray-100 dark:bg-gray-700 rounded-full flex items-center justify-center mb-4">
              <Info className="w-8 h-8 text-gray-400" />
            </div>
            <h3 className="text-lg font-medium text-gray-900 dark:text-white mb-2">No segments yet</h3>
            <p className="text-gray-600 dark:text-gray-400 max-w-md mx-auto">
              Start by adding a junction closure to create your first cable segment.
            </p>
          </div>
        )}

        {error && (
          <div className="bg-red-50 dark:bg-red-900/20 border border-red-200 dark:border-red-800 rounded-lg p-4">
            <div className="flex items-center">
              <AlertCircle className="w-5 h-5 text-red-500 mr-2" />
              <p className="text-red-800 dark:text-red-300 font-medium">Error</p>
            </div>
            <p className="text-red-700 dark:text-red-400 mt-1 text-sm">{error}</p>
          </div>
        )}
      </div>
    </CardBody>
  </Card>
</div>
  );
};

```

<!-- path: components/route-manager/ui/SpliceVisualizationModal.tsx -->
```typescript
"use client";

import React, { useMemo, useState } from 'react';
import { FiTrash2 } from 'react-icons/fi';

import { Modal, Button, PageSpinner, ErrorDisplay, ConfirmModal } from '@/components/common/ui';
import { useJcSplicingDetails, useManageSplice } from '@/hooks/database/route-manager-hooks';
import { Separator } from '@/components/common/ui/separator';
import TruncateTooltip from '@/components/common/TruncateTooltip';

// --- Type Definitions for Clarity ---
interface SpliceConnection {
  id: string;
  incoming_segment: string;
  incoming_fiber: number;
  outgoing_segment: string | null;
  outgoing_fiber: number | null;
  loss_db: number | null;
}

interface AvailableFiber {
    segment_id: string;
    segment_name: string;
    fiber_no: number;
}

interface SpliceVisualizationModalProps {
  isOpen: boolean;
  onClose: () => void;
  junctionClosureId: string | null;
}

export const SpliceVisualizationModal: React.FC<SpliceVisualizationModalProps> = ({ isOpen, onClose, junctionClosureId }) => {
  const { data: spliceDetails, isLoading, isError, error } = useJcSplicingDetails(junctionClosureId);
  const manageSpliceMutation = useManageSplice();

  const [spliceToDelete, setSpliceToDelete] = useState<SpliceConnection | null>(null);

  // Transform the fetched data into flat lists for the tables
  const { spliceConnections, availableFibers } = useMemo(() => {
    if (!spliceDetails?.segments_at_jc) {
      return { spliceConnections: [], availableFibers: [] };
    }

    const splices: SpliceConnection[] = [];
    const available: AvailableFiber[] = [];

    for (const segment of spliceDetails.segments_at_jc) {
      for (const fiber of segment.fibers) {
        if (fiber.status === 'used_as_incoming' && fiber.splice_id) {
          splices.push({
            id: fiber.splice_id,
            incoming_segment: segment.segment_name,
            incoming_fiber: fiber.fiber_no,
            outgoing_segment: fiber.connected_to_segment,
            outgoing_fiber: fiber.connected_to_fiber,
            loss_db: fiber.loss_db,
          });
        } else if (fiber.status === 'available') {
            available.push({
                segment_id: segment.segment_id,
                segment_name: segment.segment_name,
                fiber_no: fiber.fiber_no,
            });
        }
      }
    }

    // Sort for consistent display
    splices.sort((a, b) => a.incoming_fiber - b.incoming_fiber);
    available.sort((a,b) => a.segment_name.localeCompare(b.segment_name) || a.fiber_no - b.fiber_no);

    return { spliceConnections: splices, availableFibers: available };
  }, [spliceDetails]);

  const handleConfirmDelete = () => {
    if (spliceToDelete && junctionClosureId) {
      manageSpliceMutation.mutate({ action: 'delete', jcId: junctionClosureId, spliceId: spliceToDelete.id });
      setSpliceToDelete(null);
    }
  };

  const renderContent = () => {
    if (isLoading) return <PageSpinner text="Loading Splice Details..." />;
    if (isError) return <ErrorDisplay error={error?.message} />;
    if (!spliceDetails?.junction_closure) return <div className="p-8 text-center text-gray-500">Select a Junction Closure to view splice details.</div>;

    return (
      <div className="space-y-6 md:space-y-8 w-full">
        {/* Active Splices Section */}
        <div>
          <h4 className="text-base md:text-lg font-semibold text-gray-800 dark:text-gray-200 mb-3">
            Active Splice Connections ({spliceConnections.length})
          </h4>
          
          {/* Desktop Table View */}
          <div className="hidden md:block overflow-hidden rounded-lg border border-gray-200 dark:border-gray-700">
            <div className="overflow-x-auto">
              <table className="min-w-full divide-y divide-gray-200 dark:divide-gray-700">
                <thead className="bg-gray-50 dark:bg-gray-800">
                  <tr>
                    <th className="px-4 py-3 text-left text-xs font-medium text-gray-500 dark:text-gray-400 uppercase tracking-wider">Incoming</th>
                    <th className="px-4 py-3 text-left text-xs font-medium text-gray-500 dark:text-gray-400 uppercase tracking-wider">Outgoing</th>
                    <th className="px-4 py-3 text-left text-xs font-medium text-gray-500 dark:text-gray-400 uppercase tracking-wider">Loss (dB)</th>
                    <th className="px-4 py-3 text-right text-xs font-medium text-gray-500 dark:text-gray-400 uppercase tracking-wider">Actions</th>
                  </tr>
                </thead>
                <tbody className="bg-white dark:bg-gray-800/50 divide-y divide-gray-200 dark:divide-gray-700">
                  {spliceConnections.map(splice => (
                    <tr key={splice.id}>
                      <td className="px-4 py-3 whitespace-nowrap">
                        <div className="text-sm font-medium text-gray-900 dark:text-gray-100 truncate max-w-xs"><TruncateTooltip text={splice.incoming_segment} /></div>
                        <div className="text-xs text-gray-500 dark:text-gray-400">Fiber #{splice.incoming_fiber}</div>
                      </td>
                      <td className="px-4 py-3 whitespace-nowrap">
                        <div className="text-sm font-medium text-gray-900 dark:text-gray-100 truncate max-w-xs"><TruncateTooltip text={splice.outgoing_segment || 'Terminated'} /></div>
                        <div className="text-xs text-gray-500 dark:text-gray-400">{splice.outgoing_fiber ? `Fiber #${splice.outgoing_fiber}` : ''}</div>
                      </td>
                      <td className="px-4 py-3 whitespace-nowrap">
                        <div className="text-sm font-medium text-gray-900 dark:text-gray-100 truncate max-w-xs">{splice.loss_db}</div>
                      </td>
                      <td className="px-4 py-3 whitespace-nowrap text-right">
                        <Button variant="danger" size="sm" onClick={() => setSpliceToDelete(splice)} leftIcon={<FiTrash2 />}>
                          Delete
                        </Button>
                      </td>
                    </tr>
                  ))}
                  {spliceConnections.length === 0 && (
                      <tr>
                          <td colSpan={3} className="text-center py-8 text-sm text-gray-500 dark:text-gray-400">No active splices found in this junction.</td>
                      </tr>
                  )}
                </tbody>
              </table>
            </div>
          </div>

          {/* Mobile Card View */}
          <div className="md:hidden space-y-3">
            {spliceConnections.map(splice => (
              <div key={splice.id} className="bg-white dark:bg-gray-800/50 rounded-lg border border-gray-200 dark:border-gray-700 p-4 space-y-3">
                <div className="space-y-2">
                  <div>
                    <div className="text-xs font-medium text-gray-500 dark:text-gray-400 uppercase">Incoming</div>
                    <div className="text-sm font-medium text-gray-900 dark:text-gray-100 break-words"><TruncateTooltip text={splice.incoming_segment} /></div>
                    <div className="text-xs text-gray-500 dark:text-gray-400">Fiber #{splice.incoming_fiber}</div>
                  </div>
                  <div>
                    <div className="text-xs font-medium text-gray-500 dark:text-gray-400 uppercase">Outgoing</div>
                    <div className="text-sm font-medium text-gray-900 dark:text-gray-100 break-words"><TruncateTooltip text={splice.outgoing_segment || 'Terminated'} /></div>
                    <div className="text-xs text-gray-500 dark:text-gray-400">{splice.outgoing_fiber ? `Fiber #${splice.outgoing_fiber}` : ''}</div>
                  </div>
                  <div>
                    <div className="text-xs font-medium text-gray-500 dark:text-gray-400 uppercase">Loss (dB)</div>
                    <div className="text-sm font-medium text-gray-900 dark:text-gray-100 break-words">{splice.loss_db}</div>
                  </div>
                </div>
                <Button 
                  variant="danger" 
                  size="sm" 
                  onClick={() => setSpliceToDelete(splice)} 
                  leftIcon={<FiTrash2 />}
                  className="w-full"
                >
                  Delete Splice
                </Button>
              </div>
            ))}
            {spliceConnections.length === 0 && (
              <div className="text-center py-8 text-sm text-gray-500 dark:text-gray-400 bg-white dark:bg-gray-800/50 rounded-lg border border-gray-200 dark:border-gray-700">
                No active splices found in this junction.
              </div>
            )}
          </div>
        </div>

        <Separator />

        {/* Available Segments Section */}
        <div>
          <h4 className="text-base md:text-lg font-semibold text-gray-800 dark:text-gray-200 mb-3">
            Available Segments ({availableFibers.length})
          </h4>
          
          {/* Desktop Table View */}
          <div className="hidden md:block overflow-hidden rounded-lg border border-gray-200 dark:border-gray-700 max-h-80 overflow-y-auto">
            <table className="min-w-full divide-y divide-gray-200 dark:divide-gray-700">
              <thead className="bg-gray-50 dark:bg-gray-800 sticky top-0 z-10">
                <tr>
                  <th className="px-4 py-3 text-left text-xs font-medium text-gray-500 dark:text-gray-400 uppercase tracking-wider">Segment Name</th>
                  <th className="px-4 py-3 text-left text-xs font-medium text-gray-500 dark:text-gray-400 uppercase tracking-wider">Fiber #</th>
                </tr>
              </thead>
              <tbody className="bg-white dark:bg-gray-800/50 divide-y divide-gray-200 dark:divide-gray-700">
                {availableFibers.map((fiber) => (
                  <tr key={`${fiber.segment_id}-${fiber.fiber_no}`}>
                    <td className="px-4 py-2 text-sm text-gray-800 dark:text-gray-200 break-words">{fiber.segment_name}</td>
                    <td className="px-4 py-2 whitespace-nowrap text-sm text-gray-500 dark:text-gray-400 font-mono">{fiber.fiber_no}</td>
                  </tr>
                ))}
                {availableFibers.length === 0 && (
                    <tr>
                        <td colSpan={2} className="text-center py-8 text-sm text-gray-500 dark:text-gray-400">No available fibers in this junction.</td>
                    </tr>
                )}
              </tbody>
            </table>
          </div>

          {/* Mobile Card View */}
          <div className="md:hidden max-h-80 overflow-y-auto space-y-2">
            {availableFibers.map((fiber) => (
              <div key={`${fiber.segment_id}-${fiber.fiber_no}`} className="bg-white dark:bg-gray-800/50 rounded-lg border border-gray-200 dark:border-gray-700 p-3 flex items-center justify-between">
                <div className="flex-1 min-w-0 mr-3">
                  <div className="text-sm font-medium text-gray-800 dark:text-gray-200 break-words">{fiber.segment_name}</div>
                </div>
                <div className="flex-shrink-0 text-sm text-gray-500 dark:text-gray-400 font-mono bg-gray-100 dark:bg-gray-700 px-2 py-1 rounded">
                  #{fiber.fiber_no}
                </div>
              </div>
            ))}
            {availableFibers.length === 0 && (
              <div className="text-center py-8 text-sm text-gray-500 dark:text-gray-400 bg-white dark:bg-gray-800/50 rounded-lg border border-gray-200 dark:border-gray-700">
                No available fibers in this junction.
              </div>
            )}
          </div>
        </div>
      </div>
    );
  };

  return (
    <>
      <Modal 
        isOpen={isOpen} 
        onClose={onClose} 
        title={`Splice Details: ${spliceDetails?.junction_closure?.name || 'Loading...'}`} 
        size="full"
      >
        <div className="p-4 md:p-6">
          {renderContent()}
        </div>
      </Modal>
      <ConfirmModal
        isOpen={!!spliceToDelete}
        onConfirm={handleConfirmDelete}
        onCancel={() => setSpliceToDelete(null)}
        title="Confirm Splice Deletion"
        message={`Are you sure you want to delete the splice from Fiber #${spliceToDelete?.incoming_fiber} on "${spliceToDelete?.incoming_segment}"?`}
        type="danger"
        loading={manageSpliceMutation.isPending}
      />
    </>
  );
};
```

<!-- path: components/route-manager/ui/RouteVisualization.tsx -->
```typescript
// path: components/route-manager/ui/RouteVisualization.tsx
"use client";

import { motion } from 'framer-motion';
import { Trash2, Edit } from 'lucide-react';
import { RouteDetailsPayload, JointBox } from '@/schemas/custom-schemas';
import TruncateTooltip from '@/components/common/TruncateTooltip';

interface RouteVisualizationProps {
    routeDetails: RouteDetailsPayload;
    onJcClick: (jc: JointBox) => void;
    onEditJc: (jc: JointBox) => void;
    onDeleteJc: (jcId: string) => void;
}

export default function RouteVisualization({ routeDetails, onJcClick, onEditJc, onDeleteJc }: RouteVisualizationProps) {
  const { route, jointBoxes, segments } = routeDetails;
  
  // This is the crucial logic block
  const allPoints = [
    { 
      id: route.sn_id, 
      name: route.sn_name || route.start_site?.name || 'Start Node', 
      type: 'site' as const, 
      position: 0, 
      raw: {} 
    },
    ...jointBoxes.map(e => ({ 
        id: e.node_id, // <-- Use the node_id for matching against segments
        name: e.attributes?.name || e.node?.name || `JC-${e.id?.slice(-4)}`, 
        type: 'jointBox' as const, 
        position: e.attributes?.position_on_route || 0, 
        status: e.status,
        raw: e 
    })),
    { 
      id: route.en_id, 
      name: route.en_name || route.end_site?.name || 'End Node', 
      type: 'site' as const, 
      position: 100, 
      raw: {} 
    }
  ].sort((a, b) => a.position - b.position);

  // console.log("allPoints", allPoints);

  return (
    <div className="bg-white dark:bg-gray-800 p-6 rounded-lg shadow-md border dark:border-gray-700">
      <div className="flex items-center justify-between mb-6">
        <h3 className="text-xl font-semibold text-gray-900 dark:text-white">Route Visualization</h3>
        <div className="flex items-center space-x-4 text-sm">
          <div className="flex items-center space-x-2">
            <div className="w-3 h-3 rounded-full bg-blue-600"></div>
            <span className="text-gray-600 dark:text-gray-400">Sites</span>
          </div>
          <div className="flex items-center space-x-2">
            <div className="w-3 h-3 rounded-full bg-green-600"></div>
            <span className="text-gray-600 dark:text-gray-400">Existing JC</span>
          </div>
        </div>
      </div>
      
      <div className="mb-8">
        <div className="overflow-x-auto pb-4">
          <div className="relative min-w-[800px] h-64 py-8">
            <div 
              className="absolute top-1/2 h-2 bg-gradient-to-r from-blue-400 via-blue-500 to-blue-600 rounded-full shadow-lg" 
              style={{ transform: 'translateY(-50%)', left: '4.8%', width: '92%' }} 
            />
            
            <div className="absolute top-0 left-0 right-0 h-full">
              {allPoints.map((point, index) => {
                const km = ((point.position / 100) * (route.current_rkm || 0)).toFixed(2);
                const isFirst = index === 0;
                const isLast = index === allPoints.length - 1;
                
                return (
                  <motion.div 
                    key={point.id} 
                    className="absolute top-1/2 flex flex-col items-center group" 
                    style={{ 
                      left: `calc(4% + ${point.position}% * 0.92)`, 
                      transform: 'translateX(-50%) translateY(-50%)'
                    }}
                    initial={{ opacity: 0, scale: 0.5, y: -20 }}
                    animate={{ opacity: 1, scale: 1, y: 0 }}
                    transition={{ 
                      duration: 0.6, 
                      delay: index * 0.1,
                      ease: "easeOut"
                    }}
                  >
                    <div className="absolute -top-16 text-center min-w-max max-w-40">
                      <p className="text-xs font-semibold text-gray-800 dark:text-gray-200 px-2 py-1.5 bg-white dark:bg-gray-700 rounded-lg shadow-md border dark:border-gray-600 whitespace-nowrap">
                        {point.name}
                      </p>
                      <div className="absolute top-full left-1/2 transform -translate-x-1/2 w-0 h-0 border-l-4 border-r-4 border-t-4 border-l-transparent border-r-transparent border-t-white dark:border-t-gray-700"></div>
                    </div>
                    
                    <div 
                      onClick={() => point.type === 'jointBox' && onJcClick(point.raw as JointBox)}
                      className={`relative w-6 h-6 rounded-full border-4 flex items-center justify-center transition-all duration-300 z-10 shadow-lg ${
                        point.type === 'site' 
                          ? 'bg-blue-600 border-blue-200 hover:bg-blue-700 hover:border-blue-300' 
                          : point.status === 'existing' 
                            ? 'bg-green-600 border-green-200 hover:bg-green-700 hover:border-green-300' 
                            : 'bg-yellow-500 border-yellow-200 hover:bg-yellow-600 hover:border-yellow-300'
                      } ${point.type === 'jointBox' ? 'cursor-pointer hover:scale-125 hover:shadow-xl' : 'hover:scale-110'}`}
                      title={`${point.name} at ${km} km`}
                    >
                      <span className='text-white font-bold text-xs'>
                        {point.type === 'site' ? (isFirst ? 'S' : 'E') : 'J'}
                      </span>
                    </div>
                    
                    <div className="absolute top-10 text-center min-w-max">
                      <p className="text-xs font-mono text-gray-600 dark:text-gray-300 bg-gray-100 dark:bg-gray-700 px-2 py-1 rounded-md border dark:border-gray-600 shadow-sm">
                        {km} km
                      </p>
                    </div>
                    
                    {point.type === 'jointBox' && (
                      <div className="absolute top-20 flex space-x-1 opacity-0 group-hover:opacity-100 transition-all duration-300 transform translate-y-2 group-hover:translate-y-0">
                        <button 
                          onClick={(e) => {
                            e.stopPropagation();
                            onEditJc(point.raw as JointBox);
                          }} 
                          className="p-2 bg-blue-500 text-white rounded-full hover:bg-blue-600 transition-all duration-200 shadow-lg hover:shadow-xl transform hover:scale-105" 
                          title="Edit JC"
                        >
                          <Edit size={14} />
                        </button>
                        <button 
                          onClick={(e) => {
                            e.stopPropagation();
                            onDeleteJc((point.raw as JointBox).id!);
                          }} 
                          className="p-2 bg-red-500 text-white rounded-full hover:bg-red-600 transition-all duration-200 shadow-lg hover:shadow-xl transform hover:scale-105" 
                          title="Delete JC"
                        >
                          <Trash2 size={14} />
                        </button>
                      </div>
                    )}
                  </motion.div>
                )
              })}
            </div>
          </div>
        </div>
      </div>
      
      <div className="border-t dark:border-gray-600 pt-6">
        <div className="flex items-center justify-between mb-4">
          <h4 className="font-semibold text-gray-800 dark:text-gray-200 flex items-center">
            <span className="w-3 h-3 bg-blue-600 rounded-full mr-2"></span>
            Cable Segments ({segments.length})
          </h4>
          {segments.length > 0 && (
            <div className="text-sm text-gray-500 dark:text-gray-400">
              Total: {segments.reduce((acc, seg) => acc + (seg.distance_km || 0), 0).toFixed(2)} km
            </div>
          )}
        </div>
        
        {segments.length > 0 ? (
          <div className="space-y-3">
            {segments.map((seg, index) => {
              const start = allPoints.find(p => p.id === seg.start_node_id);
              const end = allPoints.find(p => p.id === seg.end_node_id);
              return (
                <motion.div 
                  key={seg.id} 
                  className="bg-gradient-to-r from-gray-50 to-gray-100 dark:from-gray-700/30 dark:to-gray-700/50 p-4 rounded-xl border dark:border-gray-600/50 hover:from-blue-50 hover:to-blue-100 dark:hover:from-gray-700/50 dark:hover:to-gray-700/70 transition-all duration-300 hover:shadow-md"
                  initial={{ opacity: 0, x: -20 }}
                  animate={{ opacity: 1, x: 0 }}
                  transition={{ duration: 0.4, delay: index * 0.1 }}
                >
                  <div className="flex justify-between items-center">
                    <div className="flex items-center space-x-3">
                      <span className="inline-flex items-center px-3 py-1 rounded-full text-xs font-medium bg-blue-500 text-white shadow-sm">
                        #{seg.segment_order}
                      </span>
                      <div className="text-sm">
                        <span className="font-medium text-gray-800 dark:text-gray-200"><TruncateTooltip text={start?.name || 'Unknown'} /></span>
                        <span className="mx-3 text-gray-400">
                          <svg className="w-4 h-4 inline" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M13 7l5 5m0 0l-5 5m5-5H6" />
                          </svg>
                        </span>
                        <span className="font-medium text-gray-800 dark:text-gray-200"><TruncateTooltip text={end?.name || 'Unknown'} /></span>
                      </div>
                    </div>
                    <div className="flex items-center space-x-2">
                      <span className='font-mono text-sm bg-white dark:bg-gray-600 text-gray-700 dark:text-gray-300 px-3 py-1.5 rounded-full border dark:border-gray-500 shadow-sm'>
                        {seg.distance_km || 0} km
                      </span>
                    </div>
                  </div>
                </motion.div>
              )
            })}
          </div>
        ) : (
          <motion.div 
            className='text-center py-12 bg-gray-50 dark:bg-gray-700/30 rounded-xl border-2 border-dashed border-gray-300 dark:border-gray-600'
            initial={{ opacity: 0, scale: 0.95 }}
            animate={{ opacity: 1, scale: 1 }}
            transition={{ duration: 0.3 }}
          >
            <div className="flex flex-col items-center space-y-3">
              <div className="w-12 h-12 rounded-full bg-gray-300 dark:bg-gray-600 flex items-center justify-center">
                <svg className="w-6 h-6 text-gray-500" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                  <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={1.5} d="M9 12h6m-6 4h6m2 5H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z" />
                </svg>
              </div>
              <div>
                <p className="text-sm font-medium text-gray-600 dark:text-gray-400">No cable segments found</p>
                <p className="text-xs text-gray-500 dark:text-gray-500 mt-1">Segments will appear here once they are configured</p>
              </div>
            </div>
          </motion.div>
        )}
      </div>
    </div>
  );
}
```

<!-- path: components/route-manager/logic/project.ts -->
```typescript
import { z } from 'zod';
import { 
    v_ofc_cables_completeRowSchema, 
    cable_segmentsRowSchema, 
    junction_closuresRowSchema,
    fiber_splicesRowSchema 
} from '@/schemas/zod-schemas';

// --- TYPE DEFINITIONS INFERRED FROM ZOD SCHEMAS ---
type CableRoute = z.infer<typeof v_ofc_cables_completeRowSchema>;
type Equipment = z.infer<typeof junction_closuresRowSchema> & { 
  node?: { name: string | null; } | null;
  status: 'existing' | 'planned'; 
  attributes: { position_on_route: number; name?: string; } 
};
type CableSegment = z.infer<typeof cable_segmentsRowSchema>;
type FiberSplice = z.infer<typeof fiber_splicesRowSchema>;

// --- STRICT LOCAL TYPES (NO 'any') ---
interface BranchConfig {
  target_id: string;
  target_type: 'site' | 'equipment';
  distance_km: number;
  tap_fibers: number;
}
export type BranchConfigMap = Record<string, BranchConfig>;

export function projectSegments(
  route: CableRoute,
  equipment: Equipment[],
): CableSegment[] {
  if (!route || !route.sn_id || !route.en_id) {
    return [];
  }

  const sorted = [...equipment].sort(
    (a, b) => a.attributes.position_on_route - b.attributes.position_on_route
  );

  const points = [
    { id: route.sn_id, type: 'site' as const, position: 0 },
    ...sorted.map((jc) => ({ id: jc.id, type: 'equipment' as const, position: jc.attributes.position_on_route })),
    { id: route.en_id, type: 'site' as const, position: 100 },
  ];

  const segments: CableSegment[] = [];
  let order = 1;
  for (let i = 0; i < points.length - 1; i++) {
    const start = points[i];
    const end = points[i + 1];
    const pct = Math.max(0, end.position - start.position) / 100;
    const distance = Math.round((route.current_rkm || 0) * pct * 1000) / 1000;
    
    segments.push({
      id: `proj-seg-${route.id}-${order}`,
      segment_order: order,
      start_node_id: start.id,
      end_node_id: end.id,
      start_node_type: start.type,
      end_node_type: end.type,
      fiber_count: route.capacity || 0,
      distance_km: distance,
      original_cable_id: route.id!,
      created_at: new Date().toISOString(),
      updated_at: new Date().toISOString(),
    });
    order++;
  }

  return segments;
}

export function projectDefaultSplices(
  route: CableRoute,
  segments: CableSegment[],
  equipment: Equipment[],
): FiberSplice[] {
    // Placeholder for future implementation
    return [];
}
```

<!-- path: components/route-manager/RouteSelection.tsx -->
```typescript
import { PageHeader } from "@/components/common/page-header";
import { Option, SearchableSelect } from "@/components/common/ui/select/SearchableSelect";
import { useOfcRoutesForSelection } from "@/hooks/database/route-manager-hooks";
import React, { useCallback, useMemo } from "react";
import { FaRoute } from "react-icons/fa";
import { FiPlus } from "react-icons/fi";
import { useQueryClient } from "@tanstack/react-query";

// RouteSelection Component
interface RouteSelectionProps {
  selectedRouteId: string | null;
  onRouteChange: (routeId: string | null) => void;
  onAddJunctionClosure: () => void;
  isLoadingRouteDetails: boolean;
}

const RouteSelection: React.FC<RouteSelectionProps> = ({
  selectedRouteId,
  onRouteChange,
  onAddJunctionClosure,
  isLoadingRouteDetails
}) => {
  const queryClient = useQueryClient();
  const { data: routesForSelection, isLoading: isLoadingRoutesData } = useOfcRoutesForSelection();

  const routeOptions = useMemo((): Option[] => {
    if (!routesForSelection) return [];
    return routesForSelection
      .filter(r => r.id !== null && r.route_name !== null)
      .map((r) => ({ value: r.id as string, label: r.route_name as string }));
  }, [routesForSelection]);

  const handleRouteChange = useCallback((value: string | null) => {
    onRouteChange(value);
    // Invalidate ALL splice details when the route changes.
    // This forces a refetch for any JC on the newly selected route.
    queryClient.invalidateQueries({ queryKey: ['jc-splicing-details'] });
  }, [onRouteChange, queryClient]);

  return (
    <>
      <PageHeader
        title='Route Manager'
        description='Visualize routes, add junction closures, and manage fiber splices.'
        icon={<FaRoute />}
        isLoading={isLoadingRoutesData}
        actions={[{
          label: "Add Junction Closure",
          onClick: onAddJunctionClosure,
          variant: "primary",
          leftIcon: <FiPlus />,
          disabled: !selectedRouteId || isLoadingRouteDetails,
        }]}
      />
      
      <div className='bg-white dark:bg-gray-800 p-4 rounded-lg shadow-md border dark:border-gray-700'>
        <label className='block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2'>
          Select an OFC Route to Manage
        </label>
        <SearchableSelect 
          options={routeOptions} 
          value={selectedRouteId || ""} 
          onChange={handleRouteChange} 
          placeholder={isLoadingRoutesData ? "Loading routes..." : "Select a route"} 
          disabled={isLoadingRoutesData} 
          clearable 
        />
      </div>
    </>
  );
};

export default RouteSelection;

```

<!-- path: components/route-manager/queryKeys.ts -->
```typescript
// components/route-manager/queryKeys.ts

export const queryKeys = {
  routes: ['routes'] as const,
  routeDetails: (routeId: string | null) => ['routeDetails', routeId] as const,
};

```

<!-- path: components/route-manager/FiberSpliceManager.tsx -->
```typescript
// path: components/route-manager/FiberSpliceManager.tsx
"use client";

import { useMemo, useState, useEffect } from 'react';
import { useJcSplicingDetails, useManageSplice, useAutoSplice, useSyncPathUpdates } from '@/hooks/database/route-manager-hooks';
import { PageSpinner, Button } from '@/components/common/ui';
import { FiLink, FiX, FiZap, FiRefreshCw } from 'react-icons/fi';
import { JcSplicingDetails } from '@/schemas/custom-schemas';
import { SpliceVisualizationModal } from '@/components/route-manager/ui/SpliceVisualizationModal';
import TruncateTooltip from '@/components/common/TruncateTooltip';
import { Loader2 } from 'lucide-react';

// --- Local Type Definitions (Inferred from imported Zod schemas for clarity) ---
type FiberStatus = JcSplicingDetails['segments_at_jc'][0]['fibers'][0]['status'];
type FiberAtSegment = JcSplicingDetails['segments_at_jc'][0]['fibers'][0];

interface FiberSpliceManagerProps {
    junctionClosureId: string | null;
}

interface SpliceAction {
    type: 'manual' | 'auto';
    manualData?: {
        incomingSegmentId: string;
        incomingFiberNo: number;
        outgoingSegmentId: string;
        outgoingFiberNo: number;
    };
    autoData?: {
        segment1Id: string;
        segment2Id: string;
        segment1Name: string;
        segment2Name: string;
    };
}

interface AutoSplicePair {
    fiber1No: number;
    fiber2No: number;
    lossDb: string;
}

const useNormalizedSplicingDetails = (junctionClosureId: string | null): { 
  normalizedData: JcSplicingDetails | null; 
  isLoading: boolean; 
  isError: boolean; 
  error: Error | null 
} => {
    const { data: rawData, isLoading, isError, error } = useJcSplicingDetails(junctionClosureId);

    const normalizedData = useMemo((): JcSplicingDetails | null => {
        if (!rawData || typeof rawData !== 'object' || !('junction_closure' in rawData)) {
            return null;
        }
        return rawData;
    }, [rawData]);

    return { normalizedData, isLoading, isError, error };
};

export const FiberSpliceManager: React.FC<FiberSpliceManagerProps> = ({ junctionClosureId }) => {

    const { normalizedData: spliceDetails, isLoading, isError, error } = useNormalizedSplicingDetails(junctionClosureId);
    
    const manageSpliceMutation = useManageSplice();
    const autoSpliceMutation = useAutoSplice();
    const syncPathUpdatesMutation = useSyncPathUpdates(); // NEW HOOK

    const [selectedFiber, setSelectedFiber] = useState<{ segmentId: string; fiberNo: number } | null>(null);
    const [showLossModal, setShowLossModal] = useState(false);
    const [lossDbValue, setLossDbValue] = useState('0.3');
    const [pendingSpliceAction, setPendingSpliceAction] = useState<SpliceAction | null>(null);
    const [autoSpliceMode, setAutoSpliceMode] = useState<'uniform' | 'individual'>('uniform');
    const [autoSplicePairs, setAutoSplicePairs] = useState<AutoSplicePair[]>([]);
    const [showVisualizationModal, setShowVisualizationModal] = useState(false);

    // (useEffect for auto-splice pairs remains the same)
    useEffect(() => {
        if (pendingSpliceAction?.type === 'auto' && pendingSpliceAction.autoData && spliceDetails) {
            const { segment1Id, segment2Id } = pendingSpliceAction.autoData;
            const segment1 = spliceDetails.segments_at_jc.find(s => s.segment_id === segment1Id);
            const segment2 = spliceDetails.segments_at_jc.find(s => s.segment_id === segment2Id);

            if (segment1 && segment2) {
                const availableFibers1 = segment1.fibers.filter(f => f.status === 'available').map(f => f.fiber_no);
                const availableFibers2 = segment2.fibers.filter(f => f.status === 'available').map(f => f.fiber_no);
                
                const pairs: AutoSplicePair[] = [];
                const maxPairs = Math.min(availableFibers1.length, availableFibers2.length);
                
                for (let i = 0; i < maxPairs; i++) {
                    pairs.push({
                        fiber1No: availableFibers1[i],
                        fiber2No: availableFibers2[i],
                        lossDb: '0.3'
                    });
                }
                
                setAutoSplicePairs(pairs);
            }
        }
    }, [pendingSpliceAction, spliceDetails]);

    const handleFiberClick = (segmentId: string, fiberNo: number, status: FiberStatus) => {
        if (status === 'used_as_outgoing') return;
        if (selectedFiber && selectedFiber.segmentId === segmentId && selectedFiber.fiberNo === fiberNo) {
            setSelectedFiber(null);
        } else {
            setSelectedFiber({ segmentId, fiberNo });
        }
    };

    const handleTargetFiberClick = (targetSegmentId: string, targetFiberNo: number) => {
        if (!selectedFiber || !junctionClosureId) return;
        
        setPendingSpliceAction({
            type: 'manual',
            manualData: {
                incomingSegmentId: selectedFiber.segmentId,
                incomingFiberNo: selectedFiber.fiberNo,
                outgoingSegmentId: targetSegmentId,
                outgoingFiberNo: targetFiberNo,
            }
        });
        setShowLossModal(true);
    };

    const handleAutoSplice = (segment1Id: string, segment2Id: string) => {
        if (!junctionClosureId || !spliceDetails) return;
        
        const segment1 = spliceDetails.segments_at_jc.find(s => s.segment_id === segment1Id);
        const segment2 = spliceDetails.segments_at_jc.find(s => s.segment_id === segment2Id);
        
        setPendingSpliceAction({
            type: 'auto',
            autoData: {
                segment1Id,
                segment2Id,
                segment1Name: segment1?.segment_name || 'Segment 1',
                segment2Name: segment2?.segment_name || 'Segment 2',
            }
        });
        setShowLossModal(true);
    };

    const applyUniformLoss = () => {
        const uniform = lossDbValue;
        setAutoSplicePairs(pairs => pairs.map(p => ({ ...p, lossDb: uniform })));
    };

    const confirmSplice = async () => {
        if (!pendingSpliceAction || !junctionClosureId) return;

        if (pendingSpliceAction.type === 'manual' && pendingSpliceAction.manualData) {
            const lossDb = parseFloat(lossDbValue) || 0;
            const { incomingSegmentId, incomingFiberNo, outgoingSegmentId, outgoingFiberNo } = pendingSpliceAction.manualData;
            manageSpliceMutation.mutate({
                action: 'create',
                jcId: junctionClosureId,
                incomingSegmentId,
                incomingFiberNo,
                outgoingSegmentId,
                outgoingFiberNo,
                lossDb,
            });
            setSelectedFiber(null);
            resetModal();
        } else if (pendingSpliceAction.type === 'auto' && pendingSpliceAction.autoData) {
            const { segment1Id, segment2Id } = pendingSpliceAction.autoData;
            
            if (autoSpliceMode === 'uniform') {
                const lossDb = parseFloat(lossDbValue) || 0;
                autoSpliceMutation.mutate({
                    jcId: junctionClosureId,
                    segment1Id,
                    segment2Id,
                    lossDb,
                });
                resetModal();
            } else {
                for (const pair of autoSplicePairs) {
                    const lossDb = parseFloat(pair.lossDb) || 0;
                    await manageSpliceMutation.mutateAsync({
                        action: 'create',
                        jcId: junctionClosureId,
                        incomingSegmentId: segment1Id,
                        incomingFiberNo: pair.fiber1No,
                        outgoingSegmentId: segment2Id,
                        outgoingFiberNo: pair.fiber2No,
                        lossDb,
                    });
                }
                resetModal();
            }
        }
    };

    const resetModal = () => {
        setShowLossModal(false);
        setPendingSpliceAction(null);
        setLossDbValue('0.3');
        setAutoSpliceMode('uniform');
        setAutoSplicePairs([]);
    };

    const handleRemoveSplice = (fiber: FiberAtSegment) => {
      if (!junctionClosureId || !fiber.splice_id) return;
      if (window.confirm("Are you sure you want to remove this splice?")) {
        manageSpliceMutation.mutate({
          action: 'delete',
          jcId: junctionClosureId,
          spliceId: fiber.splice_id,
        });
        setSelectedFiber(null);
      }
    };

    if (isLoading) return <PageSpinner text="Loading splice details..." />;
    if (isError) return <div className="p-4 text-red-500">Error: {error?.message}</div>;
    if (!spliceDetails?.junction_closure) {
        return <div className="p-4 text-gray-500">Select a Junction Closure to manage its splices.</div>;
    }

    const { junction_closure, segments_at_jc } = spliceDetails;

    const gridTemplateColumns = `repeat(${Math.max(1, segments_at_jc.length)}, minmax(0, 1fr))`;

    const renderFiber = (fiber: FiberAtSegment, segmentId: string) => {
        const isSelected = selectedFiber?.segmentId === segmentId && selectedFiber.fiberNo === fiber.fiber_no;
        const isTargetable = Boolean(selectedFiber) && selectedFiber?.segmentId !== segmentId && fiber.status === 'available';

        const statusClasses: Record<FiberStatus, string> = {
            available: 'bg-green-100 dark:bg-green-900/30 text-green-700 dark:text-green-300',
            used_as_incoming: 'bg-blue-100 dark:bg-blue-900/30 text-blue-700 dark:text-blue-300',
            used_as_outgoing: 'bg-purple-100 dark:bg-purple-900/30 text-purple-700 dark:text-purple-300',
            terminated: 'bg-gray-200 dark:bg-gray-800 text-gray-700 dark:text-gray-300',
        };

        const titleText = fiber.connected_to_segment 
          ? `-> F${fiber.connected_to_fiber ?? ''} on ${fiber.connected_to_segment}` 
          : fiber.status.replace(/_/g, ' ');

        return (
            <div
                key={fiber.fiber_no}
                onClick={() => isTargetable ? handleTargetFiberClick(segmentId, fiber.fiber_no) : handleFiberClick(segmentId, fiber.fiber_no, fiber.status)}
                className={`flex items-center justify-between p-2 rounded-md transition-all duration-200 ${
                    isSelected ? 'ring-2 ring-yellow-500 bg-yellow-100 dark:bg-yellow-900/40' :
                    isTargetable ? 'cursor-pointer hover:bg-green-200 dark:hover:bg-green-800/50' :
                    fiber.status === 'used_as_outgoing' ? 'cursor-not-allowed opacity-60' : 'cursor-pointer hover:bg-gray-100 dark:hover:bg-gray-700'
                } ${statusClasses[fiber.status] || ''}`}
            >
                <div className="flex items-center gap-2 min-w-0">
                    <span className="font-mono text-xs font-bold w-6 text-center">{fiber.fiber_no}</span>
                    {fiber.status !== 'available' && <FiLink className="w-3 h-3 flex-shrink-0" />}
                    <span className="text-xs truncate" title={titleText}>
                        {titleText}
                    </span>
                </div>
                {fiber.splice_id && fiber.status === 'used_as_incoming' && (
                    <button onClick={(e) => { e.stopPropagation(); handleRemoveSplice(fiber); }} className="p-1 rounded-full hover:bg-red-200 dark:hover:bg-red-800 text-red-500">
                        <FiX className="w-3 h-3" />
                    </button>
                )}
            </div>
        );
    };

    return (
        <div className="bg-white dark:bg-gray-800 p-6 rounded-lg shadow-md border dark:border-gray-700">
            <div className="flex flex-wrap justify-between items-center gap-4 mb-4">
              <h3 className="text-xl font-semibold">Splice Manager: {junction_closure.name}</h3>
              <div className="flex items-center gap-2">
                <Button size="sm" onClick={() => setShowVisualizationModal(true)} variant="outline">
                    View All Splices
                </Button>
                {/* NEW SYNC BUTTON */}
                <Button 
                    size="sm" 
                    variant="primary" 
                    onClick={() => syncPathUpdatesMutation.mutate({ jcId: junctionClosureId! })}
                    disabled={syncPathUpdatesMutation.isPending}
                    leftIcon={syncPathUpdatesMutation.isPending ? <Loader2 className="animate-spin" /> : <FiRefreshCw />}
                >
                    {syncPathUpdatesMutation.isPending ? "Syncing..." : "Apply Path Updates"}
                </Button>
              </div>
            </div>
            
            {/* ... rest of the component remains the same ... */}
            {selectedFiber && (
                <div className="p-3 mb-4 bg-yellow-50 dark:bg-yellow-900/20 border border-yellow-200 dark:border-yellow-700 rounded-lg text-center">
                    <p className="text-sm font-medium text-yellow-800 dark:text-yellow-200">
                        Selected Fiber #{selectedFiber.fiberNo} from {segments_at_jc.find(s => s.segment_id === selectedFiber.segmentId)?.segment_name}. Click an available fiber to create a splice.
                    </p>
                </div>
            )}
            
            <div className="grid gap-4" style={{ gridTemplateColumns }}>
                {segments_at_jc.map((segment, index) => (
                    <div key={segment.segment_id} className="bg-gray-50 dark:bg-gray-900/50 p-3 rounded-lg border dark:border-gray-700">
                        <h4 className="font-bold text-sm mb-2 truncate"><TruncateTooltip text={segment.segment_name} /></h4>
                        <p className="text-xs text-gray-500 dark:text-gray-400 mb-3">Fibers: {segment.fiber_count}</p>
                        
                        {index < segments_at_jc.length - 1 && (
                             <Button size="xs" onClick={() => handleAutoSplice(segment.segment_id, segments_at_jc[index + 1].segment_id)} className="w-full mb-3" variant="outline">
                                <FiZap className="w-3 h-3 mr-1"/> Auto-Splice
                            </Button>
                        )}

                        <div className="space-y-1 max-h-96 overflow-y-auto">
                            {segment.fibers.map((fiber) => renderFiber(fiber, segment.segment_id))}
                        </div>
                    </div>
                ))}
            </div>

            <SpliceVisualizationModal isOpen={showVisualizationModal} onClose={() => setShowVisualizationModal(false)} junctionClosureId={junctionClosureId} />

            {showLossModal && (
                <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 p-4">
                    <div className="bg-white dark:bg-gray-800 rounded-lg shadow-xl p-6 max-w-2xl w-full max-h-[90vh] overflow-y-auto">
                        <h3 className="text-lg font-semibold mb-4">
                            {pendingSpliceAction?.type === 'auto' ? 'Auto-Splice Configuration' : 'Configure Splice Loss'}
                        </h3>
                        
                        {pendingSpliceAction?.type === 'auto' ? (
                            <>
                                <div className="mb-4">
                                    <p className="text-sm text-gray-600 dark:text-gray-400 mb-3">
                                        Splicing between: <strong>{pendingSpliceAction.autoData?.segment1Name}</strong> ↔ <strong>{pendingSpliceAction.autoData?.segment2Name}</strong>
                                    </p>
                                    <p className="text-sm text-gray-600 dark:text-gray-400">
                                        {autoSplicePairs.length} fiber pair{autoSplicePairs.length !== 1 ? 's' : ''} will be spliced
                                    </p>
                                </div>

                                <div className="mb-4 space-y-3">
                                    <label className="flex items-start gap-3 p-3 border rounded-lg cursor-pointer hover:bg-gray-50 dark:hover:bg-gray-700 transition-colors">
                                        <input
                                            type="radio"
                                            name="spliceMode"
                                            value="uniform"
                                            checked={autoSpliceMode === 'uniform'}
                                            onChange={(e) => setAutoSpliceMode(e.target.value as 'uniform' | 'individual')}
                                            className="mt-1"
                                        />
                                        <div className="flex-1">
                                            <div className="font-medium text-sm">Uniform Loss</div>
                                            <div className="text-xs text-gray-600 dark:text-gray-400">Apply same loss to all splices</div>
                                        </div>
                                    </label>
                                    
                                    <label className="flex items-start gap-3 p-3 border rounded-lg cursor-pointer hover:bg-gray-50 dark:hover:bg-gray-700 transition-colors">
                                        <input
                                            type="radio"
                                            name="spliceMode"
                                            value="individual"
                                            checked={autoSpliceMode === 'individual'}
                                            onChange={(e) => setAutoSpliceMode(e.target.value as 'uniform' | 'individual')}
                                            className="mt-1"
                                        />
                                        <div className="flex-1">
                                            <div className="font-medium text-sm">Individual Loss</div>
                                            <div className="text-xs text-gray-600 dark:text-gray-400">Set different loss for each splice</div>
                                        </div>
                                    </label>
                                </div>

                                {autoSpliceMode === 'uniform' ? (
                                    <div className="mb-6">
                                        <label htmlFor="lossDb" className="block text-sm font-medium mb-2">
                                            Loss (dB) for all splices
                                        </label>
                                        <input
                                            id="lossDb"
                                            type="number"
                                            step="0.01"
                                            min="0"
                                            max="10"
                                            value={lossDbValue}
                                            onChange={(e) => setLossDbValue(e.target.value)}
                                            className="w-full px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500 dark:bg-gray-700"
                                            autoFocus
                                        />
                                        <p className="text-xs text-gray-500 dark:text-gray-400 mt-1">
                                            Typical splice loss: 0.1 - 0.5 dB
                                        </p>
                                    </div>
                                ) : (
                                    <div className="mb-6">
                                        <div className="flex items-center gap-2 mb-3">
                                            <input
                                                type="number"
                                                step="0.01"
                                                min="0"
                                                max="10"
                                                value={lossDbValue}
                                                onChange={(e) => setLossDbValue(e.target.value)}
                                                className="w-32 px-3 py-2 text-sm border border-gray-300 dark:border-gray-600 rounded-md focus:outline-none focus:ring-1 focus:ring-blue-500 dark:bg-gray-700"
                                                placeholder="0.3"
                                            />
                                            <Button size="xs" onClick={applyUniformLoss} variant="outline">
                                                Apply to All
                                            </Button>
                                        </div>
                                        
                                        <div className="border dark:border-gray-700 rounded-lg overflow-hidden">
                                            <div className="bg-gray-100 dark:bg-gray-900 px-3 py-2 grid grid-cols-3 gap-2 text-xs font-semibold">
                                                <div>Fiber 1</div>
                                                <div>Fiber 2</div>
                                                <div>Loss (dB)</div>
                                            </div>
                                            <div className="max-h-64 overflow-y-auto">
                                                {autoSplicePairs.map((pair, idx) => (
                                                    <div key={idx} className="px-3 py-2 grid grid-cols-3 gap-2 items-center border-t dark:border-gray-700 hover:bg-gray-50 dark:hover:bg-gray-700/50">
                                                        <div className="text-sm font-mono">#{pair.fiber1No}</div>
                                                        <div className="text-sm font-mono">#{pair.fiber2No}</div>
                                                        <input
                                                            type="number"
                                                            step="0.01"
                                                            min="0"
                                                            max="10"
                                                            value={pair.lossDb}
                                                            onChange={(e) => {
                                                                const newPairs = [...autoSplicePairs];
                                                                newPairs[idx].lossDb = e.target.value;
                                                                setAutoSplicePairs(newPairs);
                                                            }}
                                                            className="w-full px-2 py-1 text-sm border border-gray-300 dark:border-gray-600 rounded focus:outline-none focus:ring-1 focus:ring-blue-500 dark:bg-gray-700"
                                                        />
                                                    </div>
                                                ))}
                                            </div>
                                        </div>
                                    </div>
                                )}
                            </>
                        ) : (
                            <>
                                <p className="text-sm text-gray-600 dark:text-gray-400 mb-4">
                                    Enter the splice loss in dB for this connection:
                                </p>
                                <div className="mb-6">
                                    <label htmlFor="lossDb" className="block text-sm font-medium mb-2">
                                        Loss (dB)
                                    </label>
                                    <input
                                        id="lossDb"
                                        type="number"
                                        step="0.01"
                                        min="0"
                                        max="10"
                                        value={lossDbValue}
                                        onChange={(e) => setLossDbValue(e.target.value)}
                                        className="w-full px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500 dark:bg-gray-700"
                                        autoFocus
                                    />
                                    <p className="text-xs text-gray-500 dark:text-gray-400 mt-1">
                                        Typical splice loss: 0.1 - 0.5 dB
                                    </p>
                                </div>
                            </>
                        )}
                        
                        <div className="flex gap-3 justify-end">
                            <Button variant="outline" onClick={resetModal}>
                                Cancel
                            </Button>
                            <Button onClick={confirmSplice} disabled={manageSpliceMutation.isPending || autoSpliceMutation.isPending}>
                                {manageSpliceMutation.isPending || autoSpliceMutation.isPending ? 'Creating...' : 
                                    pendingSpliceAction?.type === 'auto' 
                                        ? `Create ${autoSplicePairs.length} Splice${autoSplicePairs.length !== 1 ? 's' : ''}` 
                                        : 'Confirm Splice'}
                            </Button>
                        </div>
                    </div>
                </div>
            )}
        </div>
    );
};
```

<!-- path: components/rings/RingModal.tsx -->
```typescript
"use client";

import React, { useCallback, useEffect, useMemo } from "react";
import { Modal } from "@/components/common/ui/Modal";
import { Option } from "@/components/common/ui/select/SearchableSelect";
import { useForm } from "react-hook-form";
import { zodResolver } from "@hookform/resolvers/zod";
import { FormCard } from "@/components/common/form/FormCard";
import {
  FormInput,
  FormSearchableSelect,
  FormSwitch,
  FormTextarea,
} from "@/components/common/form/FormControls";
import { ringsInsertSchema, RingsInsertSchema, RingsRowSchema } from "@/schemas/zod-schemas";

interface RingModalProps {
  isOpen: boolean;
  onClose: () => void;
  editingRing?: RingsRowSchema | null;
  // ** Use a single onSubmit handler**
  onSubmit: (data: RingsInsertSchema) => void; 
  isLoading: boolean; // Receive loading state from parent
  ringTypes: Array<{ id: string; name: string; code: string | null }>;
  maintenanceAreas: Array<{ id: string; name: string; code: string | null }>;
}

export function RingModal({
  isOpen,
  onClose,
  editingRing,
  onSubmit, // Use the new onSubmit prop
  isLoading,
  ringTypes,
  maintenanceAreas,
}: RingModalProps) {
  const {
    register,
    handleSubmit,
    formState: { errors },
    reset,
    control,
  } = useForm<RingsInsertSchema>({
    resolver: zodResolver(ringsInsertSchema),
    defaultValues: {
      name: "",
      description: null,
      ring_type_id: null,
      maintenance_terminal_id: null,
      status: true,
    },
  });

  // REMOVED: Internal mutation hooks are no longer needed
  // const supabase = createClient();
  // const { mutate: insertRing, isPending: creating } = useTableInsert(supabase, "rings");
  // const { mutate: updateRing, isPending: updating } = useTableUpdate(supabase, "rings");

  const isEdit = useMemo(() => Boolean(editingRing), [editingRing]);

  const ringTypeOptions: Option[] = useMemo(
    () => (ringTypes || []).map((rt) => ({ value: rt.id, label: `${rt.name}${rt.code ? ` (${rt.code})` : ""}` })),
    [ringTypes]
  );

  const maintenanceAreaOptions: Option[] = useMemo(
    () => (maintenanceAreas || []).map((a) => ({ value: a.id, label: `${a.name}${a.code ? ` (${a.code})` : ""}` })),
    [maintenanceAreas]
  );

  useEffect(() => {
    if (!isOpen) return;
    if (editingRing) {
      reset({
        name: editingRing.name ?? "",
        description: editingRing.description ?? null,
        status: editingRing.status ?? true,
        ring_type_id: editingRing.ring_type_id ?? null,
        maintenance_terminal_id: editingRing.maintenance_terminal_id ?? null,
      });
    } else {
      reset({
        name: "", description: null, status: true, ring_type_id: null, maintenance_terminal_id: null,
      });
    }
  }, [isOpen, editingRing, reset]);

  // ** The form's submit handler now just calls the prop.**
  const onValidSubmit = useCallback(
    (formData: RingsInsertSchema) => {
      onSubmit(formData);
    },
    [onSubmit]
  );

  return (
    <Modal
      isOpen={isOpen}
      onClose={onClose}
      title={isEdit ? "Edit Ring" : "Add Ring"}
      visible={false}
      className="transparent bg-gray-700 rounded-2xl"
    >
      <FormCard
        onSubmit={handleSubmit(onValidSubmit)}
        heightClass="min-h-calc(90vh - 200px)"
        title={isEdit ? "Edit Ring" : "Add Ring"}
        onCancel={onClose}
        isLoading={isLoading} // Use loading state from props
        standalone={true}
      >
        <FormInput
          name="name"
          label="Name"
          register={register}
          error={errors.name}
          disabled={isLoading}
          placeholder="Enter ring name"
        />
        <FormSearchableSelect
          name="ring_type_id"
          label="Ring Type"
          control={control}
          error={errors.ring_type_id}
          disabled={isLoading}
          placeholder="Select ring type"
          options={ringTypeOptions}
        />

        <FormSearchableSelect
          name="maintenance_terminal_id"
          label="Maintenance Terminal"
          control={control}
          error={errors.maintenance_terminal_id}
          disabled={isLoading}
          placeholder="Select maintenance terminal"
          options={maintenanceAreaOptions}
        />

        <FormTextarea
          name="description"
          label="Description"
          control={control}
          error={errors.description}
          disabled={isLoading}
          placeholder="Optional description"
        />
        <FormSwitch
          name="status"
          label="Status"
          control={control}
          error={errors.status}
          className="my-2"
        />
      </FormCard>
    </Modal>
  );
}

```

<!-- path: components/rings/RingSystemsModal.tsx -->
```typescript
// path: components/rings/RingSystemsModal.tsx
"use client";

import React, { useState, useEffect } from 'react';
import { useQuery, useMutation, useQueryClient } from '@tanstack/react-query';
import { createClient } from '@/utils/supabase/client';
import { Modal, Button, PageSpinner, ErrorDisplay } from '@/components/common/ui';
import { V_ringsRowSchema } from '@/schemas/zod-schemas';
import { toast } from 'sonner';
import { ArrowLeft, ArrowRight } from 'lucide-react';

interface SystemOption {
  id: string;
  name: string | null;
}

interface RingSystemsModalProps {
  isOpen: boolean;
  onClose: () => void;
  ring: V_ringsRowSchema | null;
}

// Data fetching hook
const useRingSystemsData = (ring: V_ringsRowSchema | null) => {
  const supabase = createClient();
  return useQuery({
    queryKey: ['ring-systems-data', ring?.id],
    queryFn: async () => {
      if (!ring?.id || !ring.maintenance_terminal_id) {
        return { associated: [], available: [] };
      }

      // Fetch systems already associated with this ring (no change here)
      const { data: associated, error: assocError } = await supabase
        .from('v_systems_complete')
        .select('id, system_name')
        .eq('ring_id', ring.id);
      if (assocError) throw new Error(`Failed to fetch associated systems: ${assocError.message}`);

      // CORRECTED QUERY: Fetch available systems ONLY from the same maintenance area
      const { data: available, error: availError } = await supabase
        .from('v_systems_complete')
        .select('id, system_name')
        .in('system_type_name', ['CPAN', 'MAAN', 'SDH'])
        .is('ring_id', null)
        .eq('maintenance_terminal_id', ring.maintenance_terminal_id); // <-- THE FIX

      if (availError) throw new Error(`Failed to fetch available systems: ${availError.message}`);

      return { associated: associated || [], available: available || [] };
    },
    enabled: !!ring?.id && !!ring.maintenance_terminal_id,
  });
};

export function RingSystemsModal({ isOpen, onClose, ring }: RingSystemsModalProps) {
  const queryClient = useQueryClient();
  const supabase = createClient();
  const { data, isLoading, isError, error } = useRingSystemsData(ring);

  const [associated, setAssociated] = useState<SystemOption[]>([]);
  const [available, setAvailable] = useState<SystemOption[]>([]);
  const [selectedAssociated, setSelectedAssociated] = useState<Set<string>>(new Set());
  const [selectedAvailable, setSelectedAvailable] = useState<Set<string>>(new Set());

  // CORRECTED: This effect, with your provided fix, correctly maps the
  // data from the API shape (`system_name`) to the component state shape (`name`).
  useEffect(() => {
    if (data) {
      setAssociated(data.associated.map(item => ({ id: item.id, name: item.system_name })));
      setAvailable(data.available.map(item => ({ id: item.id, name: item.system_name })));
    }
  }, [data]);
  
  const updateMutation = useMutation({
    mutationFn: async (systemIds: string[]) => {
      if (!ring?.id) throw new Error("Ring ID is missing.");
      const { error } = await supabase.rpc('update_ring_system_associations', {
        p_ring_id: ring.id,
        p_system_ids: systemIds,
      });
      if (error) throw error;
    },
    onSuccess: () => {
      toast.success(`Systems for ring "${ring?.name}" have been updated.`);
      queryClient.invalidateQueries({ queryKey: ['ring-systems-data', ring?.id] });
      queryClient.invalidateQueries({ queryKey: ['table', 'rings'] });
      queryClient.invalidateQueries({ queryKey: ['table', 'v_rings'] });
      onClose();
    },
    onError: (err) => toast.error(`Failed to update systems: ${err.message}`),
  });

  const handleToggleSelection = (list: 'associated' | 'available', id: string) => {
    const [selected, setSelected] = list === 'associated' ? [selectedAssociated, setSelectedAssociated] : [selectedAvailable, setSelectedAvailable];
    const newSelection = new Set(selected);
    if (newSelection.has(id)) {
      newSelection.delete(id);
    } else {
      newSelection.add(id);
    }
    setSelected(newSelection);
  };

  const moveItems = (from: 'available' | 'associated') => {
    if (from === 'available') {
      const itemsToMove = available.filter(item => selectedAvailable.has(item.id));
      setAssociated(prev => [...prev, ...itemsToMove].sort((a, b) => a.name!.localeCompare(b.name!)));
      setAvailable(prev => prev.filter(item => !selectedAvailable.has(item.id)));
      setSelectedAvailable(new Set());
    } else {
      const itemsToMove = associated.filter(item => selectedAssociated.has(item.id));
      setAvailable(prev => [...prev, ...itemsToMove].sort((a, b) => a.name!.localeCompare(b.name!)));
      setAssociated(prev => prev.filter(item => !selectedAssociated.has(item.id)));
      setSelectedAssociated(new Set());
    }
  };

  const handleSave = () => {
    const finalSystemIds = associated.map(item => item.id);
    updateMutation.mutate(finalSystemIds);
  };

  const ListBox: React.FC<{ title: string, items: SystemOption[], selected: Set<string>, onSelect: (id: string) => void }> = ({ title, items, selected, onSelect }) => (
    <div className="flex flex-col w-full border border-gray-300 dark:border-gray-600 rounded-lg">
      <h4 className="p-3 border-b border-gray-200 dark:border-gray-600 bg-gray-50 dark:bg-gray-700/50 font-semibold text-gray-800 dark:text-gray-200">{title} ({items.length})</h4>
      <div className="flex-1 overflow-y-auto p-2 min-h-[250px]">
        {items.length === 0 ? (
          <div className="flex items-center justify-center h-full text-sm text-gray-500 dark:text-gray-400">No systems</div>
        ) : (
          items.map(item => (
            <div
              key={item.id}
              onClick={() => onSelect(item.id)}
              className={`p-2 rounded cursor-pointer text-sm ${selected.has(item.id) ? 'bg-blue-600 text-white' : 'hover:bg-gray-100 dark:hover:bg-gray-700 text-gray-800 dark:text-gray-200'}`}
            >
              {item.name}
            </div>
          ))
        )}
      </div>
    </div>
  );

  return (
    <Modal isOpen={isOpen} onClose={onClose} title={`Manage Systems in Ring: ${ring?.name}`} size="xl">
      {isLoading ? <PageSpinner text="Loading systems..." /> :
       isError ? <ErrorDisplay error={error.message} /> :
       (
        <div className="space-y-4">
          <div className="grid grid-cols-1 md:grid-cols-[1fr_auto_1fr] gap-4 items-center">
            <ListBox title="Available Systems" items={available} selected={selectedAvailable} onSelect={(id) => handleToggleSelection('available', id)} />
            
            <div className="flex flex-col gap-2">
              <Button onClick={() => moveItems('available')} disabled={selectedAvailable.size === 0}><ArrowRight className="h-4 w-4" /></Button>
              <Button onClick={() => moveItems('associated')} disabled={selectedAssociated.size === 0}><ArrowLeft className="h-4 w-4" /></Button>
            </div>
            
            <ListBox title="Associated Systems" items={associated} selected={selectedAssociated} onSelect={(id) => handleToggleSelection('associated', id)} />
          </div>
          <div className="flex justify-end gap-2 pt-4 border-t border-gray-200 dark:border-gray-700">
            <Button variant="outline" onClick={onClose} disabled={updateMutation.isPending}>Cancel</Button>
            <Button onClick={handleSave} disabled={updateMutation.isPending}>
              {updateMutation.isPending ? "Saving..." : "Save Changes"}
            </Button>
          </div>
        </div>
       )}
    </Modal>
  );
}
```

<!-- path: components/rings/RingsFilters.tsx -->
```typescript
import { FiSearch } from "react-icons/fi";

interface RingsFiltersProps {
  searchQuery: string;
  onSearchChange: (value: string) => void;
}

export function RingsFilters({ searchQuery, onSearchChange }: RingsFiltersProps) {
  return (
    <div className="w-full">
      <div className="flex-1 sm:max-w-md lg:max-w-xl">
        <div className="relative">
          <FiSearch className="absolute left-3 top-1/2 -translate-y-1/2 text-gray-400 w-4 h-4 sm:w-5 sm:h-5" />
          <input
            type="text"
            placeholder="Search rings..."
            value={searchQuery}
            onChange={(e) => onSearchChange(e.target.value)}
            className="w-full pl-9 sm:pl-10 pr-4 py-2.5 sm:py-2 text-sm sm:text-base border border-gray-300 dark:border-gray-600 rounded-lg bg-white dark:bg-gray-700 text-gray-900 dark:text-white placeholder-gray-500 dark:placeholder-gray-400 focus:ring-2 focus:ring-blue-500 focus:border-blue-500 transition-colors"
          />
        </div>
      </div>
    </div>
  );
}

export default RingsFilters;

```

<!-- path: components/diagrams/hooks/useFileHandling.ts -->
```typescript
// hooks/useFileHandling.ts
import { useCallback, useRef } from 'react';
import { AppUppy } from './useUppyUploader';

export function useFileHandling(uppyRef: React.RefObject<AppUppy | null>) {
  const fileInputRef = useRef<HTMLInputElement>(null);

  const handleFileInputChange = useCallback((event: React.ChangeEvent<HTMLInputElement>) => {
    const files = event.target.files;
    if (files && uppyRef.current) {
      Array.from(files).forEach((file) => {
        uppyRef.current?.addFile({
          name: file.name,
          type: file.type,
          data: file,
          source: "file-input",
          isRemote: false,
        });
      });
      event.target.value = '';
    }
  }, [uppyRef]);

  const triggerFileInput = useCallback(() => {
    fileInputRef.current?.click();
  }, []);

  const handleRemoveFile = useCallback((fileId: string) => {
    uppyRef.current?.removeFile(fileId);
  }, [uppyRef]);

  return {
    fileInputRef,
    handleFileInputChange,
    triggerFileInput,
    handleRemoveFile
  };
}
```

<!-- path: components/diagrams/hooks/useFolders.ts -->
```typescript
// hooks/useFolders.ts
"use client";

import { useState, useCallback } from 'react';
import { createClient } from "@/utils/supabase/client";
import { useMutation, useQuery, useQueryClient } from "@tanstack/react-query";

interface Folder {
  id: string;
  name: string;
  user_id: string;
  uploaded_at: string;
}

interface UseFoldersReturn {
  folders: Folder[];
  folderId: string | null;
  setFolderId: (id: string | null) => void;
  newFolderName: string;
  setNewFolderName: (name: string) => void;
  handleCreateFolder: () => void;
  refreshFolders: () => Promise<void>;
  isCreatingFolder: boolean;
  isLoading: boolean;
}

interface UseFoldersProps {
  onError?: (error: string) => void;
  onSuccess?: () => void;
}

export function useFolders({
  onError,
  onSuccess
}: UseFoldersProps = {}): UseFoldersReturn {
  const supabase = createClient();
  const [folderId, setFolderId] = useState<string | null>(null);
  const [newFolderName, setNewFolderName] = useState("");
  const queryClient = useQueryClient();

  // Fetch folders
  const { data: folders = [], isLoading } = useQuery<Folder[]>({
    queryKey: ['folders'],
    queryFn: async () => {
      const { data: { user }, error: authError } = await supabase.auth.getUser();
      if (authError || !user) return [];

      const { data, error } = await supabase
        .from("folders")
        .select("*");
        // .eq("user_id", user.id);

      if (error) {
        console.error("Fetch folders error:", error);
        onError?.("Failed to load folders");
        return [];
      }
      
      return data || [];
    }
  });

  // Create folder mutation
  const { mutate: createFolder, isPending: isCreating } = useMutation({
    mutationFn: async (name: string) => {
      const { data: { user }, error: authError } = await supabase.auth.getUser();
      if (authError || !user) throw new Error("Not authenticated");
      if (!name.trim()) throw new Error("Folder name cannot be empty");

      const { data, error } = await supabase
        .from("folders")
        .insert({
          user_id: user.id,
          name: name.trim(),
        })
        .select()
        .single();

      if (error) throw error;
      return data;
    },
    onSuccess: () => {
      setNewFolderName("");
      queryClient.invalidateQueries({ queryKey: ['folders'] });
      onSuccess?.();
    },
    onError: (error: Error) => {
      console.error("Create folder error:", error);
      onError?.(error.message);
    },
  });

  const handleCreateFolder = useCallback(() => {
    if (newFolderName.trim()) {
      createFolder(newFolderName);
    }
  }, [createFolder, newFolderName]);

  const refreshFolders = useCallback(async () => {
    await queryClient.invalidateQueries({ queryKey: ['folders'] });
  }, [queryClient]);

  return {
    folders,
    folderId,
    setFolderId,
    newFolderName,
    setNewFolderName,
    handleCreateFolder,
    refreshFolders,
    isCreatingFolder: isCreating,
    isLoading,
  };
}
```

<!-- path: components/diagrams/hooks/useUppyUploader.ts -->
```typescript
// hooks/useUppyUploader.ts
import { useRef, useState, useEffect } from 'react';
import Uppy, { type UppyFile } from '@uppy/core';
import XHRUpload from '@uppy/xhr-upload';
import Webcam from '@uppy/webcam';
import { createClient } from "@/utils/supabase/client";
import { createOptimizedUppy } from "@/utils/imageOptimization";
import { smartCompress, convertToWebP, createProgressiveJPEG } from "@/utils/imageOptimization";
import { useUploadFile } from "@/hooks/database/file-queries";


export interface UploadedFile {
  public_id: string;
  secure_url: string | null | undefined;
  [key: string]: unknown;
}

export interface SelectedFile {
  id: string;
  name: string;
  type: string;
  size: number;
}

type UppyMeta = { folderId: string | null };
type UppyBody = Record<string, never>;
export type AppUppy = Uppy<UppyMeta, UppyBody>;
type AppUppyFile = UppyFile<UppyMeta, UppyBody>;

interface UploadSuccessResponse {
  body?: unknown;
  status: number;
  bytesUploaded?: number;
  uploadURL?: string;
}

const isUploadedFile = (value: unknown): value is UploadedFile => {
  if (!value || typeof value !== "object") {
    return false;
  }

  const record = value as Record<string, unknown>;
  return typeof record.public_id === "string";
};

interface UseUppyUploaderProps {
  folderId: string | null;
  // refresh: boolean;
  setRefresh: React.Dispatch<React.SetStateAction<boolean>>;
  // error?: string | null;
  setError: React.Dispatch<React.SetStateAction<string | null>>;
}

interface UseUppyUploaderReturn {
  uppyRef: React.RefObject<AppUppy | null>;
  uploadedFiles: UploadedFile[];
  selectedFiles: SelectedFile[];
  isUploading: boolean;
  processedFiles: Set<string>;
  handleStartUpload: () => void;
  toggleCamera: () => void;
  toggleCameraActive: () => void;
  facingMode: 'user' | 'environment';
  isCameraActive: boolean;
  cameraError: string | null;
}

export function useUppyUploader({
  folderId,
  setRefresh,
  setError,
}: UseUppyUploaderProps): UseUppyUploaderReturn {
  const { mutate: uploadFile } = useUploadFile();
  const supabase = createClient();
  const uppyRef = useRef<AppUppy | null>(null);
  const [uploadedFiles, setUploadedFiles] = useState<UploadedFile[]>([]);
  const [selectedFiles, setSelectedFiles] = useState<SelectedFile[]>([]);
  const [isUploading, setIsUploading] = useState(false);
  const [facingMode, setFacingMode] = useState<'user' | 'environment'>(
    (localStorage.getItem("preferredCamera") as 'user' | 'environment') || 'environment'
  );
  const [isCameraActive, setIsCameraActive] = useState(false);
  const [cameraError, setCameraError] = useState<string | null>(null);
  const [processedFiles, setProcessedFiles] = useState<Set<string>>(new Set());
  const processedFilesRef = useRef<Set<string>>(new Set());

  useEffect(() => {
    processedFilesRef.current = processedFiles;
  }, [processedFiles]);

  const addProcessedFile = (fileId: string) => {
    setProcessedFiles((prev) => {
      if (prev.has(fileId)) {
        return prev;
      }
      const next = new Set(prev);
      next.add(fileId);
      processedFilesRef.current = next;
      return next;
    });
  };

  const removeProcessedFile = (fileId: string) => {
    setProcessedFiles((prev) => {
      if (!prev.has(fileId)) {
        return prev;
      }
      const next = new Set(prev);
      next.delete(fileId);
      processedFilesRef.current = next;
      return next;
    });
  };

  const resetProcessedFiles = () => {
    const empty = new Set<string>();
    processedFilesRef.current = empty;
    setProcessedFiles(empty);
  };


  // Initialize Uppy
  useEffect(() => {
    const uppy = createOptimizedUppy({ folderId }) as AppUppy;

    uppy.use(XHRUpload, {
      endpoint: "/api/upload",
      method: "POST",
      formData: true,
      fieldName: "file",
      bundle: false,
      headers: {
        "x-folder-id": folderId || "",
      },
      limit: 14,
    });

    // Configure Webcam
    const webcamPlugin = uppy.use(Webcam, {
      onBeforeSnapshot: () => Promise.resolve(),
      countdown: false,
      modes: ["video-audio", "video-only", "audio-only", "picture"],
      mirror: facingMode === "user",
      videoConstraints: {
        facingMode: facingMode,
      },
      showVideoSourceDropdown: true,
    });

    if (webcamPlugin && typeof webcamPlugin.on === "function") {
      webcamPlugin.on("error", (error: unknown) => {
        const message = error instanceof Error ? error.message : "Unknown camera error";
        setCameraError(`Camera error: ${message}`);
        console.error("Webcam error:", error);
      });
    }

    // Add optimization preprocessor
    uppy.addPreProcessor(async (fileIDs) => {
      const optimizationPromises = fileIDs.map(async (fileID) => {
        const file = uppy.getFile(fileID);

        if (file?.type?.startsWith("image/") && file.data instanceof Blob) {
          try {
            const originalName = typeof file.name === "string" && file.name ? file.name : "image-upload";
            const sourceFile =
              file.data instanceof File ? file.data : new File([file.data], originalName, { type: file.type ?? "application/octet-stream" });

            let optimizedFile = await smartCompress(sourceFile);
            if (!optimizedFile || optimizedFile.size === 0) {
              console.warn("Optimization failed for", file.name, "- using original");
              return;
            }

            const webpFile = await convertToWebP(optimizedFile);
            if (webpFile.size < optimizedFile.size) {
              optimizedFile = webpFile;
            }

            if (optimizedFile.type === "image/jpeg") {
              optimizedFile = await createProgressiveJPEG(optimizedFile);
            }

            if (optimizedFile.size > 0) {
              uppy.setFileState(fileID, {
                data: optimizedFile,
                size: optimizedFile.size,
              });

              console.log(
                `Optimized ${file.name}: ${((file.size ?? 0) / 1024 / 1024).toFixed(2)}MB → ${(optimizedFile.size / 1024 / 1024).toFixed(2)}MB`,
              );
            }
          } catch (error) {
            console.warn(`Failed to optimize ${file.name}:`, error);
            uppy.setFileState(fileID, {
              data: file.data,
              size: file.size,
            });
          }
        }
      });

      await Promise.all(optimizationPromises);
    });

    uppy.on("upload", () => {
      setIsUploading(true);
      setCameraError(null);
    });

    uppy.on("upload-success", async (file: AppUppyFile | undefined, response: UploadSuccessResponse) => {
      try {
        if (!file || processedFilesRef.current.has(file.id)) return;
        addProcessedFile(file.id);

        const { data: userData, error: userError } = await supabase.auth.getUser();
        if (userError || !userData?.user) {
          throw new Error("User not authenticated");
        }

        const responseBody = response?.body;

        if (!isUploadedFile(responseBody)) {
          console.error("Missing public_id in response:", {
            file: file.name,
            response: responseBody,
          });
          setError("Upload response is missing public_id.");
          return;
        }

        const fileName = typeof file.name === "string" ? file.name : "Unnamed File";

        if (!fileName) {
          throw new Error("File name is required");
        }

        const fileData = {
          user_id: userData.user.id,
          file_name: fileName,
          file_type: typeof file.type === "string" && file.type ? file.type : 'application/octet-stream',
          file_size: typeof file.size === "number" ? file.size.toString() : '0',
          file_route: responseBody.public_id,
          file_url: responseBody.secure_url ?? "",
          folder_id: folderId || null,
        };

        try {
          await uploadFile(fileData);
          setUploadedFiles((prev) => [...prev, responseBody]);
          setRefresh((prev) => !prev);
        } catch (error) {
          const message = error instanceof Error ? error.message : 'Unknown error';
          console.error("Error saving file to database:", error);
          setError(`Database error: ${message}`);
          removeProcessedFile(file.id);
        }
      } catch (error) {
        const message = error instanceof Error ? error.message : "Unexpected error occurred during upload.";
        console.error("Upload success handler error:", error);
        setError(message);
        if (file) {
          removeProcessedFile(file.id);
        }
      }
    });

    uppy.on("upload-error", (_file: AppUppyFile | undefined, error: unknown) => {
      const message = error instanceof Error ? error.message : "Unknown error";
      console.error("Upload error:", error);
      setError(`Upload failed: ${message}`);
      setIsUploading(false);
    });

    uppy.on("complete", (result: { successful?: unknown[] } | undefined) => {
      console.log("Upload complete:", result);
      setIsUploading(false);
      if (Array.isArray(result?.successful) && result.successful.length > 0) {
        setError(null);
        setSelectedFiles([]);
        setTimeout(() => resetProcessedFiles(), 1000);
      }
    });

    uppy.on("file-added", (file: AppUppyFile) => {
      uppy.setFileMeta(file.id, { folderId });
      setSelectedFiles(prev => [
        ...prev.filter(f => f.id !== file.id),
        {
          id: file.id,
          name: typeof file.name === "string" ? file.name : "Unnamed File",
          type: typeof file.type === "string" && file.type ? file.type : "application/octet-stream",
          size: typeof file.size === "number" ? file.size : 0,
        },
      ]);
    });

    uppy.on("file-removed", (file: AppUppyFile) => {
      setSelectedFiles((prev) => prev.filter((f) => f.id !== file.id));
    });

    uppyRef.current = uppy;

    return () => {
      uppy.destroy();
      uppyRef.current = null;
    };
  }, [folderId, facingMode, setError, setRefresh, uploadFile, supabase]);

  const handleStartUpload = () => {
    if (!folderId) {
      setError("Please select a folder first.");
      return;
    }

    if (!selectedFiles.length) {
      setError("Please select files to upload first.");
      return;
    }

    uppyRef.current?.upload();
  };

  const toggleCamera = () => {
    const newMode = facingMode === "user" ? "environment" : "user";
    setFacingMode(newMode);
    localStorage.setItem("preferredCamera", newMode);

    if (uppyRef.current) {
      const webcamPlugin = uppyRef.current.getPlugin("Webcam");
      if (webcamPlugin) {
        webcamPlugin.setOptions({
          mirror: newMode === "user",
          facingMode: newMode,
        });
      }
    }
  };

  const toggleCameraActive = () => {
    setIsCameraActive((prev) => !prev);
  };

  return {
    uppyRef,
    uploadedFiles,
    selectedFiles,
    isUploading,
    processedFiles,
    handleStartUpload,
    toggleCamera,
    toggleCameraActive,
    facingMode,
    isCameraActive,
    cameraError
  };
}
```

<!-- path: components/diagrams/FileUploader.tsx -->
```typescript
// components/FileUploader.tsx
'use client';

import { useState, useCallback } from 'react';
import { FileTable } from './FileTable';
import { useUppyUploader } from './hooks/useUppyUploader';
import { useFolders } from './hooks/useFolders';
import { useFileHandling } from './hooks/useFileHandling';
import { Toaster } from 'sonner';
import { useQueryClient } from '@tanstack/react-query';

export default function FileUploader() {
  const queryClient = useQueryClient();
  const [error, setError] = useState<string | null>(null);
  const [showUploadSection, setShowUploadSection] = useState(false);
  // const [showDashboard, setShowDashboard] = useState(false);

  const {
    folders,
    folderId,
    newFolderName,
    setFolderId,
    setNewFolderName,
    handleCreateFolder,
    isCreatingFolder,
    isLoading: isLoadingFolders,
  } = useFolders({
    onError: setError,
    onSuccess: () => queryClient.invalidateQueries({ queryKey: ['files'] }),
  });

  // const handleUploadSuccess = useCallback(() => {
  //   queryClient.invalidateQueries({ queryKey: ['files'] });
  // }, [queryClient]);

  const {
    uppyRef,
    // uploadedFiles,
    selectedFiles,
    isUploading,
    handleStartUpload,
    // toggleCamera,
    // toggleCameraActive,
    // facingMode,
    // isCameraActive,
    // cameraError,
  } = useUppyUploader({
    folderId: folderId || null,
    setRefresh: () => {
      queryClient.invalidateQueries({ queryKey: ['files'] });
    },
    setError: (error) => {
      setError(error);
    },
  });

  const {
    fileInputRef,
    handleFileInputChange,
    triggerFileInput,
    // handleRemoveFile,
  } = useFileHandling(uppyRef);

  const handleFileDeleted = useCallback(() => {
    queryClient.invalidateQueries({ queryKey: ['files'] });
  }, [queryClient]);

  if(error){
    console.log("Error: ", error);
    
  }

  return (
    <div className="mx-auto max-w-4xl space-y-6 p-4">
      <Toaster position="top-right" duration={4000} />

      <button
        onClick={() => setShowUploadSection(!showUploadSection)}
        className="mb-4 px-4 py-2 bg-blue-500 text-white rounded hover:bg-blue-600 transition-colors"
      >
        {showUploadSection ? 'Hide Upload Section' : 'Show Upload Section'}
      </button>

      {showUploadSection && (
        <div className="space-y-4 p-4 border rounded-lg bg-white dark:bg-gray-800">
          {/* Folder Management */}
          <div className="space-y-2">
            <input
              type="text"
              value={newFolderName}
              onChange={(e) => setNewFolderName(e.target.value)}
              placeholder="New folder name"
              className="w-full p-2 border rounded"
              disabled={isCreatingFolder}
            />
            <button
              onClick={handleCreateFolder}
              disabled={!newFolderName.trim() || isCreatingFolder}
              className="px-4 py-2 bg-green-500 text-white rounded hover:bg-green-600 disabled:opacity-50"
            >
              {isCreatingFolder ? 'Creating...' : 'Create Folder'}
            </button>
          </div>

          {/* File Upload Area */}
          <div className="mt-4">
            <input
              type="file"
              ref={fileInputRef}
              onChange={handleFileInputChange}
              className="hidden"
              multiple
            />
            <button
              onClick={triggerFileInput}
              className="px-4 py-2 bg-blue-500 text-white rounded hover:bg-blue-600"
              disabled={isUploading}
            >
              {isUploading ? 'Uploading...' : 'Select Files'}
            </button>
            <button
              onClick={handleStartUpload}
              disabled={selectedFiles.length === 0 || isUploading}
              className="ml-2 px-4 py-2 bg-purple-500 text-white rounded hover:bg-purple-600 disabled:opacity-50"
            >
              {isUploading
                ? 'Uploading...'
                : `Upload ${selectedFiles.length} Files`}
            </button>
          </div>
        </div>
      )}

      {/* File Table */}
      <div className="mt-6">
        <FileTable
          folders={folders}
          onFileDelete={handleFileDeleted}
          folderId={folderId}
          onFolderSelect={setFolderId}
          isLoading={isLoadingFolders}
        />
      </div>
    </div>
  );
}

```

<!-- path: components/diagrams/FileTable.tsx -->
```typescript
"use client";

import { useState, useMemo, useEffect, useCallback } from "react";
import { Eye, Download, Trash2, Search, Filter, Grid, List, X } from "lucide-react";
import { useFiles, useDeleteFile } from "@/hooks/database/file-queries";
import "../../app/customuppy.css"; // Custom styles for Uppy

// Define file type for better type safety
interface FileType {
  id: string;
  file_name: string;
  file_type: string;
  file_url: string;
  uploaded_at: string;
  [key: string]: unknown;
}

interface FileTableProps {
  folders: Array<{ id: string; name: string }>;
  onFileDelete?: () => void;
  folderId?: string | null;
  onFolderSelect?: (id: string | null) => void;
  isLoading?: boolean;
}

export function FileTable({ folders, onFileDelete }: FileTableProps) {
  const [selectedFolder, setSelectedFolder] = useState<string | null>(null);
  const [folderSearchTerm, setFolderSearchTerm] = useState<string>("");
  const [fileSearchTerm, setFileSearchTerm] = useState<string>("");
  const [sortBy, setSortBy] = useState<"name" | "date" | "type">("date");
  const [sortOrder, setSortOrder] = useState<"asc" | "desc">("desc");
  const [fileTypeFilter, setFileTypeFilter] = useState<string>("all");
  const [viewMode, setViewMode] = useState<"grid" | "list">("list");
  const [deletingFile, setDeletingFile] = useState<string | null>(null);

  // Use React Query to fetch files
  const { data: files = [], isLoading, refetch } = useFiles(selectedFolder || undefined);
  const loading = isLoading; // Use loading state from React Query
  const { mutate: deleteFile } = useDeleteFile();

  // Filter folders based on folder search term and sort alphabetically in ascending order
  const filteredFolders = useMemo(() => 
    folders
      .filter(folder =>
        folder.name.toLowerCase().includes(folderSearchTerm.toLowerCase())
      )
      .sort((a, b) => a.name.toLowerCase().localeCompare(b.name.toLowerCase())),
    [folders, folderSearchTerm]
  );

  // Reset selected folder when it's not in filtered results
  useEffect(() => {
    if (selectedFolder && folderSearchTerm) {
      const isFolderVisible = filteredFolders.some(folder => folder.id === selectedFolder);
      if (!isFolderVisible) {
        setSelectedFolder(null);
      }
    }
  }, [selectedFolder, folderSearchTerm, filteredFolders]);


  // Sort and filter files based on user preferences
  const processedFiles = useMemo(() => {
    return (files as FileType[])
      .filter((file) => {
        const matchesSearch = file.file_name.toLowerCase().includes(fileSearchTerm.toLowerCase());
        const matchesType = fileTypeFilter === "all" || file.file_type?.includes(fileTypeFilter);
        return matchesSearch && matchesType;
      })
      .sort((a, b) => {
        let comparison = 0;
        
        if (sortBy === "name") {
          comparison = a.file_name.localeCompare(b.file_name);
        } else if (sortBy === "type") {
          comparison = (a.file_type || "").localeCompare(b.file_type || "");
        } else {
          // Sort by date
          const dateA = new Date(a.uploaded_at || 0).getTime();
          const dateB = new Date(b.uploaded_at || 0).getTime();
          comparison = dateA - dateB;
        }
        
        return sortOrder === "asc" ? comparison : -comparison;
      });
  }, [files, fileSearchTerm, fileTypeFilter, sortBy, sortOrder]);

  const handleView = (file: FileType) => {
    if (file.file_type === "application/pdf") {
      const googleViewerUrl = `https://docs.google.com/gview?url=${encodeURIComponent(file.file_url)}&embedded=true`;
      window.open(googleViewerUrl, '_blank');
    } else {
      window.open(file.file_url, '_blank');
    }
  };

  const handleDelete = (file: FileType) => {
    if (!confirm(`Are you sure you want to delete "${file.file_name}"?`)) {
      return;
    }

    setDeletingFile(file.id);
    deleteFile(
      { id: file.id, folderId: selectedFolder },
      {
        onSuccess: () => {
          onFileDelete?.();
          refetch();
        },
        onError: (error) => {
          console.error("Delete error:", error);
          alert("Failed to delete file");
        },
        onSettled: () => {
          setDeletingFile(null);
        }
      }
    );
  };

  const getDownloadUrl = (file: FileType) => {
    if (file.file_type === "application/pdf") {
      return file.file_url.replace("/upload/", "/upload/fl_attachment/");
    }
    return file.file_url;
  };

  const getFileIcon = (fileType: string = '') => {
    if (fileType.startsWith("image/")) return "🖼️";
    if (fileType === "application/pdf") return "📄";
    if (fileType.startsWith("video/")) return "🎥";
    if (fileType.startsWith("audio/")) return "🎵";
    if (fileType.includes("document") || fileType.includes("word")) return "📝";
    if (fileType.includes("spreadsheet") || fileType.includes("excel")) return "📊";
    if (fileType.includes("presentation") || fileType.includes("powerpoint")) return "📈";
    return "📎";
  };

  const formatDate = (dateString: string) => {
    return new Date(dateString).toLocaleDateString("en-US", {
      year: "numeric",
      month: "short",
      day: "numeric",
      hour: "2-digit",
      minute: "2-digit",
    });
  };

  // Helper function to truncate folder names with ellipsis
  const truncateFolderName = (name: string, maxLength: number = 20) => {
    if (name.length <= maxLength) return name;
    return name.substring(0, maxLength) + "...";
  };

  // Clear search functions
  const clearFolderSearch = useCallback(() => {
    setFolderSearchTerm("");
  }, []);

  const clearFileSearch = useCallback(() => {
    setFileSearchTerm("");
  }, []);

  // Filter and sort files
  const filteredAndSortedFiles = useMemo(() => {
    return (files as FileType[])
      .filter((file) => {
        const matchesSearch = file.file_name.toLowerCase().includes(fileSearchTerm.toLowerCase());
        const matchesType = fileTypeFilter === "all" || file.file_type.startsWith(fileTypeFilter);
        return matchesSearch && matchesType;
      })
      .sort((a, b) => {
        let aValue: string | Date;
        let bValue: string | Date;
        
        switch (sortBy) {
          case "name":
            aValue = a.file_name.toLowerCase();
            bValue = b.file_name.toLowerCase();
            break;
          case "type":
            aValue = a.file_type || '';
            bValue = b.file_type || '';
            break;
          case "date":
          default:
            aValue = new Date(a.uploaded_at || 0);
            bValue = new Date(b.uploaded_at || 0);
            break;
        }
        
        const comparison = aValue > bValue ? 1 : aValue < bValue ? -1 : 0;
        return sortOrder === "asc" ? comparison : -comparison;
      });
  }, [files, fileSearchTerm, fileTypeFilter, sortBy, sortOrder]);

  const getFileTypeOptions = () => {
    const types = [...new Set((files as FileType[]).map(file => file.file_type.split("/")[0]))];
    return types.map(type => ({
      value: type,
      label: type ? type.charAt(0).toUpperCase() + type.slice(1) : 'Unknown',
    }));
  };

  return (
    <div className="mt-8 space-y-6">
      <h2
        className={`text-xl font-semibold dark:text-white text-black`}
      >
        UPLOADED DIAGRAMS
      </h2>
      {/* Files Display */}
      {selectedFolder && (
        <div className="space-y-4">
          <div className="flex items-center justify-between">
            <h3 className={`text-lg font-medium dark:text-white text-black`}>
              Files ({filteredAndSortedFiles.length})
            </h3>
            {loading && (
              <div className="text-sm text-gray-500">Loading files...</div>
            )}
          </div>

          {/* File Search */}
          <div className="relative max-w-md">
            <Search className="absolute left-3 top-1/2 transform -translate-y-1/2 h-4 w-4 text-gray-400" />
            <input
              type="text"
              placeholder="Search files..."
              value={fileSearchTerm}
              onChange={(e) => setFileSearchTerm(e.target.value)}
              className={`w-full pl-10 pr-10 py-2 rounded border text-sm dark:border-gray-600 dark:bg-gray-700 dark:text-white dark:placeholder-gray-400 border-gray-300 bg-white text-black placeholder-gray-500 focus:outline-none focus:ring-2 focus:ring-blue-500`}
            />
            {fileSearchTerm && (
              <button
                onClick={clearFileSearch}
                className="absolute right-3 top-1/2 transform -translate-y-1/2 text-gray-400 hover:text-gray-600 transition-colors"
                title="Clear search"
              >
                <X className="h-4 w-4" />
              </button>
            )}
          </div>

          {loading ? (
            <div className="flex justify-center py-8">
              <div className="animate-spin rounded-full h-8 w-8 border-b-2 border-blue-500"></div>
            </div>
          ) : filteredAndSortedFiles.length > 0 ? (
            viewMode === "grid" ? (
              <div className="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 xl:grid-cols-4 gap-4">
                {filteredAndSortedFiles.map((file) => (
                  <div
                    key={file.id}
                    className={`group relative overflow-hidden rounded-lg border p-3 transition-all hover:shadow-lg dark:border-gray-600 dark:bg-gray-700 dark:hover:bg-gray-600 border-gray-200 bg-white hover:bg-gray-50`}
                  >
                    {/* File Preview */}
                    <div className="aspect-square mb-3 overflow-hidden rounded">
                      {file.file_type.includes("image") ? (
                        <img
                          src={file.file_url}
                          alt={file.file_name}
                          className="h-full w-full object-cover transition-transform group-hover:scale-105"
                        />
                      ) : (
                        <div className={`flex h-full w-full items-center justify-center dark:bg-gray-600 bg-gray-100`}>
                          <div className="text-center">
                            <div className="mb-2 text-3xl">{getFileIcon(file.file_type)}</div>
                            <p className="text-xs text-gray-500 uppercase">
                              {file.file_type.split("/")[1] || "FILE"}
                            </p>
                          </div>
                        </div>
                      )}
                    </div>

                    {/* File Info */}
                    <div className="space-y-1">
                      <p
                        className={`truncate text-sm font-medium dark:text-white text-black`}
                        title={file.file_name}
                      >
                        {file.file_name}
                      </p>
                      <p className="text-xs text-gray-500">
                        {formatDate(file.uploaded_at)}
                      </p>
                    </div>

                    {/* Action buttons */}
                    <div className="absolute top-2 right-2 flex gap-1 opacity-0 transition-opacity group-hover:opacity-100">
                      <button
                        onClick={() => handleView(file)}
                        title="View"
                        className="bg-opacity-80 hover:bg-opacity-100 rounded bg-black p-1.5 text-white transition-all"
                      >
                        <Eye className="h-3 w-3" />
                      </button>
                      <a
                        href={getDownloadUrl(file)}
                        download={file.file_name}
                        title="Download"
                        className="bg-opacity-80 hover:bg-opacity-100 rounded bg-black p-1.5 text-white transition-all"
                      >
                        <Download className="h-3 w-3" />
                      </a>
                      <button
                        onClick={() => handleDelete(file)}
                        disabled={deletingFile === file.id}
                        title="Delete"
                        className="bg-opacity-80 hover:bg-opacity-100 rounded bg-red-600 p-1.5 text-white transition-all disabled:opacity-50"
                      >
                        {deletingFile === file.id ? (
                          <div className="h-3 w-3 animate-spin rounded-full border border-white border-t-transparent"></div>
                        ) : (
                          <Trash2 className="h-3 w-3" />
                        )}
                      </button>
                    </div>
                  </div>
                ))}
              </div>
            ) : (
              <div className="overflow-hidden rounded-lg border">
                <div className={`dark:bg-gray-700 bg-gray-50 px-4 py-2 border-b`}>
                  <div className="grid grid-cols-12 gap-4 text-xs font-medium uppercase tracking-wide text-gray-500">
                    <div className="col-span-5">Name</div>
                    <div className="col-span-2">Type</div>
                    <div className="col-span-2">Date</div>
                    <div className="col-span-1">Actions</div>
                  </div>
                </div>
                <div className={`divide-y dark:divide-gray-600 divide-gray-200`}>
                  {filteredAndSortedFiles.map((file) => (
                    <div
                      key={file.id}
                      className={`group px-4 py-3 transition-colors hover:bg-gray-50`}
                    >
                      <div className="grid grid-cols-12 gap-4 items-center">
                        <div className="col-span-5 flex items-center gap-3">
                          <span className="text-lg">{getFileIcon(file.file_type)}</span>
                          <span
                            className={`truncate text-sm dark:text-white text-black`}
                            title={file.file_name}
                          >
                            {file.file_name}
                          </span>
                        </div>
                        <div className="col-span-2 text-xs text-gray-500 uppercase">
                          {file.file_type.split("/")[1] || "Unknown"}
                        </div>
                        <div className="col-span-2 text-xs text-gray-500">
                          {formatDate(file.uploaded_at)}
                        </div>
                        <div className="col-span-1 flex gap-1">
                          <button
                            onClick={() => handleView(file)}
                            title="View"
                            className={`p-1 text-gray-400 hover:text-blue-500 transition-colors`}
                          >
                            <Eye className="h-4 w-4" />
                          </button>
                          <a
                            href={getDownloadUrl(file)}
                            download={file.file_name}
                            title="Download"
                            className={`p-1 text-gray-400 hover:text-green-500 transition-colors`}
                          >
                            <Download className="h-4 w-4" />
                          </a>
                          <button
                            onClick={() => handleDelete(file)}
                            disabled={deletingFile === file.id}
                            title="Delete"
                            className={`p-1 text-gray-400 hover:text-red-500 transition-colors disabled:opacity-50`}
                          >
                            {deletingFile === file.id ? (
                              <div className="h-4 w-4 animate-spin rounded-full border border-gray-400 border-t-transparent"></div>
                            ) : (
                              <Trash2 className="h-4 w-4" />
                            )}
                          </button>
                        </div>
                      </div>
                    </div>
                  ))}
                </div>
              </div>
            )
          ) : (
            <div className={`text-center py-12 dark:text-gray-400 text-gray-500`}>
              <div className="text-4xl mb-4">📭</div>
              <p className="text-lg font-medium">No files found</p>
              <p className="text-sm">
                {fileSearchTerm || fileTypeFilter !== "all"
                  ? "Try adjusting your search or filter criteria."
                  : "Upload some files to get started."}
              </p>
            </div>
          )}
        </div>
      )}
      {/* Search and Filter Controls */}
      <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-4">
        {/* Folder Search */}
        <div className="relative">
          <Search className="absolute left-3 top-1/2 transform -translate-y-1/2 h-4 w-4 text-gray-400" />
          <input
            type="text"
            placeholder="Search folders..."
            value={folderSearchTerm}
            onChange={(e) => setFolderSearchTerm(e.target.value)}
            className={`w-full pl-10 pr-10 py-2 rounded border text-sm dark:border-gray-600 dark:bg-gray-700 dark:text-white dark:placeholder-gray-400 border-gray-300 bg-white text-black placeholder-gray-500 focus:outline-none focus:ring-2 focus:ring-blue-500`}
          />
          {folderSearchTerm && (
            <button
              onClick={clearFolderSearch}
              className="absolute right-3 top-1/2 transform -translate-y-1/2 text-gray-400 hover:text-gray-600 transition-colors"
              title="Clear search"
            >
              <X className="h-4 w-4" />
            </button>
          )}
        </div>

        {/* View Mode Toggle */}
        <div className="flex rounded border overflow-hidden">
          <button
            onClick={(e) => { e.stopPropagation(); setViewMode("grid"); }}
            className={`flex-1 px-3 py-2 text-sm transition-colors ${
              viewMode === "grid"
                ? "dark:bg-blue-700 dark:text-white bg-blue-600 text-white"
                : "dark:bg-gray-700 dark:text-gray-300 dark:hover:bg-gray-600 bg-gray-100 text-gray-700 hover:bg-gray-200"
            }`}
          >
            <Grid className="h-4 w-4 mx-auto" />
          </button>
          <button
            onClick={(e) => { e.stopPropagation(); setViewMode("list"); }}
            className={`flex-1 px-3 py-2 text-sm transition-colors ${
              viewMode === "list"
                ? "dark:bg-blue-700 dark:text-white bg-blue-600 text-white"
                : "dark:bg-gray-700 dark:text-gray-300 dark:hover:bg-gray-600 bg-gray-100 text-gray-700 hover:bg-gray-200"
            }`}
          >
            <List className="h-4 w-4 mx-auto" />
          </button>
        </div>
      </div>

      {/* File Type Filter */}
      {files.length > 0 && (
        <div className="flex gap-2 flex-wrap">
          <button
            onClick={() => setFileTypeFilter("all")}
            className={`px-3 py-1 rounded text-sm transition-colors ${
              fileTypeFilter === "all"
                ? "dark:bg-blue-700 dark:text-white bg-blue-600 text-white"
                : "dark:bg-gray-700 dark:text-gray-300 dark:hover:bg-gray-600 bg-gray-200 text-gray-700 hover:bg-gray-300"
            }`}
          >
            All Files ({files.length})
          </button>
          {getFileTypeOptions().map((option) => {
            const count = files.filter(file => file.file_type.startsWith(option.value)).length;
            // console.log(`File type: ${option.value}, Count: ${count}`, "label:", option.label);
            
            return (
              <button
                key={option.value}
                onClick={() => setFileTypeFilter(option.value)}
                className={`px-3 py-1 rounded text-sm transition-colors ${
                  fileTypeFilter === option.value
                    ? "dark:bg-blue-700 dark:text-white bg-blue-600 text-white"
                    : "dark:bg-gray-700 dark:text-gray-300 dark:hover:bg-gray-600 bg-gray-200 text-gray-700 hover:bg-gray-300"
                }`}
              >
                {option.label === "Application" ? "Pdf" : option.label} ({count})
              </button>
            );
          })}
        </div>
      )}

      {/* Folder Selection */}
      <div className="space-y-4">
        <h3 className={`text-lg font-medium dark:text-white text-black`}>
          Select Folder to View Files
        </h3>
        
        {filteredFolders.length > 0 ? (
          <div className="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 xl:grid-cols-4 2xl:grid-cols-5 gap-3">
            {filteredFolders.map((folder) => (
              <div key={folder.id} className="group relative">
                <button
                  className={`w-full p-4 rounded border text-left transition-all hover:shadow-md ${
                    selectedFolder === folder.id
                      ? "dark:border-blue-500 dark:bg-blue-900 shadow-lg"
                      : "dark:border-gray-600 dark:bg-gray-700 dark:hover:bg-gray-600 border-gray-200 bg-white hover:bg-gray-50"
                  } dark:text-white text-black`}
                  onClick={() => setSelectedFolder(folder.id)}
                  title={folder.name} // Show full name on hover
                >
                  <div className="flex items-center justify-between min-w-0">
                    <div className="flex items-center gap-2 min-w-0 flex-1">
                      <span className="text-lg flex-shrink-0">📁</span>
                      <span className="font-medium text-sm leading-tight break-words line-clamp-2 min-w-0">
                        {folder.name}
                      </span>
                    </div>
                    {selectedFolder === folder.id && (
                      <span className="text-xs bg-blue-500 text-white px-2 py-1 rounded flex-shrink-0 ml-2">
                        Selected
                      </span>
                    )}
                  </div>
                </button>
                
                {/* Tooltip for long folder names */}
                {folder.name.length > 25 && (
                  <div className="absolute bottom-full left-1/2 transform -translate-x-1/2 mb-2 px-3 py-2 bg-black text-white text-sm rounded opacity-0 group-hover:opacity-100 transition-opacity duration-200 pointer-events-none z-10 max-w-xs text-center">
                    {folder.name}
                    <div className="absolute top-full left-1/2 transform -translate-x-1/2 w-0 h-0 border-l-4 border-r-4 border-t-4 border-transparent border-t-black"></div>
                  </div>
                )}
              </div>
            ))}
          </div>
        ) : (
          <div className={`text-center py-8 dark:text-gray-400 text-gray-500`}>
            {folderSearchTerm ? "No folders found matching your search." : "No folders available."}
          </div>
        )}
      </div>


    </div>
  );
}
```

<!-- path: components/diagrams/types/storage.ts -->
```typescript
// components/diagrams/types/storage.ts
import { z } from 'zod';
import { filesRowSchema } from '@/schemas/zod-schemas';

//  Derive the type from the Zod schema.
export type StoredFile = z.infer<typeof filesRowSchema>;

export interface UploadProgress {
  [key: number]: number;
}

export interface StorageManagerProps {
  bucketName?: string;
  maxFileSize?: number;
  allowedFileTypes?: string[];
  onUploadComplete?: (files: StoredFile[]) => void;
  onError?: (error: string) => void;
}

export interface SupabaseStorageError {
  error: string;
  message: string;
  statusCode?: string;
}


```

<!-- path: components/diagrams/uploader-components/ErrorDisplay.tsx -->
```typescript
// components/diagrams/uploader-components/ErrorDisplay.tsx
import React, { useEffect } from "react";
import { toast } from "sonner";

interface ErrorDisplayProps {
  error: string | null;
  cameraError: string | null;
}

const ErrorDisplay: React.FC<ErrorDisplayProps> = ({
  error,
  cameraError,
}) => {
  useEffect(() => {
    if (error) {
      toast.error(error, {
        position: "top-right",
        duration: 5000,
      });
    }
  }, [error]);

  useEffect(() => {
    if (cameraError) {
      toast.warning(`Camera Error: ${cameraError}`, {
        position: "top-right",
        duration: 5000,
      });
    }
  }, [cameraError]);

  return null; // Toasts are handled globally
};

export default ErrorDisplay;

```

<!-- path: components/diagrams/uploader-components/AdvancedUpload.tsx -->
```typescript


"use client";

import React, { useRef } from "react";
import { Dashboard } from "@uppy/react";
import { Camera, CameraOff, Camera as CameraIcon, SwitchCamera } from "lucide-react";
import Uppy from "@uppy/core";

interface AdvancedUploadProps {
  uppyRef: React.RefObject<Uppy | null>;
  isCameraActive: boolean;
  toggleCameraActive: () => void;
  facingMode: "user" | "environment";
  toggleCamera: () => void;
}

const AdvancedUpload: React.FC<AdvancedUploadProps> = ({
  uppyRef,
  isCameraActive,
  toggleCameraActive,
  facingMode,
  toggleCamera,
}) => {
  const fileInputRef = useRef<HTMLInputElement | null>(null);

  const handleFileChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    if (e.target.files && e.target.files[0] && uppyRef.current) {
      const file = e.target.files[0];
      uppyRef.current.addFile({
        name: file.name,
        type: file.type,
        data: file,
        source: "Camera",
      });
    }
  };

  const openNativeCamera = () => {
    fileInputRef.current?.click();
  };

  return (
    <div className={`uppy-dashboard-container rounded-lg dark:uppy-dark uppy-light`}>
      {/* Native camera file input (hidden) */}
      <input
        ref={fileInputRef}
        type="file"
        accept="image/*"
        capture={facingMode}
        onChange={handleFileChange}
        className="hidden"
      />

      {/* Action Buttons */}
      <div className="mb-2 flex flex-wrap gap-2 justify-between items-center">
        <div className="flex gap-2">
          {/* <button
            onClick={toggleCameraActive}
            className={`flex items-center gap-2 rounded px-3 py-1 text-sm ${
              isNightMode
                ? "bg-gray-600 text-white hover:bg-gray-500"
                : "bg-gray-200 text-black hover:bg-gray-300"
            }`}
          >
            {isCameraActive ? (
              <>
                <CameraOff size={16} /> Stop Camera
              </>
            ) : (
              <>
                <Camera size={16} /> Start Camera
              </>
            )}
          </button> */}

          <button
            onClick={toggleCamera}
            className={`flex items-center gap-2 rounded px-3 py-1 text-sm dark:bg-gray-600 dark:text-white dark:hover:bg-gray-500 bg-gray-200 text-black hover:bg-gray-300`}
          >
            <SwitchCamera size={16} />
            Switch ({facingMode === "user" ? "Front" : "Back"})
          </button>
        </div>

        <button
          onClick={openNativeCamera}
          className="flex items-center gap-2 rounded px-3 py-1 text-sm bg-blue-600 text-white hover:bg-blue-700"
        >
          <CameraIcon size={16} /> Open Camera
        </button>
      </div>

      {/* Uppy Dashboard */}
      {uppyRef.current && (
        <div className="relative overflow-hidden rounded-lg">
          <Dashboard
            uppy={uppyRef.current}
            plugins={isCameraActive ? ["Webcam"] : []}
            height={400}
            width="100%"
            hideProgressDetails={true}
            showSelectedFiles={true}
            showRemoveButtonAfterComplete={true}
            disableStatusBar={false}
            disableInformer={false}
            disableThumbnailGenerator={false}
            proudlyDisplayPoweredByUppy={false}
            note="Select files to upload or drag and drop them here"
            locale={{
              strings: {
                uploading: "Uploading...",
                complete: "Complete",
                uploadFailed: "Upload failed",
                paused: "Paused",
                retry: "Retry",
                cancel: "Cancel",
                pause: "Pause",
                resume: "Resume",
                done: "Done",
                filesUploadedOfTotal: {
                  0: "%{complete} of %{smart_count} file uploaded",
                  1: "%{complete} of %{smart_count} files uploaded",
                },
                dataUploadedOfTotal: "%{complete} of %{total}",
                dataUploadedOfUnknown: "%{complete} uploaded",
                xTimeLeft: "%{time} left",
                uploadXFiles: {
                  0: "Upload %{smart_count} file",
                  1: "Upload %{smart_count} files",
                },
                uploadXNewFiles: {
                  0: "Upload %{smart_count} new file",
                  1: "Upload %{smart_count} new files",
                },
                upload: "Upload",
                retryUpload: "Retry upload",
                xMoreFilesAdded: {
                  0: "%{numFiles} more file added",
                  1: "%{numFiles} more files added",
                },
                showErrorDetails: "Show error details",
              },
            }}
          />
        </div>
      )}
    </div>
  );
};

export default AdvancedUpload;

```

<!-- path: components/diagrams/uploader-components/SimpleUpload.tsx -->
```typescript
import React from "react";
import type { AppUppy, SelectedFile } from "@/components/diagrams/hooks/useUppyUploader";
import { Loader2 } from "lucide-react";

interface SimpleUploadProps {
  uppyRef: React.RefObject<AppUppy | null>;
  fileInputRef: React.RefObject<HTMLInputElement | null>;
  handleFileInputChange: (event: React.ChangeEvent<HTMLInputElement>) => void;
  triggerFileInput: () => void;
  selectedFiles: SelectedFile[];
  handleRemoveFile: (fileId: string) => void;
  isUploading: boolean;
  handleStartUpload: () => void;
}

const formatFileSize = (bytes: number) => {
  if (bytes === 0) return "0 Bytes";
  const k = 1024;
  const sizes = ["Bytes", "KB", "MB", "GB"];
  const i = Math.floor(Math.log(bytes) / Math.log(k));
  return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + " " + sizes[i];
};

const SimpleUpload: React.FC<SimpleUploadProps> = ({
  uppyRef,
  fileInputRef,
  handleFileInputChange,
  triggerFileInput,
  selectedFiles,
  handleRemoveFile,
  isUploading,
  handleStartUpload,
}) => {
  return (
    <div className="space-y-4">
      <div
        id="uppy-drag-drop"
        onClick={triggerFileInput}
        className={`cursor-pointer rounded-lg border-2 border-dashed p-8 text-center transition-colors dark:border-gray-600 dark:bg-gray-750 dark:hover:border-gray-500`}
      >
        <input
          ref={fileInputRef}
          type="file"
          multiple
          accept="image/*,application/pdf,.doc,.docx,.txt,.rtf,video/*,audio/*"
          onChange={handleFileInputChange}
          className="hidden"
        />
        <div>
          <p className="text-lg font-medium">Drag files here or click to browse</p>
          <p className="mt-2 text-sm opacity-70">
            Supports images, PDFs, documents, audio, and video files
          </p>
        </div>
      </div>

      <div id="uppy-progress" className="w-full"></div>

      {selectedFiles.length > 0 && (
        <div
          className={`rounded-lg border p-4 dark:border-gray-600 dark:bg-gray-700`}
        >
          <h4
            className={`mb-3 text-sm font-medium dark:text-gray-200 text-gray-700`}
          >
            Selected Files ({selectedFiles.length})
          </h4>
          <div className="max-h-40 space-y-2 overflow-y-auto">
            {selectedFiles.map((file) => (
              <div
                key={file.id}
                className={`flex items-center justify-between rounded p-2 dark:hover:bg-gray-600 dark:bg-gray-650 border dark:border-gray-500`}
              >
                <div className="flex min-w-0 flex-1 items-center space-x-3">
                  <div className="flex-shrink-0">
                    {file.type?.startsWith("image/") ? (
                      <div className="flex h-8 w-8 items-center justify-center rounded bg-green-100">
                        <span className="text-xs text-green-600">🖼️</span>
                      </div>
                    ) : file.type?.includes("pdf") ? (
                      <div className="flex h-8 w-8 items-center justify-center rounded bg-red-100">
                        <span className="text-xs text-red-600">📄</span>
                      </div>
                    ) : file.type?.startsWith("video/") ? (
                      <div className="flex h-8 w-8 items-center justify-center rounded bg-blue-100">
                        <span className="text-xs text-blue-600">🎥</span>
                      </div>
                    ) : file.type?.startsWith("audio/") ? (
                      <div className="flex h-8 w-8 items-center justify-center rounded bg-purple-100">
                        <span className="text-xs text-purple-600">🎵</span>
                      </div>
                    ) : (
                      <div className="flex h-8 w-8 items-center justify-center rounded bg-gray-100">
                        <span className="text-xs text-gray-600">📁</span>
                      </div>
                    )}
                  </div>
                  <div className="min-w-0 flex-1">
                    <p
                      className={`truncate text-sm font-medium dark:text-white text-gray-900`}
                    >
                      {file.name}
                    </p>
                    <p
                      className={`text-xs dark:text-gray-400 text-gray-500`}
                    >
                      {formatFileSize(file.size)}
                    </p>
                  </div>
                </div>
                <button
                  onClick={() => handleRemoveFile(file.id)}
                  className={`ml-2 flex-shrink-0 rounded-full p-1 transition-colors dark:text-gray-400 dark:hover:bg-red-500 dark:hover:text-red-400 text-gray-500 hover:bg-red-500 hover:text-red`}
                  title="Remove file"
                >
                  <svg
                    className="h-4 w-4"
                    fill="none"
                    stroke="currentColor"
                    viewBox="0 0 24 24"
                  >
                    <path
                      strokeLinecap="round"
                      strokeLinejoin="round"
                      strokeWidth={2}
                      d="M6 18L18 6M6 6l12 12"
                    />
                  </svg>
                </button>
              </div>
            ))}
          </div>
        </div>
      )}

      <button
        onClick={handleStartUpload}
        disabled={selectedFiles.length === 0 || isUploading}
        className={`flex w-full items-center justify-center gap-2 rounded px-4 py-2 transition-colors disabled:cursor-not-allowed disabled:opacity-50 dark:bg-blue-700 dark:hover:bg-blue-800 dark:disabled:bg-gray-600 bg-blue-600 hover:bg-blue-700 disabled:bg-gray-400 text-white`}
      >
        {isUploading && <Loader2 className="h-4 w-4 animate-spin" />}
        {isUploading
          ? "Uploading..."
          : selectedFiles.length > 0
            ? `Upload ${selectedFiles.length} File${selectedFiles.length > 1 ? "s" : ""}`
            : "Start Upload"}
      </button>
    </div>
  );
};

export default SimpleUpload;
```

<!-- path: components/diagrams/uploader-components/UploadModeToggle.tsx -->
```typescript
// components/diagrams/uploader-components/UploadModeToggle.tsx
import React from "react";

interface UploadModeToggleProps {
  showDashboard: boolean;
  setShowDashboard: (value: boolean) => void;
  folderId: string | null;
}

const UploadModeToggle: React.FC<UploadModeToggleProps> = ({
  showDashboard,
  setShowDashboard,
  folderId,
}) => {
  return (
    <div className="flex gap-2">
      <button
        onClick={() => setShowDashboard(true)}
        disabled={!folderId}
        className={`flex-1 rounded px-4 py-2 font-medium transition-colors ${
          showDashboard
            ? "dark:bg-blue-700 bg-blue-600"
            : "dark:bg-gray-600 dark:hover:bg-gray-500 bg-gray-400 hover:bg-gray-500"
        } text-white disabled:cursor-not-allowed disabled:opacity-50`}
      >
        Advanced Upload
      </button>
      <button
        onClick={() => setShowDashboard(false)}
        className={`flex-1 rounded px-4 py-2 font-medium transition-colors ${
          !showDashboard
            ? "dark:bg-blue-700 bg-blue-600"
            : "dark:bg-gray-600 dark:hover:bg-gray-500 bg-gray-400 hover:bg-gray-500"
        } text-white`}
      >
        Simple Upload
      </button>
    </div>
  );
};

export default UploadModeToggle;
```

<!-- path: components/diagrams/uploader-components/FolderManagement.tsx -->
```typescript
// components/diagrams/uploader-components/FolderManagement.tsx
import React from "react";

interface FolderManagementProps {
  newFolderName: string;
  setNewFolderName: (value: string) => void;
  handleCreateFolder: () => void;
  folders: { id: string; name: string }[];
  folderId: string | null;
  setFolderId: (value: string | null) => void;
}

const FolderManagement: React.FC<FolderManagementProps> = ({
  newFolderName,
  setNewFolderName,
  handleCreateFolder,
  folders,
  folderId,
  setFolderId,
}) => {
  // Sort folders alphabetically by name
  const sortedFolders = [...folders].sort((a, b) => 
    a.name.localeCompare(b.name, undefined, { sensitivity: 'base' })
  );

  return (
    <>
      <div className="flex gap-2">
        <input
          type="text"
          placeholder="New folder name"
          value={newFolderName}
          onChange={(e) => setNewFolderName(e.target.value)}
          className={`flex-1 rounded border px-3 py-2 dark:border-gray-600 dark:bg-gray-700 dark:text-white dark:placeholder-gray-400`}
          onKeyPress={(e) => e.key === "Enter" && handleCreateFolder()}
        />
        <button
          onClick={handleCreateFolder}
          disabled={!newFolderName.trim()}
          className={`rounded px-4 py-2 font-medium transition-colors dark:bg-green-700 dark:hover:bg-green-600 dark:disabled:bg-gray-600 bg-green-600 hover:bg-green-500 disabled:bg-gray-400 text-white disabled:cursor-not-allowed`}
        >
          Create
        </button>
      </div>

      <div>
        <label
          className={`mb-2 block text-sm font-medium dark:text-gray-200 text-gray-700`}
        >
          Select Destination Folder
        </label>
        <select
          className={`w-full rounded border px-3 py-2 dark:border-gray-600 dark:bg-gray-700 dark:text-white`}
          value={folderId || ""}
          onChange={(e) => setFolderId(e.target.value || null)}
        >
          <option value="">Select Folder</option>
          {sortedFolders.map((folder) => (
            <option key={folder.id} value={folder.id}>
              {folder.name}
            </option>
          ))}
        </select>
      </div>
    </>
  );
};

export default FolderManagement;
```

<!-- path: components/diagrams/uploader-components/RecentlyUploaded.tsx -->
```typescript
// components/diagrams/uploader-components/RecentlyUploaded.tsx
import React from "react";
import Image from "next/image";
import { Eye, Download } from "lucide-react";

interface UploadedFileSummary {
  secure_url?: string | null;
  format?: string | null;
}

interface RecentlyUploadedProps {
  uploadedFiles: UploadedFileSummary[];
}

const RecentlyUploaded: React.FC<RecentlyUploadedProps> = ({
  uploadedFiles,
}) => {
  return (
    <div className="space-y-4">
      <h3
        className={`text-lg font-semibold dark:text-white text-black`}
      >
        Recently Uploaded
      </h3>
      <div className="grid grid-cols-2 gap-4 md:grid-cols-4">
        {uploadedFiles.slice(-4).map((file, index) => {
          const secureUrl = typeof file.secure_url === "string" ? file.secure_url : null;
          const isImageFile = secureUrl ? /\.(jpg|jpeg|png|gif|webp|bmp|svg)$/i.test(secureUrl) : false;

          return (
          <div
            key={index}
            className={`group relative overflow-hidden rounded border p-2 dark:border-gray-600 dark:bg-gray-700 dark:text-white`}
          >
            {isImageFile && secureUrl ? (
              <Image
                src={secureUrl}
                alt="Uploaded file"
                className="h-24 w-full rounded object-cover"
                width={300}
                height={96}
                style={{ objectFit: "cover" }}
              />
            ) : (
              <div className="flex h-24 w-full items-center justify-center rounded bg-gray-100">
                <div className="text-center">
                  <div className="mb-1 text-xl">📄</div>
                  <p className="text-xs text-gray-600">
                    {file.format?.toUpperCase() || "FILE"}
                  </p>
                </div>
              </div>
            )}

            {secureUrl && (
              <div className="absolute top-2 right-2 flex gap-1 opacity-0 transition-opacity group-hover:opacity-100">
                <button
                  onClick={() => window.open(secureUrl, "_blank")}
                  title="View"
                  className="bg-opacity-60 hover:bg-opacity-80 rounded bg-black p-1 text-white transition-all"
                >
                  <Eye className="h-3 w-3" />
                </button>
                <a
                  href={secureUrl}
                  download
                  title="Download"
                  className="bg-opacity-60 hover:bg-opacity-80 rounded bg-black p-1 text-white transition-all"
                >
                  <Download className="h-3 w-3" />
                </a>
              </div>
            )}
          </div>
        );
        })}
      </div>
    </div>
  );
};

export default RecentlyUploaded;
```

<!-- path: components/categories/EmptyState.tsx -->
```typescript
import { FiPlus } from "react-icons/fi";
import { Button } from "@/components/common/ui/Button";
import { Card } from "@/components/common/ui/card";

interface EmptyStateProps {
  onCreate: () => void;
}

export function EmptyState({ onCreate }: EmptyStateProps) {
  return (
    <Card className="p-8 text-center dark:border-gray-700 dark:bg-gray-800">
      <p className="mb-4 text-gray-500 dark:text-gray-400">
        No unique categories found.
      </p>
      <Button onClick={onCreate}>
        <FiPlus className="mr-2 h-4 w-4" />
        Create First Category
      </Button>
    </Card>
  );
}
```

<!-- path: components/categories/CategorySearch.tsx -->
```typescript
import { FiSearch } from "react-icons/fi";
import { Input } from "@/components/common/ui/Input";

interface CategorySearchProps {
  searchTerm: string;
  onSearchChange: (value: string) => void;
}

export function CategorySearch({
  searchTerm,
  onSearchChange,
}: CategorySearchProps) {
  return (
    <div className="max-w-md">
      <label className="mb-2 block text-sm font-medium text-gray-700 dark:text-gray-300">
        Search Categories
      </label>
      <div className="relative">
        <FiSearch className="absolute top-1/2 left-3 h-4 w-4 -translate-y-1/2 transform text-gray-400" />
        <Input
          type="text"
          placeholder="Search unique categories..."
          value={searchTerm}
          onChange={(e) => onSearchChange(e.target.value)}
          className="pl-10 dark:bg-gray-800 dark:border-gray-700 dark:text-white dark:placeholder-gray-400"
        />
      </div>
    </div>
  );
}

```

<!-- path: components/categories/CategoriesTable.tsx -->
```typescript
import Link from "next/link";
import { FiEdit2, FiInfo } from "react-icons/fi";
import { Button } from "@/components/common/ui/Button";
import { Card } from "@/components/common/ui/card";
import { formatCategoryName } from "@/components/categories/utils";
import { Categories, CategoryInfo } from "./categories-types";
import { useIsSuperAdmin } from "@/hooks/useAdminUsers";

interface CategoriesTableProps {
  categories: Categories[];
  categoryLookupCounts: Record<string, CategoryInfo>;
  totalCategories: number;
  onEdit: (categoryName: string) => void;
  onDelete: (categoryName: string) => void;
  isDeleting: boolean;
  searchTerm?: string;
}

export function CategoriesTable({
  categories,
  categoryLookupCounts,
  totalCategories,
  onEdit,
  onDelete,
  isDeleting,
  searchTerm,
}: CategoriesTableProps) {

  const {data: isSuperAdmin} = useIsSuperAdmin();
  return (
    <Card className="overflow-hidden dark:border-gray-700 dark:bg-gray-800">
      <div className="border-b bg-gray-50 p-4 dark:border-gray-700 dark:bg-gray-700/50">
        <p className="text-sm text-gray-600 dark:text-gray-400">
          Showing {categories.length} of {totalCategories} unique categories
        </p>
      </div>

      {categories.length > 0 ? (
        <div className="overflow-x-auto">
          <table className="w-full">
            <thead className="bg-gray-50 dark:bg-gray-700/50">
              <tr>
                <th className="px-6 py-3 text-left text-xs font-medium tracking-wider text-gray-500 uppercase dark:text-gray-400">
                  Category Name
                </th>
                <th className="px-6 py-3 text-left text-xs font-medium tracking-wider text-gray-500 uppercase dark:text-gray-400">
                  Raw Value
                </th>
                <th className="px-6 py-3 text-left text-xs font-medium tracking-wider text-gray-500 uppercase dark:text-gray-400">
                  Lookup Types Count
                </th>
                <th className="px-6 py-3 text-left text-xs font-medium tracking-wider text-gray-500 uppercase dark:text-gray-400">
                  System Defaults
                </th>
                <th className="px-6 py-3 text-left text-xs font-medium tracking-wider text-gray-500 uppercase dark:text-gray-400">
                  Actions
                </th>
              </tr>
            </thead>
            <tbody className="divide-y divide-gray-200 bg-white dark:divide-gray-700 dark:bg-gray-800">
              {categories.map((category) => {
                const categoryInfo = categoryLookupCounts[category.category];
                return (
                  <tr
                    key={category.id}
                    className="hover:bg-gray-50 dark:hover:bg-gray-700/50"
                  >
                    <td className="px-6 py-4 text-sm font-medium whitespace-nowrap text-gray-900 dark:text-white">
                      {formatCategoryName(category)}
                    </td>
                    <td className="px-6 py-4 font-mono text-sm whitespace-nowrap text-gray-500 dark:text-gray-400">
                      {category.category}
                    </td>
                    <td className="px-6 py-4 text-sm whitespace-nowrap text-gray-500 dark:text-gray-400">
                      <Link
                        href={`/dashboard/lookup?category=${category.category}`}
                      >
                        <span className="inline-flex items-center gap-1 hover:text-blue-600 dark:hover:text-blue-400">
                          {categoryInfo?.lookupCount ?? 0}
                          {categoryInfo?.lookupCount > 0 && (
                            <FiInfo
                              className="h-3 w-3 text-blue-500 dark:text-blue-400"
                              title="Click to view lookup types"
                            />
                          )}
                        </span>
                      </Link>
                    </td>
                    <td className="px-6 py-4 whitespace-nowrap">
                      <span
                        className={`inline-flex rounded-full px-2 py-1 text-xs font-semibold ${
                          categoryInfo?.hasSystemDefaults
                            ? "bg-blue-100 text-blue-800 dark:bg-blue-900/50 dark:text-blue-300"
                            : "bg-gray-100 text-gray-800 dark:bg-gray-700 dark:text-gray-300"
                        }`}
                      >
                        {categoryInfo?.hasSystemDefaults ? "Yes" : "No"}
                      </span>
                    </td>
                    <td className="px-6 py-4 text-sm font-medium whitespace-nowrap">
                      <div className="flex items-center gap-2">
                        <Button
                          size="sm"
                          variant="outline"
                          onClick={() => onEdit(category.category)}
                          className="dark:border-gray-600 dark:hover:bg-gray-700"
                        >
                          <FiEdit2 className="h-4 w-4" />
                        </Button>
                        <Button
                          size="sm"
                          variant="outline"
                          onClick={() => onDelete(category.category)}
                          className="text-red-600 hover:text-red-800 dark:text-red-500 dark:hover:text-red-400 dark:border-gray-600 dark:hover:bg-gray-700"
                          disabled={!isSuperAdmin && (isDeleting || categoryInfo?.hasSystemDefaults)}
                          title={
                            isDeleting
                              ? "Deleting..."
                              : `Delete All "${category.category}" Categories`
                          }
                        >
                          {isDeleting
                            ? "Deleting..."
                            : `Delete All "${category.category}" Categories`}
                        </Button>
                      </div>
                    </td>
                  </tr>
                );
              })}
            </tbody>
          </table>
        </div>
      ) : (
        <div className="py-8 text-center text-gray-500 dark:text-gray-400">
          {searchTerm
            ? `No unique categories found matching "${searchTerm}".`
            : "No unique categories found."}
        </div>
      )}
    </Card>
  );
}
```

<!-- path: components/categories/CategoryModal.tsx -->
```typescript
"use client";

import { GroupedLookupsByCategory } from "@/components/categories/categories-types";
import { Button } from "@/components/common/ui/Button";
import { Input } from "@/components/common/ui/Input";
import { Modal } from "@/components/common/ui/Modal";
import { useTableInsert, useTableUpdate } from "@/hooks/database";
import { Lookup_typesInsertSchema, lookup_typesRowSchema, Lookup_typesRowSchema } from "@/schemas/zod-schemas";
import { snakeToTitleCase } from "@/utils/formatters";
import { createClient } from "@/utils/supabase/client";
import { zodResolver } from "@hookform/resolvers/zod";
import { PostgrestError } from "@supabase/supabase-js";
import { useCallback, useEffect, useRef } from "react";
import { useForm } from "react-hook-form";
import { toast } from "sonner";
import z from "zod";



interface CategoryModalProps {
  isOpen: boolean;
  onClose: () => void;
  onCategoryCreated?: (categoryData: Lookup_typesInsertSchema) => void;
  editingCategory?: string;
  categories?: Lookup_typesRowSchema[];
  lookupsByCategory?: GroupedLookupsByCategory;
}



export function CategoryModal({
  isOpen,
  onClose,
  onCategoryCreated,
  editingCategory,
  categories,
  lookupsByCategory,
}: CategoryModalProps) {

  const categoryFormSchema = lookup_typesRowSchema.pick({
  category: true,
  code: true,
  description: true,
  name: true,
  sort_order: true,
  is_system_default: true,
  status: true,
});
type CategoryForm = z.infer<typeof categoryFormSchema>;

  const {
    register,
    handleSubmit,
    formState: { errors, isSubmitting },
    reset,
    watch,
  } = useForm<CategoryForm>({
    resolver: zodResolver(categoryFormSchema),
    defaultValues: {
      category: "",
      code: "default",
      description: "",
      name: "DEFAULT",
      sort_order: 0,
      is_system_default: true,
      status: true,
    },
  });

  const supabase = createClient();
  const submissionInProgress = useRef(false);
  const abortControllerRef = useRef<AbortController | null>(null);

  const { mutate: createCategory } = useTableInsert(supabase, "lookup_types");
  const { mutate: updateCategory } = useTableUpdate(supabase, "lookup_types");

// Only reset when editingCategory changes or when opening for creation
useEffect(() => {
  if (isOpen) {
    if (editingCategory) {
      const categoryLookups = lookupsByCategory?.[editingCategory] || [];
      if (categoryLookups.length > 0) {
        const template = categoryLookups[0];
        reset({
          category: template.category,
          code: template.code || "default",
          description: template.description || "",
          name: template.name || "DEFAULT",
          sort_order: template.sort_order || 0,
          is_system_default: template.is_system_default ?? true,
          status: template.status ?? true,
        });
      }
    } else {
      // New category: reset to defaults
      reset({
        category: "",
        code: "default",
        description: "",
        name: "DEFAULT",
        sort_order: 0,
        is_system_default: true,
        status: true,
      });
    }
  }
  // Do not reset on close, only on open
}, [isOpen, editingCategory, lookupsByCategory, reset]);

  const handleUpdateError = useCallback((error: unknown) => {
    const postgrestError = error as PostgrestError;
    if (
      postgrestError?.message?.includes("already exists") ||
      postgrestError?.code === "23505" ||
      postgrestError?.message?.includes("violates unique constraint")
    ) {
      toast.error("Category already exists");
    } else {
      toast.error(`Failed to update category: ${postgrestError?.message || "Unknown error"}`);
    }
  }, []);

  const handleCreateError = useCallback((error: unknown) => {
    const postgrestError = error as PostgrestError;
    if (
      postgrestError?.message?.includes("already exists") ||
      postgrestError?.code === "23505" ||
      postgrestError?.message?.includes("violates unique constraint")
    ) {
      toast.error("Category already exists");
    } else {
      toast.error(`Failed to create category: ${postgrestError?.message || "Unknown error"}`);
    }
  }, []);

  const onValidSubmit = useCallback(
    async (data: CategoryForm) => {
      const id = categories?.find((cat) => cat.category === editingCategory)?.id;
      if (submissionInProgress.current) return;

      if (!data.category.trim()) {
        toast.error("Category is required");
        return;
      }

      submissionInProgress.current = true;
      abortControllerRef.current = new AbortController();

      try {
        const formattedCategory = data.category
          .trim()
          .toUpperCase()
          .replace(/\s+/g, "_")
          .replace(/[^A-Z0-9_]/g, "");

        if (!formattedCategory) {
          toast.error("Please enter a valid category name");
          return;
        }

        const commonData = {
          ...data,
          category: formattedCategory,
          description: `Default entry for ${snakeToTitleCase(formattedCategory)} category`,
        };

        if (editingCategory) {
          updateCategory(
            { id: id!, data: commonData },
            {
              onSuccess: () => {
                if (abortControllerRef.current?.signal.aborted) return;
                toast.success(`Category renamed to "${formattedCategory}"`);
                onCategoryCreated?.(commonData);
                onClose();
              },
              onError: handleUpdateError,
              onSettled: () => {
                submissionInProgress.current = false;
              },
            }
          );
        } else {
          if (categories?.some((cat) => cat.category === formattedCategory)) {
            toast.error("Category already exists");
            submissionInProgress.current = false;
            return;
          }
          createCategory(commonData, {
            onSuccess: () => {
              if (abortControllerRef.current?.signal.aborted) return;
              onCategoryCreated?.(commonData);
              onClose();
            },
            onError: handleCreateError,
            onSettled: () => {
              submissionInProgress.current = false;
            },
          });
        }
      } catch (error) {
        console.error("Error saving category:", error);
        toast.error(`Failed to ${editingCategory ? "update" : "create"} category`);
        submissionInProgress.current = false;
      }
    },
    [categories, editingCategory, createCategory, updateCategory, onCategoryCreated, onClose, handleUpdateError, handleCreateError]
  );

  const handleClose = useCallback(() => {
    if (!isSubmitting && !submissionInProgress.current) {
      onClose();
    }
  }, [isSubmitting, onClose]);

  const categoryValue = watch("category") || "";
  const formattedPreview = categoryValue
    .trim()
    .toUpperCase()
    .replace(/\s+/g, "_")
    .replace(/[^A-Z0-9_]/g, "");

  const isEditing = !!editingCategory;

  return (
    <Modal isOpen={isOpen} onClose={handleClose} title={isEditing ? "Edit Category" : "Create New Category"} visible={false}
      className="transparent bg-gray-700 rounded-2xl">
      <form onSubmit={handleSubmit(onValidSubmit)} className="space-y-4">
        <div className="grid grid-cols-1 gap-4 md:grid-cols-2">
          <div className="md:col-span-2">
            <label className="mb-2 block text-sm font-medium text-gray-700 dark:text-gray-300">
              Category {isEditing ? "Name" : ""} <span className="text-red-500">*</span>
            </label>
            <Input
              type="text"
              {...register("category")}
              placeholder="Enter category (e.g., Node Type, System Type)"
              required
              disabled={isSubmitting || submissionInProgress.current}
              className="dark:bg-gray-800 dark:border-gray-700 dark:text-white dark:placeholder-gray-400"
            />
            {formattedPreview && (
              <p className="mt-1 text-xs text-gray-500 dark:text-gray-400">
                Will be saved as:{" "}
                <code className="rounded bg-gray-100 px-1 py-0.5 dark:bg-gray-700 dark:text-gray-200">
                  {formattedPreview}
                </code>
              </p>
            )}
            {errors.category && (
              <p className="mt-1 text-xs text-red-500 dark:text-red-400">{errors.category.message}</p>
            )}
          </div>
        </div>

        <div
          className={`rounded-md border p-3 ${
            isEditing
              ? "border-yellow-200 bg-yellow-50 dark:border-yellow-800/50 dark:bg-yellow-900/20"
              : "border-blue-200 bg-blue-50 dark:border-blue-800/50 dark:bg-blue-900/20"
          }`}
        >
          <h4
            className={`mb-1 text-sm font-medium ${
              isEditing ? "text-yellow-900 dark:text-yellow-200" : "text-blue-900 dark:text-blue-200"
            }`}
          >
            {isEditing ? "Edit Category Notes:" : "Category Creation Notes:"}
          </h4>
          <ul
            className={`space-y-1 text-xs ${
              isEditing ? "text-yellow-800 dark:text-yellow-200/80" : "text-blue-800 dark:text-blue-200/80"
            }`}
          >
            {isEditing ? (
              <>
                <li>• This will update the category name for ALL lookup types in this category</li>
                <li>• Category name will be converted to uppercase with underscores</li>
                <li>• Special characters will be removed except letters, numbers, and underscores</li>
              </>
            ) : (
              <>
                <li>• Category field will be converted to uppercase with underscores</li>
                <li>• Special characters will be removed except letters, numbers, and underscores</li>
                <li>• Created and updated timestamps will be set automatically</li>
                <li>• ID will be generated automatically</li>
              </>
            )}
          </ul>
        </div>

        <div className="flex justify-end gap-2 pt-4">
          <Button
            type="button"
            variant="outline"
            onClick={handleClose}
            disabled={isSubmitting || submissionInProgress.current}
            className="dark:border-gray-700 dark:hover:bg-gray-800"
          >
            Cancel
          </Button>
          <Button
            type="submit"
            disabled={isSubmitting || submissionInProgress.current || !categoryValue.trim()}
          >
            {isSubmitting || submissionInProgress.current
              ? isEditing
                ? "Updating..."
                : "Creating..."
              : isEditing
              ? "Update Category"
              : "Create Category"}
          </Button>
        </div>
      </form>
    </Modal>
  );
}

```

<!-- path: components/categories/categories-types.ts -->
```typescript
// components/categories/categories-types.ts
import { z } from 'zod';
import { lookup_typesRowSchema } from '@/schemas/zod-schemas';

//  Derive all types from the Zod schema
export type Categories = z.infer<typeof lookup_typesRowSchema>;

export type GroupedLookupsByCategory = Record<string, Categories[]>;

export interface CategoryInfo {
    name: string;
    lookupCount: number;
    hasSystemDefaults: boolean;
}
```

<!-- path: components/categories/utils.ts -->
```typescript
import { Categories } from "@/components/categories/categories-types";

export function formatCategoryName(category: Categories): string {
  return category.category
    .split("_")
    .map((word) => word.charAt(0).toUpperCase() + word.slice(1))
    .join(" ");
}
```

<!-- path: components/categories/LoadingState.tsx -->
```typescript
import { LoadingSpinner } from "@/components/common/ui/LoadingSpinner";

export function LoadingState() {
  return (
    <div className="flex justify-center py-8">
      <LoadingSpinner />
      <span className="ml-2 dark:text-gray-400">Loading data...</span>
    </div>
  );
}
```

<!-- path: components/auth/terms.tsx -->
```typescript
import React from "react";

const Terms = () => {
  return (
    <div className='bg-gray-100 dark:bg-gray-900 min-h-screen'>
      <div className='container mx-auto px-4 py-8'>
        <h1 className='text-4xl font-bold text-center text-gray-800 dark:text-white mb-8'>Terms of Service</h1>
        <div className='bg-white dark:bg-gray-800 rounded-lg shadow-md p-8'>
          <p className='mb-4 text-gray-700 dark:text-gray-300'>Welcome to Harinavi Transmission Maintenance. These terms and conditions outline the rules and regulations for the use of our website.</p>
          <p className='mb-4 text-gray-700 dark:text-gray-300'>
            By accessing this website, we assume you accept these terms and conditions. Do not continue to use Harinavi Transmission Maintenance if you do not agree to all of the terms and conditions stated on this page.
          </p>

          <h2 className='text-2xl font-bold text-gray-800 dark:text-white mt-6 mb-4'>Intellectual Property Rights</h2>
          <p className='mb-4 text-gray-700 dark:text-gray-300'>
            Other than the content you own, under these Terms, Harinavi Transmission Maintenance and/or its licensors own all the intellectual property rights and materials contained in this Website.
          </p>

          <h2 className='text-2xl font-bold text-gray-800 dark:text-white mt-6 mb-4'>Restrictions</h2>
          <p className='mb-4 text-gray-700 dark:text-gray-300'>You are specifically restricted from all of the following:</p>
          <ul className='list-disc list-inside mb-4 text-gray-700 dark:text-gray-300'>
            <li>Publishing any Website material in any other media.</li>
            <li>Selling, sublicensing and/or otherwise commercializing any Website material.</li>
            <li>Publicly performing and/or showing any Website material.</li>
            <li>Using this Website in any way that is or may be damaging to this Website.</li>
          </ul>

          <h2 className='text-2xl font-bold text-gray-800 dark:text-white mt-6 mb-4'>No Warranties</h2>
          <p className='mb-4 text-gray-700 dark:text-gray-300'>
            This Website is provided "as is," with all faults, and Harinavi Transmission Maintenance expresses no representations or warranties, of any kind related to this Website or the materials contained on this Website.
          </p>

          <h2 className='text-2xl font-bold text-gray-800 dark:text-white mt-6 mb-4'>Limitation of Liability</h2>
          <p className='mb-4 text-gray-700 dark:text-gray-300'>
            In no event shall Harinavi Transmission Maintenance, nor any of its officers, directors and employees, be held liable for anything arising out of or in any way connected with your use of this Website.
          </p>

          <h2 className='text-2xl font-bold text-gray-800 dark:text-white mt-6 mb-4'>Contact Us</h2>
          <p className='text-gray-700 dark:text-gray-300'>If you have any questions about these Terms, please contact us at support@harinavi.com.</p>
        </div>
      </div>
    </div>
  );
};

export default Terms;

```

<!-- path: components/auth/ForgotPasswordForm.tsx -->
```typescript
// path: components/auth/ForgotPasswordForm.tsx
"use client";

import { useState } from "react";
import { motion } from "framer-motion";
import { toast } from "sonner";
import { FiMail, FiArrowLeft, FiLoader, FiCheck } from "react-icons/fi";
import Link from "next/link";
import { useAuth } from "@/hooks/useAuth";
import { isValidEmail } from "@/utils/validationUtils";
import { ButtonSpinner } from "../common/ui/LoadingSpinner";
import { useRouter } from "next/navigation";

export default function ForgotPasswordForm() {
  const [email, setEmail] = useState("");
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState("");
  const { forgotPassword } = useAuth();
  const router = useRouter();

  const validateEmail = isValidEmail(email);

  const isResetEmailSent = () => {
    return typeof window !== 'undefined' && !!localStorage.getItem("reset_email_sent");
  };

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    setError("");

    if (!email) {
      setError("Email is required");
      return;
    }
    if (!validateEmail) {
      setError("Invalid email format");
      return;
    }

    setIsLoading(true);
    // CORRECTED: Destructure the new return shape
    const { success, error: responseError } = await forgotPassword(email);
    setIsLoading(false);

    if (success) {
      localStorage.setItem("reset_email_sent", email);
      setEmail("");
      setError("");
      // Force a re-render to show the confirmation screen
      router.refresh(); 
    } else {
      setError(responseError?.message || "Failed to send reset email.");
    }
  };

  const handleResendEmail = async () => {
    setIsLoading(true);
    setError("");
    const sentEmail = localStorage.getItem("reset_email_sent");
    if (sentEmail) {
      await forgotPassword(sentEmail);
    }
    setIsLoading(false);
  };
  
  const clearResetState = () => {
    localStorage.removeItem("reset_email_sent");
    router.refresh();
  };


  if (isResetEmailSent()) {
    return (
      <motion.div initial={{ opacity: 0, y: 20 }} animate={{ opacity: 1, y: 0 }} transition={{ duration: 0.5 }} className='w-full max-w-md mx-auto'>
        <div className='bg-white dark:bg-gray-800 rounded-lg shadow-lg p-8'>
          <div className='text-center'>
            <motion.div initial={{ scale: 0 }} animate={{ scale: 1 }} transition={{ delay: 0.2, type: "spring", stiffness: 200 }} className='w-16 h-16 bg-green-100 dark:bg-green-900/20 rounded-full flex items-center justify-center mx-auto mb-4'>
              <FiCheck className='w-8 h-8 text-green-600 dark:text-green-400' />
            </motion.div>

            <h2 className='text-2xl font-bold text-gray-900 dark:text-white mb-2'>Check Your Email</h2>

            <p className='text-gray-600 dark:text-gray-400 mb-6'>
              We&apos;ve sent a password reset link to <span className="font-medium text-gray-800 dark:text-gray-200">{localStorage.getItem("reset_email_sent")}</span>.
            </p>

            <div className='space-y-4'>
              <motion.button
                whileHover={{ scale: 1.02 }}
                whileTap={{ scale: 0.98 }}
                onClick={handleResendEmail}
                disabled={isLoading}
                className='w-full bg-gray-100 dark:bg-gray-700 hover:bg-gray-200 dark:hover:bg-gray-600 text-gray-700 dark:text-gray-300 font-medium py-3 px-4 rounded-lg transition-colors disabled:opacity-50 disabled:cursor-not-allowed'>
                {isLoading ? (
                  <div className='flex items-center justify-center'>
                    <FiLoader className='animate-spin mr-2' />
                    Resending...
                  </div>
                ) : (
                  "Resend Email"
                )}
              </motion.button>

              <motion.button
                whileHover={{ scale: 1.02 }}
                whileTap={{ scale: 0.98 }}
                onClick={clearResetState}
                className='w-full text-sm text-gray-500 hover:text-gray-700 dark:text-gray-400 dark:hover:text-gray-200'>
                Use a different email address
              </motion.button>
              
              <Link
                href='/login'
                className='inline-flex items-center justify-center w-full text-blue-600 dark:text-blue-400 hover:text-blue-500 dark:hover:text-blue-300 font-medium transition-colors'
              >
                <FiArrowLeft className='mr-2' />
                Back to Login
              </Link>
            </div>
          </div>
        </div>
      </motion.div>
    );
  }

  return (
    <motion.div initial={{ opacity: 0, y: 20 }} animate={{ opacity: 1, y: 0 }} transition={{ duration: 0.5 }} className='w-full max-w-md mx-auto'>
      <div className='bg-white dark:bg-gray-800 rounded-lg shadow-lg p-8'>
        <div className='text-center mb-8'>
          <h2 className='text-3xl font-bold text-gray-900 dark:text-white'>Forgot Password?</h2>
          <p className='text-gray-600 dark:text-gray-400 mt-2'>Enter your email and we&apos;ll send you a reset link.</p>
        </div>

        {error && (
          <motion.div initial={{ opacity: 0, scale: 0.95 }} animate={{ opacity: 1, scale: 1 }} className='mb-4 p-3 bg-red-50 dark:bg-red-900/20 border border-red-200 dark:border-red-800 rounded-md'>
            <p className='text-red-600 dark:text-red-400 text-sm'>{error}</p>
          </motion.div>
        )}

        <form onSubmit={handleSubmit} className='space-y-6'>
          <div>
            <label htmlFor='email' className='block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2'>
              Email Address
            </label>
            <div className='relative'>
              <FiMail className='absolute left-3 top-1/2 transform -translate-y-1/2 text-gray-400 dark:text-gray-500' />
              <input
                id='email'
                name='email'
                type='email'
                autoComplete='email'
                required
                value={email}
                onChange={(e) => setEmail(e.target.value)}
                className='w-full pl-10 pr-4 py-3 border border-gray-300 dark:border-gray-600 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-transparent transition-all bg-white dark:bg-gray-700 text-gray-900 dark:text-white placeholder-gray-500 dark:placeholder-gray-400'
                placeholder='Enter your email address'
              />
            </div>
          </div>

          <motion.button
            whileHover={{ scale: 1.02 }}
            whileTap={{ scale: 0.98 }}
            type='submit'
            disabled={isLoading}
            className='w-full bg-blue-600 hover:bg-blue-700 disabled:bg-blue-400 text-white font-medium py-3 px-4 rounded-lg transition-colors focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-offset-2 dark:focus:ring-offset-gray-800 disabled:cursor-not-allowed'>
            {isLoading ? (
              <ButtonSpinner />
            ) : (
              "Send Reset Link"
            )}
          </motion.button>
        </form>

        <div className='mt-8 text-center'>
          <Link
            href='/login'
            className='inline-flex items-center text-blue-600 dark:text-blue-400 hover:text-blue-500 dark:hover:text-blue-300 font-medium transition-colors'
          >
            <FiArrowLeft className='mr-2' />
            Back to Login
          </Link>
        </div>
      </div>
    </motion.div>
  );
}
```

<!-- path: components/auth/UnauthorizedModal.tsx -->
```typescript
// components/auth/UnauthorizedModal.tsx
"use client"

import { useState, useEffect } from "react";
import { useRouter } from "next/navigation";
import { UserRole } from "@/types/user-roles";

interface UnauthorizedModalProps {
  allowedRoles: UserRole[];
  currentRole?: string | null;
}

export const UnauthorizedModal: React.FC<UnauthorizedModalProps> = ({ 
  allowedRoles, 
  currentRole 
}) => {
  const [isOpen, setIsOpen] = useState(true);
  const router = useRouter();

  // Auto-close modal and redirect after 5 seconds
  useEffect(() => {
    const timer = setTimeout(() => {
      handleClose();
    }, 5000);

    return () => clearTimeout(timer);
  // eslint-disable-next-line react-hooks/exhaustive-deps
  }, []);

  const handleClose = () => {
    setIsOpen(false);
    // Redirect to dashboard or home page
    router.push("/dashboard");
  };

  const handleGoBack = () => {
    router.back();
    setIsOpen(false);
  };

  if (!isOpen) return null;

  const formatRole = (role: UserRole) => {
    return role.replace(/_/g, " ").replace(/\b\w/g, l => l.toUpperCase());
  };

  return (
    <div className="fixed inset-0 z-50 flex items-center justify-center">
      {/* Backdrop */}
      <div 
        className="absolute inset-0 bg-black bg-opacity-50 transition-opacity"
        onClick={handleClose}
      />
      
      {/* Modal */}
      <div className="relative bg-white rounded-lg shadow-xl max-w-md mx-4 p-6 z-10">
        {/* Icon */}
        <div className="flex items-center justify-center w-16 h-16 mx-auto mb-4 bg-red-100 rounded-full">
          <svg 
            className="w-8 h-8 text-red-600" 
            fill="none" 
            stroke="currentColor" 
            viewBox="0 0 24 24"
          >
            <path 
              strokeLinecap="round" 
              strokeLinejoin="round" 
              strokeWidth={2} 
              d="M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-2.5L13.732 4c-.77-.833-1.964-.833-2.732 0L4.082 15.5c-.77.833.192 2.5 1.732 2.5z" 
            />
          </svg>
        </div>

        {/* Title */}
        <h3 className="text-lg font-semibold text-gray-900 text-center mb-2">
          Access Denied
        </h3>

        {/* Message */}
        <div className="text-sm text-gray-600 text-center mb-6">
          <p className="mb-3">
            You don&apos;t have permission to access this page.
          </p>
          <div className="bg-gray-50 rounded-md p-3">
            <p className="font-medium text-gray-700 mb-1">Required roles:</p>
            <p className="text-gray-600">
              {allowedRoles.map(formatRole).join(", ")}
            </p>
            {currentRole && (
              <>
                <p className="font-medium text-gray-700 mt-2 mb-1">Your current role:</p>
                <p className="text-gray-600">{currentRole}</p>
              </>
            )}
          </div>
        </div>

        {/* Actions */}
        <div className="flex flex-col sm:flex-row gap-3">
          <button
            onClick={handleGoBack}
            className="flex-1 px-4 py-2 text-sm font-medium text-gray-700 bg-gray-100 border border-gray-300 rounded-md hover:bg-gray-200 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-gray-500 transition-colors"
          >
            Go Back
          </button>
          <button
            onClick={handleClose}
            className="flex-1 px-4 py-2 text-sm font-medium text-white bg-blue-600 border border-transparent rounded-md hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-blue-500 transition-colors"
          >
            Go to Dashboard
          </button>
        </div>

        {/* Auto-close notice */}
        <p className="text-xs text-gray-500 text-center mt-4">
          This modal will auto-close in 5 seconds
        </p>
      </div>
    </div>
  );
};
```

<!-- path: components/auth/OnboardingPromptModal.tsx -->
```typescript
// components/auth/OnboardingPromptModal.tsx
"use client";

import { motion } from "framer-motion";
import { FiUserCheck, FiArrowRight, FiX } from "react-icons/fi";
import { Button } from "@/components/common/ui";

interface OnboardingPromptModalProps {
  isOpen: boolean;
  onClose: () => void;
  onGoToProfile: () => void;
  onDismissPermanently: () => void;
  userName?: string;
}

export const OnboardingPromptModal: React.FC<OnboardingPromptModalProps> = ({
  isOpen,
  onClose,
  onGoToProfile,
  onDismissPermanently,
  userName,
}) => {
  if (!isOpen) return null;

  return (
    <div className="fixed inset-0 z-50 flex items-end justify-center p-4 sm:items-center sm:justify-end">
      <motion.div
        initial={{ opacity: 0, y: 50, scale: 0.9 }}
        animate={{ opacity: 1, y: 0, scale: 1 }}
        exit={{ opacity: 0, y: 50, scale: 0.9 }}
        transition={{ type: "spring", stiffness: 300, damping: 30 }}
        className="relative w-full max-w-sm p-6 bg-white dark:bg-gray-800 border border-gray-200 dark:border-gray-700 rounded-xl shadow-2xl"
      >
        <div className="flex items-start gap-4">
          <div className="flex-shrink-0 w-12 h-12 rounded-full bg-blue-100 dark:bg-blue-900/50 flex items-center justify-center">
            <FiUserCheck className="w-6 h-6 text-blue-600 dark:text-blue-400" />
          </div>
          <div className="flex-1">
            <h3 className="text-lg font-semibold text-gray-900 dark:text-white">
              Complete Your Profile
            </h3>
            <p className="text-sm text-gray-600 dark:text-gray-400 mt-1">
              Welcome, {userName}! Help us get to know you better by adding a few more details.
            </p>
          </div>
        </div>
        <div className="mt-6 flex flex-col sm:flex-row gap-3">
          <Button
            onClick={onGoToProfile}
            className="w-full sm:flex-1"
            variant="primary"
            rightIcon={<FiArrowRight />}
          >
            Update Profile
          </Button>
          <Button
            onClick={onClose}
            className="w-full sm:flex-1"
            variant="outline"
          >
            Maybe Later
          </Button>
        </div>
        <button
          onClick={onDismissPermanently}
          className="w-full text-center text-xs text-gray-500 hover:text-gray-700 dark:hover:text-gray-300 mt-4"
        >
          Don't show this again
        </button>
      </motion.div>
    </div>
  );
};
```

<!-- path: components/auth/OAuthProviders.tsx -->
```typescript
// components/auth/OAuthProviders.tsx
'use client';

import { OAuthButton } from '@/components/auth/OAuthButton';

interface OAuthProvidersProps {
  variant?: 'login' | 'signup';
  redirectTo?: string;
  providers?: string[];
  className?: string;
  showDivider?: boolean;
  dividerText?: string;
}

const defaultProviders: string[] = ['google'];

export default function OAuthProviders({
  variant = 'login',
  providers = defaultProviders,
  className = '',
  showDivider = true,
  dividerText,
}: OAuthProvidersProps) {
  const defaultDividerText = variant === 'signup' 
    ? 'Or sign up with email' 
    : 'Or continue with email';

  return (
    <div className={`space-y-4 ${className}`}>
      <div className="space-y-3">
        {providers.map((provider) => (
          <OAuthButton
            key={provider}
            provider={provider}
            variant={variant}
          />
        ))}
      </div>

      {showDivider && (
        <div className="relative">
          <div className="absolute inset-0 flex items-center">
            <div className="w-full border-t border-gray-300" />
          </div>
          <div className="relative flex justify-center text-sm">
            <span className="px-2 bg-white text-gray-500">
              {dividerText || defaultDividerText}
            </span>
          </div>
        </div>
      )}
    </div>
  );
}
```

<!-- path: components/auth/OAuthButton.tsx -->
```typescript
// components/auth/OAuthButton.tsx
/* @refresh reset */
"use client";

import { useState, useEffect, useCallback, useRef } from "react";
import { useAuth } from "@/hooks/useAuth";
import { FaGoogle } from "react-icons/fa";
import { LoadingSpinner } from "../common/ui/LoadingSpinner/LoadingSpinner";

const debug = (...args: unknown[]) => {
  if (process.env.NODE_ENV === "development") {
    console.log("[OAuthButton]", ...args);
  }
};

interface OAuthButtonProps {
  provider: string;
  variant?: "login" | "signup";
  className?: string;
  disabled?: boolean;
}

const providerConfig = {
  google: {
    name: "Google",
    icon: FaGoogle,
    bgColor: "bg-white hover:bg-gray-50",
    textColor: "text-gray-800",
  },
} as const;

export function OAuthButton({
  provider,
  variant = "login",
  className = "",
  disabled = false,
}: OAuthButtonProps) {
  const { signInWithGoogle, authState } = useAuth();
  const [isLocalLoading, setIsLocalLoading] = useState(false);
  const [isOAuthInProgress, setIsOAuthInProgress] = useState(false);
  
  //  Use ref to track if action is in progress
  const isProcessingRef = useRef(false);

  //  Remove authState and isLocalLoading from dependencies
  // Only depend on the stable signInWithGoogle function
  const handleGoogleSignIn = useCallback(async () => {
    debug("handleGoogleSignIn called");

    // Prevent multiple clicks - check ref instead of state
    if (isProcessingRef.current) {
      debug("Already processing, ignoring click");
      return;
    }

    try {
      debug("Setting loading state");
      isProcessingRef.current = true;
      setIsLocalLoading(true);
      setIsOAuthInProgress(true);
      sessionStorage.setItem("oauth_in_progress", "true");

      debug("Calling signInWithGoogle");
      await signInWithGoogle();
      debug("signInWithGoogle completed");
    } catch (error) {
      debug("OAuth error:", error);
      sessionStorage.removeItem("oauth_in_progress");
      setIsOAuthInProgress(false);
    } finally {
      debug("Cleaning up");
      isProcessingRef.current = false;
      setIsLocalLoading(false);
      sessionStorage.removeItem("oauth_in_progress");
    }
  }, [signInWithGoogle]); // Only signInWithGoogle in deps

  // Check for OAuth in progress on mount
  useEffect(() => {
    const inProgress = sessionStorage.getItem("oauth_in_progress") === "true";
    if (inProgress) {
      setIsOAuthInProgress(true);
    }
  }, []); // Run once on mount

  // Combine all loading states
  const isLoading = isLocalLoading || authState === "loading" || isOAuthInProgress;
  const isButtonDisabled = disabled || isLoading;
  const config = providerConfig[provider as keyof typeof providerConfig];

  debug("Rendering with state:", {
    isLocalLoading,
    authState,
    isOAuthInProgress,
    isLoading,
  });

  return (
    <button
      onClick={handleGoogleSignIn}
      disabled={isButtonDisabled}
      data-loading={isLoading}
      className={[
        "relative flex items-center justify-center gap-3 w-full px-6 py-3 rounded-xl",
        "font-semibold text-sm tracking-wide overflow-hidden",
        "transition-all duration-300 ease-out transform-gpu",
        config.bgColor || "bg-white border-2 border-gray-200/50",
        config.textColor || "text-gray-700",
        isButtonDisabled
          ? "opacity-60 cursor-not-allowed scale-100"
          : [
              "hover:shadow-2xl hover:shadow-blue-500/20",
              "hover:-translate-y-1 hover:scale-[1.02]",
              "active:translate-y-0 active:scale-[0.98]",
              "focus:outline-none focus:ring-4 focus:ring-blue-500/20 focus:ring-offset-2",
              "hover:border-blue-300/60",
            ].join(" "),
        isLoading && "animate-pulse",
        className,
      ]
        .filter(Boolean)
        .join(" ")
        .trim()}
      style={{
        transition: "all 300ms cubic-bezier(0.4, 0, 0.2, 1)",
        transform: "translateZ(0)",
        backfaceVisibility: "hidden",
        WebkitFontSmoothing: "antialiased",
        background: isButtonDisabled
          ? undefined
          : `linear-gradient(135deg, ${config.bgColor || "rgba(255, 255, 255, 0.95)"}, ${
              config.bgColor || "rgba(249, 250, 251, 0.95)"
            })`,
        boxShadow: isButtonDisabled
          ? undefined
          : "inset 0 1px 0 rgba(255, 255, 255, 0.1), 0 1px 3px rgba(0, 0, 0, 0.1), 0 4px 6px rgba(0, 0, 0, 0.05)",
      }}
    >
      {isLoading && (
        <div
          className="absolute inset-0 animate-shimmer"
          style={{
            background: "linear-gradient(90deg, transparent, rgba(255,255,255,0.4), transparent)",
            backgroundSize: "200% 100%",
            animation: "shimmer 1.5s infinite",
          }}
        />
      )}

      <div
        className={[
          "flex items-center justify-center min-w-[24px] h-6 relative z-10",
          "transition-transform duration-300 ease-out",
          isLoading ? "animate-spin" : "group-hover:scale-110",
        ].join(" ")}
      >
        {isLoading ? (
          <div className="relative">
            <LoadingSpinner size="sm" className="h-5 w-5 text-current opacity-80" />
            <div className="absolute inset-0 animate-ping">
              <div className="h-5 w-5 rounded-full bg-current opacity-20" />
            </div>
          </div>
        ) : (
          <config.icon className="h-5 w-5 transition-all duration-300 filter drop-shadow-sm" />
        )}
      </div>

      <span
        className={[
          "relative z-10 whitespace-nowrap select-none",
          "transition-all duration-300 ease-out",
          isLoading ? "tracking-wider" : "group-hover:tracking-wide",
        ].join(" ")}
      >
        {isLoading ? (
          <span className="flex items-center gap-2">
            Connecting
            <span className="flex gap-1">
              <span
                className="w-1 h-1 bg-current rounded-full animate-bounce"
                style={{ animationDelay: "0ms" }}
              />
              <span
                className="w-1 h-1 bg-current rounded-full animate-bounce"
                style={{ animationDelay: "150ms" }}
              />
              <span
                className="w-1 h-1 bg-current rounded-full animate-bounce"
                style={{ animationDelay: "300ms" }}
              />
            </span>
          </span>
        ) : (
          `${variant === "signup" ? "Sign up" : "Continue"} with ${config.name}`
        )}
      </span>

      {!isButtonDisabled && !isLoading && (
        <div className="absolute inset-0 rounded-xl bg-gradient-to-r from-transparent via-white/5 to-transparent opacity-0 group-hover:opacity-100 transition-opacity duration-300" />
      )}
    </button>
  );
}
```

<!-- path: components/auth/privacy.tsx -->
```typescript
import React from "react";

const Privacy = () => {
  return (
    <div className='bg-gray-100 dark:bg-gray-900 min-h-screen'>
      <div className='container mx-auto px-4 py-8'>
        <h1 className='text-4xl font-bold text-center text-gray-800 dark:text-white mb-8'>Privacy Policy</h1>
        <div className='bg-white dark:bg-gray-800 rounded-lg shadow-md p-8'>
          <p className='mb-4 text-gray-700 dark:text-gray-300'>Your privacy is important to us. It is Harinavi Transmission Maintenance's policy to respect your privacy regarding any information we may collect from you across our website.</p>
          <p className='mb-4 text-gray-700 dark:text-gray-300'>
            We only ask for personal information when we truly need it to provide a service to you. We collect it by fair and lawful means, with your knowledge and consent. We also let you know why we’re collecting it and how it will be used.
          </p>

          <h2 className='text-2xl font-bold text-gray-800 dark:text-white mt-6 mb-4'>Information We Collect</h2>
          <p className='mb-4 text-gray-700 dark:text-gray-300'>
            We may collect personal identification information from Users in a variety of ways, including, but not limited to, when Users visit our site, register on the site, and in connection with other activities, services, features or resources
            we make available on our Site.
          </p>

          <h2 className='text-2xl font-bold text-gray-800 dark:text-white mt-6 mb-4'>How We Use Your Information</h2>
          <p className='mb-4 text-gray-700 dark:text-gray-300'>We may use the information we collect for various purposes, including to:</p>
          <ul className='list-disc list-inside mb-4 text-gray-700 dark:text-gray-300'>
            <li>Provide, operate, and maintain our website</li>
            <li>Improve, personalize, and expand our website</li>
            <li>Understand and analyze how you use our website</li>
            <li>Develop new products, services, features, and functionality</li>
          </ul>

          <h2 className='text-2xl font-bold text-gray-800 dark:text-white mt-6 mb-4'>Security</h2>
          <p className='mb-4 text-gray-700 dark:text-gray-300'>The security of your personal information is important to us, but remember that no method of transmission over the Internet, or method of electronic storage, is 100% secure.</p>

          <h2 className='text-2xl font-bold text-gray-800 dark:text-white mt-6 mb-4'>Contact Us</h2>
          <p className='text-gray-700 dark:text-gray-300'>If you have any questions about this Privacy Policy, please contact us at support@harinavi.com.</p>
        </div>
      </div>
    </div>
  );
};

export default Privacy;

```

<!-- path: components/auth/Protected.tsx -->
```typescript
// components/auth/Protected.tsx
"use client";

import { useEffect, useRef } from "react";
import { useRouter } from "next/navigation";
import { PageSpinner } from "../common/ui/LoadingSpinner";
import { useUserPermissionsExtended } from "@/hooks/useRoleFunctions";
import { UserRole } from "@/types/user-roles";
import { UnauthorizedModal } from "./UnauthorizedModal";
import { useAuthStore } from "@/stores/authStore";
import { useQuery } from "@tanstack/react-query";
import { createClient } from "@/utils/supabase/client";

// This hook checks the user's profile to see if they need to complete onboarding.
const useUserProfileCheck = (userId?: string) => {
  const supabase = createClient();
  return useQuery({
    queryKey: ['user-profile-check', userId],
    queryFn: async () => {
      if (!userId) return null;
      const { data, error } = await supabase
        .from('user_profiles')
        .select('first_name, preferences') // Only fetch what's needed for the check
        .eq('id', userId)
        .single();

      if (error) {
        // 'PGRST116' means no rows found, which is a valid state for a brand new user
        if (error.code === 'PGRST116') return null; 
        throw error;
      }
      return data;
    },
    enabled: !!userId,
    staleTime: 5 * 60 * 1000, // 5 minutes
  });
};

interface ProtectedProps {
  children: React.ReactNode;
  allowedRoles?: UserRole[];
  redirectTo?: string;
  fallbackComponent?: React.ReactNode;
}

export const Protected: React.FC<ProtectedProps> = ({ children, allowedRoles, redirectTo = "/login" }) => {
  const authState = useAuthStore((state) => state.authState);
  const user = useAuthStore((state) => state.user);
  const router = useRouter();
  const hasRedirected = useRef(false);

  const { data: profile, isLoading: isProfileLoading, isError: isProfileError, error: profileError } = useUserProfileCheck(user?.id);
  const { isSuperAdmin, canAccess, isLoading: isRoleLoading, isError: isRoleError, error: roleError } = useUserPermissionsExtended();

  useEffect(() => {
    // Unauthenticated: Redirect to login if not already done
    if (authState === 'unauthenticated' && !hasRedirected.current) {
      hasRedirected.current = true;
      router.replace(redirectTo);
      return;
    }

    // Authenticated: Check for onboarding completion once all data is loaded
    if (authState === 'authenticated' && !isProfileLoading && !isRoleLoading) {
      const needsOnboarding = (profile?.preferences)?.needsOnboarding === true;

      if (needsOnboarding) {
        if (window.location.pathname !== '/onboarding') {
          router.replace('/onboarding');
        }
        return;
      }

      // If onboarding is complete, check role-based access
      if (allowedRoles && !canAccess(allowedRoles) && !isSuperAdmin) {
        // The UnauthorizedModal will be rendered below.
        return;
      }
    }
  }, [
    authState,
    profile,
    isProfileLoading,
    isRoleLoading,
    canAccess,
    isSuperAdmin,
    allowedRoles,
    router,
    redirectTo
  ]);

  // Render states
  if (authState === 'loading' || isProfileLoading || isRoleLoading) {
    return <PageSpinner text="Verifying session..." />;
  }
  
  // ** Add an explicit check for any error state.**
  if (isRoleError || isProfileError) {
    const errorMessage = roleError?.message || profileError?.message || "Could not verify your user permissions or profile.";
    return (
      <div className="flex min-h-screen items-center justify-center p-4">
        <div className="p-8 text-center bg-red-50 dark:bg-red-900/20 rounded-lg border border-red-200 dark:border-red-700">
          <h3 className="text-xl font-semibold text-red-700 dark:text-red-300">Authentication Error</h3>
          <p className="mt-2 text-red-600 dark:text-red-400">{errorMessage}</p>
        </div>
      </div>
    );
  }

  if (authState === 'unauthenticated') {
    return <PageSpinner text="Redirecting..." />;
  }

  if (authState === 'authenticated' && user) {
    // If profile is still loading, it's safer to wait
    if (isProfileLoading) return <PageSpinner text="Loading user profile..." />;

    const needsOnboarding = (profile?.preferences)?.needsOnboarding === true;
    
    // The useEffect will handle the redirect, show a spinner in the meantime
    if (needsOnboarding) {
        return <PageSpinner text="Finalizing session..." />;
    }

    // If profile is loaded and onboarding is complete, check roles
    if (profile) {
      if (allowedRoles && !canAccess(allowedRoles) && !isSuperAdmin) {
        return <UnauthorizedModal allowedRoles={allowedRoles} currentRole={user.role} />;
      }
      // If authorized, render the children
      return <>{children}</>;
    }
  }

  // Fallback for any other unexpected state
  return <PageSpinner text="Finalizing..." />;
};
```

<!-- path: components/auth/authButton.tsx -->
```typescript
// components/auth/authButton.tsx
'use client'
 
import Link from 'next/link'
import { useAuth } from '@/hooks/useAuth'
import { useAuthStore } from '@/stores/authStore'
import { BiLogOut, BiUser } from 'react-icons/bi'
import { CiSettings } from 'react-icons/ci'
import Image from 'next/image'
 
export default function AuthButton() {
  const { logout } = useAuth()
  const user = useAuthStore((state) => state.user)
 
  if (!user) {
    return (
      <div className="h-9 w-24 bg-gray-100 dark:bg-gray-800 animate-pulse rounded-lg border border-gray-200 dark:border-gray-700"></div>
    )
  }
 
  if (user) {
    return (
      <div className="bg-white dark:bg-gray-900 border border-gray-200 dark:border-gray-700 rounded-lg shadow-sm min-w-[220px]">
        {/* User Info Header */}
        <div className="px-4 py-3 border-b border-gray-100 dark:border-gray-800">
          <div className="flex items-center space-x-3">
            <div className="flex-shrink-0">
              {user.user_metadata?.avatar_url ? (
                <Image
                  src={user.user_metadata.avatar_url}
                  alt="Avatar"
                  className="h-8 w-8 rounded-full ring-2 ring-gray-100 dark:ring-gray-800"
                  width={32}
                  height={32}
                />
              ) : (
                <div className="h-8 w-8 rounded-full bg-gradient-to-br from-blue-500 to-indigo-600 flex items-center justify-center">
                  <BiUser className="h-4 w-4 text-white" />
                </div>
              )}
            </div>
            <div className="flex-1 min-w-0">
              <p className="text-sm font-semibold text-gray-900 dark:text-gray-100 truncate">
                {user.user_metadata?.first_name + ' ' + user.user_metadata?.last_name || user.email?.split('@')[0] || 'User'}
              </p>
              <p className="text-xs text-gray-500 dark:text-gray-400 truncate">
                {user.email}
              </p>
            </div>
          </div>
        </div>

        {/* Menu Items */}
        <div className="py-2">
          <Link
            href="/onboarding"
            className="flex items-center px-4 py-2.5 text-sm text-gray-700 dark:text-gray-300 hover:bg-gray-50 dark:hover:bg-gray-800 transition-colors group"
          >
            <CiSettings className="h-4 w-4 mr-3 text-gray-400 group-hover:text-gray-600 dark:group-hover:text-gray-300" />
            <span className="font-medium">Update Profile</span>
          </Link>
          
          <button
            onClick={logout}
            className="w-full flex items-center px-4 py-2.5 text-sm text-red-600 dark:text-red-400 hover:bg-red-50 dark:hover:bg-red-900/20 transition-colors group"
          >
            <BiLogOut className="h-4 w-4 mr-3 text-red-500 group-hover:text-red-600 dark:group-hover:text-red-400" />
            <span className="font-medium">Sign Out</span>
          </button>
        </div>
      </div>
    )
  }
 
  return (
    <div className="flex items-center space-x-3 bg-white dark:bg-gray-900 border border-gray-200 dark:border-gray-700 rounded-lg px-4 py-2 shadow-sm">
      <Link
        href="/login"
        className="text-sm font-medium text-gray-600 dark:text-gray-400 hover:text-gray-900 dark:hover:text-gray-100 transition-colors"
      >
        Sign In
      </Link>
      <div className="h-4 w-px bg-gray-300 dark:bg-gray-600"></div>
      <Link
        href="/signup"
        className="inline-flex items-center px-3 py-1.5 bg-gradient-to-r from-blue-600 to-indigo-600 hover:from-blue-700 hover:to-indigo-700 text-white text-sm font-medium rounded-md transition-all duration-200 shadow-sm hover:shadow-md"
      >
        Get Started
      </Link>
    </div>
  )
}
```

<!-- path: components/maintenance-areas/AreaFormModal.tsx -->
```typescript
// components/maintenance-areas/AreaFormModal.tsx
"use client";

import { useEffect, useMemo, useState } from "react";
import { MaintenanceArea, AreaFormModalProps } from "@/config/areas";
import { zodResolver } from "@hookform/resolvers/zod";
import { FormCard } from "@/components/common/form/FormCard";
import { FormInput, FormSearchableSelect, FormSwitch, FormTextarea } from "@/components/common/form/FormControls";
import { useForm } from "react-hook-form";
import { maintenance_areasInsertSchema, Maintenance_areasInsertSchema } from "@/schemas/zod-schemas";
import { generateCodeFromName } from "@/config/helper-functions";

export function AreaFormModal({
  isOpen,
  onClose,
  onSubmit,
  area,
  allAreas,
  areaTypes,
  isLoading
}: AreaFormModalProps) {
  const [isCodeManuallyEdited, setIsCodeManuallyEdited] = useState(false);
  const isEditMode = !!area;

  const {
    register,
    handleSubmit,
    formState: { errors },
    reset,
    control,
    watch,
    setValue,
  } = useForm<Maintenance_areasInsertSchema>({
    resolver: zodResolver(maintenance_areasInsertSchema),
    defaultValues: {
      name: "", code: "", area_type_id: null, parent_id: null,
      contact_person: null, contact_number: null, email: null,
      address: null, latitude: null, longitude: null, status: true
    },
  });

  const watchedName = watch('name');

  useEffect(() => {
    if (isOpen) {
      setIsCodeManuallyEdited(isEditMode);
      if (area) {
        // ** Manually map fields from the 'area' prop to what the form schema expects.**
        // This avoids passing unexpected nested objects (like `parent_area`) to the form state.
        reset({
          name: area.name,
          code: area.code,
          area_type_id: area.area_type_id,
          parent_id: area.parent_id, // Use the ID directly, not the nested object
          contact_person: area.contact_person,
          contact_number: area.contact_number,
          email: area.email,
          address: area.address,
          latitude: area.latitude,
          longitude: area.longitude,
          status: area.status ?? true,
        });
      } else {
        reset({
          name: "", code: "", area_type_id: null, parent_id: null,
          contact_person: null, contact_number: null, email: null,
          address: null, latitude: null, longitude: null, status: true
        });
      }
    }
  }, [area, isOpen, reset, isEditMode]);

  useEffect(() => {
    if (!isCodeManuallyEdited && !isEditMode) {
      const generatedCode = generateCodeFromName(watchedName);
      setValue('code', generatedCode, { shouldValidate: true });
    }
  }, [watchedName, isCodeManuallyEdited, isEditMode, setValue]);

  const availableParents = useMemo(() => {
    if (!area) return allAreas;
    const getDescendantIds = (areaId: string, areas: MaintenanceArea[]): Set<string> => {
      const descendants = new Set<string>([areaId]);
      const children = areas.filter(a => a.parent_id === areaId);
      children.forEach(child => {
        const childDescendants = getDescendantIds(child.id, areas);
        childDescendants.forEach(id => descendants.add(id));
      });
      return descendants;
    };
    const excludeIds = getDescendantIds(area.id, allAreas);
    return allAreas.filter(a => !excludeIds.has(a.id));
  }, [area, allAreas]);

  const onValidSubmit = (data: Maintenance_areasInsertSchema) => {
    onSubmit(data);
  };

  if (!isOpen) return null;

  return (
    <div className="fixed inset-0 z-50 flex items-center justify-center bg-black/50 p-4 backdrop-blur-sm">
      <div className="w-0 h-0 transparent">
        <FormCard 
          onSubmit={handleSubmit(onValidSubmit)} 
          title={area ? "Edit Area" : "Add New Area"} 
          onCancel={onClose}
          isLoading={isLoading}
          heightClass="max-h-[85vh] overflow-y-auto"
          standalone
        >
          {/* Basic Information Section */}
          <div className="space-y-4">
            <div className="grid grid-cols-1 gap-4 md:grid-cols-2">
              <FormInput 
                name="name" 
                label="Area Name" 
                register={register} 
                error={errors.name} 
                required 
                disabled={isLoading} 
              />
              
              <FormInput
                name="code"
                label="Area Code"
                register={register}
                error={errors.code}
                disabled={isLoading}
                onChange={(e) => {
                  setIsCodeManuallyEdited(true);
                  register('code').onChange(e);
                }}
              />
            </div>
            
            <div className="grid grid-cols-1 gap-4 md:grid-cols-2">
              <FormSearchableSelect
                name="area_type_id"
                label="Area Type"
                control={control}
                error={errors.area_type_id}
                disabled={isLoading}
                options={areaTypes.filter(type => type.name !== "DEFAULT").map(type => ({ value: type.id, label: type.name }))}
              />
              
              <FormSearchableSelect
                name="parent_id"
                label="Parent Area"
                control={control}
                error={errors.parent_id}
                disabled={isLoading}
                options={availableParents.map(a => ({ value: a.id, label: a.name }))}
              />
            </div>
          </div>

          {/* Contact Information Section */}
          <div className="mt-6 space-y-4 border-t border-gray-200 pt-6 dark:border-gray-700">
            <h3 className="text-sm font-semibold text-gray-700 dark:text-gray-300">Contact Information</h3>
            
            <div className="grid grid-cols-1 gap-4 md:grid-cols-2">
              <FormInput 
                name="contact_person" 
                label="Contact Person" 
                register={register} 
                error={errors.contact_person} 
                disabled={isLoading} 
              />
              
              <FormInput 
                name="contact_number" 
                label="Contact Number" 
                register={register} 
                error={errors.contact_number} 
                disabled={isLoading} 
              />
            </div>
            
            <FormInput 
              name="email" 
              label="Email Address" 
              register={register} 
              error={errors.email} 
              disabled={isLoading} 
            />
          </div>

          {/* Location Information Section */}
          <div className="mt-6 space-y-4 border-t border-gray-200 pt-6 dark:border-gray-700">
            <h3 className="text-sm font-semibold text-gray-700 dark:text-gray-300">Location Details</h3>
            
            <FormTextarea 
              name="address" 
              label="Address" 
              control={control} 
              error={errors.address} 
              disabled={isLoading} 
            />
            
            <div className="grid grid-cols-1 gap-4 md:grid-cols-2">
              <FormInput 
                name="latitude" 
                label="Latitude" 
                register={register} 
                error={errors.latitude} 
                disabled={isLoading} 
                placeholder="e.g., 22.5726"
              />
              
              <FormInput 
                name="longitude" 
                label="Longitude" 
                register={register} 
                error={errors.longitude} 
                disabled={isLoading} 
                placeholder="e.g., 88.3639"
              />
            </div>
          </div>

          {/* Status Section */}
          <div className="mt-6 border-t border-gray-200 pt-6 dark:border-gray-700">
            <FormSwitch 
              name="status" 
              label="Active Status" 
              control={control} 
              error={errors.status} 
            />
          </div>
        </FormCard>
      </div>
    </div>
  );
}
```

<!-- path: components/maintenance-areas/useMaintenanceAreasMutations.ts -->
```typescript
// components/maintenance-areas/useMaintenanceAreasMutations.ts
import { createClient } from "@/utils/supabase/client";
import { useTableInsert, useTableUpdate, useToggleStatus } from "@/hooks/database";
import { Maintenance_areasInsertSchema, Maintenance_areasUpdateSchema } from "@/schemas/zod-schemas";
import { toast } from "sonner"; // <-- Import toast

export function useMaintenanceAreasMutations(
  supabase: ReturnType<typeof createClient>,
  onSuccess: () => void
) {
  const createAreaMutation = useTableInsert(supabase, "maintenance_areas", { 
    onSuccess,
    // ** Add an onError handler for creation failures.**
    onError: (error) => {
      toast.error(`Failed to create area: ${error.message}`);
    }
  });

  const updateAreaMutation = useTableUpdate(supabase, "maintenance_areas", { 
    onSuccess,
    // ** Add an onError handler for update failures.**
    onError: (error) => {
      toast.error(`Failed to update area: ${error.message}`);
    }
  });

  const toggleStatusMutation = useToggleStatus(supabase, "maintenance_areas", { 
    onSuccess,
    // ** Add an onError handler for status toggle failures.**
    onError: (error) => {
      toast.error(`Failed to toggle status: ${error.message}`);
    }
  });

  const handleFormSubmit = (
    data: Maintenance_areasInsertSchema,
    editingArea?: { id: string } | null
  ) => {
    if (editingArea?.id) {
      const { id, ...updateData } = data;
      
      updateAreaMutation.mutate({ 
        id: editingArea.id, 
        data: updateData as Maintenance_areasUpdateSchema 
      });
    } else {
      createAreaMutation.mutate(data);
    }
  };

  return {
    createAreaMutation,
    updateAreaMutation,
    toggleStatusMutation,
    handleFormSubmit: (data: Maintenance_areasInsertSchema, editingArea?: { id: string } | null) => handleFormSubmit(data, editingArea)
  };
}
```

<!-- path: components/maintenance-areas/index.ts -->
```typescript
export * from "./AreaFormModal";
export * from "./useMaintenanceAreasMutations";


```

<!-- path: components/map/ClientRingMap.tsx -->
```typescript
// path: components/map/ClientRingMap.tsx
"use client";

import { MapContainer, TileLayer, Marker, Popup, Polyline, useMap } from "react-leaflet";
import L, { LatLngBounds } from "leaflet";
import "leaflet/dist/leaflet.css";
import { useState, useRef, useEffect, useMemo } from "react";
import ReactDOM from "react-dom";
import { useThemeStore } from "@/stores/themeStore";
import { FiMaximize, FiMinimize } from "react-icons/fi";
import { getNodeIcon } from "@/utils/getNodeIcons";
import { MapNode, RingMapNode } from "./types/node";

interface ClientRingMapProps {
  nodes: MapNode[];
  solidLines?: Array<[MapNode, MapNode]>;
  dashedLines?: Array<[RingMapNode, RingMapNode]>;
  distances?: Record<string, string>;
  highlightedNodeIds?: string[];
  onNodeClick?: (nodeId: string) => void;
  onBack?: () => void;
  flyToCoordinates?: [number, number] | null;
  showControls?: boolean; // NEW PROP
}

// ... (Helper components like MapController and FullscreenControl remain the same)
const MapController = ({ isFullScreen }: { isFullScreen: boolean }) => {
  const map = useMap();
  useEffect(() => {
    const timer = setTimeout(() => map.invalidateSize(), 100);
    return () => clearTimeout(timer);
  }, [isFullScreen, map]);
  return null;
};

const FullscreenControl = ({ isFullScreen, setIsFullScreen }: { isFullScreen: boolean; setIsFullScreen: (fs: boolean) => void }) => {
  const map = useMap();
  useEffect(() => {
    const Fullscreen = L.Control.extend({
      onAdd: function() {
        const container = L.DomUtil.create('div', 'leaflet-bar leaflet-control leaflet-control-custom');
        container.style.backgroundColor = 'white';
        container.style.width = '34px';
        container.style.height = '34px';
        container.style.borderRadius = '4px';
        container.style.cursor = 'pointer';
        container.style.display = 'flex';
        container.style.alignItems = 'center';
        container.style.justifyContent = 'center';
        container.title = isFullScreen ? "Exit Full Screen" : "Enter Full Screen";
        
        const iconHTML = isFullScreen 
          ? `<svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M8 3v3a2 2 0 0 1-2 2H3m18 0h-3a2 2 0 0 1-2-2V3m0 18v-3a2 2 0 0 1 2-2h3M3 16h3a2 2 0 0 1 2 2v3"/></svg>`
          : `<svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M8 3H5a2 2 0 0 0-2 2v3m18 0V5a2 2 0 0 0-2-2h-3m0 18h3a2 2 0 0 0 2-2v-3M3 16v3a2 2 0 0 0 2 2h3"/></svg>`;
        
        container.innerHTML = iconHTML;

        L.DomEvent.on(container, 'click', (e) => {
          L.DomEvent.stopPropagation(e);
          setIsFullScreen(!isFullScreen);
        });
        return container;
      },
    });
    const control = new Fullscreen({ position: 'topleft' });
    control.addTo(map);
    return () => { control.remove(); };
  }, [map, isFullScreen, setIsFullScreen]);
  return null;
};

const MapFlyToController = ({ coords }: { coords: [number, number] | null }) => {
    const map = useMap();
    useEffect(() => {
        if (coords) {
            map.flyTo(coords, 16);
        }
    }, [coords, map]);
    return null;
};


export default function ClientRingMap({
  nodes,
  solidLines = [],
  dashedLines = [],
  distances = {},
  onBack,
  highlightedNodeIds = [],
  onNodeClick,
  flyToCoordinates = null,
  showControls = false, // NEW PROP with default value
}: ClientRingMapProps) {
  const { theme } = useThemeStore();
  const [isFullScreen, setIsFullScreen] = useState(false);
  const [showAllNodePopups, setShowAllNodePopups] = useState(false);
  const [showAllLinePopups, setShowAllLinePopups] = useState(false);
  
  const mapRef = useRef<L.Map>(null);
  const markerRefs = useRef<{ [key: string]: L.Marker }>({});
  const polylineRefs = useRef<{ [key: string]: L.Polyline }>({});

  useEffect(() => {
    delete (L.Icon.Default.prototype as any)._getIconUrl;
    L.Icon.Default.mergeOptions({
        iconRetinaUrl: 'https://unpkg.com/leaflet@1.7.1/dist/images/marker-icon-2x.png',
        iconUrl: 'https://unpkg.com/leaflet@1.7.1/dist/images/marker-icon.png',
        shadowUrl: 'https://unpkg.com/leaflet@1.7.1/dist/images/marker-shadow.png',
    });
  }, []);

  useEffect(() => {
    Object.values(markerRefs.current).forEach(marker => showAllNodePopups ? marker.openPopup() : marker.closePopup());
  }, [showAllNodePopups]);

  useEffect(() => {
    Object.values(polylineRefs.current).forEach(polyline => showAllLinePopups ? polyline.openPopup() : polyline.closePopup());
  }, [showAllLinePopups]);

  if (nodes.length === 0) return <div className='py-10 text-center'>No nodes to display</div>;

  const bounds = useMemo(() => {
    if (nodes.length === 0) return null;
    const lats = nodes.map((n) => n.lat);
    const lngs = nodes.map((n) => n.long);
    return new LatLngBounds([Math.min(...lats), Math.min(...lngs)], [Math.max(...lats), Math.max(...lngs)]);
  }, [nodes]);

  const mapUrl = theme === "dark" ? "https://{s}.basemaps.cartocdn.com/dark_all/{z}/{x}/{y}{r}.png" : "https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png";
  const mapAttribution = "&copy; OpenStreetMap contributors &copy; CARTO";
  const mapContainerClass = isFullScreen ? "fixed inset-0 z-[100]" : "relative h-full w-full rounded-lg overflow-hidden";

  return (
    <div className={mapContainerClass}>
      {/* --- THIS UI BLOCK IS NOW CONDITIONAL --- */}
      {showControls && (
        <div className='absolute top-4 right-4 z-[1000] flex flex-col gap-2 bg-white dark:bg-gray-800 min-w-[160px] rounded-lg p-2 shadow-lg text-gray-800 dark:text-white'>
          {onBack && <button onClick={onBack} className='px-3 py-2 text-sm hover:bg-gray-100 dark:hover:bg-gray-700 flex items-center gap-1 rounded transition-colors'>← Back to List</button>}
          <button onClick={() => setShowAllNodePopups(!showAllNodePopups)} className='px-3 py-2 text-sm hover:bg-gray-100 dark:hover:bg-gray-700 flex items-center gap-1 rounded transition-colors'>
            <span className={showAllNodePopups ? "text-green-500" : "text-red-500"}>●</span> {showAllNodePopups ? "Hide" : "Show"} Node Info
          </button>
          <button onClick={() => setShowAllLinePopups(!showAllLinePopups)} className='px-3 py-2 text-sm hover:bg-gray-100 dark:hover:bg-gray-700 flex items-center gap-1 rounded transition-colors'>
            <span className={showAllLinePopups ? "text-green-500" : "text-red-500"}>●</span> {showAllLinePopups ? "Hide" : "Show"} Line Info
          </button>
        </div>
      )}

      <MapContainer center={bounds?.getCenter() || [22.57, 88.36]} bounds={bounds || undefined} zoom={13} ref={mapRef} style={{ height: "100%", width: "100%" }} className='z-0'>
        <MapController isFullScreen={isFullScreen} />
        <FullscreenControl isFullScreen={isFullScreen} setIsFullScreen={setIsFullScreen} />
        <MapFlyToController coords={flyToCoordinates} />
        <TileLayer url={mapUrl} attribution={mapAttribution} />
        
        {solidLines.map(([start, end]) => (
          <Polyline key={`solid-${start.id}-${end.id}`} positions={[[start.lat, start.long], [end.lat, end.long]]} color={theme === "dark" ? "#3b82f6" : "#2563eb"} weight={4} opacity={0.8} ref={(el) => { if (el) polylineRefs.current[`solid-${start.id}-${end.id}`] = el; }}>
            <Popup autoClose={false} closeOnClick={false} className={theme === "dark" ? "dark-popup" : ""}>
              <div className='text-sm'>
                <p>{start.name} → {end.name}</p>
                <p>Road Distance: {distances[`${start.id}-${end.id}`] ?? "..."}</p>
              </div>
            </Popup>
          </Polyline>
        ))}

        {dashedLines.map(([source, target]) => (
          <Polyline key={`dashed-${source.id}-${target.id}`} positions={[[source.lat, source.long], [target.lat, target.long]]} color={theme === "dark" ? "#ef4444" : "#dc2626"} weight={2.5} opacity={0.7} dashArray='6' ref={(el) => { if (el) polylineRefs.current[`dashed-${source.id}-${target.id}`] = el; }}>
            <Popup autoClose={false} closeOnClick={false} className={theme === "dark" ? "dark-popup" : ""}>
              <div className='text-sm'>
                <p>{source.name} ↔ {target.name}</p>
                <p>Road Distance: {distances[`${source.id}-${target.id}`] ?? "..."}</p>
              </div>
            </Popup>
          </Polyline>
        ))}

        {nodes.map((node) => {
          const isHighlighted = highlightedNodeIds.includes(node.id);
          const displayIp = node.ip ? node.ip.split('/')[0] : 'N/A';
          return (
            <Marker key={node.id} position={[node.lat, node.long]} icon={getNodeIcon(node.type, isHighlighted)} eventHandlers={{ click: () => onNodeClick?.(node.id) }} ref={(el) => { if (el) markerRefs.current[node.id] = el; }}>
              <Popup autoClose={false} closeOnClick={false} className={theme === "dark" ? "dark-popup" : ""}>
                <div className='text-sm'>
                  <h4 className='font-bold'>{node.name}</h4>
                  <p>Type: {node.type}</p>
                  <p>IP: {displayIp}</p>
                </div>
              </Popup>
            </Marker>
          );
        })}
      </MapContainer>
    </div>
  );
}
```

<!-- path: components/map/types/node.ts -->
```typescript
// path: components/map/types/node.ts
import { z } from 'zod';
import { v_ring_nodesRowSchema } from '@/schemas/zod-schemas';

// The RingMapNode is the primary, feature-rich node type, derived directly from the view.
export type RingMapNode = z.infer<typeof v_ring_nodesRowSchema>;

// The MapNode can be a simplified version or a partial type for more generic use cases.
// For simplicity and type safety, we can often just use RingMapNode everywhere.
export type MapNode = RingMapNode;

// Enums can remain as they are application-level constants, not direct DB models.
export enum NodeType {
  EXCHANGE = "EXCHANGE",
  CUSTOMER = "CUSTOMER",
  BTS = "BTS",
  MAAN = "MAAN",
  CPAN = "CPAN",
  BTS_RUNNING_OVER_RADIOLINK = "BTS(RUNNING OVER RADIOLINK)",
}
```

<!-- path: components/designations/DesignationFormModal.tsx -->
```typescript
import React, { useEffect, useMemo } from "react";
import { useForm } from "react-hook-form";
import { zodResolver } from "@hookform/resolvers/zod";
import { z } from "zod";
import { FormCard } from "@/components/common/form/FormCard";
import { FormInput, FormSearchableSelect, FormSwitch } from "@/components/common/form/FormControls";
import { employee_designationsInsertSchema, Employee_designationsInsertSchema, Employee_designationsRowSchema } from "@/schemas/zod-schemas";
import { DesignationWithRelations } from "@/app/dashboard/designations/page";



interface DesignationFormModalProps {
  isOpen: boolean;
  onClose: () => void;
  onSubmit: (data: Employee_designationsInsertSchema) => void;
  designation: DesignationWithRelations | null;
  allDesignations: Employee_designationsRowSchema[];
  isLoading: boolean;
}

export function DesignationFormModal({ isOpen, onClose, onSubmit, designation, allDesignations }: DesignationFormModalProps) {
  // === React Hook Form Setup ===
  // Create a form-specific schema that excludes timestamp fields to avoid Date vs string/null mismatches
  const designationFormSchema = employee_designationsInsertSchema.pick({ id: true, name: true, parent_id: true, status: true });
  type DesignationForm = z.infer<typeof designationFormSchema>;

  const {
    register,
    handleSubmit,
    formState: { errors },
    reset,
    control,
  } = useForm<DesignationForm>({
    resolver: zodResolver(designationFormSchema),
    defaultValues: {
      name: "",
      parent_id: null,
      status: true,
    },
  });

  const availableParents = useMemo(() => {
    if (!designation || !designation.id) return allDesignations;

    const getDescendantIds = (designationId: string, designations: Employee_designationsInsertSchema[]): Set<string> => {
      const descendants = new Set<string>([designationId]);
      const children = designations.filter((d) => d.parent_id === designationId);
      children.forEach((child) => {
        if (!child.id) return;
        const childDescendants = getDescendantIds(child.id, designations);
        childDescendants.forEach((id) => descendants.add(id));
      });
      return descendants;
    };

    const excludeIds = getDescendantIds(designation.id, allDesignations);
    return allDesignations.filter((d) => !d.id || !excludeIds.has(d.id));
  }, [designation, allDesignations]);

  // Reset form when designation changes (to pre-fill the form when editing)
  useEffect(() => {
    if (designation) {
      reset({
        id: designation.id,
        name: designation.name,
        parent_id: designation.parent_id ?? null,
        status: designation.status ?? true,
      });
    }
  }, [designation, reset]);

  const onValidSubmit = (data: DesignationForm) => {
    // Forward only the fields we collect; backend/consumer can add timestamps as needed
    const parsedData = {
      ...data,
    };
    onSubmit(parsedData);
  };

  if (!isOpen) return null;

  return (
    <div className='fixed inset-0 z-50 flex items-center justify-center bg-black bg-opacity-50'>
        <FormCard standalone onSubmit={handleSubmit(onValidSubmit)} title={designation ? "Edit Designation" : "Add New Designation"} onCancel={onClose} heightClass="h-[calc(90vh-140px)]">
          <FormInput name='name' label='Designation Name' register={register} error={errors.name} required />
          <FormSearchableSelect name='parent_id' label='Parent Designation' control={control} error={errors.parent_id} required options={availableParents.map((d) => ({ value: d.id, label: d.name }))} />
          <FormSwitch name='status' label='Status' control={control} error={errors.status} className="mt-4" />
        </FormCard>
    </div>
  );
}

```

<!-- path: components/polyfills/PolyfillLoader.tsx -->
```typescript
"use client";
 
import { useEffect } from "react";
 
export default function PolyfillLoader() {
  useEffect(() => {
    const needsPolyfills = !("fetch" in window) || !("IntersectionObserver" in window);
 
    if (needsPolyfills) {
      import("core-js/stable");
      import("regenerator-runtime/runtime");
      import("whatwg-fetch");
      import("intersection-observer");
      import("url-polyfill");
    }
  }, []);
 
  return null; // No UI needed
}
```

<!-- path: components/doc/AccordionTriggerContent.tsx -->
```typescript
import { WorkflowSection } from "@/components/doc/types/workflowTypes";
import { ChevronRight } from "lucide-react";


interface AccordionTriggerContentProps {
  section: WorkflowSection;
  isOpen: boolean;
}

export default function AccordionTriggerContent({ 
  section, 
  isOpen 
}: AccordionTriggerContentProps) {
  const Icon = section.icon;
  
  return (
    <div className={`w-full flex items-center gap-4 p-6 rounded-2xl bg-gradient-to-br from-gray-900/80 to-gray-800/50 backdrop-blur-sm border border-gray-800 hover:border-${section.color}-500/50 transition-all duration-300 ${isOpen ? `border-${section.color}-500/50 shadow-lg shadow-${section.color}-500/20` : ""}`}>
      <div className={`p-3 rounded-xl bg-gradient-to-br ${section.gradient} ${section.bgGlow}`}>
        <Icon className="w-6 h-6 text-white" />
      </div>
      <div className="flex-1 text-left">
        <h3 className="text-xl font-semibold text-gray-100 group-hover:text-white transition-colors">
          {section.title}
        </h3>
        <p className="text-sm text-gray-500 mt-1">{section.subtitle}</p>
      </div>
      <ChevronRight className={`w-5 h-5 text-gray-500 transition-transform duration-300 ${isOpen ? "rotate-90" : ""}`} />
    </div>
  );
}
```

<!-- path: components/doc/WorkflowCard.tsx -->
```typescript
import { Card, CardContent, CardHeader, CardTitle } from '@/components/common/ui/card/card';
import { ScrollArea } from '@/components/common/ui/scroll-area';
import { WorkflowCardProps } from '@/components/doc/types/workflowTypes';
import WorkflowSection from '@/components/doc/WorkflowSection';
import { Workflow } from 'lucide-react';

export default function WorkflowCard({ purpose, workflows, color }: WorkflowCardProps) {
  const colorMap = {
    violet: {
      border: 'border-violet-500/30',
      glow: 'shadow-violet-500/10',
      badge: 'bg-violet-500/20 text-violet-300 border-violet-500/30',
      icon: 'text-violet-400',
    },
    blue: {
      border: 'border-blue-500/30',
      glow: 'shadow-blue-500/10',
      badge: 'bg-blue-500/20 text-blue-300 border-blue-500/30',
      icon: 'text-blue-400',
    },
    teal: {
      border: 'border-teal-500/30',
      glow: 'shadow-teal-500/10',
      badge: 'bg-teal-500/20 text-teal-300 border-teal-500/30',
      icon: 'text-teal-400',
    },
    cyan: {
      border: 'border-cyan-500/30',
      glow: 'shadow-cyan-500/10',
      badge: 'bg-cyan-500/20 text-cyan-300 border-cyan-500/30',
      icon: 'text-cyan-400',
    },
    orange: {
      border: 'border-orange-500/30',
      glow: 'shadow-orange-500/10',
      badge: 'bg-orange-500/20 text-orange-300 border-orange-500/30',
      icon: 'text-orange-400',
    },
    yellow: {
      border: 'border-yellow-500/30',
      glow: 'shadow-yellow-500/10',
      badge: 'bg-yellow-500/20 text-yellow-300 border-yellow-500/30',
      icon: 'text-yellow-400',
    },
  };

  const colors = colorMap[color];

  return (
    <Card
      className={`mt-4 bg-gradient-to-br from-gray-900/90 to-gray-800/50 backdrop-blur-sm border ${colors.border} ${colors.glow} shadow-2xl`}
    >
      <CardHeader className="pb-4">
        <div className="flex items-start gap-3">
          <div className="p-2 bg-gradient-to-br from-gray-800 to-gray-900 rounded-lg">
            <Workflow className={`w-5 h-5 ${colors.icon}`} />
          </div>
          <div className="flex-1">
            <CardTitle className="text-lg text-gray-100 mb-2">Purpose</CardTitle>
            <p className="text-gray-400 text-sm leading-relaxed">{purpose}</p>
          </div>
        </div>
      </CardHeader>

      <CardContent className="pt-0">
        <ScrollArea className="h-[600px] rounded-xl border border-gray-800/50 bg-gray-950/50 backdrop-blur-sm">
          <div className="p-6 space-y-8">
            {workflows.map((workflow, index) => (
              <WorkflowSection
                key={index}
                workflow={workflow}
                index={index}
                colors={colors}
                isLast={index === workflows.length - 1}
              />
            ))}
          </div>
        </ScrollArea>
      </CardContent>
    </Card>
  );
}

```

<!-- path: components/doc/HeaderSection.tsx -->
```typescript
import { Workflow } from "lucide-react";

export default function HeaderSection() {
  return (
    <div className="text-center space-y-4 mb-12">
      <div className="inline-flex items-center gap-2 px-4 py-2 bg-gradient-to-r from-violet-500/20 to-cyan-500/20 rounded-full border border-violet-500/30 backdrop-blur-sm">
        <Workflow className="w-4 h-4 text-violet-400" />
        <span className="text-sm font-medium text-gray-300">Technical Documentation</span>
      </div>
      <h1 className="text-5xl md:text-6xl font-bold bg-gradient-to-r from-white via-gray-100 to-gray-400 bg-clip-text text-transparent">
        System Workflows
      </h1>
      <p className="text-gray-400 text-lg max-w-2xl mx-auto">
        Comprehensive step-by-step user and technical workflows for your application
      </p>
    </div>
  );
}
```

<!-- path: components/doc/StepList.tsx -->
```typescript
import { LucideIcon } from "lucide-react";

interface StepListProps {
  icon: LucideIcon;
  iconColor: string;
  title: string;
  steps: string[];
  stepColor: string;
  isTechnical?: boolean;
}

export default function StepList({ 
  icon: Icon, 
  iconColor, 
  title, 
  steps, 
  stepColor,
  isTechnical = false 
}: StepListProps) {
  return (
    <div className="space-y-2">
      <div className="flex items-center gap-2">
        <Icon className={`w-4 h-4 ${iconColor}`} />
        <h4 className="text-sm font-semibold text-gray-200">{title}</h4>
      </div>
      <ul className="space-y-2 ml-6">
        {steps.map((step, index) => (
          <li key={index} className="text-sm text-gray-400 flex items-start gap-2">
            <span className={`${stepColor} mt-1`}>•</span>
            {isTechnical ? (
              <span dangerouslySetInnerHTML={{ 
                __html: step.replace(
                  /`([^`]+)`/g, 
                  '<code class="bg-gray-800/80 text-amber-300 px-1.5 py-0.5 rounded text-xs font-mono border border-gray-700/50">$1</code>'
                ) 
              }} />
            ) : (
              <span>{step}</span>
            )}
          </li>
        ))}
      </ul>
    </div>
  );
}
```

<!-- path: components/doc/data/workflowData.ts -->
```typescript
import { ShieldCheck, Route, GitBranch, GitCommit, Users, Cpu, BellRing, Server } from "lucide-react";
import { WorkflowSection } from "../types/workflowTypes";
import { FaDiagramNext } from "react-icons/fa6";
import { BsPeople } from "react-icons/bs";
import { ImUserTie } from "react-icons/im";

export const workflowSections: WorkflowSection[] = [
  {
    value: "auth",
    icon: ShieldCheck,
    title: "Authentication & Authorization",
    subtitle: "User registration, login & RBAC",
    gradient: "from-violet-500 to-purple-600",
    iconColor: "text-violet-400",
    bgGlow: "bg-violet-500/10",
    color: "violet",
    purpose: "To manage user registration, login, session handling, and role-based access control (RBAC).",
    workflows: [
      {
        title: "Workflow A: New User Registration & Onboarding Prompt",
        userSteps: [
          "User fills out the form on `/signup` and submits.",
          "User receives a verification email and clicks the link.",
          "User will log in and redirected to the `/dashboard` page.",
          "A welcome popup appears, prompting them to complete their profile.",
          "User can choose to 'Update Profile', 'Maybe Later', or 'Don't show again'.",
        ],
        uiSteps: ["On submit, user is redirected to `/verify-email`.", "After email verification, the `/auth/callback` route sends the user to `/dashboard`.", "On the dashboard, the `OnboardingPromptModal` appears if the profile is incomplete."],
        techSteps: [
          "`signUp` calls `supabase.auth.signUp`.",
          'DB Trigger `on_auth_user_created` inserts a `user_profiles` record and adds `{"needsOnboarding": true}` to the `preferences` JSONB column.',
          "The `app/dashboard/page.tsx` component uses the `useGetMyUserDetails` hook.",
          "A `useEffect` checks if `profile.preferences.needsOnboarding` is `true` and if `profile.preferences.showOnboardingPrompt` is not `false`.",
          "If conditions are met, the modal's state is set to open.",
          "Clicking 'Don't show again' updates the `preferences` column, setting `showOnboardingPrompt: false`.",
          "Clicking 'Update Profile' navigates the user to the `/onboarding` page.",
        ],
      },
      {
        title: "Workflow B: User Login & Session Management",
        userSteps: ["User enters credentials on `/login` and clicks 'Sign in'."],
        uiSteps: ["Loading state shown.", "On success, user is redirected to `/dashboard`.", "On failure, an error toast is displayed."],
        techSteps: [
          "`signIn` function in `useAuth` calls `supabase.auth.signInWithPassword`.",
          "The hook verifies that the response contains no error AND a valid session object.",
          "If verification fails, an error toast is shown and the function returns `success: false`.",
          "If successful, Supabase returns a session with a JWT, which is stored in cookies.",
          "The `middleware.ts` refreshes the user's auth token on subsequent requests.",
          "The `useAuthStore` (Zustand) is updated by the `onAuthStateChange` listener, making the user session globally available.",
        ],
      },
      {
        title: "Workflow C: Role Synchronization & RLS",
        userSteps: ["An admin changes a user's role in the User Management page."],
        uiSteps: ["The user's permissions are updated for their next session."],
        techSteps: [
          "An admin action updates the `role` column in the `public.user_profiles` table.",
          "A database trigger (`sync_user_role_trigger`) fires on update.",
          "This trigger updates the `raw_app_meta_data` JSONB column in the corresponding `auth.users` table, setting the new role.",
          "The user's JWT is now minted with the new role claim, which is used by RLS policies to grant access.",
        ],
      },
      {
        title: "Workflow D: Existing User Profile Update",
        userSteps: ["User clicks on their avatar in the header and selects 'Update Profile'.", "User is taken to the `/onboarding` page, which acts as a profile editor.", "User changes their details and clicks 'Update Profile'."],
        uiSteps: ["The form on the `/onboarding` page is pre-populated with the user's existing data.", "A toast notification confirms that the profile has been updated successfully.", "The user remains on the profile page to make further changes."],
        techSteps: [
          "The `AuthButton` component contains a `<Link>` that navigates to `/onboarding`.",
          "The `OnboardingFormEnhanced` component fetches the user's profile using the `useGetMyUserDetails` hook.",
          "An `useEffect` populates the form fields with the fetched data.",
          "On submit, `OnboardingFormEnhanced` calls the `useTableUpdate` mutation, which updates the `user_profiles` record and sets `needsOnboarding` to `false` within the `preferences` column.",
          "The `isDirty` state from `react-hook-form` ensures the update only happens if changes were actually made.",
        ],
      },
    ],
  },
  {
    value: "base_structure",
    icon: Server,
    title: "Base Structure Setup",
    subtitle: "Categories, Lookups, Areas & Designations",
    gradient: "from-gray-500 to-slate-600",
    iconColor: "text-gray-400",
    bgGlow: "bg-gray-500/10",
    color: "yellow", // Using a distinct color
    purpose: "To configure the foundational data that categorizes and organizes all other entities in the system. This setup is typically performed by an administrator before regular data entry begins.",
    workflows: [
      {
        title: "Workflow A: Managing Categories & Lookups",
        userSteps: [
          "Admin goes to `/dashboard/categories` and creates a new category (e.g., 'NODE_TYPES'). This acts as a grouping for dropdown options.",
          "Admin then navigates to `/dashboard/lookup` and selects the newly created 'Node Types' category.",
          "Clicks 'Add New' to open the `LookupModal`.",
          "Admin adds a new lookup type, filling in the details:",
          "  - **Name:** 'Base Transceiver Station' (The human-readable text shown in dropdowns).",
          "  - **Code:** 'BTS' (A short, unique code for this type, useful for display or logic).",
          "  - **Sort Order:** '10' (A number to control the display order in lists; lower numbers appear first).",
          "  - **System Default:** Left unchecked. This flag is reserved for critical, system-required types and prevents their deletion.",
          "Admin saves the new lookup type.",
        ],
        uiSteps: [
          "The Categories page allows creating and renaming high-level categories.",
          "On the Lookups page, a category must be selected to view or add types.",
          "The `DataTable` lists all lookup types for the selected category, ordered by the `sort_order` value.",
          "If a lookup type has `is_system_default` set to `true`, its Edit and Delete buttons are disabled in the UI to prevent accidental modification.",
        ],
        techSteps: [
          "A **Category** is not a separate table; it's a distinct value in the `category` column of the `lookup_types` table. It acts as the primary grouping key.",
          "A **Lookup Type** is a single row in the `lookup_types` table.",
          "The **`name`** field is the primary value displayed to users in dropdowns and tables.",
          "The **`code`** field provides a concise, alternative identifier. It's often used for badges or in places where a full name is too long.",
          "The **`sort_order`** field dictates the ordering of items when fetched for dropdowns. This allows for a custom order that isn't alphabetical (e.g., 'High', 'Medium', 'Low').",
          "The **`is_system_default`** flag is a protective measure. When `true`, UI controls for editing and deleting are disabled. This prevents an admin from deleting a lookup type that the application's internal logic depends on (e.g., a status type like 'Active' or 'Pending').",
          "All dropdowns for types (e.g., Node Type, Ring Type) are populated by querying the `lookup_types` table with a `WHERE category = ?` clause and ordering by `sort_order`.",
        ],
      },
      {
        title: "Workflow B: Managing Maintenance Areas",
        userSteps: [
          "Admin navigates to `/dashboard/maintenance-areas`.",
          "Clicks 'Add New' and fills out the `AreaFormModal` to create a top-level area (e.g., a Zone).",
          "Admin then creates another area (e.g., a Terminal), but this time selects the newly created Zone as its 'Parent Area', establishing a hierarchy.",
        ],
        uiSteps: [
          "The `EntityManagementComponent` displays the areas in a hierarchical tree view or a simple list view.",
          "The form modal for an area dynamically filters the 'Parent Area' dropdown to prevent a user from making an area its own child (circular dependency).",
        ],
        techSteps: [
          "The page uses the `EntityManagementComponent` with `areaConfig`, which defines the parent-child relationship via the `parent_id` foreign key field.",
          "Data is fetched using `useTableWithRelations` to include nested `parent_area` and `child_areas` data in a single query.",
          "The `AreaFormModal` uses `useTableInsert` or `useTableUpdate` to modify records in the `maintenance_areas` table.",
        ],
      },
    ],
  },
  {
    value: 'designations_crud',
    icon: ImUserTie,
    title: 'Designation Management',
    subtitle: 'Organizing employee roles in a hierarchy',
    gradient: 'from-cyan-500 to-sky-600',
    iconColor: 'text-cyan-400',
    bgGlow: 'bg-cyan-500/10',
    color: 'cyan',
    purpose: 'To establish a hierarchical structure for employee roles, enabling clear reporting lines and organizational charts. This feature is crucial for building an accurate representation of the company structure.',
    workflows: [
      {
        title: 'Workflow: Managing a Designation Hierarchy',
        userSteps: [
          "Admin navigates to `/dashboard/designations`.",
          "Clicks 'Add New Designation' to create a top-level role (e.g., 'General Manager') without selecting a parent.",
          "Clicks 'Add New' again to create a child role (e.g., 'Deputy Manager') and selects 'General Manager' from the 'Parent Designation' dropdown.",
          "User toggles between 'Tree' and 'List' view to visualize the structure.",
          "Admin clicks the 'Delete' icon on a role.",
        ],
        uiSteps: [
          'The `EntityManagementComponent` is the main layout, displaying designations in either a nested tree structure or a flat list.',
          'The `DesignationFormModal` appears for creating or editing. It intelligently filters the `Parent Designation` dropdown to prevent a designation from being its own child or grandchild (a circular dependency).',
          'A `ConfirmModal` appears before any deletion to ensure the action is intentional.',
        ],
        techSteps: [
          'The page is powered by the generic `EntityManagementComponent`, configured with `designationConfig`. This config object specifies `isHierarchical: true` and sets `parent_id` as the relational key.',
          'Data is fetched using the `useTableWithRelations` hook, which performs a self-join on the `employee_designations` table to get the `parent_designation` object for each record.',
          'The `useEntityManagement` hook processes the flat list into a nested tree structure for the UI by matching `id` and `parent_id` fields.',
          'When creating or editing, the `DesignationFormModal` uses the `useTableInsert` or `useTableUpdate` mutation to save data directly to the `employee_designations` table.',
          'The `useDelete` hook (via `useDeleteManager`) handles deletion by calling `supabase.from("employee_designations").delete()`. Postgres handles the `ON DELETE SET NULL` constraint for any children of the deleted designation.',
        ],
      },
    ],
  },
  {
    value: "employees_crud",
    icon: BsPeople,
    title: "Employee Management",
    subtitle: "Managing employee records and roles",
    gradient: "from-sky-500 to-blue-600",
    iconColor: "text-sky-400",
    bgGlow: "bg-sky-500/10",
    color: "cyan",
    purpose: "To maintain a central database of all employees, their designations, contact information, and assigned maintenance areas.",
    workflows: [
      {
        title: "Workflow: Managing Employee Records",
        userSteps: ["Admin navigates to `/dashboard/employees`.", "Clicks 'Add New' to open the `EmployeeForm`.", "Fills in employee details, selecting a pre-configured Designation and Maintenance Area.", "Saves the new employee record."],
        uiSteps: ["The `DataTable` on the page lists all employees.", "The form modal provides dropdowns for selecting related data like designations.", "On success, a toast appears, and the employee list is refreshed."],
        techSteps: [
          "The page uses `useCrudManager` configured for the `employees` table.",
          "The `EmployeeForm` uses `useTableInsert` or `useTableUpdate` to save data to the `employees` table.",
          "The `employee_designation_id` and `maintenance_terminal_id` fields are foreign keys linking to their respective tables.",
          "The main data table queries the `v_employees` view to efficiently join and display the names of the designation and maintenance area.",
        ],
      },
    ],
  },
  {
    value: "diagrams_crud",
    icon: FaDiagramNext,
    title: "Diagrams & File Management",
    subtitle: "Uploading and organizing network diagrams",
    gradient: "from-rose-500 to-pink-600",
    iconColor: "text-rose-400",
    bgGlow: "bg-rose-500/10",
    color: "orange", // Using a distinct color
    purpose: "To provide a centralized repository for uploading, storing, and accessing network diagrams, schematics, and other related documents.",
    workflows: [
      {
        title: "Workflow: Uploading a Diagram",
        userSteps: ["User navigates to the `/dashboard/diagrams` page.", "Creates a new folder or selects an existing one.", "Drags a file into the upload area or clicks 'Select Files'.", "Clicks the 'Upload' button."],
        uiSteps: ["The `FileUploader` component provides the main interface.", "A list of selected files appears before uploading.", "A success toast confirms the upload, and the file appears in the `FileTable` under the selected folder."],
        techSteps: [
          "The `useFolders` hook fetches and manages folder state from the `folders` table.",
          "The `useUppyUploader` hook handles the client-side file processing, including optimizations.",
          "Uppy uploads the file to a serverless API route at `/api/upload` (not shown, but assumed).",
          "The API route uploads the file to Supabase Storage.",
          "On `upload-success`, the `useUppyUploader` hook calls the `useUploadFile` mutation, which inserts a new record into the `files` table, linking the file metadata to the `folder_id` and `user_id`.",
        ],
      },
    ],
  },
  {
    value: "users_crud",
    icon: Users,
    title: "User CRUD Operations",
    subtitle: "Creating, updating, and deleting users",
    gradient: "from-blue-500 to-cyan-600",
    iconColor: "text-blue-400",
    bgGlow: "bg-blue-500/10",
    color: "blue",
    purpose: "To provide administrators with the tools to manage user accounts, assign roles, and control access.",
    workflows: [
      {
        title: 'Workflow A: Viewing & Filtering Users',
        userSteps: [
          'Admin navigates to the `/dashboard/users` page.',
          'Admin uses the search bar and filter dropdowns to find specific users.',
        ],
        uiSteps: [
          'The `DataTable` displays a paginated list of users from the `v_user_profiles_extended` view.',
          'The `UserFilters` component updates the view as the admin types or selects filters.',
        ],
        techSteps: [
          'The `AdminUsersPage` uses a `useCrudManager` hook with a `useUsersData` adapter.',
          'The `useUsersData` adapter calls the `admin_get_all_users_extended` Supabase RPC.',
          'The RPC function performs a server-side search and filter on the `v_user_profiles_extended` view and returns the paginated results.',
        ],
      },
      {
        title: 'Workflow B: Creating a New User (Admin)',
        userSteps: [
          "Admin clicks 'Add New'.",
          "Fills in the user's details (name, email, password, role) in the `UserCreateModal`.",
          "Clicks 'Create User'.",
        ],
        uiSteps: [
          'The modal appears for data entry.',
          'On success, a toast notification is shown, the modal closes, and the user list refreshes.',
        ],
        techSteps: [
          'The `handleCreateUser` function calls the `createUser` mutation from `useAdminUserOperations` hook.',
          'This mutation sends a `POST` request to the `/api/admin/users` serverless function.',
          'The API route manually hashes the password and inserts a single new record directly into the `auth.users` table.',
          'Crucially, this `INSERT` operation causes the `on_auth_user_created` database trigger to fire.',
          'The trigger function is now the single source of truth for profile creation; it automatically reads the metadata from the new `auth.users` record and inserts a corresponding row into `public.user_profiles`.',
          'The frontend invalidates the user list query to show the new user.',
        ],
      },
      {
        title: 'Workflow C: Editing a User',
        userSteps: [
          "Admin clicks the 'Edit' icon on a user row.",
          "Modifies user details (e.g., name, role, status) in the `UserProfileEditModal`.",
          "Clicks 'Save Changes'.",
        ],
        uiSteps: [
          'The modal opens, pre-filled with the selected user’s data.',
          'On success, a toast is shown, and the UI updates with the new information.',
        ],
        techSteps: [
          'The `onEdit` handler from `useCrudManager` opens the modal with the user record.',
          'Submitting the form calls the `updateProfile` mutation from the `useAdminUpdateUserProfile` hook.',
          'This mutation calls the `admin_update_user_profile` RPC, which updates the `user_profiles` table.',
          'If the role is changed, a database trigger syncs it to the `auth.users` table.',
          'The user list query is invalidated and refetched.',
        ],
      },
      {
        title: 'Workflow D: Deleting a User',
        userSteps: [
          "Admin selects one or more users using the checkboxes.",
          "Clicks the 'Delete' button in the `BulkActions` toolbar.",
          "Confirms the deletion in the `ConfirmModal`.",
        ],
        uiSteps: [
          'A confirmation modal appears to prevent accidental deletion.',
          'On success, a toast is shown, and the user(s) are removed from the table.',
        ],
        techSteps: [
          'The `handleBulkDelete` function calls the `bulkDelete` mutation from `useAdminUserOperations`.',
          'This mutation sends a `DELETE` request to the `/api/admin/users` endpoint with the selected user IDs.',
          'The API route first verifies the requester is a super admin, then uses a privileged Supabase client to call `supabase.auth.admin.deleteUser()` for each ID.',
          'The `ON DELETE CASCADE` constraint on the `user_profiles` table automatically removes the corresponding profile.',
          'The user list query is invalidated to refresh the UI.',
        ],
      },
    ],
  },
  {
    value: "nodes_crud",
    icon: Cpu,
    title: "Node CRUD Operations",
    subtitle: "Managing physical network locations",
    gradient: "from-emerald-500 to-teal-600",
    iconColor: "text-emerald-400",
    bgGlow: "bg-emerald-500/10",
    color: "teal",
    purpose: "To create, view, update, and delete network nodes, which represent physical sites like exchanges, BTS towers, or junction points.",
    workflows: [
      {
        title: "Workflow A: Viewing & Filtering Nodes",
        userSteps: ["User navigates to the `/dashboard/nodes` page.", "User types a node name in the search bar or selects a node type from the dropdown."],
        uiSteps: ["The `DataTable` displays a list of nodes from the `v_nodes_complete` view.", "The list updates automatically as the user interacts with the filters."],
        techSteps: [
          "The `NodesPage` uses `useCrudManager` with a `useNodesData` adapter.",
          "The `useNodesData` adapter calls the `get_paged_data` RPC function with the specified filters.",
          "The RPC function queries the `v_nodes_complete` view to get the data along with related names (e.g., maintenance area name).",
        ],
      },
      {
        title: "Workflow B: Creating or Editing a Node",
        userSteps: ["User clicks 'Add New' or the 'Edit' icon on a node row.", "Fills out the node details (name, type, location, etc.) in the `NodeFormModal`.", "Clicks 'Save'."],
        uiSteps: ["A modal opens with the form.", "On success, a toast notification appears, and the table refreshes."],
        techSteps: [
          "`useCrudManager` opens the `NodeFormModal` with either `null` (for create) or the selected node data (for edit).",
          "On form submission, `handleSave` is called, which triggers either the `useTableInsert` or `useTableUpdate` hook.",
          "The mutation sends a request directly to the Supabase `nodes` table.",
          "TanStack Query invalidates the `v_nodes_complete` view query, causing the UI to refetch and display the changes.",
        ],
      },
      {
        title: "Workflow C: Deleting a Node",
        userSteps: ["User clicks the 'Delete' icon on a node row.", "Confirms the action in the `ConfirmModal`."],
        uiSteps: ["A confirmation prompt appears.", "On success, a toast is shown, and the node is removed from the table."],
        techSteps: [
          "`crudActions.handleDelete` is called, which uses `useDeleteManager`.",
          "`useDeleteManager` triggers the `ConfirmModal`.",
          "On confirmation, a `useTableDelete` mutation is called, which sends a `DELETE` request to the Supabase `nodes` table for the specified ID.",
          "The query for `v_nodes_complete` is invalidated, refreshing the UI.",
        ],
      },
    ],
  },
  {
    value: "rings_crud",
    icon: BellRing,
    title: "Ring CRUD Operations",
    subtitle: "Defining and managing logical network rings",
    gradient: "from-orange-500 to-amber-600",
    iconColor: "text-orange-400",
    bgGlow: "bg-orange-500/10",
    color: "orange",
    purpose: "To manage logical network rings, which group various systems together to form a resilient communication path.",
    workflows: [
      {
        title: "Workflow A: Viewing & Filtering Rings",
        userSteps: ["User navigates to the `/dashboard/rings` page.", "User types a ring name in the search bar."],
        uiSteps: ["The `DataTable` displays a list of rings from the `v_rings` view, showing details like total nodes and maintenance area."],
        techSteps: ["The `RingsPage` uses `useCrudManager` with a `useRingsData` adapter.", "The `useRingsData` adapter calls the `get_paged_data` RPC, which queries the `v_rings` view."],
      },
      {
        title: "Workflow B: Creating or Editing a Ring",
        userSteps: ["User clicks 'Add New' or 'Edit'.", "Fills out the ring's name, type, and maintenance terminal in the `RingModal`.", "Clicks 'Save'."],
        uiSteps: ["A modal opens with the form.", "On success, a toast notification appears, and the table refreshes."],
        techSteps: ["`useCrudManager` opens the `RingModal`.", "On submission, `handleSave` triggers `useTableInsert` or `useTableUpdate` on the `rings` table.", "The query for the `v_rings` view is invalidated, refreshing the UI."],
      },
      {
        title: "Workflow C: Associating Systems with a Ring",
        userSteps: ["User clicks the 'Manage Systems' icon on a ring row.", "In the `RingSystemsModal`, user moves systems from the 'Available' list to the 'Associated' list.", "User clicks 'Save Changes'."],
        uiSteps: ["A dual-listbox modal appears, showing systems in the same maintenance area.", "On success, a toast is shown, the modal closes, and the 'Total Nodes' count in the table updates."],
        techSteps: [
          "The `handleManageSystems` handler opens the `RingSystemsModal`.",
          "The modal fetches associated systems (from `v_systems_complete` where `ring_id` matches) and available systems (from `v_systems_complete` where `ring_id` is null and `maintenance_terminal_id` matches).",
          "Saving triggers the `updateMutation`, which calls the `update_ring_system_associations` RPC function.",
          "This RPC function deletes old associations and inserts the new list of system IDs into the `ring_based_systems` junction table.",
          "The `v_rings` view query is invalidated, causing the 'Total Nodes' count to update.",
        ],
      },
    ],
  },
  {
    value: "routes",
    icon: Route,
    title: "OFC & Route Management",
    subtitle: "Cable segmentation & fiber splicing",
    gradient: "from-teal-500 to-emerald-600",
    iconColor: "text-teal-400",
    bgGlow: "bg-teal-500/10",
    color: "teal",
    purpose: "An advanced tool to manage the physical segmentation and fiber splicing of an optical fiber cable (OFC) route.",
    workflows: [
      {
        title: 'Workflow A: Managing OFC Cable Records (CRUD)',
        userSteps: [
          'Admin navigates to `/dashboard/ofc`.',
          "Clicks 'Add New' to create a new cable route.",
          "Fills in details like nodes, type, and capacity, then clicks 'Create'.",
          "To edit, admin clicks the 'Edit' icon on a row, modifies data, and saves.",
          "To delete, admin clicks the 'Delete' icon and confirms in the popup.",
        ],
        uiSteps: [
          'The `DataTable` displays a list of all existing OFC cables.',
          'A `route_name` is automatically generated when start and end nodes are selected.',
          'On successful save/delete, a toast notification appears and the table refreshes.',
        ],
        techSteps: [
          'The `OfcPage` uses `useCrudManager` to manage state and data fetching.',
          'Creating a record calls the `useTableInsert` hook to write to the `ofc_cables` table.',
          'An `AFTER INSERT` trigger on `ofc_cables` automatically populates the `ofc_connections` table with records for each fiber.',
          'Editing calls the `useTableUpdate` hook to update the `ofc_cables` record.',
          // **UPDATED DOCUMENTATION STEP**
          'Deleting calls the `useTableDelete` hook to remove a record from `ofc_cables`.',
          'The `ON DELETE CASCADE` constraint on the `ofc_connections` table\'s `ofc_id` foreign key ensures that PostgreSQL automatically deletes all associated fiber connection records in the same transaction.',
        ],
      },
      {
        title: 'Workflow B: Visualizing a Route',
        userSteps: ['User selects an OFC route from the dropdown in the Route Manager.'],
        uiSteps: [
          'The `RouteVisualization` component renders the start/end nodes and any existing Junction Closures (JCs).',
          'A list of `Cable Segments` is displayed below the visualization.',
        ],
        techSteps: [
          "The page component's `useQuery` fetches data from the API route `/api/route/[id]`.",
          'The API route fetches data from multiple tables, including `v_ofc_cables_complete` and `cable_segments`.',
          'The API returns a consolidated `RouteDetailsPayload` object.',
        ],
      },
      {
        title: 'Workflow C: Adding a Junction Closure',
        userSteps: [
          "User clicks 'Add Junction Closure' in the Route Manager.",
          "Fills in the JC's name and position and saves.",
        ],
        uiSteps: [
          'The `RouteVisualization` updates to show the new JC on the cable path.',
          'The `Cable Segments` list is recalculated and re-rendered.',
        ],
        techSteps: [
          'The form calls the `add_junction_closure` Supabase RPC function.',
          'This RPC inserts records into the `nodes` and `junction_closures` tables.',
          'An `AFTER INSERT` trigger on `junction_closures` fires the `recalculate_segments_for_cable` function, which rebuilds the records in the `cable_segments` table.',
          'The frontend refetches the route details, updating the UI.',
        ],
      },
      {
        title: 'Workflow D: Managing Fiber Splices',
        userSteps: [
          'User clicks on an existing JC in the visualization.',
          "User selects a fiber from one segment and then clicks an available fiber on another to create a splice.",
        ],
        uiSteps: [
          'The `FiberSpliceManager` component displays a matrix of all segments and fibers at that JC.',
          'UI provides visual cues for selected, available, and used fibers.',
        ],
        techSteps: [
          '`FiberSpliceManager` calls the `get_jc_splicing_details` RPC to fetch the current splice state.',
          "A `manage_splice` RPC function is called with `p_action: 'create'`, inserting a record into the `fiber_splices` table.",
          'The frontend query for splicing details is invalidated and refetched, updating the UI.',
        ],
      },
    ],
  },
  {
    value: "provisioning",
    icon: GitBranch,
    title: "Logical Path & Fiber Provisioning",
    subtitle: "End-to-end service provisioning",
    gradient: "from-cyan-500 to-blue-600",
    iconColor: "text-cyan-400",
    bgGlow: "bg-cyan-500/10",
    color: "cyan",
    purpose: "To define an end-to-end logical path over physical cable segments and provision working/protection fibers for a service.",
    workflows: [
      {
        title: "Workflow A: Building a Logical Path",
        userSteps: ["User navigates to a System's detail page (`/dashboard/systems/[id]`).", "User clicks 'Initialize Path' to create a logical path record.", "In 'Build Mode', user clicks on nodes in the map to add cable segments to the path."],
        uiSteps: ["The `SystemRingPath` component displays a map of nodes and a list of segments in the path.", "The map highlights nodes in the current path."],
        techSteps: [
          "Initializing inserts a new record into `logical_fiber_paths`.",
          "Clicking a node calls the `find_cable_between_nodes` RPC to find the physical `ofc_cables` record.",
          "A new record is inserted into `logical_path_segments`, linking the `logical_fiber_paths` ID with the `ofc_cables` ID.",
          "The path is validated in real-time using the `validate_ring_path` RPC.",
        ],
      },
      {
        title: "Workflow B: Provisioning Fibers",
        userSteps: ["Once a valid path is built, the `FiberProvisioning` section appears.", "User selects a 'Working Fiber' and a 'Protection Fiber' from the dropdowns and clicks 'Save Changes'."],
        uiSteps: ["The dropdowns only show fibers that are continuously available across all segments of the logical path.", "After saving, the UI switches to a read-only view showing the provisioned fibers."],
        techSteps: [
          "The `useAvailableFibers` hook calls the `get_continuous_available_fibers` RPC, which finds common unallocated fiber numbers across all `ofc_connections` in the path.",
          "Saving calls the `provision_logical_path` RPC.",
          "This RPC creates two new `logical_fiber_paths` records (one for working, one for protection) and then updates the `logical_path_id` and `fiber_role` columns on all relevant `ofc_connections` records.",
          "This atomically allocates the fibers to the service.",
        ],
      },
    ],
  },
  {
    value: "auditing",
    icon: GitCommit,
    title: "Auditing System",
    subtitle: "Automatic change tracking & logging",
    gradient: "from-orange-500 to-red-600",
    iconColor: "text-orange-400",
    bgGlow: "bg-orange-500/10",
    color: "orange",
    purpose: "To automatically log all data modifications (INSERT, UPDATE, DELETE) for accountability and history tracking.",
    workflows: [
      {
        title: "Workflow: Automatic Data Change Logging",
        userSteps: ["An admin edits and saves an employee's profile."],
        uiSteps: ["The change is reflected in the UI as usual.", "An admin with permission can view the change log in the 'User Activity' section."],
        techSteps: [
          "The `UPDATE` operation on the `employees` table completes.",
          "An `AFTER UPDATE` trigger (`employees_log_trigger`) on the table fires automatically.",
          "The trigger executes the `log_data_changes()` function.",
          "This function captures the `OLD` and `NEW` row data, converts them to JSONB, and determines the operation type ('UPDATE').",
          "It then calls `log_user_activity()`, passing the captured data.",
          "The `log_user_activity()` function inserts a new record into the `user_activity_logs` table, including the current user's ID (`auth.uid()`) and role (`get_my_role()`).",
          "The entire process is atomic and happens within the same database transaction as the original update.",
        ],
      },
    ],
  },
];

```

<!-- path: components/doc/WorkflowSection.tsx -->
```typescript
import { Separator } from "@/components/common/ui/separator";
import StepList from "@/components/doc/StepList";
import { WorkflowSectionProps } from "@/components/doc/types/workflowTypes";
import { User, Monitor, Zap } from "lucide-react";

export default function WorkflowSection({ 
  workflow, 
  index, 
  colors, 
  isLast 
}: WorkflowSectionProps) {
  return (
    <div className="space-y-4">
      <div className="flex items-center gap-3">
        <div className={`px-3 py-1 rounded-full text-xs font-medium border ${colors.badge}`}>
          Workflow {String.fromCharCode(65 + index)}
        </div>
        <h3 className="text-lg font-semibold text-gray-100 flex-1">
          {workflow.title.replace(/^Workflow [A-Z]: /, '')}
        </h3>
      </div>

      <div className="space-y-4 pl-4 border-l-2 border-gray-800/50">
        {/* User Actions */}
        <StepList
          icon={User}
          iconColor="text-emerald-400"
          title="User Actions"
          steps={workflow.userSteps}
          stepColor="text-emerald-400"
        />

        {/* UI Response */}
        <StepList
          icon={Monitor}
          iconColor="text-blue-400"
          title="System Response (UI)"
          steps={workflow.uiSteps}
          stepColor="text-blue-400"
        />

        {/* Technical Flow */}
        <StepList
          icon={Zap}
          iconColor="text-amber-400"
          title="Technical Flow"
          steps={workflow.techSteps}
          stepColor="text-amber-400"
          isTechnical
        />
      </div>

      {!isLast && (
        <Separator className="bg-gradient-to-r from-transparent via-gray-800 to-transparent my-6" />
      )}
    </div>
  );
}
```

<!-- path: components/doc/BackgroundElements.tsx -->
```typescript
export default function BackgroundElements() {
    return (
      <div className="fixed inset-0 overflow-hidden pointer-events-none">
        <div className="absolute top-1/4 -left-48 w-96 h-96 bg-violet-500/10 rounded-full blur-3xl animate-pulse"></div>
        <div className="absolute bottom-1/4 -right-48 w-96 h-96 bg-cyan-500/10 rounded-full blur-3xl animate-pulse delay-1000"></div>
      </div>
    );
  }
```

<!-- path: components/doc/types/workflowTypes.ts -->
```typescript
import type { LucideIcon } from "lucide-react";
import type { IconType } from "react-icons";

export type WorkflowIcon = LucideIcon | IconType;

export interface WorkflowSection {
  value: string;
  icon: WorkflowIcon;
  title: string;
  subtitle: string;
  gradient: string;
  iconColor: string;
  bgGlow: string;
  color: "violet" | "blue" | "teal" | "cyan" | "orange" | "yellow";
  purpose: string;
  workflows: Workflow[];
}

export interface Workflow {
  title: string;
  userSteps: string[];
  uiSteps: string[];
  techSteps: string[];
}

export interface WorkflowCardProps {
  purpose: string;
  workflows: Workflow[];
  color: "violet" | "blue" | "teal" | "cyan" | "orange" | "yellow";
}

export interface WorkflowSectionProps {
  workflow: Workflow;
  index: number;
  colors: {
    border: string;
    glow: string;
    badge: string;
    icon: string;
  };
  isLast: boolean;
}
```

<!-- path: components/doc/WorkflowAccordion.tsx -->
```typescript
import {
    Accordion,
    AccordionContent,
    AccordionItem,
    AccordionTrigger,
  } from "@/components/common/ui/accordion";
import AccordionTriggerContent from "@/components/doc/AccordionTriggerContent";
import { WorkflowSection } from "@/components/doc/types/workflowTypes";
import WorkflowCard from "@/components/doc/WorkflowCard";

  
  interface WorkflowAccordionProps {
    sections: WorkflowSection[];
    open: string | undefined;
    onValueChange: (value: string | undefined) => void;
  }
  
  export default function WorkflowAccordion({ 
    sections, 
    open, 
    onValueChange 
  }: WorkflowAccordionProps) {
    return (
      <Accordion
        type="single"
        collapsible
        value={open}
        onValueChange={onValueChange}
        className="space-y-4"
      >
        {sections.map((section) => (
          <AccordionItem key={section.value} value={section.value} className="border-none">
            <AccordionTrigger className="hover:no-underline group">
              <AccordionTriggerContent 
                section={section}
                isOpen={open === section.value}
              />
            </AccordionTrigger>
            <AccordionContent>
              <WorkflowCard
                purpose={section.purpose}
                workflows={section.workflows}
                color={section.color}
              />
            </AccordionContent>
          </AccordionItem>
        ))}
      </Accordion>
    );
  }
```

<!-- path: components/dashboard/MenuButton.tsx -->
```typescript
"use client";
import { FiMenu } from "react-icons/fi";

interface MenuButtonProps {
  onClick: () => void;
}

export default function MenuButton({ onClick }: MenuButtonProps) {
  return (
    <button
      onClick={onClick}
      className="block md:hidden p-2 rounded-lg text-gray-700 dark:text-gray-200 hover:bg-gray-100 dark:hover:bg-gray-800 focus:outline-none focus:ring-2 focus:ring-blue-500"
      aria-label="Open sidebar menu"
      type="button"
    >
      <FiMenu className="h-6 w-6" />
    </button>
  );
}

```

<!-- path: components/dashboard/ColumnManagementProvider.tsx -->
```typescript
"use client";

import { createContext, useContext, useState, useEffect, useMemo, ReactNode } from "react";
import { toast } from "sonner";

interface ColumnOption {
  label: string;
  value: string;
}

interface ColumnManagementContextType {
  visibleColumns: string[];
  setVisibleColumns: (columns: string[]) => void;
  isDeleteVisible: boolean;
  setIsDeleteVisible: (visible: boolean) => void;
  columnOptions: ColumnOption[];
  toggleDelete: () => void;
  resetColumnsToDefault: () => void;
}

const ColumnManagementContext =
  createContext<ColumnManagementContextType | null>(null);

export function useColumnManagement() {
  const context = useContext(ColumnManagementContext);
  if (!context) {
    throw new Error(
      "useColumnManagement must be used within a ColumnManagementProvider"
    );
  }
  return context;
}

interface ColumnManagementProviderProps {
  children: ReactNode;
  data: ReactNode | ReactNode[] | Record<string, unknown>[] | null; // The data to generate column options from
  excludeColumns?: string[];
}

export default function ColumnManagementProvider({
  children,
  data,
  excludeColumns = ["password_hash", "internal_id"],
}: ColumnManagementProviderProps) {
  const [visibleColumns, setVisibleColumns] = useState<string[]>([]);
  const [isDeleteVisible, setIsDeleteVisible] = useState(false);

  // Generate column options from data
  const columnOptions = useMemo(() => {
    if (!data || (data as Record<string, unknown>[]).length === 0) return [];

    // Get keys from first item in data array
    const firstItem = data as Record<string, unknown>[];
    if (!firstItem || typeof firstItem !== "object") return [];

    const keys = Object.keys(firstItem);

    return keys
      .filter((key) => !excludeColumns.includes(key))
      .map((key) => ({
        label: key.replace(/_/g, " ").replace(/\b\w/g, (l) => l.toUpperCase()),
        value: key,
      }));
  }, [data, excludeColumns]);

  // Initialize visible columns when column options change
  useEffect(() => {
    if (columnOptions.length > 0 && visibleColumns.length === 0) {
      setVisibleColumns(columnOptions.map((col) => col.value));
    }
  }, [columnOptions, visibleColumns.length]);

  // Toggle delete visibility
  const toggleDelete = () => {
    setIsDeleteVisible((prev) => {
      const newState = !prev;
      toast.info(newState ? "Delete options shown" : "Delete options hidden");
      return newState;
    });
  };

  // Reset columns to default
  const resetColumnsToDefault = () => {
    if (columnOptions.length > 0) {
      setVisibleColumns(columnOptions.map((col) => col.value));
      toast.success("Columns reset to default");
    } else {
      toast.warning("No columns available to reset");
    }
  };

  const contextValue: ColumnManagementContextType = {
    visibleColumns,
    setVisibleColumns,
    isDeleteVisible,
    setIsDeleteVisible,
    columnOptions,
    toggleDelete,
    resetColumnsToDefault,
  };

  return (
    <ColumnManagementContext.Provider value={contextValue}>
      {children}
    </ColumnManagementContext.Provider>
  );
}

```

<!-- path: components/dashboard/DashboardHeader.tsx -->
```typescript
"use client";

import AuthButton from "@/components/auth/authButton";
import Link from "next/link";
import MenuButton from "./MenuButton";
import { useAuthStore } from "@/stores/authStore";
import Image from "next/image";
import ThemeToggle from "../common/ui/theme/ThemeToggle";

interface DashboardHeaderProps {
  onMenuClick: () => void;
  title?: string;
}

export default function DashboardHeader({
  onMenuClick,
  title = "Dashboard",
}: DashboardHeaderProps) {
  const user = useAuthStore((state) => state.user);

  return (
    <header className="sticky top-0 z-40 border-b border-gray-200 bg-white shadow-sm dark:border-gray-700 dark:bg-gray-800">
      <div className="mx-auto max-w-full px-4 sm:px-6 lg:px-8">
        <div className="flex h-16 items-center justify-between">
          <div className="flex items-center">
            {/* Mobile menu button */}
            <MenuButton onClick={onMenuClick} />
            <h1 className="hidden text-2xl font-bold text-gray-900 md:block dark:text-white">
              {title}
            </h1>
          </div>

          <div className="space-x-4 relative flex items-center">
            {user && (
              <div className="group">
                <Link
                  href="/onboarding"
                  className="flex items-center space-x-2 transition-colors hover:opacity-80"
                >
                  {user.user_metadata?.avatar_url ? (
                    <Image
                      src={user.user_metadata?.avatar_url}
                      alt="User Avatar"
                      className="h-8 w-8 rounded-full"
                      width={32}
                      height={32}
                    />
                  ) : (
                    <div className="flex h-8 w-8 items-center justify-center rounded-full bg-blue-500">
                      <span className="text-sm font-medium text-white">
                        {user.user_metadata?.first_name?.[0] || "U"}
                      </span>
                    </div>
                  )}
                  <span className="text-sm font-medium text-gray-700 dark:text-gray-300">
                    {user.user_metadata?.first_name || "User"}
                  </span>
                </Link>

                {/* Dropdown AuthButton - SIMPLIFIED and CORRECTED positioning */}
                <div
                  className="absolute top-full right-0 mt-2 opacity-0 invisible group-hover:opacity-100 group-hover:visible transition-all duration-200 z-50"
                >
                  <div
                    className="bg-white dark:bg-gray-800 rounded-lg shadow-lg border border-gray-200 dark:border-gray-700 p-2 w-auto min-w-64"
                  >
                    <AuthButton />
                  </div>
                </div>
              </div>
            )}
            <ThemeToggle />
          </div>
        </div>
      </div>
    </header>
  );
}
```

<!-- path: components/dashboard/DashboardContent.tsx -->
```typescript
import { ReactNode } from "react";
import ColumnManagementProvider from "./ColumnManagementProvider";
import DashboardHeader from "./DashboardHeader";
import Sidebar from "../navigation/sidebar";
import { usePathname } from "next/navigation";


interface DashboardContentProps {
  children: ReactNode | ReactNode[] | Record<string, unknown>[] | null;
  isCollapsed: boolean;
  setIsCollapsed: (collapsed: boolean) => void;
  isMobile: boolean;
  showColumnManagement: boolean;
}

function DashboardContent({
  children,
  isCollapsed,
  setIsCollapsed,
  isMobile,
  showColumnManagement,
}: DashboardContentProps) {
  // Get page route
  const pathname = usePathname();
  // Check if the current page is the dashboard
  const isDashboard = pathname === "/dashboard";

  return (
      <ColumnManagementProvider
        data={children as Record<string, unknown>[] | null}
      >
        {/* Sidebar */}
        <Sidebar 
          isCollapsed={isCollapsed} 
          setIsCollapsed={setIsCollapsed}
          showMenuFeatures={showColumnManagement}
        />

        {/* Main Content Area */}
        <div
          className={`transition-all duration-300 min-h-screen${
            isMobile ? "" : isCollapsed ? " ml-16" : " ml-64"
            // isMobile ? "" : isCollapsed ? " " : " "
          }`}
        >
          {/* Header */}
          <DashboardHeader onMenuClick={() => setIsCollapsed(false)} />

          {/* Main Content */}
          <main className={isDashboard ? "" : "p-4"} >
            <div className="mx-auto max-w-full">
              {children as ReactNode}
            </div>
          </main>
        </div>
      </ColumnManagementProvider>
  );
}

export default DashboardContent;

```

<!-- path: components/common/entity-management/EntityDetailsPanel.tsx -->
```typescript
import React from 'react';
import { FiEdit3, FiTrash2 } from 'react-icons/fi';
import { BaseEntity, EntityConfig } from '@/components/common/entity-management/types';
import { DetailItem } from '@/components/common/entity-management/DetailItem';

interface EntityDetailsPanelProps<T extends BaseEntity> {
  entity: T | null;
  config: EntityConfig<T>;
  onEdit: () => void;
  onDelete: (entity: { id: string; name: string }) => void;
}

export function EntityDetailsPanel<T extends BaseEntity>({
  entity,
  config,
  onEdit,
  onDelete,
}: EntityDetailsPanelProps<T>) {
  if (!entity) {
    const IconComponent = config.icon;
    return (
      <div className="p-8 text-center text-gray-500 dark:text-gray-400">
        <IconComponent className="mx-auto mb-3 h-12 w-12 text-gray-300 dark:text-gray-600" />
        <p>Select a {config.entityDisplayName.toLowerCase()} to view details</p>
      </div>
    );
  }

  return (
    <div className="p-4 space-y-4">
      <div className="mb-2 flex items-start justify-between">
        <h3 className="text-xl font-bold text-gray-900 dark:text-white">{entity.name}</h3>
        <span
          className={`rounded-full px-2 py-1 text-xs ${
            entity.status
              ? 'bg-green-100 dark:bg-green-900/30 text-green-800 dark:text-green-200'
              : 'bg-red-100 dark:bg-red-900/30 text-red-800 dark:text-red-200'
          }`}
        >
          {entity.status ? 'Active' : 'Inactive'}
        </span>
      </div>

      {config.detailFields.map((field) => (
        <DetailItem
          key={String(field.key)}
          label={field.label}
          value={entity[field.key]}
          type={field.type}
          entity={entity}
          render={field.render}
        />
      ))}

      <div className="border-t border-gray-200 dark:border-gray-700 pt-4">
        <div className="flex gap-2">
          <button
            onClick={onEdit}
            className="flex flex-1 items-center justify-center gap-2 rounded-lg bg-blue-600 px-4 py-2 text-white hover:bg-blue-700 dark:bg-blue-700 dark:hover:bg-blue-800"
          >
            <FiEdit3 className="h-4 w-4" /> Edit
          </button>
          <button
            onClick={() => onDelete({ id: entity.id, name: entity.name })}
            className="flex items-center justify-center gap-2 rounded-lg border border-red-300 dark:border-red-700 px-4 py-2 text-red-700 dark:text-red-400 hover:bg-red-50 dark:hover:bg-red-900/30"
          >
            <FiTrash2 className="h-4 w-4" /> Delete
          </button>
        </div>
      </div>
    </div>
  );
}

```

<!-- path: components/common/entity-management/EntityManagementComponent.tsx -->
```typescript
import type { UseQueryResult } from "@tanstack/react-query";
import { EntityDetailsPanel } from "@/components/common/entity-management/EntityDetailsPanel";
import { EntityListItem } from "@/components/common/entity-management/EntityListItem";
import { EntityTreeItem } from "@/components/common/entity-management/EntityTreeItem";
import { SearchAndFilters } from "@/components/common/entity-management/SearchAndFilters";
import { BaseEntity, EntityConfig } from "@/components/common/entity-management/types";
import { ViewModeToggle } from "@/components/common/entity-management/ViewModeToggle";
import { useEntityManagement } from "@/hooks/useEntityManagement";
import { FiInfo, FiPlus } from "react-icons/fi";
import { useCallback, useState } from "react";

type ToggleStatusVariables = {
  id: string;
  status: boolean;
  nameField?: keyof BaseEntity;
};

interface EntityManagementComponentProps<T extends BaseEntity> {
  config: EntityConfig<T>;
  entitiesQuery: UseQueryResult<T[], Error>;
  toggleStatusMutation: {
    mutate: (variables: ToggleStatusVariables) => void;
    isPending: boolean;
  };
  onEdit: (entity: T) => void;
  onDelete: (entity: { id: string; name: string }) => void;
  onCreateNew: () => void;
  selectedEntityId: string | null;
  onSelect: (id: string | null) => void;
}

export function EntityManagementComponent<T extends BaseEntity>({
  config,
  entitiesQuery,
  toggleStatusMutation,
  onEdit,
  onDelete,
  onCreateNew,
  selectedEntityId,
  onSelect,
}: EntityManagementComponentProps<T>) {
  const [searchTerm, setSearchTerm] = useState("");
  const [viewMode, setViewMode] = useState<"list" | "tree">("list");
  const [showFilters, setShowFilters] = useState(false);
  const [filters, setFilters] = useState<Record<string, string>>({});
  const [showDetailsPanel, setShowDetailsPanel] = useState(false);
  const [expandedEntities] = useState<Set<string>>(new Set());

  const handleToggleStatus = useCallback((e: React.MouseEvent, entity: T) => {
    e.stopPropagation();
    if (entity.status === null || entity.status === undefined) return;
    toggleStatusMutation.mutate({
      id: entity.id,
      status: !entity.status,
      nameField: 'status'
    });
  }, [toggleStatusMutation]);

  const handleCloseDetailsPanel = useCallback(() => {
    setShowDetailsPanel(false);
    onSelect(null);
  }, [onSelect]);

  // **THE FIX IS HERE:** Removed `handleOpenEditForm` from the destructuring
  const {
    filteredEntities,
    hierarchicalEntities,
    selectedEntity,
    handleEntitySelect,
    handleOpenCreateForm,
    toggleExpanded,
  } = useEntityManagement<T>({
    entitiesQuery,
    config: { ...config, isHierarchical: config.isHierarchical || false },
    onEdit,
    onDelete,
    onToggleStatus: handleToggleStatus,
    onCreateNew,
    selectedEntityId,
    onSelect,
  });
  
  const IconComponent = config.icon;
  
  const handleItemSelect = (id: string) => {
    handleEntitySelect(id);
    setShowDetailsPanel(true);
  };
  
  const handleOpenEditForm = useCallback(() => {
    if (selectedEntity) {
      onEdit(selectedEntity);
    }
  }, [selectedEntity, onEdit]);

  return (
    <div className="h-screen flex flex-col bg-gray-50 dark:bg-gray-900">
      <div className="bg-white dark:bg-gray-800 border-b border-gray-200 dark:border-gray-700 px-6 py-4">
        <div className="flex items-center justify-between">
          <div className="flex items-center space-x-3">
            <IconComponent className="h-6 w-6 text-gray-600 dark:text-gray-400" />
            <h1 className="text-2xl font-semibold text-gray-900 dark:text-white">
              {config.entityPluralName}
            </h1>
          </div>
          <button
            onClick={handleOpenCreateForm}
            className="inline-flex items-center px-4 py-2 text-sm font-medium text-white bg-blue-600 rounded-md hover:bg-blue-700 dark:bg-blue-700 dark:hover:bg-blue-800"
          >
            <FiPlus className="h-4 w-4 mr-2" />
            Add {config.entityDisplayName}
          </button>
        </div>
      </div>

      <div className="flex flex-col lg:flex-row lg:h-[calc(100vh-80px)]">
        <div className={`flex-1 flex flex-col ${showDetailsPanel ? "hidden lg:flex" : "flex"} lg:border-r lg:border-gray-200 lg:dark:border-gray-700`}>
          <div className="bg-white dark:bg-gray-800 border-b border-gray-200 dark:border-gray-700">
            <SearchAndFilters
              searchTerm={searchTerm}
              onSearchChange={setSearchTerm}
              showFilters={showFilters}
              onToggleFilters={() => setShowFilters(p => !p)}
              filters={filters}
              onFilterChange={setFilters}
              onClearFilters={() => setFilters({})}
              config={config}
            />
            {config.isHierarchical && <ViewModeToggle viewMode={viewMode} onChange={setViewMode} />}
          </div>

          <div className="flex-1 overflow-y-auto bg-white dark:bg-gray-800">
            {entitiesQuery.isLoading ? (
              <div className="flex items-center justify-center py-12 text-center">...Loading...</div>
            ) : entitiesQuery.isError ? (
              <div className="flex items-center justify-center py-12 text-center text-red-500">Error loading data.</div>
            ) : filteredEntities.length === 0 ? (
              <div className="flex items-center justify-center py-12 text-center">
                 <div>
                    <IconComponent className="h-12 w-12 text-gray-300 dark:text-gray-600 mx-auto mb-4" />
                    <p className="text-gray-500 dark:text-gray-400">No {config.entityPluralName.toLowerCase()} found.</p>
                    <button
                        onClick={handleOpenCreateForm}
                        className="mt-4 inline-flex items-center px-4 py-2 text-sm font-medium text-blue-600 bg-blue-50 rounded-md hover:bg-blue-100 dark:bg-blue-900/20 dark:text-blue-400 dark:hover:bg-blue-900/30"
                    >
                        <FiPlus className="h-4 w-4 mr-2" />
                        Add First {config.entityDisplayName}
                    </button>
                </div>
              </div>
            ) : config.isHierarchical && viewMode === "tree" ? (
              <div className="divide-y divide-gray-100 dark:divide-gray-700">
                {hierarchicalEntities.map((entity) => (
                  <EntityTreeItem
                    key={entity.id}
                    entity={entity}
                    config={config}
                    level={0}
                    selectedEntityId={selectedEntityId}
                    expandedEntities={expandedEntities}
                    onSelect={handleItemSelect}
                    onToggleExpand={(id) => toggleExpanded(id)}
                    onToggleStatus={(e) => handleToggleStatus(e, entity)}
                    isLoading={toggleStatusMutation.isPending}
                  />
                ))}
              </div>
            ) : (
              <div className="divide-y divide-gray-100 dark:divide-gray-700">
                {filteredEntities.map((entity) => (
                  <EntityListItem
                    key={entity.id}
                    entity={entity}
                    config={config}
                    isSelected={entity.id === selectedEntityId}
                    onSelect={() => handleItemSelect(entity.id)}
                    onToggleStatus={(e) => handleToggleStatus(e, entity)}
                    isLoading={toggleStatusMutation.isPending}
                  />
                ))}
              </div>
            )}
          </div>
        </div>

        <div className={`${showDetailsPanel ? "flex" : "hidden lg:flex"} flex-col w-full lg:w-96 xl:w-1/3 bg-white dark:bg-gray-800 border-t lg:border-t-0 border-gray-200 dark:border-gray-700`}>
          <div className="sticky top-0 z-10 bg-white dark:bg-gray-800 border-b border-gray-200 dark:border-gray-700 px-4 py-3 lg:hidden">
            <div className="flex items-center justify-between">
              <h2 className="text-lg font-medium text-gray-900 dark:text-white">Details</h2>
              <button onClick={handleCloseDetailsPanel} className="p-2 rounded-md text-gray-400">
                <svg className="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M6 18L18 6M6 6l12 12" /></svg>
              </button>
            </div>
          </div>
          <div className="hidden lg:block border-b border-gray-200 dark:border-gray-700 px-4 py-3">
            <h2 className="text-lg font-medium text-gray-900 dark:text-white">{config.entityDisplayName} Details</h2>
          </div>
          <div className="flex-1 overflow-y-auto">
            {selectedEntity ? (
              <EntityDetailsPanel 
                entity={selectedEntity} 
                config={config} 
                onEdit={handleOpenEditForm}
                onDelete={onDelete} 
              />
            ) : (
              <div className="flex items-center justify-center h-full p-8 text-center">
                <div>
                  <FiInfo className="h-12 w-12 text-gray-300 dark:text-gray-600 mx-auto mb-4" />
                  <p className="text-gray-500 dark:text-gray-400">Select a {config.entityDisplayName.toLowerCase()} to view details</p>
                </div>
              </div>
            )}
          </div>
        </div>
      </div>
    </div>
  );
}
```

<!-- path: components/common/entity-management/ViewModeToggle.tsx -->
```typescript
interface ViewModeToggleProps {
    viewMode: "tree" | "list";
    onChange: (mode: "tree" | "list") => void;
  }
  
  export function ViewModeToggle({ viewMode, onChange }: ViewModeToggleProps) {
    return (
      <div className="p-4 border-b border-gray-200 dark:border-gray-700">
        <div className="flex items-center gap-2">
          <button
            onClick={() => onChange("tree")}
            className={`px-3 py-2 rounded-lg text-sm font-medium ${
              viewMode === "tree"
                ? "bg-blue-100 text-blue-700 dark:bg-blue-900/30 dark:text-blue-300"
                : "text-gray-600 hover:bg-gray-100 dark:text-gray-400 dark:hover:bg-gray-700"
            }`}
          >
            Tree
          </button>
          <button
            onClick={() => onChange("list")}
            className={`px-3 py-2 rounded-lg text-sm font-medium ${
              viewMode === "list"
                ? "bg-blue-100 text-blue-700 dark:bg-blue-900/30 dark:text-blue-300"
                : "text-gray-600 hover:bg-gray-100 dark:text-gray-400 dark:hover:bg-gray-700"
            }`}
          >
            List
          </button>
        </div>
      </div>
    );
  }
```

<!-- path: components/common/entity-management/DetailItem.tsx -->
```typescript
import React from 'react';
import { BaseEntity } from '@/components/common/entity-management/types';

interface DetailItemProps<T extends BaseEntity> {
  label: string;
  value: T[keyof T] | unknown;
  type: 'text' | 'status' | 'parent' | 'date' | 'custom';
  entity: T;
  render?: (value: T[keyof T], entity: T) => React.ReactNode;
}

export function DetailItem<T extends BaseEntity>({
  label,
  value,
  type,
  entity,
  render,
}: DetailItemProps<T>) {
  if (!value && type !== 'status') return null;

  const renderValue = () => {
    if (render) {
      // We know value should be T[keyof T] when render is provided
      return render(value as T[keyof T], entity);
    }

    switch (type) {
      case 'status':
        return (
          <span
            className={`inline-flex rounded-full px-2 py-1 text-xs font-semibold ${
              value
                ? "bg-green-100 dark:bg-green-900/30 text-green-800 dark:text-green-200"
                : "bg-red-100 dark:bg-red-900/30 text-red-800 dark:text-red-200"
            }`}
          >
            {value ? "Active" : "Inactive"}
          </span>
        );
      case 'parent':
        return value && typeof value === 'object' && 'name' in value
          ? String(value.name)
          : 'No parent';
      case 'date':
        if (value && (typeof value === 'string' || typeof value === 'number' || value instanceof Date)) {
          return new Date(value).toLocaleDateString();
        }
        return 'N/A';
      case 'text':
      default:
        return String(value);
    }
  };

  return (
    <div className="py-2">
      <dt className="text-sm font-medium text-gray-500 dark:text-gray-400">{label}</dt>
      <dd className="mt-1 text-sm text-gray-900 dark:text-gray-100">{renderValue()}</dd>
    </div>
  );
}
```

<!-- path: components/common/entity-management/types.ts -->
```typescript
// components/common/entity-management/types.ts
import { UseQueryResult } from '@tanstack/react-query';

export interface BaseEntity {
  id: string;
  name: string;
  status: boolean | null;
  created_at?: string | null;
  updated_at?: string | null;
}

export interface HierarchicalEntity extends BaseEntity {
  parent_id?: string | null;
  parent?: HierarchicalEntity | null;
}

// Utility type for entities with computed children
export type EntityWithChildren<T extends BaseEntity> = T & {
  children: EntityWithChildren<T>[];
};

// Type guard functions
export function isHierarchicalEntity<T extends BaseEntity>(
  entity: T
): entity is T & HierarchicalEntity {
  return 'parent_id' in entity || 'parent' in entity;
}

export interface EntityConfig<T extends BaseEntity> {
  entityName: string;
  entityDisplayName: string;
  entityPluralName: string;
  parentField?: keyof T;
  icon: React.ComponentType<{ className?: string }>;
  isHierarchical: boolean;
  searchFields: (keyof T)[];
  detailFields: Array<{
    key: keyof T;
    label: string;
    type: 'text' | 'status' | 'parent' | 'date' | 'custom';
    render?: (value: T[keyof T], entity: T) => React.ReactNode;
  }>;
  filterOptions: Array<{
    key: string;
    label: string;
    type: 'select' | 'text' | 'date';
    options?: Array<{ value: string; label: string }>;
  }>;
}

// ** Update the hook's props interface**
export interface UseEntityManagementProps<T extends BaseEntity> {
  entitiesQuery: UseQueryResult<T[], Error>;
  config: EntityConfig<T>;
  onDelete: (entity: { id: string; name: string }) => void;
  onToggleStatus: (e: React.MouseEvent, entity: T) => void;
  onCreateNew: () => void;
  // Add the new props to make it a controlled component
  selectedEntityId: string | null;
  onSelect: (id: string | null) => void;
}

// Updated component interfaces
export interface EntityTreeItemProps<T extends BaseEntity> {
    entity: EntityWithChildren<T>;
    config: EntityConfig<T>;
    level: number;
    selectedEntityId: string | null;
    expandedEntities: Set<string>;
    onSelect: (id: string) => void;
    onToggleExpand: (id: string) => void;
    onToggleStatus: (e: React.MouseEvent, entity: T) => void;
    isLoading: boolean;
  }
```

<!-- path: components/common/entity-management/EntityTreeItem.tsx -->
```typescript
import { BaseEntity, EntityTreeItemProps } from "@/components/common/entity-management/types";
import { FiChevronDown, FiChevronRight, FiToggleLeft, FiToggleRight } from "react-icons/fi";

export function EntityTreeItem<T extends BaseEntity>({
    entity,
    config,
    level,
    selectedEntityId,
    expandedEntities,
    onSelect,
    onToggleExpand,
    onToggleStatus,
    isLoading,
  }: EntityTreeItemProps<T>) {
    const IconComponent = config.icon;
    const hasChildren = entity.children.length > 0;
    const isSelected = entity.id === selectedEntityId;
    const isExpanded = expandedEntities.has(entity.id);
  
    return (
      <div className="border-b border-gray-100 dark:border-gray-700 last:border-b-0">
        <div
          className={`flex cursor-pointer items-center p-4 hover:bg-gray-50 dark:hover:bg-gray-800 ${
            isSelected
              ? "border-l-4 border-l-blue-500 bg-blue-50 dark:bg-gray-800"
              : "border-l-4 border-l-transparent"
          }`}
          style={{ paddingLeft: `${16 + level * 24}px` }}
          onClick={() => onSelect(entity.id)}
        >
          <div className="flex flex-1 items-center gap-2 truncate">
            {hasChildren ? (
              <button
                onClick={(e) => {
                  e.stopPropagation();
                  onToggleExpand(entity.id);
                }}
                className="rounded p-1 hover:bg-gray-200 dark:hover:bg-gray-700"
              >
                {isExpanded ? (
                  <FiChevronDown className="h-4 w-4 text-gray-400 dark:text-gray-500" />
                ) : (
                  <FiChevronRight className="h-4 w-4 text-gray-400 dark:text-gray-500" />
                )}
              </button>
            ) : (
              <div className="w-6" />
            )}
            <IconComponent className="h-5 w-5 flex-shrink-0 text-gray-400 dark:text-gray-500" />
            <div className="flex-1 truncate">
              <h3 className="font-medium text-gray-900 dark:text-gray-100 truncate">{entity.name}</h3>
            </div>
          </div>
          <button
            onClick={(e) => onToggleStatus(e, entity)}
            disabled={isLoading}
            className="ml-auto"
          >
            {entity.status ? (
              <FiToggleRight className="h-5 w-5 text-green-500 dark:text-green-400" />
            ) : (
              <FiToggleLeft className="h-5 w-5 text-gray-400 dark:text-gray-500" />
            )}
          </button>
        </div>
        {isExpanded && hasChildren && (
          <div>
            {entity.children.map((child) => (
              <EntityTreeItem
                key={child.id}
                entity={child}
                config={config}
                level={level + 1}
                selectedEntityId={selectedEntityId}
                expandedEntities={expandedEntities}
                onSelect={onSelect}
                onToggleExpand={onToggleExpand}
                onToggleStatus={onToggleStatus}
                isLoading={isLoading}
              />
            ))}
          </div>
        )}
      </div>
    );
  }
  
```

<!-- path: components/common/entity-management/SearchAndFilters.tsx -->
```typescript
import { MdFilterList as Filter, MdSearch as Search, MdClear as Clear } from 'react-icons/md';
import { BaseEntity, EntityConfig } from '@/components/common/entity-management/types';

interface SearchAndFiltersProps<T extends BaseEntity> {
  searchTerm: string;
  onSearchChange: (term: string) => void;
  showFilters: boolean;
  onToggleFilters: () => void;
  filters: Record<string, string>;
  onFilterChange: (filters: Record<string, string>) => void;
  onClearFilters: () => void;
  config: EntityConfig<T>;
}

export function SearchAndFilters<T extends BaseEntity>({
  searchTerm,
  onSearchChange,
  showFilters,
  onToggleFilters,
  filters,
  onFilterChange,
  onClearFilters,
  config,
}: SearchAndFiltersProps<T>) {
  return (
    <div className="border-b border-gray-200 dark:border-gray-700 p-4">
      <div className="mb-4 flex items-center gap-4">
        <div className="relative flex-1">
          <Search className="absolute top-1/2 left-3 h-4 w-4 -translate-y-1/2 transform text-gray-400 dark:text-gray-500" />
          <input
            type="text"
            placeholder={`Search ${config.entityPluralName.toLowerCase()}...`}
            value={searchTerm}
            onChange={(e) => onSearchChange(e.target.value)}
            className="w-full rounded-lg border border-gray-300 dark:border-gray-600 dark:bg-gray-700 dark:text-white py-2 pr-4 pl-10 focus:border-transparent focus:ring-2 focus:ring-blue-500 dark:focus:ring-blue-600"
          />
          {searchTerm && (
            <button
              onClick={() => onSearchChange("")}
              className="absolute right-3 top-1/2 -translate-y-1/2 text-gray-400 hover:text-gray-600"
            >
              <Clear className="h-4 w-4" />
            </button>
          )}
        </div>
        <button
          onClick={onToggleFilters}
          className="flex items-center gap-2 rounded-lg border border-gray-300 dark:border-gray-600 px-3 py-2 hover:bg-gray-50 dark:hover:bg-gray-700"
        >
          <Filter className="h-4 w-4" />
          Filters
        </button>
      </div>
      {showFilters && (
        <div className="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 gap-4 rounded-lg bg-gray-50 dark:bg-gray-700 p-4">
          {config.filterOptions.map((filterOption) => (
            <div key={filterOption.key}>
              <label className="mb-1 block text-sm font-medium text-gray-700 dark:text-gray-300">
                {filterOption.label}
              </label>
              {filterOption.type === 'select' ? (
                <select
                  value={filters[filterOption.key] || ''}
                  onChange={(e) => onFilterChange({ ...filters, [filterOption.key]: e.target.value })}
                  className="w-full rounded-lg border border-gray-300 px-3 py-2 focus:ring-2 focus:ring-blue-500 dark:border-gray-600 dark:bg-gray-700 dark:text-white dark:focus:ring-blue-600"
                >
                  {filterOption.options?.map((option) => (
                    <option key={option.value} value={option.value}>
                      {option.label}
                    </option>
                  ))}
                </select>
              ) : filterOption.type === 'text' ? (
                <input
                  type="text"
                  value={filters[filterOption.key] || ''}
                  onChange={(e) => onFilterChange({ ...filters, [filterOption.key]: e.target.value })}
                  className="w-full rounded-lg border border-gray-300 px-3 py-2 focus:ring-2 focus:ring-blue-500 dark:border-gray-600 dark:bg-gray-700 dark:text-white dark:focus:ring-blue-600"
                />
              ) : filterOption.type === 'date' ? (
                <input
                  type="date"
                  value={filters[filterOption.key] || ''}
                  onChange={(e) => onFilterChange({ ...filters, [filterOption.key]: e.target.value })}
                  className="w-full rounded-lg border border-gray-300 px-3 py-2 focus:ring-2 focus:ring-blue-500 dark:border-gray-600 dark:bg-gray-700 dark:text-white dark:focus:ring-blue-600"
                />
              ) : null}
            </div>
          ))}
          <div className="flex items-end">
            <button
              onClick={onClearFilters}
              className="px-4 py-2 text-gray-600 dark:text-gray-400 hover:text-gray-800 dark:hover:text-gray-200"
            >
              Clear Filters
            </button>
          </div>
        </div>
      )}
    </div>
  );
}
```

<!-- path: components/common/entity-management/EntityListItem.tsx -->
```typescript
import React from 'react';
import { BiToggleLeft, BiToggleRight } from 'react-icons/bi';
import { BaseEntity, EntityConfig, HierarchicalEntity, isHierarchicalEntity } from '@/components/common/entity-management/types';

interface EntityListItemProps<T extends BaseEntity> {
  entity: T;
  config: EntityConfig<T>;
  isSelected: boolean;
  onSelect: (id: string) => void;
  onToggleStatus: (e: React.MouseEvent, entity: T) => void;
  isLoading: boolean;
}

export function EntityListItem<T extends BaseEntity>({
  entity,
  config,
  isSelected,
  onSelect,
  onToggleStatus,
  isLoading,
}: EntityListItemProps<T>) {
  const IconComponent = config.icon;

  // Function to get parent name using the configured parent field
  const getParentName = (entity: T): string | null => {
    if (!config.isHierarchical || !config.parentField) return null;
    
    const parentObject = entity[config.parentField] as HierarchicalEntity;
    if (parentObject?.name) {
      return parentObject.name;
    }
    
    return null;
  };

  const parentName = getParentName(entity);

  return (
    <div
      className={`cursor-pointer border-b border-gray-100 dark:border-gray-700 p-4 hover:bg-gray-50 dark:hover:bg-gray-800 ${
        isSelected
          ? "border-l-4 border-l-blue-500 bg-blue-50 dark:bg-gray-800"
          : "border-l-4 border-l-transparent"
      }`}
      onClick={() => onSelect(entity.id)}
    >
      <div className="flex items-center justify-between">
        <div className="flex-1">
          <div className="mb-2 flex items-center gap-2">
            <IconComponent className="h-5 w-5 text-gray-400 dark:text-gray-500" />
            <h3 className="font-medium text-gray-900 dark:text-gray-100">{entity.name}</h3>
          </div>
          {config.isHierarchical && isHierarchicalEntity(entity) && parentName && (
            <span className="text-xs bg-blue-100 dark:bg-blue-900/30 text-blue-800 dark:text-blue-200 px-2 py-1 rounded">
              Child of: {parentName}
            </span>
          )}
        </div>
        <button
          onClick={(e) => {
            // IMPROVEMENT: Stop the click from bubbling up to the parent div.
            e.stopPropagation(); 
            onToggleStatus(e, entity);
          }}
          disabled={isLoading}
          className="ml-2"
        >
          {entity.status ? (
            <BiToggleRight className="h-5 w-5 text-green-500 dark:text-green-400" />
          ) : (
            <BiToggleLeft className="h-5 w-5 text-gray-400 dark:text-gray-500" />
          )}
        </button>
      </div>
    </div>
  );
}
```

<!-- path: components/common/page-header/PageHeader.tsx -->
```typescript
'use client';

import React, { ReactNode } from 'react';
import { Button } from '@/components/common/ui/Button/Button';
import { cn } from '@/lib/utils';
import { CardSkeleton } from '@/components/common/ui/table/TableSkeleton';
import { StatCard, StatProps } from '@/components/common/page-header/StatCard';
import {
  ActionButton,
  DropdownButton,
} from '@/components/common/page-header/DropdownButton';

// --- TYPE DEFINITIONS ---

export interface PageHeaderProps {
  title: string;
  description?: string;
  icon?: ReactNode;
  stats?: StatProps[];
  actions?: ActionButton[];
  isLoading?: boolean;
  className?: string;
}

// --- SUB-COMPONENTS ---

// --- MAIN COMPONENT ---

export function PageHeader({
  title,
  description,
  icon,
  stats,
  actions = [],
  isLoading = false,
  className,
}: PageHeaderProps) {
  return (
    <>
      {isLoading ? (
        <CardSkeleton />
      ) : (
        <div
          className={cn(
            'space-y-4 sm:space-y-6',
            isLoading && 'opacity-50',
            className
          )}
        >
          {/* Header Section */}
          <div className="flex flex-col space-y-4 lg:space-y-0 lg:flex-row lg:items-start lg:justify-between">
            <div className="flex-1 space-y-2 sm:space-y-3 min-w-0">
              <div className="flex flex-col space-y-2 sm:space-y-0 sm:flex-row sm:items-center sm:gap-3">
                {icon && (
                  <div className="text-2xl sm:text-3xl text-blue-600 dark:text-blue-400">
                    {icon}
                  </div>
                )}
                <h1 className="text-2xl sm:text-3xl font-bold text-gray-900 dark:text-white leading-tight">
                  {title}
                </h1>
              </div>
              {description && (
                <p className="text-gray-600 dark:text-gray-400 text-base sm:text-lg leading-relaxed">
                  {description}
                </p>
              )}
            </div>

            {/* Desktop Action Buttons */}
            <div className="hidden lg:flex items-center gap-2 flex-shrink-0 ml-4">
              {actions.map((action, index) =>
                action['data-dropdown'] ? (
                  <div key={`desktop-dropdown-${index}`} data-dropdown="true">
                    <DropdownButton
                      {...action}
                      disabled={action.disabled || isLoading}
                    />
                  </div>
                ) : (
                  <Button
                    key={`desktop-action-${index}`}
                    {...action}
                    disabled={action.disabled || isLoading}
                  >
                    {action.label}
                  </Button>
                )
              )}
            </div>
          </div>

          {/* Stats and Mobile Actions Row */}
          <div className="flex flex-col space-y-4 sm:space-y-0 sm:flex-row sm:items-center sm:justify-between sm:gap-4">
            {/* Stats Grid */}
            <div className="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-4 gap-4 flex-grow">
              {isLoading
                ? Array.from({ length: stats?.length || 2 }).map((_, i) => (
                    <div
                      key={`stat-skeleton-${i}`}
                      className="rounded-lg border border-gray-200 bg-white p-4 dark:border-gray-700 dark:bg-gray-900 animate-pulse"
                    >
                      <div className="h-8 w-1/2 rounded-md bg-gray-200 dark:bg-gray-700 mb-2"></div>
                      <div className="h-4 w-3/4 rounded-md bg-gray-200 dark:bg-gray-700"></div>
                    </div>
                  ))
                : stats?.map((stat) => <StatCard key={stat.label} {...stat} />)}
            </div>

            {/* Mobile/Tablet Action Buttons */}
            <div className="flex lg:hidden items-center gap-2 w-full sm:w-auto sm:flex-shrink-0">
              {actions.map((action, index) =>
                action['data-dropdown'] ? (
                  <DropdownButton
                    key={`mobile-dropdown-${index}`}
                    {...action}
                    className={`flex-1 sm:flex-none ${
                      action.hideOnMobile ? 'hidden sm:flex' : ''
                    }`}
                    disabled={action.disabled || isLoading}
                  />
                ) : (
                  <Button
                    key={`mobile-action-${index}`}
                    {...action}
                    className={`flex-1 sm:flex-none ${
                      action.hideOnMobile ? 'hidden sm:flex' : ''
                    }`}
                    disabled={action.disabled || isLoading}
                  >
                    {action.hideTextOnMobile ? '' : action.label}
                  </Button>
                )
              )}
            </div>
          </div>
        </div>
      )}
    </>
  );
}

// --- HOOK FOR CREATING STANDARD ACTIONS ---

```

<!-- path: components/common/page-header/hooks/useStandardHeaderActions.tsx -->
```typescript
'use client';

import { useCallback } from 'react';
import { toast } from 'sonner';
import { createClient } from '@/utils/supabase/client';
import { useTableExcelDownload } from '@/hooks/database/excel-queries';
import { formatDate } from '@/utils/formatters';
import { useDynamicColumnConfig } from '@/hooks/useColumnConfig';

import { ActionButton } from '@/components/common/page-header/DropdownButton';
import { Filters, Row, TableOrViewName } from '@/hooks/database';
import { useMemo } from 'react';
import { FiDownload, FiPlus, FiRefreshCw } from 'react-icons/fi';

interface ExportFilterOption {
  label: string;
  filters?: Filters;
  fileName?: string;
}

interface ExportConfig<T extends TableOrViewName> {
  tableName: T;
  maxRows?: number;
  columns?: (keyof Row<T> & string)[]; // Allow specifying a subset of columns for export
  filterOptions?: ExportFilterOption[]; // New: array of filter options
  // Deprecated: keeping for backward compatibility
  filters?: Filters;
  fileName?: string;
}

interface StandardActionsConfig<T extends TableOrViewName> {
  onRefresh?: () => void;
  onAddNew?: () => void;
  exportConfig?: ExportConfig<T>;
  isLoading?: boolean;
  data?: Row<T>[];
}

export function useStandardHeaderActions<T extends TableOrViewName>({
  onRefresh,
  onAddNew,
  exportConfig,
  isLoading,
  data,
}: StandardActionsConfig<T>): ActionButton[] {
  const supabase = useMemo(() => createClient(), []);
  const columns = useDynamicColumnConfig(exportConfig?.tableName as T, {
    data: data,
  });

  const tableExcelDownload = useTableExcelDownload(
    supabase,
    exportConfig?.tableName as T,
    {
      onSuccess: () => toast.success('Export successful!'),
      onError: (err) => toast.error(`Export failed: ${err.message}`),
    }
  );

  const handleExport = useCallback(
    (filterOption?: ExportFilterOption) => {
      if (!exportConfig?.tableName) {
        toast.error('Export failed: Table name not configured.');
        return;
      }

      // Use filterOption filters if provided, otherwise fall back to exportConfig filters
      const filters = filterOption?.filters || exportConfig.filters;

      // Determine the file and sheet name
      let fileName: string;
      let sheetName: string;

      if (filterOption) {
        // If it's a filter option, use custom fileName or append label to table name
        if (filterOption.fileName) {
          fileName = filterOption.fileName;
          sheetName = filterOption.fileName;
        } else {
          // Append filter label to table name
          fileName = `${exportConfig.tableName}-${filterOption.label
            .toLowerCase()
            .replace(/\s+/g, '-')}`;
          sheetName = `${exportConfig.tableName}-${filterOption.label}`;
        }
      } else {
        // No filter option - use default table name or custom fileName
        fileName = exportConfig.fileName || exportConfig.tableName;
        sheetName = exportConfig.fileName || exportConfig.tableName;
      }

      tableExcelDownload.mutate({
        fileName: `${formatDate(new Date(), {
          format: 'dd-mm-yyyy',
        })}-${fileName}.xlsx`,
        sheetName: sheetName,
        filters: filters,
        columns: columns.filter((c) =>
          exportConfig.columns
            ? exportConfig.columns.includes(c.key as keyof Row<T> & string)
            : true
        ),
        maxRows: exportConfig.maxRows,
      });
    },
    [exportConfig, columns, tableExcelDownload]
  );

  return useMemo(() => {
    const actions: ActionButton[] = [];

    if (onRefresh) {
      actions.push({
        label: 'Refresh',
        onClick: onRefresh,
        variant: 'outline',
        leftIcon: <FiRefreshCw className={isLoading ? 'animate-spin' : ''} />,
        disabled: isLoading,
      });
    }

    if (exportConfig) {
      // Check if we have multiple filter options
      if (exportConfig.filterOptions && exportConfig.filterOptions.length > 0) {
        // Create dropdown with filter options
        const dropdownoptions = [
          {
            label: 'Export All (No Filters)',
            onClick: () =>
              handleExport({
                label: 'All',
                filters: undefined,
                fileName: undefined,
              }),
            disabled: tableExcelDownload.isPending,
          },
        ];
        exportConfig.filterOptions.forEach((option) => {
          dropdownoptions.push({
            label: `Export ${option.label}`,
            onClick: () => handleExport(option),
            disabled: tableExcelDownload.isPending,
          });
        });

        actions.push({
          label: 'Export',
          variant: 'outline',
          leftIcon: <FiDownload />,
          disabled: tableExcelDownload.isPending,
          'data-dropdown': true,
          dropdownoptions,
        });
      } else {
        // Single export button (backward compatibility)
        actions.push({
          label: tableExcelDownload.isPending ? 'Exporting...' : 'Export',
          onClick: () => handleExport(),
          variant: 'outline',
          leftIcon: <FiDownload />,
          disabled: isLoading || tableExcelDownload.isPending,
        });
      }
    }

    if (onAddNew) {
      actions.push({
        label: 'Add New',
        onClick: onAddNew,
        variant: 'primary',
        leftIcon: <FiPlus />,
        disabled: isLoading,
      });
    }

    return actions;
  }, [
    onRefresh,
    onAddNew,
    exportConfig,
    isLoading,
    handleExport,
    tableExcelDownload.isPending,
  ]);
}

```

<!-- path: components/common/page-header/DropdownButton.tsx -->
```typescript
'use client';
import { Button } from '@/components/common/ui';
import { FiChevronDown } from 'react-icons/fi';
import { cn } from '@/lib/utils';

import { ButtonProps } from '@/components/common/ui/Button/Button';
import { useState } from 'react';

export interface ActionButton extends Omit<ButtonProps, 'is_dropdown'> {
  label: string;
  hideOnMobile?: boolean;
  hideTextOnMobile?: boolean;
  priority?: 'high' | 'medium' | 'low'; // For mobile button ordering
  'data-dropdown'?: boolean; // Using data attribute instead of custom prop
  dropdownoptions?: Array<{
    label: string;
    onClick: () => void;
    disabled?: boolean;
  }>;
}

export const DropdownButton: React.FC<ActionButton> = ({
  label,
  dropdownoptions = [],
  disabled,
  variant = 'outline',
  leftIcon,
  className,
  ...props
}) => {
  const [isOpen, setIsOpen] = useState(false);

  return (
    <div className="relative" style={{ zIndex: 50 }}>
      <Button
        {...props}
        variant={variant}
        disabled={disabled}
        onClick={() => {
          setIsOpen(!isOpen);
        }}
        className={cn('flex items-center gap-2', className)}
        leftIcon={leftIcon}
        rightIcon={
          <FiChevronDown
            className={`transition-transform ${isOpen ? 'rotate-180' : ''}`}
          />
        }
      >
        {label}
      </Button>

      {isOpen && (
        <>
          {/* Backdrop */}
          <div
            className="fixed inset-0 z-40 bg-black/20 dark:bg-black/40"
            onClick={() => {
              setIsOpen(false);
            }}
            style={{
              position: 'fixed',
              inset: 0,
              zIndex: 40,
            }}
          />
          {/* Dropdown Menu */}
          <div className="absolute right-0 top-full z-50 mt-1 min-w-[200px] rounded-md border-2 border-gray-200 bg-white py-1 shadow-lg dark:border-gray-700 dark:bg-gray-800">
            {dropdownoptions.map((option, index) => (
              <button
                key={index}
                onClick={() => {
                  option.onClick();
                  setIsOpen(false);
                }}
                disabled={option.disabled}
                className="block w-full px-4 py-2 text-left text-sm text-gray-700 hover:bg-gray-100 disabled:cursor-not-allowed disabled:opacity-50 dark:text-gray-300 dark:hover:bg-gray-700"
              >
                {option.label}
              </button>
            ))}
          </div>
        </>
      )}
    </div>
  );
};

```

<!-- path: components/common/page-header/StatCard.tsx -->
```typescript
import { cn } from '@/lib/utils';
import { ReactNode } from 'react';

export interface StatProps {
  value: string | number;
  label: string;
  icon?: ReactNode;
  color?: 'primary' | 'success' | 'warning' | 'danger' | 'default';
}

export const StatCard: React.FC<StatProps> = ({
  value,
  label,
  icon,
  color = 'default',
}) => {
  const statColors = {
    primary: 'text-blue-600 dark:text-blue-400',
    success: 'text-green-600 dark:text-green-400',
    warning: 'text-yellow-600 dark:text-yellow-400',
    danger: 'text-red-600 dark:text-red-400',
    default: 'text-gray-900 dark:text-white',
  };

  const borderColors = {
    primary: 'border-blue-200 dark:border-blue-700',
    success: 'border-green-200 dark:border-green-700',
    warning: 'border-yellow-200 dark:border-yellow-700',
    danger: 'border-red-200 dark:border-red-700',
    default: 'border-gray-200 dark:border-gray-700',
  };

  const bgColors = {
    primary: 'bg-blue-50 dark:bg-blue-900/20',
    success: 'bg-green-50 dark:bg-green-900/20',
    warning: 'bg-yellow-50 dark:bg-yellow-900/20',
    danger: 'bg-red-50 dark:bg-red-900/20',
    default: 'bg-white dark:bg-gray-900',
  };

  return (
    <div
      className={cn(
        'rounded-lg border p-4 flex items-start gap-4',
        borderColors[color],
        bgColors[color]
      )}
    >
      {icon && (
        <div className={`flex-shrink-0 text-2xl ${statColors[color]}`}>
          {icon}
        </div>
      )}
      <div>
        <div className={`text-2xl font-bold ${statColors[color]}`}>{value}</div>
        <div className="text-sm text-gray-600 dark:text-gray-400">{label}</div>
      </div>
    </div>
  );
};

```

<!-- path: components/common/page-header/index.ts -->
```typescript
export * from './DropdownButton';
export * from './PageHeader';
export * from './StatCard';
export * from './hooks/useStandardHeaderActions';

```

<!-- path: components/common/DataListView.tsx -->
```typescript
import React, { useState } from 'react';
import { 
  FiSearch, 
  FiFilter, 
  FiGrid, 
  FiList, 
  FiInfo, 
  FiPlus, 
  FiX,
  FiAlertCircle 
} from 'react-icons/fi';
interface DataItem {
    id: string | number;  // Adjust the type based on your actual ID type
    name: string;
    description?: string;
    status?: boolean;
    title?: string;
    // Add other properties that your data items have
  }
interface DataListViewProps {
    data: DataItem[];
    isLoading: boolean;
    error: unknown;
    searchTerm: string;
    onSearchChange: (value: string) => void;
    searchPlaceholder: string;
    showFilters: boolean;
    onToggleFilters: () => void;
    filters: unknown;
    onFilterChange: (newFilters: unknown) => void;
    onClearFilters: () => void;
    viewMode: string;
    onViewModeChange: (mode: string) => void;
    showViewModeToggle: boolean;
    selectedItemId: string | null;
    showDetailsPanel: boolean;
    setShowDetailsPanel: (value: boolean) => void;
    detailsTitle: string;
    onCreateNew: () => void;
    createButtonText: string;
    createButtonIcon: React.ReactNode;
    onItemSelect: (item: DataItem) => void;
    renderListItem: (item: DataItem, isSelected: boolean, onSelect: () => void) => React.ReactNode;
    renderGridItem: (item: DataItem, isSelected: boolean, onSelect: () => void) => React.ReactNode;
    renderTreeItem: (item: DataItem, level: number, isSelected: boolean, isExpanded: boolean, onSelect: () => void, onToggleExpand: () => void) => React.ReactNode;
    renderDetailsPanel: (selectedItem: DataItem) => React.ReactNode;
    renderFilters: (filters: unknown, onFilterChange: (newFilters: unknown) => void, onClearFilters: () => void) => React.ReactNode;
    emptyStateIcon: React.ComponentType<{ className?: string }>;
    createIcon: React.ComponentType<{ className?: string }>;
    emptyStateTitle: string;
    emptyStateDescription: string;
    showCreateOnEmpty: boolean;
    loadingText: string;
    errorTitle: string;
    className: string;
    listClassName: string;
    detailsClassName: string;
}

/**
 * A reusable data list view component with search, filters, and details panel
 * @param {Object} props - Component props
 */
const DataListView = (props: DataListViewProps) => {
  // Destructure props with defaults
  const {
    data = [],
    isLoading = false,
    error = null,
    searchTerm = '',
    onSearchChange,
    searchPlaceholder = 'Search...',
    showFilters = false,
    onToggleFilters,
    filters = {},
    onFilterChange,
    onClearFilters,
    viewMode = 'list',
    onViewModeChange,
    showViewModeToggle = true,
    selectedItemId = null,
    onItemSelect,
    showDetailsPanel = false,
    setShowDetailsPanel,
    detailsTitle = 'Details',
    onCreateNew,
    createButtonText = 'Add New',
    renderListItem,
    renderTreeItem,
    renderGridItem,
    renderDetailsPanel,
    renderFilters,
    emptyStateIcon = FiInfo,
    emptyStateTitle = 'No items found',
    emptyStateDescription = 'No items match your criteria.',
    showCreateOnEmpty = true,
    loadingText = 'Loading...',
    errorTitle = 'Error loading data',
    className = '',
    listClassName = '',
    detailsClassName = '',
  } = props;

  const [internalShowDetailsPanel, setInternalShowDetailsPanel] = useState(false);
  
  // Use external state if provided, otherwise use internal state
  const detailsPanelVisible = showDetailsPanel !== undefined ? showDetailsPanel : internalShowDetailsPanel;
  const setDetailsPanelVisible = setShowDetailsPanel || setInternalShowDetailsPanel;

  const selectedItem = data.find((item) => (item as unknown as { id: string }).id === selectedItemId);

  const handleItemSelect = (item: DataItem) => {
    if (onItemSelect) {
      onItemSelect(item);
    }
    // Auto-show details panel on mobile when item is selected
    if (window.innerWidth < 1024) {
      setDetailsPanelVisible(true);
    }
  };

  const ViewModeToggle = () => {
    if (!showViewModeToggle) return null;
    
    return (
      <div className="flex items-center space-x-1 px-4 py-2 border-t border-gray-200 dark:border-gray-700">
        <button
          onClick={() => onViewModeChange && onViewModeChange('list')}
          className={`p-2 rounded-md ${
            viewMode === 'list'
              ? 'bg-blue-100 text-blue-600 dark:bg-blue-900/20 dark:text-blue-400'
              : 'text-gray-400 hover:text-gray-600 dark:hover:text-gray-300'
          }`}
        >
          <FiList className="h-4 w-4" />
        </button>
        <button
          onClick={() => onViewModeChange && onViewModeChange('grid')}
          className={`p-2 rounded-md ${
            viewMode === 'grid'
              ? 'bg-blue-100 text-blue-600 dark:bg-blue-900/20 dark:text-blue-400'
              : 'text-gray-400 hover:text-gray-600 dark:hover:text-gray-300'
          }`}
        >
          <FiGrid className="h-4 w-4" />
        </button>
      </div>
    );
  };

  const SearchAndFiltersSection = () => (
    <div className="bg-white dark:bg-gray-800 border-b border-gray-200 dark:border-gray-700">
      <div className="px-4 py-3">
        <div className="flex items-center space-x-3">
          <div className="flex-1 relative">
            <FiSearch className="absolute left-3 top-1/2 transform -translate-y-1/2 h-4 w-4 text-gray-400" />
            <input
              type="text"
              placeholder={searchPlaceholder}
              value={searchTerm}
              onChange={(e) => onSearchChange && onSearchChange(e.target.value)}
              className="w-full pl-10 pr-4 py-2 border border-gray-300 rounded-md focus:ring-blue-500 focus:border-blue-500 dark:bg-gray-700 dark:border-gray-600 dark:text-white"
            />
          </div>
          {onToggleFilters && (
            <button
              onClick={onToggleFilters}
              className={`p-2 rounded-md ${
                showFilters
                  ? 'bg-blue-100 text-blue-600 dark:bg-blue-900/20 dark:text-blue-400'
                  : 'text-gray-400 hover:text-gray-600 dark:hover:text-gray-300'
              }`}
            >
              <FiFilter className="h-4 w-4" />
            </button>
          )}
        </div>
      </div>
      
      {showFilters && renderFilters && (
        <div className="px-4 pb-3 border-t border-gray-200 dark:border-gray-700">
          {renderFilters(filters, onFilterChange, onClearFilters)}
        </div>
      )}
      
      <ViewModeToggle />
    </div>
  );

  const LoadingState = () => (
    <div className="flex items-center justify-center py-12">
      <div className="text-center">
        <div className="inline-block animate-spin rounded-full h-8 w-8 border-b-2 border-blue-600 mb-4"></div>
        <p className="text-gray-600 dark:text-gray-400">{loadingText}</p>
      </div>
    </div>
  );

  const ErrorState = () => {
    const ErrorIcon = FiAlertCircle;
    return (
      <div className="flex items-center justify-center py-12">
        <div className="text-center">
          <div className="rounded-full bg-red-100 dark:bg-red-900/20 p-3 inline-block mb-4">
            <ErrorIcon className="h-6 w-6 text-red-600 dark:text-red-400" />
          </div>
          <p className="text-red-600 dark:text-red-400">
            {errorTitle}: {(error as Error)?.message || String(error)}
          </p>
        </div>
      </div>
    );
  };

  const EmptyState = () => {
    
    return (
      <div className="flex items-center justify-center py-12">
        <div className="text-center">
          {React.createElement(emptyStateIcon, { 
            className: "h-12 w-12 text-gray-300 dark:text-gray-600 mx-auto mb-4" 
          })}
          <p className="text-gray-900 dark:text-white font-medium mb-2">
            {emptyStateTitle}
          </p>
          <p className="text-gray-500 dark:text-gray-400 mb-4">
            {emptyStateDescription}
          </p>
          {showCreateOnEmpty && onCreateNew && (
            <button
              onClick={onCreateNew}
              className="inline-flex items-center px-4 py-2 text-sm font-medium text-blue-600 bg-blue-50 rounded-md hover:bg-blue-100 dark:bg-blue-900/20 dark:text-blue-400 dark:hover:bg-blue-900/30"
            >
              <FiPlus className="h-4 w-4 mr-2" />
              {createButtonText}
            </button>
          )}
        </div>
      </div>
    );
  };

  const renderContent = () => {
    if (isLoading) return <LoadingState />;
    if (error) return <ErrorState />;
    if (data.length === 0) return <EmptyState />;

    const contentClass = viewMode === 'grid' 
      ? "grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4 p-4"
      : "divide-y divide-gray-100 dark:divide-gray-700";

    return (
      <div className={contentClass}>
        {data.map((item) => {
          const isSelected = selectedItemId === item.id;
          
          if (viewMode === 'grid' && renderGridItem) {
            return renderGridItem(item, isSelected, () => handleItemSelect(item));
          } else if (viewMode === 'tree' && renderTreeItem) {
            return renderTreeItem(item, 0, isSelected, false, () => handleItemSelect(item), () => {});
          } else if (renderListItem) {
            return renderListItem(item, isSelected, () => handleItemSelect(item));
          }
          
          // Fallback default rendering
          return (
            <div
              key={item.id}
              onClick={() => handleItemSelect(item)}
              className={`p-4 cursor-pointer hover:bg-gray-50 dark:hover:bg-gray-700 ${
                isSelected ? 'bg-blue-50 dark:bg-blue-900/20' : ''
              }`}
            >
              <div className="font-medium text-gray-900 dark:text-white">
                {item.name || item.title || item.id}
              </div>
              {item.description && (
                <div className="text-sm text-gray-500 dark:text-gray-400 mt-1">
                  {item.description}
                </div>
              )}
            </div>
          );
        })}
      </div>
    );
  };

  return (
    <div className={`flex flex-col lg:flex-row lg:h-[calc(100vh-80px)] ${className}`}>
      {/* Left Panel - List */}
      <div
        className={`flex-1 flex flex-col ${
          detailsPanelVisible ? "hidden lg:flex" : "flex"
        } lg:border-r lg:border-gray-200 lg:dark:border-gray-700 ${listClassName}`}
      >
        <SearchAndFiltersSection />
        
        <div className="flex-1 overflow-y-auto bg-white dark:bg-gray-800">
          {renderContent()}
        </div>
      </div>

      {/* Right Panel - Details */}
      <div
        className={`${
          detailsPanelVisible ? "flex" : "hidden lg:flex"
        } flex-col w-full lg:w-96 xl:w-1/3 bg-white dark:bg-gray-800 border-t lg:border-t-0 border-gray-200 dark:border-gray-700 ${detailsClassName}`}
      >
        {/* Mobile Details Header */}
        <div className="sticky top-0 z-10 bg-white dark:bg-gray-800 border-b border-gray-200 dark:border-gray-700 px-4 py-3 lg:hidden">
          <div className="flex items-center justify-between">
            <h2 className="text-lg font-medium text-gray-900 dark:text-white">
              {detailsTitle}
            </h2>
            <button
              onClick={() => setDetailsPanelVisible(false)}
              className="p-2 rounded-md text-gray-400 hover:text-gray-600 dark:hover:text-gray-300"
            >
              <FiX className="h-5 w-5" />
            </button>
          </div>
        </div>

        {/* Desktop Details Header */}
        <div className="hidden lg:block border-b border-gray-200 dark:border-gray-700 px-4 py-3">
          <h2 className="text-lg font-medium text-gray-900 dark:text-white">
            {detailsTitle}
          </h2>
        </div>

        <div className="flex-1 overflow-y-auto">
          {selectedItem && renderDetailsPanel ? (
            renderDetailsPanel(selectedItem)
          ) : (
            <div className="flex items-center justify-center h-full p-8">
              <div className="text-center">
                <FiInfo className="h-12 w-12 text-gray-300 dark:text-gray-600 mx-auto mb-4" />
                <p className="text-gray-500 dark:text-gray-400">
                  Select an item to view details
                </p>
              </div>
            </div>
          )}
        </div>
      </div>
    </div>
  );
};

export default DataListView;
```

<!-- path: components/common/form/IPAddressInput.tsx -->
```typescript
import React, { useState, useCallback, useEffect } from 'react';
import { AlertCircle, CheckCircle2, Globe } from 'lucide-react';
// import { Label } from '@/components/common/ui';

// The ValidationState type remains useful for internal logic
interface ValidationState {
  isValid: boolean | null;
  type: 'IPv4' | 'IPv6' | null;
  error: string | null;
}

// Props are simplified. We now only expect a simple onChange.
interface IPAddressInputProps {
  value?: string;
  onChange?: (value: string) => void;
  placeholder?: string;
  allowIPv4?: boolean;
  allowIPv6?: boolean;
  className?: string;
}

const IPAddressInput: React.FC<IPAddressInputProps> = ({
  value = '',
  onChange = () => {},
  placeholder = 'Enter IP address',
  allowIPv4 = true,
  allowIPv6 = true,
  className = '',
}) => {
  const [validationState, setValidationState] = useState<ValidationState>({
    isValid: null,
    type: null,
    error: null,
  });

  // IPv4 validation
  const isValidIPv4 = useCallback((ip: string): boolean => {
    const ipv4Regex = /^(\d{1,3})\.(\d{1,3})\.(\d{1,3})\.(\d{1,3})$/;
    const match = ip.match(ipv4Regex);
    if (!match) return false;

    return match.slice(1).every((octet) => {
      const num = parseInt(octet, 10);
      return num >= 0 && num <= 255 && octet === num.toString();
    });
  }, []);

  const isValidIPv6Basic = useCallback((ip: string): boolean => {
    // Normalize the IPv6 address
    const normalized = ip.toLowerCase();

    // Handle :: compression
    if (normalized.includes('::')) {
      const parts = normalized.split('::');
      if (parts.length > 2) return false; // More than one ::

      const leftParts = parts[0] ? parts[0].split(':') : [];
      const rightParts = parts[1] ? parts[1].split(':') : [];
      const totalParts = leftParts.length + rightParts.length;

      if (totalParts > 8) return false;
    } else {
      // No compression, should have exactly 8 parts
      const parts = normalized.split(':');
      if (parts.length !== 8) return false;
    }

    // Validate each hexadecimal group
    const hexGroups = normalized
      .split('::')
      .join(':')
      .split(':')
      .filter((part) => part !== '');
    return hexGroups.every((group) => {
      if (group.length === 0 || group.length > 4) return false;
      return /^[0-9a-f]+$/i.test(group);
    });
  }, []);

  // IPv6 validation
  const isValidIPv6 = useCallback(
    (ip: string): boolean => {
      // Handle IPv6 with embedded IPv4
      const ipv6WithIPv4Regex =
        /^([0-9a-fA-F:]+):(\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3})$/;
      if (ipv6WithIPv4Regex.test(ip)) {
        const parts = ip.split(':');
        const ipv4Part = parts[parts.length - 1];
        const ipv6Part = parts.slice(0, -1).join(':') + ':';
        return isValidIPv4(ipv4Part) && isValidIPv6Basic(ipv6Part.slice(0, -1));
      }

      return isValidIPv6Basic(ip);
    },
    [isValidIPv4, isValidIPv6Basic]
  );

  const validateIP = useCallback(
    (ip: string): ValidationState => {
      if (!ip.trim()) {
        return { isValid: null, type: null, error: null };
      }

      let isIPv4Valid = false;
      let isIPv6Valid = false;

      if (allowIPv4) {
        isIPv4Valid = isValidIPv4(ip);
      }

      if (allowIPv6) {
        isIPv6Valid = isValidIPv6(ip);
      }

      if (isIPv4Valid) {
        return { isValid: true, type: 'IPv4', error: null };
      } else if (isIPv6Valid) {
        return { isValid: true, type: 'IPv6', error: null };
      } else {
        let error = 'Invalid IP address format';
        if (!allowIPv4 && !allowIPv6) {
          error = 'IP address input is disabled';
        } else if (!allowIPv4) {
          error = 'Only IPv6 addresses are allowed';
        } else if (!allowIPv6) {
          error = 'Only IPv4 addresses are allowed';
        }
        return { isValid: false, type: null, error };
      }
    },
    [allowIPv4, allowIPv6, isValidIPv4, isValidIPv6]
  );

  // Update validation state whenever the prop value changes from the outside (e.g., from react-hook-form)
  useEffect(() => {
    setValidationState(validateIP(value));
  }, [value, validateIP]);

  const handleInputChange = (e: React.ChangeEvent<HTMLInputElement>): void => {
    const newValue = e.target.value;
    // We call the onChange from props directly, letting react-hook-form manage the state.
    onChange(newValue);
  };

  const getInputClass = (): string => {
    let baseClass = `w-full px-4 py-3 border rounded-lg transition-all duration-200 font-mono text-sm ${className}`;

    if (validationState.isValid === true) {
      baseClass +=
        ' border-green-500 bg-green-50 focus:border-green-600 focus:ring-2 focus:ring-green-200 dark:bg-green-900/20 dark:border-green-600 dark:focus:border-green-500 dark:focus:ring-green-500/20';
    } else if (validationState.isValid === false) {
      baseClass +=
        ' border-red-500 bg-red-50 focus:border-red-600 focus:ring-2 focus:ring-red-200 dark:bg-red-900/20 dark:border-red-600 dark:focus:border-red-500 dark:focus:ring-red-500/20';
    } else {
      baseClass +=
        ' border-gray-300 bg-white focus:border-blue-500 focus:ring-2 focus:ring-blue-200 dark:bg-gray-800 dark:border-gray-600 dark:text-white dark:focus:border-blue-400 dark:focus:ring-blue-400/20';
    }

    return baseClass;
  };

  return (
    <div className="w-full">
      <div className="relative">
        <input
          type="text"
          value={value} // Directly use the value from props
          onChange={handleInputChange}
          placeholder={placeholder}
          className={getInputClass()}
          autoComplete="off"
          spellCheck="false"
        />

        <div className="absolute right-3 top-1/2 transform -translate-y-1/2">
          {validationState.isValid === true && (
            <CheckCircle2 className="w-5 h-5 text-green-500 dark:text-green-400" />
          )}
          {validationState.isValid === false && (
            <AlertCircle className="w-5 h-5 text-red-500 dark:text-red-400" />
          )}
          {validationState.isValid === null && value && (
            <Globe className="w-5 h-5 text-gray-400 dark:text-gray-500" />
          )}
        </div>
      </div>

      <div className="mt-2 min-h-[1.5rem]">
        {validationState.isValid === false && (
          <div className="flex items-center gap-2 text-sm text-red-600 dark:text-red-400">
            <AlertCircle className="w-4 h-4" />
            <span>{validationState.error}</span>
          </div>
        )}
      </div>
    </div>
  );
};

export default IPAddressInput;

```

<!-- path: components/common/form/SectionCard.tsx -->
```typescript
import { ReactNode } from "react";
import { cn } from "@/utils/classNames";

interface SectionCardProps {
  title: string;
  icon?: ReactNode;
  children: ReactNode;
  className?: string;
}

export default function SectionCard({
  title,
  icon,
  children,
  className,
}: SectionCardProps) {
  return (
    <div
      className={cn(
        "border rounded-xl p-4 space-y-4 bg-white shadow-sm",
        "transition-all duration-200 hover:shadow-md",
        className
      )}
    >
      <div className="flex items-center space-x-2 border-b pb-2">
        {icon && <span className="text-xl text-primary">{icon}</span>}
        <h3 className="font-semibold text-gray-800 text-base">{title}</h3>
      </div>
      <div className="grid gap-4">{children}</div>
    </div>
  );
}

```

<!-- path: components/common/form/FormControls.tsx -->
```typescript
/* eslint-disable @typescript-eslint/no-explicit-any */
'use client';

import {
  Control,
  Controller,
  FieldError,
  FieldErrorsImpl,
  Merge,
  UseFormRegister,
  Path,
  FieldValues,
} from 'react-hook-form';
import {
  SearchableSelect,
  Option,
} from '@/components/common/ui/select/SearchableSelect';
import { Input } from '@/components/common/ui/Input';
import { Textarea } from '@/components/common/ui/textarea/Textarea';
import { Label, Switch } from '@/components/common/ui';
import { forwardRef } from 'react';
import DatePicker, { type DatePickerProps } from 'react-datepicker';
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from '@/components/common/ui/select/Select';
import IPAddressInput from '@/components/common/form/IPAddressInput';

// --- TYPE DEFINITIONS for Generic Components ---

type BaseProps<T extends FieldValues> = {
  name: Path<T>;
  label: string;
  error?: FieldError | Merge<FieldError, FieldErrorsImpl<any>>;
  required?: boolean;
  className?: string;
  labelClassName?: string;
};

// --- FORM INPUT COMPONENT ---

interface FormInputProps<T extends FieldValues>
  extends BaseProps<T>,
    Omit<React.InputHTMLAttributes<HTMLInputElement>, 'name' | 'size'> {
  register: UseFormRegister<T>;
}

export function FormInput<T extends FieldValues>({
  name,
  register,
  label,
  error,
  type = 'text',
  className,
  labelClassName,
  ...props
}: FormInputProps<T>) {
  return (
    <div className={className}>
      <Label
        htmlFor={name}
        required={props.required}
        className={labelClassName}
      >
        {label}
      </Label>
      <Input
        id={name}
        type={type}
        error={typeof error?.message === 'string' ? error.message : undefined}
        {...props}
        {...register(name, {
          // For number inputs, treat empty string as null and otherwise coerce to Number
          ...(type === 'number' && {
            setValueAs: (v) =>
              v === '' || v === null || typeof v === 'undefined' ? null : Number(v),
          }),
          // For date inputs, map empty to null and non-empty to Date object
          ...(type === 'date' && {
            setValueAs: (v) => (v ? new Date(v) : null),
          }),
        })}
      />
    </div>
  );
}

// --- FORM TEXTAREA COMPONENT ---

interface FormTextareaProps<T extends FieldValues>
  extends BaseProps<T>,
    Omit<
      React.TextareaHTMLAttributes<HTMLTextAreaElement>,
      'name' | 'value' | 'onChange'
    > {
  register?: UseFormRegister<T>;
  control?: Control<T>;
}

export function FormTextarea<T extends FieldValues>({
  name,
  control,
  label,
  error,
  className,
  labelClassName,
  ...props
}: FormTextareaProps<T>) {
  return (
    <div className={className}>
      <Label
        htmlFor={name}
        required={props.required}
        className={labelClassName}
      >
        {label}
      </Label>
      {control ? (
        <Controller
          name={name}
          control={control}
          render={({ field }) => (
            <Textarea
              id={name}
              value={(field.value as string) ?? ''}
              onChange={(_e, val) => field.onChange(val)}
              onBlur={field.onBlur}
              error={!!error}
              errorMessage={
                typeof error?.message === 'string' ? error.message : undefined
              }
              {...props}
            />
          )}
        />
      ) : (
        <Textarea
          id={name}
          error={!!error}
          errorMessage={
            typeof error?.message === 'string' ? error.message : undefined
          }
          {...props}
        />
      )}
    </div>
  );
}

// --- FORM SEARCHABLE SELECT COMPONENT ---

interface FormSearchableSelectProps<T extends FieldValues>
  extends BaseProps<T> {
  control: Control<T>;
  options: Option[];
  placeholder?: string;
  searchPlaceholder?: string;
  disabled?: boolean;
  clearable?: boolean;
  // **NEW PROPS FOR SERVER-SIDE SEARCH**
  serverSide?: boolean; // When true, options are not filtered client-side
  onSearch?: (term: string) => void; // Function to trigger a search
  isLoading?: boolean; // To show a loading indicator
}

export function FormSearchableSelect<T extends FieldValues>({
  name,
  control,
  label,
  options,
  error,
  className,
  labelClassName,
  ...props
}: FormSearchableSelectProps<T>) {
  // console.log("options",options);

  return (
    <div className={className}>
      <Label
        htmlFor={name}
        required={props.required}
        className={labelClassName}
      >
        {label}
      </Label>
      <Controller
        name={name}
        control={control}
        render={({ field }) => (
          <SearchableSelect
            {...props}
            value={(field.value as string) ?? ''}
            onChange={(value) => field.onChange(value === '' ? '' : value)}
            options={options}
            error={!!error}
          />
        )}
      />
      {error && (
        <p className="mt-1 text-sm text-red-500">
          {typeof error?.message === 'string' ? error.message : null}
        </p>
      )}
    </div>
  );
}

// --- FORM SELECT COMPONENT ---

interface FormSelectProps<T extends FieldValues> extends BaseProps<T> {
  control: Control<T>;
  options: Option[];
  placeholder?: string;
  searchPlaceholder?: string;
  disabled?: boolean;
  clearable?: boolean;
}

export function FormSelect<T extends FieldValues>({
  name,
  control,
  label,
  options,
  error,
  className,
  labelClassName,
  ...props
}: FormSelectProps<T>) {
  return (
    <div className={className}>
      <Label
        htmlFor={name}
        required={props.required}
        className={labelClassName}
      >
        {label}
      </Label>
      <Controller
        name={name}
        control={control}
        render={({ field }) => (
          <Select
            {...props}
            value={(field.value as string) ?? ''}
            onValueChange={(value) => field.onChange(value)}
          >
            <SelectTrigger className="w-full" aria-invalid={!!error}>
              <SelectValue placeholder={props.placeholder ?? 'Select'} />
            </SelectTrigger>
            <SelectContent>
              {options.map((option) => (
                <SelectItem
                  key={option.value}
                  value={option.value}
                  disabled={option.disabled}
                >
                  {option.label}
                </SelectItem>
              ))}
            </SelectContent>
          </Select>
        )}
      />
      {error && (
        <p className="mt-1 text-sm text-red-500">
          {typeof error?.message === 'string' ? error.message : null}
        </p>
      )}
    </div>
  );
}

// --- FORM DATE INPUT COMPONENT ---

// Keep your original prop intent; allow passing datepicker props safely
export interface FormDateInputProps<T extends FieldValues>
  extends BaseProps<T>,
    Omit<
      React.InputHTMLAttributes<HTMLInputElement>,
      'name' | 'type' | 'size'
    > {
  control: Control<T>;
  // Optional passthrough for DatePicker props (minDate, maxDate, showTimeSelect, etc.)
  pickerProps?: Partial<
    Omit<
      DatePickerProps,
      // Keep single-date mode: exclude props that change `onChange` signature
      | 'selected'
      | 'onChange'
      | 'customInput'
      | 'onBlur'
      | 'onSelect'
      | 'selectsRange'
      | 'selectsMultiple'
      | 'startDate'
      | 'endDate'
    >
  >;
}

/** A styled input used as ReactDatePicker's customInput to control theme + icon */
const DateTextInput = forwardRef<
  HTMLInputElement,
  React.InputHTMLAttributes<HTMLInputElement> & { errorText?: string }
>(({ className, errorText, ...rest }, ref) => {
  return (
    <div className="relative">
      <input
        ref={ref}
        {...rest}
        className={[
          'w-full rounded-md border bg-white text-gray-900',
          'dark:bg-gray-900 dark:text-gray-100 dark:border-gray-700',
          'px-10 py-2 outline-none',
          'focus:ring-2 focus:ring-blue-500 focus:border-blue-500',
          errorText
            ? 'border-red-500 focus:ring-red-500 focus:border-red-500'
            : 'border-gray-300',
          className ?? '',
        ].join(' ')}
        readOnly // recommended with customInput to avoid parsing issues
      />
      {/* Calendar icon (theme-aware via currentColor) */}
      <svg
        className="pointer-events-none absolute left-3 top-1/2 h-5 w-5 -translate-y-1/2 text-gray-500 dark:text-gray-300"
        viewBox="0 0 24 24"
        fill="none"
        stroke="currentColor"
        strokeWidth="2"
        strokeLinecap="round"
        strokeLinejoin="round"
        aria-hidden="true"
      >
        <rect x="3" y="4" width="18" height="18" rx="2" />
        <line x1="16" y1="2" x2="16" y2="6" />
        <line x1="8" y1="2" x2="8" y2="6" />
        <line x1="3" y1="10" x2="21" y2="10" />
      </svg>
      {errorText ? (
        <p className="mt-1 text-sm text-red-600">{errorText}</p>
      ) : null}
    </div>
  );
});
DateTextInput.displayName = 'DateTextInput';

export function FormDateInput<T extends FieldValues>({
  name,
  control,
  label,
  error,
  className,
  labelClassName,
  pickerProps,
  required,
  ...inputProps
}: FormDateInputProps<T>) {
  return (
    <div className={className}>
      {label ? (
        <Label htmlFor={name} className={labelClassName}>
          {label}
          {required ? <span className="ml-0.5 text-red-600">*</span> : null}
        </Label>
      ) : null}

      <Controller
        name={name}
        control={control}
        render={({ field }) => {
          // Normalize value to Date | null
          const raw = field.value as unknown;
          const selected: Date | null =
            raw == null || (raw as any) === ''
              ? null
              : typeof raw === 'object' &&
                raw !== null &&
                'getTime' in (raw as object)
              ? (raw as Date)
              : new Date(raw as any);

          return (
            // @ts-expect-error react-datepicker's prop union sometimes misinfers to multi-select variant.
            // We intentionally use single-date mode: `selected: Date | null` and `onChange(date | null)`.
            <DatePicker
              id={name}
              // --- recommended defaults for date-only fields ---
              selected={selected}
              onChange={(d: Date | null) =>
                field.onChange(d ? d.toISOString().split('T')[0] : null)
              }
              onBlur={field.onBlur}
              // Keep keyboard nav and accessibility
              // Use a date-only format; adjust as you like
              dateFormat={(pickerProps as any)?.dateFormat ?? 'yyyy-MM-dd'}
              // Show clear button by default; optional
              isClearable
              // Enable year and month dropdowns
              showMonthDropdown
              showYearDropdown
              dropdownMode="select" // Makes dropdowns selectable instead of scrollable
              // You can also set year range if needed
              yearDropdownItemNumber={15} // Shows 15 years in dropdown
              // Render portal into Next.js root so it appears above modals/overflows
              portalId="__next"
              // Custom input so we fully control theme + icon
              customInput={
                <DateTextInput
                  errorText={
                    typeof error?.message === 'string'
                      ? error.message
                      : undefined
                  }
                  placeholder={inputProps.placeholder ?? 'Select date'}
                />
              }
              // Pass through any extra ReactDatePicker props (minDate, maxDate, showTimeSelect, etc.)
              {...pickerProps}
            />
          );
        }}
      />
    </div>
  );
}

// --- FORM SWITCH COMPONENT ---

interface FormSwitchProps<T extends FieldValues> extends BaseProps<T> {
  control: Control<T>;
  description?: string;
}

export function FormSwitch<T extends FieldValues>({
  name,
  control,
  label,
  error,
  description,
  className,
}: FormSwitchProps<T>) {
  return (
    <div className={className}>
      <Controller
        name={name}
        control={control}
        render={({ field }) => (
          <div className="flex items-center space-x-2">
            <Switch
              id={name}
              checked={!!field.value}
              onChange={(checked: boolean) => field.onChange(checked)}
            />
            <div>
              <Label htmlFor={name}>{label}</Label>
              {description && (
                <p className="text-xs text-gray-500">{description}</p>
              )}
            </div>
          </div>
        )}
      />
      {error && (
        <p className="mt-1 text-sm text-red-500">
          {typeof error?.message === 'string' ? error.message : null}
        </p>
      )}
    </div>
  );
}

// --- FORM IP ADDRESS COMPONENT ---

interface FormIPAddressInputProps<T extends FieldValues> extends BaseProps<T> {
  control: Control<T>;
  placeholder?: string;
  allowIPv4?: boolean;
  allowIPv6?: boolean;
}

export function FormIPAddressInput<T extends FieldValues>({
  name,
  control,
  label,
  error,
  className,
  labelClassName,
  ...props
}: FormIPAddressInputProps<T>) {
  return (
    <div className={className}>
      <Label
        htmlFor={name}
        required={props.required}
        className={labelClassName}
      >
        {label}
      </Label>
      <Controller
        name={name}
        control={control}
        render={({ field }) => (
          <IPAddressInput
            {...props} // Pass through placeholder, allowIPv4, etc.
            value={field.value || ''} // Get value from react-hook-form
            onChange={field.onChange} // Use react-hook-form's onChange
          />
        )}
      />
      {error && (
        <p className="mt-1 text-sm text-red-500">
          {typeof error?.message === 'string' ? error.message : 'Invalid input'}
        </p>
      )}
    </div>
  );
}

```

<!-- path: components/common/form/FormCard.tsx -->
```typescript
import React from "react";
import { cn } from "@/utils/classNames";

interface FormCardProps {
  title: string;
  subtitle?: string;
  isLoading?: boolean;
  onCancel: () => void;
  onSubmit?: React.FormEventHandler<HTMLFormElement>;
  submitText?: string;
  cancelText?: string;
  children: React.ReactNode;
  footerContent?: React.ReactNode;
  widthClass?: string;
  disableSubmit?: boolean;
  heightClass?: string;
  standalone?: boolean; // New prop to control backdrop behavior
}

export const FormCard: React.FC<FormCardProps> = ({
  title,
  subtitle,
  isLoading = false,
  onCancel,
  onSubmit,
  submitText = "Submit",
  cancelText = "Cancel",
  children,
  footerContent,
  widthClass = "max-w-3xl",
  heightClass = "max-h-[90vh]",
  disableSubmit = false,
  standalone = false, // Default to false - no backdrop
}) => {
  const modalContent = (
    <div
      className={cn(
        "w-full overflow-hidden rounded-xl bg-white shadow-2xl dark:bg-gray-900 dark:border dark:border-gray-700 flex flex-col transform mx-auto",
        widthClass,
        heightClass
      )}
      style={{
        animation: "slideInScale 0.4s cubic-bezier(0.34, 1.56, 0.64, 1)",
        boxShadow: "0 25px 50px -12px rgba(0, 0, 0, 0.4), 0 0 0 1px rgba(255, 255, 255, 0.05)"
      }}
      onClick={(e) => e.stopPropagation()}
    >
      {/* Header */}
      <div 
        className="flex-shrink-0 px-6 py-4 border-b border-gray-200 dark:border-gray-700 flex items-center justify-between"
        style={{
          animation: "slideDown 0.5s ease-out 0.1s both"
        }}
      >
        <div>
          <h2 
            className="text-2xl font-bold text-gray-900 dark:text-white"
            style={{
              animation: "fadeInUp 0.6s ease-out 0.2s both"
            }}
          >
            {title}
          </h2>
          {subtitle && (
            <p 
              className="text-gray-600 dark:text-gray-400 text-sm mt-1"
              style={{
                animation: "fadeInUp 0.6s ease-out 0.3s both"
              }}
            >
              {subtitle}
            </p>
          )}
        </div>
        <button
          onClick={onCancel}
          disabled={isLoading}
          className="text-gray-400 hover:text-gray-600 dark:text-gray-500 dark:hover:text-gray-300 hover:bg-gray-100 dark:hover:bg-gray-800 rounded-full p-2 transition-all duration-300 hover:scale-110 hover:rotate-90"
          style={{
            animation: "fadeInRotate 0.5s ease-out 0.2s both"
          }}
        >
          <svg className="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M6 18L18 6M6 6l12 12" />
          </svg>
        </button>
      </div>

      {/* Form Body + Footer */}
      <form onSubmit={onSubmit} className="flex flex-col flex-1 min-h-0">
        {/* Body */}
        <div 
          className="flex-1 overflow-y-auto relative min-h-0"
          style={{
            animation: "fadeInUp 0.6s ease-out 0.3s both"
          }}
        >
          {isLoading && (
            <div 
              className="absolute inset-0 bg-white/80 dark:bg-gray-900/80 backdrop-blur-sm flex items-center justify-center z-10"
              style={{
                animation: "fadeIn 0.3s ease-out"
              }}
            >
              <div className="flex items-center space-x-2">
                <div 
                  className="w-4 h-4 bg-blue-600 rounded-full"
                  style={{
                    animation: "bounce 1.4s ease-in-out infinite both"
                  }}
                ></div>
                <div 
                  className="w-4 h-4 bg-blue-600 rounded-full"
                  style={{
                    animation: "bounce 1.4s ease-in-out 0.16s infinite both"
                  }}
                ></div>
                <div 
                  className="w-4 h-4 bg-blue-600 rounded-full"
                  style={{
                    animation: "bounce 1.4s ease-in-out 0.32s infinite both"
                  }}
                ></div>
                <span className="text-gray-600 dark:text-gray-300 ml-3">Loading...</span>
              </div>
            </div>
          )}
          <div className="p-6">{children}</div>
        </div>

        {/* Footer */}
        <div 
          className="flex-shrink-0 px-6 py-4 border-t border-gray-200 dark:border-gray-700 flex justify-between items-center bg-gray-50 dark:bg-gray-800/50"
          style={{
            animation: "slideUp 0.5s ease-out 0.4s both"
          }}
        >
          {footerContent ? (
            footerContent
          ) : (
            <div className="flex justify-end space-x-3 w-full">
              <button
                type="button"
                onClick={onCancel}
                disabled={isLoading}
                className="px-6 py-2 border rounded-md dark:border-gray-600 dark:text-gray-300 dark:hover:bg-gray-700 transition-all duration-300 hover:scale-105 hover:shadow-lg transform"
                style={{
                  animation: "fadeInLeft 0.5s ease-out 0.5s both"
                }}
              >
                {cancelText}
              </button>
              {onSubmit && (
                <button
                  type="submit"
                  disabled={isLoading || disableSubmit}
                  className="px-8 py-2 bg-blue-600 hover:bg-blue-700 dark:bg-blue-600 dark:hover:bg-blue-700 text-white shadow-lg hover:shadow-xl transform hover:-translate-y-1 hover:scale-105 transition-all duration-300 rounded-md"
                  style={{
                    animation: "fadeInRight 0.5s ease-out 0.6s both",
                    background: "linear-gradient(135deg, #3B82F6 0%, #1D4ED8 100%)"
                  }}
                >
                  {submitText}
                </button>
              )}
            </div>
          )}
        </div>
      </form>

      <style jsx>{`
        @keyframes fadeIn {
          from { opacity: 0; }
          to { opacity: 1; }
        }

        @keyframes slideInScale {
          0% {
            opacity: 0;
            transform: translateY(20px) scale(0.95);
          }
          100% {
            opacity: 1;
            transform: translateY(0) scale(1);
          }
        }

        @keyframes slideDown {
          from {
            opacity: 0;
            transform: translateY(-20px);
          }
          to {
            opacity: 1;
            transform: translateY(0);
          }
        }

        @keyframes slideUp {
          from {
            opacity: 0;
            transform: translateY(20px);
          }
          to {
            opacity: 1;
            transform: translateY(0);
          }
        }

        @keyframes fadeInUp {
          from {
            opacity: 0;
            transform: translateY(10px);
          }
          to {
            opacity: 1;
            transform: translateY(0);
          }
        }

        @keyframes fadeInLeft {
          from {
            opacity: 0;
            transform: translateX(-10px);
          }
          to {
            opacity: 1;
            transform: translateX(0);
          }
        }

        @keyframes fadeInRight {
          from {
            opacity: 0;
            transform: translateX(10px);
          }
          to {
            opacity: 1;
            transform: translateX(0);
          }
        }

        @keyframes fadeInRotate {
          from {
            opacity: 0;
            transform: rotate(-90deg) scale(0.8);
          }
          to {
            opacity: 1;
            transform: rotate(0deg) scale(1);
          }
        }

        @keyframes bounce {
          0%, 80%, 100% {
            transform: scale(0);
            opacity: 0.5;
          }
          40% {
            transform: scale(1);
            opacity: 1;
          }
        }
      `}</style>
    </div>
  );

  // If standalone, wrap with backdrop, otherwise return just the modal content
  if (standalone) {
    return (
      <div 
        className="fixed inset-0 z-[9999] flex items-center justify-center p-4"
        style={{
          background: "rgba(0, 0, 0, 0.6)",
          animation: "fadeIn 0.3s ease-out"
        }}
        onClick={(e) => {
          if (e.target === e.currentTarget) {
            onCancel();
          }
        }}
      >
        {modalContent}
      </div>
    );
  }

  // Return just the modal content without backdrop (for use within existing modals)
  return (
    <div className="flex items-center justify-center p-4 w-full">
      {modalContent}
    </div>
  );
};
```

<!-- path: components/common/form/index.ts -->
```typescript
export * from './FormCard';
export * from './FormControls';
export * from './SectionCard';
export * from './IPAddressInput';


```

<!-- path: components/common/ui/badges/RoleBadge.tsx -->
```typescript
// components/users/RoleBadge.tsx
import { UserRole } from "@/types/user-roles";

export const RoleBadge = ({ role }: { role: UserRole }) => {
  const getRoleConfig = (role: UserRole) => {
    switch (role) {
      case UserRole.ADMIN:
        return { 
          bg: "bg-gradient-to-r from-red-500/20 to-pink-500/20 dark:from-red-500/30 dark:to-pink-500/30", 
          text: "text-red-700 dark:text-red-300",
          border: "border-red-200/60 dark:border-red-500/40",
          shadow: "shadow-red-500/20 dark:shadow-red-500/30",
          icon: "👑"
        };
      case UserRole.MAANADMIN:
        return { 
          bg: "bg-gradient-to-r from-indigo-500/20 to-purple-500/20 dark:from-indigo-500/30 dark:to-purple-500/30", 
          text: "text-indigo-700 dark:text-indigo-300",
          border: "border-indigo-200/60 dark:border-indigo-500/40",
          shadow: "shadow-indigo-500/20 dark:shadow-indigo-500/30",
          icon: "⭐"
        };
      case UserRole.SDHADMIN:
        return { 
          bg: "bg-gradient-to-r from-emerald-500/20 to-teal-500/20 dark:from-emerald-500/30 dark:to-teal-500/30", 
          text: "text-emerald-700 dark:text-emerald-300",
          border: "border-emerald-200/60 dark:border-emerald-500/40",
          shadow: "shadow-emerald-500/20 dark:shadow-emerald-500/30",
          icon: "🚀"
        };
      case UserRole.VMUXADMIN:
        return { 
          bg: "bg-gradient-to-r from-slate-500/20 to-gray-500/20 dark:from-slate-500/30 dark:to-gray-500/30", 
          text: "text-slate-700 dark:text-slate-300",
          border: "border-slate-200/60 dark:border-slate-500/40",
          shadow: "shadow-slate-500/20 dark:shadow-slate-500/30",
          icon: "⚙️"
        };
      case UserRole.MNGADMIN:
        return { 
          bg: "bg-gradient-to-r from-amber-500/20 to-orange-500/20 dark:from-amber-500/30 dark:to-orange-500/30", 
          text: "text-amber-700 dark:text-amber-300",
          border: "border-amber-200/60 dark:border-amber-500/40",
          shadow: "shadow-amber-500/20 dark:shadow-amber-500/30",
          icon: "📊"
        };
      case UserRole.VIEWER:
        return { 
          bg: "bg-gradient-to-r from-gray-400/15 to-slate-400/15 dark:from-gray-500/25 dark:to-slate-500/25", 
          text: "text-gray-600 dark:text-gray-400",
          border: "border-gray-200/50 dark:border-gray-600/40",
          shadow: "shadow-gray-500/10 dark:shadow-gray-500/20",
          icon: "👁️"
        };
      case UserRole.AUTHENTICATED:
        return { 
          bg: "bg-gradient-to-r from-sky-500/20 to-blue-500/20 dark:from-sky-500/30 dark:to-blue-500/30", 
          text: "text-sky-700 dark:text-sky-300",
          border: "border-sky-200/60 dark:border-sky-500/40",
          shadow: "shadow-sky-500/20 dark:shadow-sky-500/30",
          icon: "✅"
        };
      case UserRole.ANON:
        return { 
          bg: "bg-gradient-to-r from-zinc-400/15 to-stone-400/15 dark:from-zinc-500/25 dark:to-stone-500/25", 
          text: "text-zinc-600 dark:text-zinc-400",
          border: "border-zinc-200/50 dark:border-zinc-600/40",
          shadow: "shadow-zinc-500/10 dark:shadow-zinc-500/20",
          icon: "❓"
        };
      default:
        return { 
          bg: "bg-gradient-to-r from-neutral-400/15 to-gray-400/15 dark:from-neutral-500/25 dark:to-gray-500/25", 
          text: "text-neutral-600 dark:text-neutral-400",
          border: "border-neutral-200/50 dark:border-neutral-600/40",
          shadow: "shadow-neutral-500/10 dark:shadow-neutral-500/20",
          icon: "🔸"
        };
    }
  };

  const { bg, text, border, shadow, icon } = getRoleConfig(role);
  const displayText = role.replace("_", " ").toLowerCase().replace(/\b\w/g, l => l.toUpperCase());

  return (
    <span
      className={`
        inline-flex items-center gap-1.5 px-3 py-1.5 
        rounded-full text-xs font-semibold tracking-wide
        border backdrop-blur-sm
        transition-all duration-300 ease-out
        hover:scale-105 hover:shadow-lg hover:-translate-y-0.5
        cursor-default select-none
        ${bg} ${text} ${border} ${shadow}
        dark:shadow-lg
      `}
    >
      <span className="text-[10px] leading-none" role="img" aria-hidden="true">
        {icon}
      </span>
      <span className="font-medium">
        {displayText}
      </span>
    </span>
  );
};

```

<!-- path: components/common/ui/badges/StatusBadge.tsx -->
```typescript
// components/users/StatusBadge.tsx

export const StatusBadge = ({ status }: { status: string | boolean | null }) => {
  const getStatusConfig = (status: string | boolean | null) => {
    // Handle null/undefined cases first
    if (status === null || status === undefined) {
      return { 
        bg: "bg-gradient-to-r from-gray-400/15 to-slate-400/15 dark:from-gray-500/25 dark:to-slate-500/25",
        text: "text-gray-600 dark:text-gray-400",
        border: "border-gray-200/50 dark:border-gray-600/40",
        shadow: "shadow-gray-500/10 dark:shadow-gray-500/20",
        dot: "bg-gray-500 dark:bg-gray-400",
        dotShadow: "shadow-gray-500/30",
        label: "Unknown",
        pulse: false
      };
    }

    // Handle boolean cases
    if (typeof status === 'boolean') {
      return status
        ? {
            bg: "bg-gradient-to-r from-green-500/20 to-emerald-500/20 dark:from-green-500/30 dark:to-emerald-500/30",
            text: "text-green-700 dark:text-green-300",
            border: "border-green-200/60 dark:border-green-500/40",
            shadow: "shadow-green-500/20 dark:shadow-green-500/30",
            dot: "bg-green-500 dark:bg-green-400",
            dotShadow: "shadow-green-500/40",
            label: "Active",
            pulse: true
          }
        : {
            bg: "bg-gradient-to-r from-red-500/20 to-rose-500/20 dark:from-red-500/30 dark:to-rose-500/30",
            text: "text-red-700 dark:text-red-300",
            border: "border-red-200/60 dark:border-red-500/40",
            shadow: "shadow-red-500/20 dark:shadow-red-500/30",
            dot: "bg-red-500 dark:bg-red-400",
            dotShadow: "shadow-red-500/40",
            label: "Inactive",
            pulse: false
          };
    }

    // Handle string cases
    switch (status.toLowerCase()) {
      case "active":
        return {
          bg: "bg-gradient-to-r from-green-500/20 to-emerald-500/20 dark:from-green-500/30 dark:to-emerald-500/30",
          text: "text-green-700 dark:text-green-300",
          border: "border-green-200/60 dark:border-green-500/40",
          shadow: "shadow-green-500/20 dark:shadow-green-500/30",
          dot: "bg-green-500 dark:bg-green-400",
          dotShadow: "shadow-green-500/40",
          label: "Active",
          pulse: true
        };
      case "inactive":
        return { 
          bg: "bg-gradient-to-r from-gray-400/15 to-slate-400/15 dark:from-gray-500/25 dark:to-slate-500/25",
          text: "text-gray-600 dark:text-gray-400",
          border: "border-gray-200/50 dark:border-gray-600/40",
          shadow: "shadow-gray-500/10 dark:shadow-gray-500/20",
          dot: "bg-gray-500 dark:bg-gray-400",
          dotShadow: "shadow-gray-500/30",
          label: "Inactive",
          pulse: false
        };
      case "suspended":
        return { 
          bg: "bg-gradient-to-r from-red-500/20 to-orange-500/20 dark:from-red-500/30 dark:to-orange-500/30",
          text: "text-red-700 dark:text-red-300",
          border: "border-red-200/60 dark:border-red-500/40",
          shadow: "shadow-red-500/20 dark:shadow-red-500/30",
          dot: "bg-red-500 dark:bg-red-400",
          dotShadow: "shadow-red-500/40",
          label: "Suspended",
          pulse: false
        };
      case "pending":
        return {
          bg: "bg-gradient-to-r from-amber-500/20 to-yellow-500/20 dark:from-amber-500/30 dark:to-yellow-500/30",
          text: "text-amber-700 dark:text-amber-300",
          border: "border-amber-200/60 dark:border-amber-500/40",
          shadow: "shadow-amber-500/20 dark:shadow-amber-500/30",
          dot: "bg-amber-500 dark:bg-amber-400",
          dotShadow: "shadow-amber-500/40",
          label: "Pending",
          pulse: true
        };
      case "verified":
        return {
          bg: "bg-gradient-to-r from-blue-500/20 to-cyan-500/20 dark:from-blue-500/30 dark:to-cyan-500/30",
          text: "text-blue-700 dark:text-blue-300",
          border: "border-blue-200/60 dark:border-blue-500/40",
          shadow: "shadow-blue-500/20 dark:shadow-blue-500/30",
          dot: "bg-blue-500 dark:bg-blue-400",
          dotShadow: "shadow-blue-500/40",
          label: "Verified",
          pulse: false
        };
      case "banned":
        return {
          bg: "bg-gradient-to-r from-red-600/25 to-red-800/25 dark:from-red-600/35 dark:to-red-800/35",
          text: "text-red-800 dark:text-red-200",
          border: "border-red-300/70 dark:border-red-400/50",
          shadow: "shadow-red-600/25 dark:shadow-red-600/35",
          dot: "bg-red-600 dark:bg-red-500",
          dotShadow: "shadow-red-600/50",
          label: "Banned",
          pulse: false
        };
      case "online":
        return {
          bg: "bg-gradient-to-r from-green-400/25 to-green-600/25 dark:from-green-400/35 dark:to-green-600/35",
          text: "text-green-800 dark:text-green-200",
          border: "border-green-300/70 dark:border-green-400/50",
          shadow: "shadow-green-500/25 dark:shadow-green-500/35",
          dot: "bg-green-500 dark:bg-green-400",
          dotShadow: "shadow-green-500/50",
          label: "Online",
          pulse: true
        };
      case "offline":
        return {
          bg: "bg-gradient-to-r from-slate-400/15 to-gray-500/15 dark:from-slate-500/25 dark:to-gray-600/25",
          text: "text-slate-600 dark:text-slate-400",
          border: "border-slate-200/50 dark:border-slate-600/40",
          shadow: "shadow-slate-500/10 dark:shadow-slate-500/20",
          dot: "bg-slate-500 dark:bg-slate-400",
          dotShadow: "shadow-slate-500/30",
          label: "Offline",
          pulse: false
        };
      default:
        return { 
          bg: "bg-gradient-to-r from-gray-400/15 to-slate-400/15 dark:from-gray-500/25 dark:to-slate-500/25",
          text: "text-gray-600 dark:text-gray-400",
          border: "border-gray-200/50 dark:border-gray-600/40",
          shadow: "shadow-gray-500/10 dark:shadow-gray-500/20",
          dot: "bg-gray-500 dark:bg-gray-400",
          dotShadow: "shadow-gray-500/30",
          label: typeof status === 'string' ? status.charAt(0).toUpperCase() + status.slice(1) : "Unknown",
          pulse: false
        };
    }
  };

  const config = getStatusConfig(status);

  return (
    <span
      className={`
        inline-flex items-center gap-2 px-3 py-1.5
        rounded-full text-xs font-semibold tracking-wide
        border backdrop-blur-sm
        transition-all duration-300 ease-out
        hover:scale-105 hover:shadow-lg hover:-translate-y-0.5
        cursor-default select-none
        ${config.bg} ${config.text} ${config.border} ${config.shadow}
        dark:shadow-lg
      `}
    >
      <span 
        className={`
          relative w-2 h-2 rounded-full shadow-sm
          ${config.dot} ${config.dotShadow}
          ${config.pulse ? 'animate-pulse' : ''}
        `}
      >
        {config.pulse && (
          <span 
            className={`
              absolute inset-0 w-2 h-2 rounded-full opacity-75
              animate-ping
              ${config.dot}
            `}
          />
        )}
      </span>
      <span className="font-medium">
        {config.label}
      </span>
    </span>
  );
};
```

<!-- path: components/common/ui/error/ErrorDisplay.tsx -->
```typescript
import React, { useState, MouseEvent } from "react";

interface ErrorDisplayProps {
  error?: string | string[] | null;
  variant?: "inline" | "alert" | "toast" | "banner";
  severity?: "error" | "warning" | "info";
  size?: "sm" | "md" | "lg";
  showIcon?: boolean;
  dismissible?: boolean;
  onDismiss?: () => void;
  className?: string;
  id?: string;
  title?: string;
  actions?: Array<{
    label: string;
    onClick: () => void;
    variant?: "primary" | "secondary";
  }>;
}

export const ErrorDisplay: React.FC<ErrorDisplayProps> = ({
  error,
  variant = "inline",
  severity = "error",
  size = "md",
  showIcon = true,
  dismissible = false,
  onDismiss,
  className = "",
  id,
  title,
  actions = []
}) => {
  const [dismissed, setDismissed] = useState(false);

  if (!error || dismissed) return null;

  const errorArray = Array.isArray(error) ? error : [error];
  const hasMultipleErrors = errorArray.length > 1;

  const iconConfig = {
    error: {
      icon: (
        <svg className="w-5 h-5" fill="currentColor" viewBox="0 0 20 20">
          <path
            fillRule="evenodd"
            d="M18 10a8 8 0 11-16 0 8 8 0 0116 0zm-7 4a1 1 0 
            11-2 0 1 1 0 012 0zm-1-9a1 1 0 00-1 1v4a1 1 0 
            102 0V6a1 1 0 00-1-1z"
            clipRule="evenodd"
          />
        </svg>
      ),
      colorClass: "text-red-600"
    },
    warning: {
      icon: (
        <svg className="w-5 h-5" fill="currentColor" viewBox="0 0 20 20">
          <path
            fillRule="evenodd"
            d="M8.257 3.099c.765-1.36 2.722-1.36 
            3.486 0l5.58 9.92c.75 1.334-.213 
            2.98-1.742 2.98H4.42c-1.53 
            0-2.493-1.646-1.743-2.98l5.58-9.92zM11 
            13a1 1 0 11-2 0 1 1 0 012 0zm-1-8a1 1 0 
            00-1 1v3a1 1 0 002 0V6a1 1 0 00-1-1z"
            clipRule="evenodd"
          />
        </svg>
      ),
      colorClass: "text-yellow-600"
    },
    info: {
      icon: (
        <svg className="w-5 h-5" fill="currentColor" viewBox="0 0 20 20">
          <path
            fillRule="evenodd"
            d="M18 10a8 8 0 11-16 0 8 8 0 
            0116 0zm-7-4a1 1 0 11-2 0 1 1 
            0 012 0zM9 9a1 1 0 000 2v3a1 1 
            0 001 1h1a1 1 0 100-2v-3a1 1 0 
            00-1-1H9z"
            clipRule="evenodd"
          />
        </svg>
      ),
      colorClass: "text-blue-600"
    }
  } as const;

  const sizeConfig = {
    sm: { text: "text-sm", padding: "p-3", iconSize: "w-4 h-4" },
    md: { text: "text-base", padding: "p-4", iconSize: "w-5 h-5" },
    lg: { text: "text-lg", padding: "p-5", iconSize: "w-6 h-6" }
  };

  const variantConfig = {
    inline: {
      container: "inline-flex items-start space-x-2",
      background: "",
      border: ""
    },
    alert: {
      container: "rounded-lg border",
      background:
        severity === "error"
          ? "bg-red-50"
          : severity === "warning"
          ? "bg-yellow-50"
          : "bg-blue-50",
      border:
        severity === "error"
          ? "border-red-200"
          : severity === "warning"
          ? "border-yellow-200"
          : "border-blue-200"
    },
    toast: {
      container: "rounded-lg border shadow-lg",
      background: "bg-white",
      border:
        severity === "error"
          ? "border-red-400"
          : severity === "warning"
          ? "border-yellow-400"
          : "border-blue-400"
    },
    banner: {
      container: "border-l-4",
      background:
        severity === "error"
          ? "bg-red-50"
          : severity === "warning"
          ? "bg-yellow-50"
          : "bg-blue-50",
      border:
        severity === "error"
          ? "border-l-red-400"
          : severity === "warning"
          ? "border-l-yellow-400"
          : "border-l-blue-400"
    }
  };

  const currentIcon = iconConfig[severity];
  const currentSize = sizeConfig[size];
  const currentVariant = variantConfig[variant];

  const handleDismiss = () => {
    setDismissed(true);
    onDismiss?.();
  };

  const handleActionClick =
    (actionOnClick: () => void) => (event: MouseEvent<HTMLButtonElement>) => {
      event.preventDefault();
      actionOnClick();
    };

  return (
    <div
      id={id}
      className={`${currentVariant.container} ${currentVariant.background} ${currentVariant.border} ${
        variant !== "inline" ? currentSize.padding : ""
      } ${className}`}
      role="alert"
      aria-live="polite"
    >
      {showIcon && variant !== "inline" && (
        <div className={`flex-shrink-0 ${currentIcon.colorClass}`}>
          <div className={currentSize.iconSize}>{currentIcon.icon}</div>
        </div>
      )}

      <div className={`flex-1 ${variant !== "inline" && showIcon ? "ml-3" : ""}`}>
        {title && (
          <h3
            className={`font-medium ${currentIcon.colorClass} ${currentSize.text} mb-1`}
          >
            {title}
          </h3>
        )}

        <div
          className={`${currentSize.text} ${
            variant === "inline" ? "inline-flex items-center space-x-2" : ""
          }`}
        >
          {variant === "inline" && showIcon && (
            <div className={`flex-shrink-0 ${currentIcon.colorClass}`}>
              <div className={currentSize.iconSize}>{currentIcon.icon}</div>
            </div>
          )}

          <div className={currentIcon.colorClass}>
            {hasMultipleErrors ? (
              <ul
                className={
                  variant === "inline"
                    ? "inline"
                    : "list-disc list-inside space-y-1"
                }
              >
                {errorArray.map((errorItem, index) => (
                  <li key={index}>
                    {variant === "inline" && index > 0 && ", "}
                    {errorItem}
                  </li>
                ))}
              </ul>
            ) : (
              <span>{errorArray[0]}</span>
            )}
          </div>
        </div>

        {actions.length > 0 && variant !== "inline" && (
          <div className="mt-3 flex space-x-2">
            {actions.map((action, index) => (
              <button
                key={index}
                type="button"
                onClick={handleActionClick(action.onClick)}
                className={`px-3 py-1 rounded text-sm font-medium transition-colors duration-200 ${
                  action.variant === "primary"
                    ? `${
                        severity === "error"
                          ? "bg-red-600 hover:bg-red-700"
                          : severity === "warning"
                          ? "bg-yellow-600 hover:bg-yellow-700"
                          : "bg-blue-600 hover:bg-blue-700"
                      } text-white`
                    : `${
                        severity === "error"
                          ? "text-red-600 hover:text-red-800 hover:bg-red-100"
                          : severity === "warning"
                          ? "text-yellow-600 hover:text-yellow-800 hover:bg-yellow-100"
                          : "text-blue-600 hover:text-blue-800 hover:bg-blue-100"
                      } border ${
                        severity === "error"
                          ? "border-red-300"
                          : severity === "warning"
                          ? "border-yellow-300"
                          : "border-blue-300"
                      }`
                }`}
              >
                {action.label}
              </button>
            ))}
          </div>
        )}
      </div>

      {dismissible && (
        <div className="ml-auto pl-3">
          <button
            type="button"
            onClick={handleDismiss}
            className={`inline-flex rounded-md p-1.5 focus:outline-none focus:ring-2 focus:ring-offset-2 ${currentIcon.colorClass} hover:bg-gray-100 focus:ring-gray-500`}
            aria-label="Dismiss"
          >
            <svg className="w-5 h-5" fill="currentColor" viewBox="0 0 20 20">
              <path
                fillRule="evenodd"
                d="M4.293 4.293a1 1 0 011.414 0L10 
                8.586l4.293-4.293a1 1 0 
                111.414 1.414L11.414 10l4.293 
                4.293a1 1 0 01-1.414 1.414L10 
                11.414l-4.293 4.293a1 1 0 
                01-1.414-1.414L8.586 10 4.293 
                5.707a1 1 0 010-1.414z"
                clipRule="evenodd"
              />
            </svg>
          </button>
        </div>
      )}
    </div>
  );
};

```

<!-- path: components/common/ui/Modal/DetailsModal.tsx -->
```typescript
import { motion, AnimatePresence } from "framer-motion";
import { FiX } from "react-icons/fi";
import Image from "next/image";
import { Modal } from "@/components/common/ui";
import { CardSpinner } from "@/components/common/ui/LoadingSpinner";
import { ReactNode } from "react";

type FieldKey<T extends Record<string, unknown>> = keyof T | string;

export interface FieldConfig<T extends Record<string, unknown>> {
  key: FieldKey<T>;
  label: string;
  icon?: ReactNode;
  formatter?: (value: unknown, data: T) => ReactNode;
  condition?: (data: T) => boolean;
  className?: string;
}

export interface SectionConfig<T extends Record<string, unknown>> {
  title: string;
  icon?: ReactNode;
  fields: FieldConfig<T>[];
  condition?: (data: T) => boolean;
  className?: string;
  renderCustom?: (data: T) => ReactNode;
}

export interface HeaderConfig<T extends Record<string, unknown>> {
  title: (data: T) => string;
  subtitle?: (data: T) => string;
  avatar?: {
    urlKey: FieldKey<T>;
    fallbackText: (data: T) => string;
  };
  badges?: Array<{
    key: FieldKey<T>;
    component: (value: unknown, data: T) => ReactNode;
  }>;
}

export interface DetailsModalProps<T extends Record<string, unknown> = Record<string, unknown>> {
  data: T | null;
  onClose: () => void;
  isOpen: boolean;
  config: {
    header: HeaderConfig<T>;
    sections: SectionConfig<T>[];
  };
  loading?: boolean;
  className?: string;
}

const defaultFormatters = {
  date: (dateString: string | null | undefined): string => {
    if (!dateString) return "Not provided";
    try {
      return new Date(dateString).toLocaleDateString("en-US", {
        year: "numeric",
        month: "long",
        day: "numeric",
      });
    } catch {
      return "Invalid date";
    }
  },

  dateTime: (dateString: string | null | undefined): string => {
    if (!dateString) return "Never";
    try {
      return new Date(dateString).toLocaleString("en-US", {
        year: "numeric",
        month: "short",
        day: "numeric",
        hour: "2-digit",
        minute: "2-digit",
      });
    } catch {
      return "Invalid date";
    }
  },

  address: (
    address:
      | Partial<{
          street?: string;
          city?: string;
          state?: string;
          zip_code?: string;
          zipCode?: string;
          country?: string;
        }>
      | null
      | undefined,
  ): string | null => {
    if (!address) return null;
    const parts = [
      address.street,
      address.city,
      address.state,
      address.zip_code ?? address.zipCode,
      address.country,
    ].filter(Boolean) as string[];
    return parts.length > 0 ? parts.join(", ") : null;
  },

  json: (value: unknown): ReactNode => {
    if (value === null || value === undefined) return "Not provided";
    return (
      <pre className="text-sm text-gray-700 dark:text-gray-300 whitespace-pre-wrap font-mono leading-relaxed overflow-x-auto">
        {JSON.stringify(value, null, 2)}
      </pre>
    );
  },

  boolean: (value: boolean): ReactNode => (
    <span
      className={`text-xs px-3 py-1 rounded-full font-semibold ${
        value
          ? "bg-green-100 text-green-700 dark:bg-green-900/30 dark:text-green-400"
          : "bg-red-100 text-red-700 dark:bg-red-900/30 dark:text-red-400"
      }`}
    >
      {value ? "✓ Yes" : "✗ No"}
    </span>
  ),

  email: (email: string, isVerified?: boolean): ReactNode => (
    <div className="flex items-center justify-between">
      <span className="text-gray-900 dark:text-white font-medium flex-1">{email}</span>
      {typeof isVerified === "boolean" && (
        <span
          className={`text-xs px-3 py-1 rounded-full font-semibold ml-3 ${
            isVerified
              ? "bg-green-100 text-green-700 dark:bg-green-900/30 dark:text-green-400"
              : "bg-red-100 text-red-700 dark:bg-red-900/30 dark:text-red-400"
          }`}
        >
          {isVerified ? "✓ Verified" : "✗ Unverified"}
        </span>
      )}
    </div>
  ),
} as const;

const formatDefaultValue = (value: unknown): ReactNode => {
  if (value === null || value === undefined) {
    return "Not provided";
  }

  if (typeof value === "string") {
    return value.trim() ? value : "Not provided";
  }

  if (typeof value === "number" || typeof value === "bigint") {
    return value.toString();
  }

  if (typeof value === "boolean") {
    return defaultFormatters.boolean(value);
  }

  return defaultFormatters.json(value);
};

const getNestedValue = <T extends Record<string, unknown>>(obj: T, key: string): unknown => {
  return key.split(".").reduce<unknown>((current, prop) => {
    if (current === null || current === undefined) return undefined;
    if (typeof current !== "object") return undefined;
    return (current as Record<string, unknown>)[prop];
  }, obj);
};

const DetailsModal = <T extends Record<string, unknown>>({
  data,
  onClose,
  isOpen,
  config,
  loading = false,
  className = "",
}: DetailsModalProps<T>) => {
  const containerVariants = {
    hidden: { opacity: 0 },
    visible: {
      opacity: 1,
      transition: {
        duration: 0.3,
        staggerChildren: 0.1,
      },
    },
    exit: {
      opacity: 0,
      transition: {
        duration: 0.2,
      },
    },
  };

  const modalVariants = {
    hidden: {
      opacity: 0,
      scale: 0.8,
      y: 50,
    },
    visible: {
      opacity: 1,
      scale: 1,
      y: 0,
      transition: {
        type: "spring" as const,
        damping: 25,
        stiffness: 300,
      },
    },
    exit: {
      opacity: 0,
      scale: 0.9,
      y: 30,
      transition: {
        duration: 0.2,
      },
    },
  };

  const sectionVariants = {
    hidden: { opacity: 0, y: 20 },
    visible: {
      opacity: 1,
      y: 0,
      transition: {
        duration: 0.4,
        ease: "easeOut" as const,
      },
    },
  };

  const fieldVariants = {
    hidden: { opacity: 0, x: -10 },
    visible: {
      opacity: 1,
      x: 0,
      transition: {
        duration: 0.3,
      },
    },
  };

  const renderField = (field: FieldConfig<T>, record: T) => {
    if (field.condition && !field.condition(record)) {
      return null;
    }

    const key = String(field.key);
    const value = getNestedValue(record, key);
    const formattedValue = field.formatter ? field.formatter(value, record) : formatDefaultValue(value);
    const isPrimitive = typeof formattedValue === "string" || typeof formattedValue === "number";

    return (
      <motion.div
        key={key}
        className={`group ${field.className || ""}`}
        variants={fieldVariants}
        whileHover={{ x: 4 }}
        transition={{ type: "spring", stiffness: 300 }}
      >
        <label className="text-sm font-semibold text-gray-500 dark:text-gray-400 block mb-2 uppercase tracking-wider">
          {field.label}
        </label>
        <div className="p-3 bg-gray-50 dark:bg-gray-800 rounded-lg border border-gray-200 dark:border-gray-700 group-hover:border-blue-300 dark:group-hover:border-blue-600 transition-colors">
          <div className="flex items-center gap-3">
            {field.icon && <div className="text-gray-400 flex-shrink-0">{field.icon}</div>}
            <div className="flex-1">
              {isPrimitive ? (
                <p className="text-gray-900 dark:text-white font-medium">{formattedValue}</p>
              ) : (
                formattedValue
              )}
            </div>
          </div>
        </div>
      </motion.div>
    );
  };

  const renderSection = (section: SectionConfig<T>, record: T) => {
    if (section.condition && !section.condition(record)) {
      return null;
    }

    return (
      <motion.div
        key={section.title}
        className={`space-y-6 ${section.className || ""}`}
        variants={sectionVariants}
      >
        <div className="flex items-center gap-3 pb-3 border-b border-gray-200 dark:border-gray-700">
          {section.icon && <div className="p-2 bg-blue-100 dark:bg-blue-900/30 rounded-lg">{section.icon}</div>}
          <h3 className="text-xl font-semibold text-gray-900 dark:text-white">{section.title}</h3>
        </div>

        {section.renderCustom ? (
          section.renderCustom(record)
        ) : (
          <div className="space-y-5">
            {section.fields.map((fieldConfig) => renderField(fieldConfig, record))}
          </div>
        )}
      </motion.div>
    );
  };

  const renderHeader = (record: T) => {
    const { header } = config;
    const title = header.title(record);
    const subtitle = header.subtitle ? header.subtitle(record) : null;
    const avatarKey = header.avatar ? String(header.avatar.urlKey) : null;
    const avatarValue = avatarKey ? getNestedValue(record, avatarKey) : undefined;
    const avatarUrl = typeof avatarValue === "string" ? avatarValue : undefined;

    return (
      <div className="relative px-8 py-6 bg-gradient-to-r from-blue-50 via-indigo-50 to-purple-50 dark:from-gray-800 dark:via-gray-850 dark:to-gray-900 border-b border-gray-200/50 dark:border-gray-700/50">
        <div className="flex items-center justify-between">
          <motion.div className="flex items-center gap-4" variants={fieldVariants}>
            {header.avatar && (
              <motion.div
                className="flex-shrink-0 relative"
                whileHover={{ scale: 1.05 }}
                transition={{ type: "spring", stiffness: 300 }}
              >
                {avatarUrl ? (
                  <div className="relative">
                    <Image
                      className="h-16 w-16 rounded-full object-cover border-4 border-white shadow-lg ring-2 ring-blue-500/20"
                      src={avatarUrl}
                      alt={title}
                      width={64}
                      height={64}
                      onError={(e) => {
                        e.currentTarget.style.display = "none";
                        e.currentTarget.nextElementSibling?.classList.remove("hidden");
                      }}
                    />
                    <div className="absolute -bottom-1 -right-1 w-5 h-5 bg-green-500 border-2 border-white rounded-full"></div>
                  </div>
                ) : null}
                <div
                  className={`h-16 w-16 rounded-full bg-gradient-to-br from-blue-500 to-indigo-600 flex items-center justify-center shadow-lg ring-2 ring-blue-500/20 ${
                    avatarUrl ? "hidden" : ""
                  }`}
                >
                  <span className="text-xl font-bold text-white">{header.avatar.fallbackText(record)}</span>
                  <div className="absolute -bottom-1 -right-1 w-5 h-5 bg-green-500 border-2 border-white rounded-full"></div>
                </div>
              </motion.div>
            )}
            <div className="space-y-1">
              <motion.h2 className="text-2xl font-bold text-gray-900 dark:text-white" variants={fieldVariants}>
                {title}
              </motion.h2>
              {subtitle && (
                <motion.p className="text-gray-600 dark:text-gray-300 font-medium" variants={fieldVariants}>
                  {subtitle}
                </motion.p>
              )}
              {header.badges && (
                <motion.div className="flex items-center gap-2 flex-wrap" variants={fieldVariants}>
                  {header.badges.map((badge, index) => (
                    <div key={`${String(badge.key)}-${index}`}>
                      {badge.component(getNestedValue(record, String(badge.key)), record)}
                    </div>
                  ))}
                </motion.div>
              )}
            </div>
          </motion.div>
          <motion.button
            onClick={onClose}
            className="text-gray-400 hover:text-gray-600 dark:hover:text-gray-300 p-3 rounded-xl hover:bg-white/50 dark:hover:bg-gray-800/50 transition-all duration-200 backdrop-blur-sm"
            aria-label="Close modal"
            whileHover={{ scale: 1.1, rotate: 90 }}
            whileTap={{ scale: 0.95 }}
            transition={{ type: "spring", stiffness: 300 }}
          >
            <FiX size={24} />
          </motion.button>
        </div>
      </div>
    );
  };

  return (
    <AnimatePresence mode="wait">
      {isOpen && (
        <Modal isOpen={isOpen} onClose={onClose}>
          {loading ? (
            <motion.div
              initial={{ opacity: 0 }}
              animate={{ opacity: 1 }}
              exit={{ opacity: 0 }}
              className="fixed inset-0 bg-black/60 backdrop-blur-sm flex items-center justify-center z-50"
            >
              <CardSpinner />
            </motion.div>
          ) : data ? (
            <motion.div
              variants={containerVariants}
              initial="hidden"
              animate="visible"
              exit="exit"
              className="fixed inset-0 bg-black/60 backdrop-blur-sm flex items-center justify-center z-50 p-4"
            >
              <motion.div
                variants={modalVariants}
                className={`bg-white dark:bg-gray-900 rounded-2xl shadow-2xl max-w-5xl w-full max-h-[90vh] overflow-hidden border border-gray-200/50 dark:border-gray-700/50 ${className}`}
              >
                {renderHeader(data)}
                <div className="p-8 overflow-y-auto max-h-[calc(90vh-160px)] custom-scrollbar">
                  <div className="grid grid-cols-1 xl:grid-cols-2 gap-8">
                    {config.sections.map((section) => renderSection(section, data))}
                  </div>
                </div>
              </motion.div>
            </motion.div>
          ) : null}
        </Modal>
      )}
    </AnimatePresence>
  );
};

export { DetailsModal, defaultFormatters };

```

<!-- path: components/common/ui/Modal/ChangePasswordModal.tsx -->
```typescript
// components/common/Modal/ChangePasswordModal.tsx
import { useState } from "react";
import { FiEye, FiEyeOff } from "react-icons/fi";
import { toast } from "sonner";
import { LoadingSpinner } from "../LoadingSpinner";
import { Modal } from "./Modal"; // Make sure your Modal component is correctly imported

// --- MODIFIED Type Definition ---
export interface ChangePasswordData {
  newPassword: string;
  // currentPassword is no longer needed for the API call
}

interface ChangePasswordModalProps {
  onClose: () => void;
  // This function signature now matches our store
  changePassword: (data: ChangePasswordData) => Promise<boolean>;
  isLoading: boolean;
  isOpen: boolean;
}

export const ChangePasswordModal = ({
  isOpen,
  onClose,
  changePassword,
  isLoading,
}: ChangePasswordModalProps) => {
  // --- REMOVED currentPassword state ---
  const [newPassword, setNewPassword] = useState("");
  const [confirmPassword, setConfirmPassword] = useState("");
  const [showNewPassword, setShowNewPassword] = useState(false);

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    if (newPassword.length < 8) {
      toast.error("Password must be at least 8 characters long.");
      return;
    }
    if (newPassword !== confirmPassword) {
      toast.error("New passwords do not match.");
      return;
    }

    // --- MODIFIED: Call the function with the new data shape ---
    const success = await changePassword({ newPassword });

    if (success) {
      toast.success("Password updated successfully!");
      onClose();
    }
  };

  return (
    <Modal isOpen={isOpen} onClose={onClose} visible={false}
      className="h-screen w-screen transparent bg-gray-700 rounded-2xl">
      <form onSubmit={handleSubmit} className="p-6">
        <div className="flex items-start justify-between">
          <h3 className="text-lg font-medium text-gray-900 dark:text-white">
            Change Password
          </h3>
        </div>
        <div className="mt-4 space-y-4">
          {/* --- REMOVED Current Password Input Block --- */}

          <div className="relative">
            <label className="block text-sm font-medium text-gray-700 dark:text-gray-300">
              New Password
            </label>
            <input
              type={showNewPassword ? "text" : "password"}
              value={newPassword}
              onChange={(e) => setNewPassword(e.target.value)}
              required
              className="mt-1 w-full rounded-md border border-gray-300 bg-white px-3 py-2 text-gray-900 shadow-sm focus:ring-2 focus:ring-blue-500 dark:border-gray-600 dark:bg-gray-700 dark:text-white"
            />
            <button
              type="button"
              onClick={() => setShowNewPassword(!showNewPassword)}
              className="absolute right-0 bottom-2.5 flex items-center px-3 text-gray-400"
            >
              {showNewPassword ? <FiEyeOff /> : <FiEye />}
            </button>
          </div>
          <div>
            <label className="block text-sm font-medium text-gray-700 dark:text-gray-300">
              Confirm New Password
            </label>
            <input
              type={showNewPassword ? "text" : "password"}
              value={confirmPassword}
              onChange={(e) => setConfirmPassword(e.target.value)}
              required
              className="mt-1 w-full rounded-md border border-gray-300 bg-white px-3 py-2 text-gray-900 shadow-sm focus:ring-2 focus:ring-blue-500 dark:border-gray-600 dark:bg-gray-700 dark:text-white"
            />
          </div>
        </div>
        <div className="mt-6 flex justify-end space-x-3">
          <button
            type="button"
            onClick={onClose}
            className="rounded-md border border-gray-300 bg-white px-4 py-2 text-sm font-medium text-gray-700 hover:bg-gray-50 dark:border-gray-600 dark:bg-gray-800 dark:text-gray-300 dark:hover:bg-gray-700"
          >
            Cancel
          </button>
          <button
            type="submit"
            disabled={isLoading}
            className="inline-flex w-[120px] items-center justify-center rounded-md border border-transparent bg-blue-600 px-4 py-2 text-sm font-medium text-white hover:bg-blue-700 disabled:opacity-50"
          >
            {isLoading ? <LoadingSpinner size="sm" /> : "Save Changes"}
          </button>
        </div>
      </form>
    </Modal>
  );
};
```

<!-- path: components/common/ui/Modal/confirmModal.tsx -->
```typescript
import React, { useState, useEffect, useCallback, useRef } from 'react';

// Icon components with proper TypeScript support
interface IconProps {
  className?: string;
}

const icons = {
  Warning: ({ className = "w-6 h-6" }: IconProps) => (
    <svg className={className} fill="currentColor" viewBox="0 0 20 20">
      <path fillRule="evenodd" d="M8.257 3.099c.765-1.36 2.722-1.36 3.486 0l5.58 9.92c.75 1.334-.213 2.98-1.742 2.98H4.42c-1.53 0-2.493-1.646-1.743-2.98l5.58-9.92zM11 13a1 1 0 11-2 0 1 1 0 012 0zm-1-8a1 1 0 00-1 1v3a1 1 0 002 0V6a1 1 0 00-1-1z" clipRule="evenodd" />
    </svg>
  ),
  Close: ({ className = "w-5 h-5" }: IconProps) => (
    <svg className={className} fill="currentColor" viewBox="0 0 20 20">
      <path fillRule="evenodd" d="M4.293 4.293a1 1 0 011.414 0L10 8.586l4.293-4.293a1 1 0 111.414 1.414L11.414 10l4.293 4.293a1 1 0 01-1.414 1.414L10 11.414l-4.293 4.293a1 1 0 01-1.414-1.414L8.586 10 4.293 5.707a1 1 0 010-1.414z" clipRule="evenodd" />
    </svg>
  ),
  Check: ({ className = "w-6 h-6" }: IconProps) => (
    <svg className={className} fill="currentColor" viewBox="0 0 20 20">
      <path fillRule="evenodd" d="M16.707 5.293a1 1 0 010 1.414l-8 8a1 1 0 01-1.414 0l-4-4a1 1 0 011.414-1.414L8 12.586l7.293-7.293a1 1 0 011.414 0z" clipRule="evenodd" />
    </svg>
  ),
  Error: ({ className = "w-6 h-6" }: IconProps) => (
    <svg className={className} fill="currentColor" viewBox="0 0 20 20">
      <path fillRule="evenodd" d="M18 10a8 8 0 11-16 0 8 8 0 0116 0zm-7 4a1 1 0 11-2 0 1 1 0 012 0zm-1-9a1 1 0 00-1 1v4a1 1 0 102 0V6a1 1 0 00-1-1z" clipRule="evenodd" />
    </svg>
  ),
  Info: ({ className = "w-6 h-6" }: IconProps) => (
    <svg className={className} fill="currentColor" viewBox="0 0 20 20">
      <path fillRule="evenodd" d="M18 10a8 8 0 11-16 0 8 8 0 0116 0zm-7-4a1 1 0 11-2 0 1 1 0 012 0zM9 9a1 1 0 000 2v3a1 1 0 001 1h1a1 1 0 100-2v-3a1 1 0 00-1-1H9z" clipRule="evenodd" />
    </svg>
  ),
  Help: ({ className = "w-6 h-6" }: IconProps) => (
    <svg className={className} fill="currentColor" viewBox="0 0 20 20">
      <path fillRule="evenodd" d="M18 10a8 8 0 11-16 0 8 8 0 0116 0zm-8-3a1 1 0 00-.867.5 1 1 0 11-1.731-1A3 3 0 0113 8a3.001 3.001 0 01-2 2.83V11a1 1 0 11-2 0v-1a1 1 0 011-1 1 1 0 100-2zm0 8a1 1 0 100-2 1 1 0 000 2z" clipRule="evenodd" />
    </svg>
  ),
};

type ModalType = 'default' | 'danger' | 'warning' | 'info' | 'success';

interface ConfirmModalProps {
  isOpen: boolean;
  onConfirm: () => void | Promise<void>;
  onCancel: () => void;
  title?: string;
  message?: string | React.ReactNode;
  confirmText?: string;
  cancelText?: string;
  type?: ModalType;
  showIcon?: boolean;
  closeOnBackdrop?: boolean;
  closeOnEscape?: boolean;
  loading?: boolean;
  size?: 'sm' | 'md' | 'lg';
  className?: string;
  confirmButtonProps?: React.ButtonHTMLAttributes<HTMLButtonElement>;
  cancelButtonProps?: React.ButtonHTMLAttributes<HTMLButtonElement>;
}

const LoadingSpinner: React.FC<{ size?: 'sm' | 'md' }> = ({ size = 'md' }) => (
  <div
    className={`border-2 border-current border-t-transparent rounded-full animate-spin ${
      size === 'sm' ? 'w-4 h-4' : 'w-5 h-5'
    }`}
    aria-hidden="true"
  />
);

export const ConfirmModal: React.FC<ConfirmModalProps> = ({
  isOpen,
  onConfirm,
  onCancel,
  title = 'Confirm Action',
  message = 'Are you sure you want to proceed?',
  confirmText = 'Confirm',
  cancelText = 'Cancel',
  type = 'default',
  showIcon = true,
  closeOnBackdrop = true,
  closeOnEscape = true,
  loading = false,
  size = 'md',
  className,
  confirmButtonProps = {},
  cancelButtonProps = {},
}) => {
  const [isVisible, setIsVisible] = useState(false);
  const [isAnimating, setIsAnimating] = useState(false);
  const modalRef = useRef<HTMLDivElement>(null);
  const confirmButtonRef = useRef<HTMLButtonElement>(null);
  const cancelButtonRef = useRef<HTMLButtonElement>(null);
  const previousActiveElement = useRef<HTMLElement | null>(null);
  

  // Handle modal opening/closing
  useEffect(() => {
    if (isOpen) {
      // Store previously focused element
      previousActiveElement.current = document.activeElement as HTMLElement;
      
      setIsVisible(true);
      // Use requestAnimationFrame for smoother animations
      requestAnimationFrame(() => {
        setIsAnimating(true);
      });

      // Prevent body scroll
      document.body.style.overflow = 'hidden';
      document.body.style.paddingRight = `${window.innerWidth - document.documentElement.clientWidth}px`;
    } else {
      setIsAnimating(false);
      const timer = setTimeout(() => {
        setIsVisible(false);
        // Restore body scroll
        document.body.style.overflow = '';
        document.body.style.paddingRight = '';
        
        // Restore focus to previously active element
        if (previousActiveElement.current) {
          previousActiveElement.current.focus();
        }
      }, 200);

      return () => clearTimeout(timer);
    }
  }, [isOpen]);

  // Handle escape key
  const handleKeyDown = useCallback(
    (e: KeyboardEvent) => {
      if (!isOpen) return;

      if (e.key === 'Escape' && closeOnEscape && !loading) {
        onCancel();
        return;
      }

      // Handle tab navigation within modal
      if (e.key === 'Tab') {
        const focusableElements = modalRef.current?.querySelectorAll(
          'button, [href], input, select, textarea, [tabindex]:not([tabindex="-1"])'
        );

        if (!focusableElements?.length) return;

        const firstElement = focusableElements[0] as HTMLElement;
        const lastElement = focusableElements[focusableElements.length - 1] as HTMLElement;

        if (e.shiftKey) {
          // Shift + Tab
          if (document.activeElement === firstElement) {
            e.preventDefault();
            lastElement.focus();
          }
        } else {
          // Tab
          if (document.activeElement === lastElement) {
            e.preventDefault();
            firstElement.focus();
          }
        }
      }
    },
    [isOpen, closeOnEscape, loading, onCancel]
  );

  useEffect(() => {
    document.addEventListener('keydown', handleKeyDown);
    return () => document.removeEventListener('keydown', handleKeyDown);
  }, [handleKeyDown]);

  // Focus management
  useEffect(() => {
    if (isOpen && isAnimating) {
      // Focus the cancel button by default (safer option)
      setTimeout(() => {
        cancelButtonRef.current?.focus();
      }, 100);
    }
  }, [isOpen, isAnimating]);

  const handleBackdropClick = (e: React.MouseEvent) => {
    if (e.target === e.currentTarget && closeOnBackdrop && !loading) {
      onCancel();
    }
  };

  const handleConfirm = async () => {
    if (loading) return;
    
    try {
      await onConfirm();
    } catch (error) {
      console.error('Confirm action failed:', error);
    }
  };

  const getIcon = () => {
    const className = `w-6 h-6 ${getIconColor()}`;
    
    switch (type) {
      case 'danger':
        return <icons.Error className={className} />;
      case 'warning':
        return <icons.Warning className={className} />;
      case 'info':
        return <icons.Info className={className} />;
      case 'success':
        return <icons.Check className={className} />;
      default:
        return <icons.Help className={className} />;
    }
  };

  const getIconColor = () => {
    switch (type) {
      case 'danger':
        return 'text-red-500 dark:text-red-400';
      case 'warning':
        return 'text-yellow-500 dark:text-yellow-400';
      case 'info':
        return 'text-blue-500 dark:text-blue-400';
      case 'success':
        return 'text-green-500 dark:text-green-400';
      default:
        return 'text-gray-500 dark:text-gray-400';
    }
  };

  const getButtonStyles = () => {
    const baseConfirm = 'text-white font-medium transition-all duration-200 focus:outline-none focus:ring-2 focus:ring-offset-2 disabled:opacity-50 disabled:cursor-not-allowed';
    const baseCancel = 'font-medium transition-all duration-200 focus:outline-none focus:ring-2 focus:ring-offset-2 disabled:opacity-50 disabled:cursor-not-allowed';

    switch (type) {
      case 'danger':
        return {
          confirm: `${baseConfirm} bg-red-600 hover:bg-red-700 focus:ring-red-500 active:bg-red-800 dark:bg-red-700 dark:hover:bg-red-800 dark:focus:ring-red-600 dark:active:bg-red-900`,
          cancel: `${baseCancel} bg-gray-100 hover:bg-gray-200 text-gray-900 focus:ring-gray-500 dark:bg-gray-700 dark:hover:bg-gray-600 dark:text-gray-100 dark:focus:ring-gray-500`,
        };
      case 'warning':
        return {
          confirm: `${baseConfirm} bg-yellow-600 hover:bg-yellow-700 focus:ring-yellow-500 active:bg-yellow-800 dark:bg-yellow-700 dark:hover:bg-yellow-800 dark:focus:ring-yellow-600 dark:active:bg-yellow-900`,
          cancel: `${baseCancel} bg-gray-100 hover:bg-gray-200 text-gray-900 focus:ring-gray-500 dark:bg-gray-700 dark:hover:bg-gray-600 dark:text-gray-100 dark:focus:ring-gray-500`,
        };
      case 'success':
        return {
          confirm: `${baseConfirm} bg-green-600 hover:bg-green-700 focus:ring-green-500 active:bg-green-800 dark:bg-green-700 dark:hover:bg-green-800 dark:focus:ring-green-600 dark:active:bg-green-900`,
          cancel: `${baseCancel} bg-gray-100 hover:bg-gray-200 text-gray-900 focus:ring-gray-500 dark:bg-gray-700 dark:hover:bg-gray-600 dark:text-gray-100 dark:focus:ring-gray-500`,
        };
      case 'info':
        return {
          confirm: `${baseConfirm} bg-blue-600 hover:bg-blue-700 focus:ring-blue-500 active:bg-blue-800 dark:bg-blue-700 dark:hover:bg-blue-800 dark:focus:ring-blue-600 dark:active:bg-blue-900`,
          cancel: `${baseCancel} bg-gray-100 hover:bg-gray-200 text-gray-900 focus:ring-gray-500 dark:bg-gray-700 dark:hover:bg-gray-600 dark:text-gray-100 dark:focus:ring-gray-500`,
        };
      default:
        return {
          confirm: `${baseConfirm} bg-gray-900 hover:bg-gray-800 focus:ring-gray-700 active:bg-gray-950 dark:bg-gray-800 dark:hover:bg-gray-700 dark:focus:ring-gray-600 dark:active:bg-gray-900`,
          cancel: `${baseCancel} bg-gray-100 hover:bg-gray-200 text-gray-900 focus:ring-gray-500 dark:bg-gray-700 dark:hover:bg-gray-600 dark:text-gray-100 dark:focus:ring-gray-500`,
        };
    }
  };

  const getSizeClasses = () => {
    switch (size) {
      case 'sm':
        return 'max-w-sm';
      case 'lg':
        return 'max-w-lg';
      default:
        return 'max-w-md';
    }
  };

  const buttonStyles = getButtonStyles();

  if (!isVisible) return null;

  return (
    <div
      className={`fixed inset-0 z-50 flex items-center justify-center p-4 transition-all duration-200 ${
        isAnimating ? 'bg-black/50 dark:bg-black/70 backdrop-blur-sm' : 'bg-black/0'
      }`}
      onClick={handleBackdropClick}
      role="presentation"
    >
      <div
        ref={modalRef}
        className={`bg-white dark:bg-gray-900 rounded-xl shadow-2xl w-full transform transition-all duration-200 ${getSizeClasses()} ${
          isAnimating ? 'scale-100 opacity-100 translate-y-0' : 'scale-95 opacity-0 translate-y-4'
        } ${className || ''}`}
        role="dialog"
        aria-modal="true"
        aria-labelledby="modal-title"
        aria-describedby="modal-description"
      >
        {/* Header */}
        <div className="px-6 py-5 border-b border-gray-200 dark:border-gray-700">
          <div className="flex items-center justify-between">
            <div className="flex items-center space-x-3">
              {showIcon && (
                <div className="flex-shrink-0" aria-hidden="true">
                  {getIcon()}
                </div>
              )}
              <h3 
                id="modal-title" 
                className="text-lg font-semibold text-gray-900 dark:text-gray-100 leading-6"
              >
                {title}
              </h3>
            </div>
            <button
              onClick={onCancel}
              disabled={loading}
              className="flex-shrink-0 text-gray-400 hover:text-gray-600 dark:hover:text-gray-300 transition-colors p-2 rounded-full hover:bg-gray-100 dark:hover:bg-gray-800 focus:outline-none focus:ring-2 focus:ring-gray-500 disabled:opacity-50 disabled:cursor-not-allowed"
              aria-label="Close modal"
              type="button"
            >
              <icons.Close />
            </button>
          </div>
        </div>

        {/* Body */}
        <div className="px-6 py-5">
          <div id="modal-description" className="text-gray-600 dark:text-gray-300 leading-relaxed">
            {typeof message === 'string' ? (
              <p>{message}</p>
            ) : (
              message
            )}
          </div>
        </div>

        {/* Footer */}
        <div className="px-6 py-4 bg-gray-50 dark:bg-gray-800 rounded-b-xl flex justify-end space-x-3">
          <button
            ref={cancelButtonRef}
            onClick={onCancel}
            disabled={loading}
            className={`px-5 py-2.5 rounded-lg ${buttonStyles.cancel}`}
            type="button"
            {...cancelButtonProps}
          >
            {cancelText}
          </button>
          <button
            ref={confirmButtonRef}
            onClick={handleConfirm}
            disabled={loading}
            className={`px-5 py-2.5 rounded-lg ${buttonStyles.confirm} ${
              loading ? 'cursor-wait' : ''
            }`}
            type="button"
            {...confirmButtonProps}
          >
            {loading ? (
              <div className="flex items-center space-x-2" aria-label="Loading">
                <LoadingSpinner size="sm" />
                <span>Loading...</span>
              </div>
            ) : (
              confirmText
            )}
          </button>
        </div>
      </div>
    </div>
  );
};

// Hook for easier modal management
export const useConfirmModal = () => {
  const [isOpen, setIsOpen] = useState(false);
  const [loading, setLoading] = useState(false);
  const resolveRef = useRef<((value: boolean) => void) | null>(null);

  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  const confirm = useCallback((options?: Partial<ConfirmModalProps>): Promise<boolean> => {
    return new Promise((resolve) => {
      resolveRef.current = resolve;
      setIsOpen(true);
    });
  }, []);

  const handleConfirm = useCallback(async () => {
    if (resolveRef.current) {
      resolveRef.current(true);
      resolveRef.current = null;
    }
    setIsOpen(false);
    setLoading(false);
  }, []);

  const handleCancel = useCallback(() => {
    if (resolveRef.current) {
      resolveRef.current(false);
      resolveRef.current = null;
    }
    setIsOpen(false);
    setLoading(false);
  }, []);

  return {
    isOpen,
    loading,
    setLoading,
    confirm,
    handleConfirm,
    handleCancel,
  };
};

// Demo component
export const ConfirmModalDemo: React.FC = () => {
  const [modals, setModals] = useState({
    default: false,
    danger: false,
    warning: false,
    info: false,
    success: false,
    loading: false,
  });
  const [isLoading, setIsLoading] = useState(false);

  const openModal = (type: keyof typeof modals) => {
    setModals(prev => ({ ...prev, [type]: true }));
  };

  const closeModal = (type: keyof typeof modals) => {
    setModals(prev => ({ ...prev, [type]: false }));
    setIsLoading(false);
  };

  const handleConfirm = async (type: keyof typeof modals) => {
    if (type === 'loading') {
      setIsLoading(true);
      // Simulate async operation
      await new Promise(resolve => setTimeout(resolve, 2000));
      closeModal(type);
      alert('Action completed!');
    } else {
      closeModal(type);
      alert(`${type} action confirmed!`);
    }
  };

  return (
    <div className="p-8 bg-gray-100 dark:bg-gray-900 min-h-screen">
      <div className="max-w-4xl mx-auto">
        <h1 className="text-3xl font-bold text-gray-900 dark:text-gray-100 mb-8 text-center">
          Improved ConfirmModal Demo
        </h1>
        
        <div className="bg-white dark:bg-gray-800 rounded-lg shadow-md p-6 mb-8">
          <h2 className="text-xl font-semibold mb-4 dark:text-gray-200">Modal Types</h2>
          <div className="grid grid-cols-2 md:grid-cols-3 gap-4">
            {Object.keys(modals).map((type) => (
              <button
                key={type}
                onClick={() => openModal(type as keyof typeof modals)}
                className={`p-3 text-white rounded-md transition-colors font-medium ${
                  type === 'default' ? 'bg-gray-800 hover:bg-gray-900 dark:bg-gray-700 dark:hover:bg-gray-600' :
                  type === 'danger' ? 'bg-red-600 hover:bg-red-700 dark:bg-red-700 dark:hover:bg-red-800' :
                  type === 'warning' ? 'bg-yellow-600 hover:bg-yellow-700 dark:bg-yellow-700 dark:hover:bg-yellow-800' :
                  type === 'info' ? 'bg-blue-600 hover:bg-blue-700 dark:bg-blue-700 dark:hover:bg-blue-800' :
                  type === 'success' ? 'bg-green-600 hover:bg-green-700 dark:bg-green-700 dark:hover:bg-green-800' :
                  'bg-purple-600 hover:bg-purple-700 dark:bg-purple-700 dark:hover:bg-purple-800'
                }`}
              >
                {type.charAt(0).toUpperCase() + type.slice(1)} Modal
              </button>
            ))}
          </div>
        </div>

        {/* Modals */}
        <ConfirmModal
          isOpen={modals.default}
          onConfirm={() => handleConfirm('default')}
          onCancel={() => closeModal('default')}
          title="Confirm Action"
          message="This is a default confirmation modal. Are you sure you want to proceed?"
        />

        <ConfirmModal
          isOpen={modals.danger}
          onConfirm={() => handleConfirm('danger')}
          onCancel={() => closeModal('danger')}
          title="Delete Item"
          message="This action cannot be undone. Are you sure you want to delete this item permanently?"
          confirmText="Delete"
          cancelText="Keep"
          type="danger"
        />

        <ConfirmModal
          isOpen={modals.warning}
          onConfirm={() => handleConfirm('warning')}
          onCancel={() => closeModal('warning')}
          title="Unsaved Changes"
          message="You have unsaved changes that will be lost. Do you want to continue without saving?"
          confirmText="Continue"
          cancelText="Save First"
          type="warning"
        />

        <ConfirmModal
          isOpen={modals.info}
          onConfirm={() => handleConfirm('info')}
          onCancel={() => closeModal('info')}
          title="Information Required"
          message="Before proceeding, please confirm that you have read and understood the terms and conditions."
          confirmText="I Understand"
          cancelText="Cancel"
          type="info"
        />

        <ConfirmModal
          isOpen={modals.success}
          onConfirm={() => handleConfirm('success')}
          onCancel={() => closeModal('success')}
          title="Complete Setup"
          message="Your account setup is almost complete. Would you like to finish the configuration now?"
          confirmText="Complete Setup"
          cancelText="Later"
          type="success"
        />

        <ConfirmModal
          isOpen={modals.loading}
          onConfirm={() => handleConfirm('loading')}
          onCancel={() => closeModal('loading')}
          title="Process Data"
          message="This will process all selected items. This action may take a few moments to complete."
          confirmText="Process"
          cancelText="Cancel"
          type="default"
          loading={isLoading}
        />
      </div>
    </div>
  );
};
```

<!-- path: components/common/ui/Modal/Modal.tsx -->
```typescript
import { AnimatePresence, motion } from "framer-motion";
import { type ReactNode, useEffect } from "react";
import { IoClose } from "react-icons/io5";
import { cn } from "@/utils/classNames";

interface ModalProps {
  isOpen: boolean;
  onClose: () => void;
  title?: string;
  children: ReactNode;
  size?: "sm" | "md" | "lg" | "xl" | "full";
  showCloseButton?: boolean;
  closeOnOverlayClick?: boolean;
  closeOnEscape?: boolean;
  className?: string;
  visible?: boolean;
}

export const Modal = ({
  isOpen,
  onClose,
  title,
  children,
  size = "md",
  showCloseButton = true,
  closeOnOverlayClick = true,
  closeOnEscape = true,
  className,
  visible = true,
}: ModalProps) => {
  // Handle escape key
  useEffect(() => {
    if (!closeOnEscape || !isOpen) return;

    const handleEscape = (e: KeyboardEvent) => {
      if (e.key === "Escape") {
        onClose();
      }
    };

    document.addEventListener("keydown", handleEscape);
    return () => document.removeEventListener("keydown", handleEscape);
  }, [isOpen, closeOnEscape, onClose]);

  // Prevent body scroll when modal is open
  useEffect(() => {
    if (isOpen) {
      document.body.style.overflow = "hidden";
    } else {
      document.body.style.overflow = "unset";
    }

    return () => {
      document.body.style.overflow = "unset";
    };
  }, [isOpen]);

  const sizeClasses = {
    sm: "max-w-md",
    md: "max-w-lg",
    lg: "max-w-2xl",
    xl: "max-w-4xl",
    full: "max-w-[95vw] max-h-[95vh]",
  };

  const handleOverlayClick = (e: React.MouseEvent) => {
    if (closeOnOverlayClick && e.target === e.currentTarget) {
      onClose();
    }
  };

  return (
    <AnimatePresence>
      {isOpen && (
        <div className="fixed inset-0 z-50 flex items-center justify-center p-4">
          {/* Backdrop */}
          <motion.div
            initial={{ opacity: 0 }}
            animate={{ opacity: 1 }}
            exit={{ opacity: 0 }}
            className="absolute inset-0 bg-black/50 backdrop-blur-sm"
            onClick={handleOverlayClick}
          />

          {/* Modal */}
          <motion.div
            initial={{ opacity: 0, scale: 0.95, y: 20 }}
            animate={{ opacity: 1, scale: 1, y: 0 }}
            exit={{ opacity: 0, scale: 0.95, y: 20 }}
            transition={{ type: "spring", duration: 0.3 }}
            className={cn(
              "relative max-h-screen w-full overflow-y-auto rounded-lg bg-white shadow-xl",
              "dark:bg-gray-900 dark:border dark:border-gray-700 dark:shadow-lg dark:shadow-gray-900/50",
              sizeClasses[size],
              className,
            )}
          >
            {/* Header */}
            {(title || showCloseButton) && visible && (
              <div className="flex items-center justify-between border-b border-gray-200 p-6">
                {title && (
                  <h2 className="text-xl font-semibold text-gray-900">
                    {title}
                  </h2>
                )}
                {showCloseButton && (
                  <button
                    onClick={onClose}
                    className="rounded-full p-2 text-gray-400 transition-colors hover:bg-gray-100 hover:text-gray-600"
                    aria-label="Close modal"
                  >
                    <IoClose size={20} />
                  </button>
                )}
              </div>
            )}

            {/* Content */}
            <div className="p-6">{children}</div>
          </motion.div>
        </div>
      )}
    </AnimatePresence>
  );
};

```

<!-- path: components/common/ui/Modal/index.ts -->
```typescript
// Base Modal Component
export { Modal } from './Modal';

// Confirm Modal Components
export { ConfirmModal, useConfirmModal } from './confirmModal';

// ChangePasswordModal Components
export { ChangePasswordModal } from './ChangePasswordModal';

```

<!-- path: components/common/ui/ProgressBar/ProgressBar.tsx -->
```typescript
// src/components/common/ProgressBar/ProgressBar.tsx
import { motion } from 'framer-motion';
import { cn } from '@/utils/classNames';
import { type ReactNode } from 'react';

// Common types
export type Variant = 'default' | 'success' | 'warning' | 'danger' | 'info';

const sizeClasses = {
  xs: 'h-1',
  sm: 'h-2',
  md: 'h-3',
  lg: 'h-4',
};

const variantClasses: Record<Variant, string> = {
  default: 'bg-blue-500 dark:bg-blue-400',
  success: 'bg-green-500 dark:bg-green-400',
  warning: 'bg-yellow-500 dark:bg-yellow-400',
  danger: 'bg-red-500 dark:bg-red-400',
  info: 'bg-cyan-500 dark:bg-cyan-400',
};

const backgroundClasses: Record<Variant, string> = {
  default: 'bg-blue-100 dark:bg-blue-900',
  success: 'bg-green-100 dark:bg-green-900',
  warning: 'bg-yellow-100 dark:bg-yellow-900',
  danger: 'bg-red-100 dark:bg-red-900',
  info: 'bg-cyan-100 dark:bg-cyan-900',
};

// Linear ProgressBar
interface ProgressBarProps {
  value: number;
  max?: number;
  size?: keyof typeof sizeClasses;
  variant?: Variant;
  showLabel?: boolean;
  label?: string;
  showPercentage?: boolean;
  animated?: boolean;
  striped?: boolean;
  className?: string;
  barClassName?: string;
}

export const ProgressBar: React.FC<ProgressBarProps> = ({
  value,
  max = 100,
  size = 'md',
  variant = 'default',
  showLabel = false,
  label,
  showPercentage = true,
  animated = true,
  striped = false,
  className,
  barClassName,
}) => {
  const percentage = Math.min(Math.max((value / max) * 100, 0), 100);

  return (
    <div className={cn('w-full', className)}>
      {(showLabel || showPercentage) && (
        <div className="mb-2 flex items-center justify-between text-sm">
          {showLabel && <span className="font-medium text-gray-700 dark:text-gray-200">{label || 'Progress'}</span>}
          {showPercentage && <span className="text-gray-600 dark:text-gray-300">{Math.round(percentage)}%</span>}
        </div>
      )}

      <div className={cn('overflow-hidden rounded-full', sizeClasses[size], backgroundClasses[variant])}>
        <motion.div
          className={cn(
            'h-full rounded-full transition-all duration-300 ease-in-out',
            variantClasses[variant],
            striped && 'bg-stripes',
            striped && animated && 'animate-stripes',
            barClassName
          )}
          initial={{ width: 0 }}
          animate={{ width: `${percentage}%` }}
          transition={{ duration: animated ? 0.8 : 0, ease: 'easeOut' }}
        />
      </div>
    </div>
  );
};

// Stacked Progress Bars
interface StackedProgressBarProps {
  segments: { value: number; variant?: Variant }[];
  max?: number;
  size?: keyof typeof sizeClasses;
  animated?: boolean;
  className?: string;
}

export const StackedProgressBar: React.FC<StackedProgressBarProps> = ({
  segments,
  max = 100,
  size = 'md',
  animated = true,
  className,
}) => {
  return (
    <div className={cn('flex w-full overflow-hidden rounded-full', sizeClasses[size], className)}>
      {segments.map((seg, idx) => {
        const width = `${(seg.value / max) * 100}%`;
        const color = variantClasses[seg.variant || 'default'];
        return (
          <motion.div
            key={idx}
            className={cn('h-full', color)}
            initial={{ width: 0 }}
            animate={{ width }}
            transition={{ duration: animated ? 0.8 : 0, ease: 'easeOut' }}
          />
        );
      })}
    </div>
  );
};

// Step Progress Bar with icons
interface StepProgressProps {
  steps: Array<{
    id: string;
    label: string;
    description?: string;
    icon?: ReactNode;
  }>;
  currentStep: number;
  orientation?: 'horizontal' | 'vertical';
  className?: string;
}

export const StepProgress: React.FC<StepProgressProps> = ({
  steps,
  currentStep,
  orientation = 'horizontal',
  className,
}) => {
  const isHorizontal = orientation === 'horizontal';

  return (
    <div className={cn('flex', isHorizontal ? 'items-center space-x-4' : 'flex-col space-y-4', className)}>
      {steps.map((step, index) => {
        const isActive = index === currentStep;
        const isCompleted = index < currentStep;
        const isUpcoming = index > currentStep;

        return (
          <div key={step.id} className={cn('flex items-center', isHorizontal ? 'flex-row' : 'flex-col')}>
            <div className="flex items-center">
              <div
                className={cn(
                  'flex h-8 w-8 items-center justify-center rounded-full text-sm font-medium',
                  isCompleted && 'bg-green-500 text-white',
                  isActive && 'bg-blue-500 text-white',
                  isUpcoming && 'bg-gray-200 text-gray-600 dark:bg-gray-700 dark:text-gray-300'
                )}
              >
                {step.icon || (isCompleted ? (
                  <svg className="h-5 w-5" fill="currentColor" viewBox="0 0 20 20">
                    <path
                      fillRule="evenodd"
                      d="M16.707 5.293a1 1 0 010 1.414l-8 8a1 1 0 01-1.414 0l-4-4a1 1 0 011.414-1.414L8 12.586l7.293-7.293a1 1 0 011.414 0z"
                      clipRule="evenodd"
                    />
                  </svg>
                ) : (
                  index + 1
                ))}
              </div>
              {index < steps.length - 1 && (
                <div
                  className={cn(
                    isHorizontal ? 'h-0.5 w-12' : 'h-12 w-0.5',
                    isCompleted ? 'bg-green-500' : 'bg-gray-200 dark:bg-gray-700'
                  )}
                />
              )}
            </div>
            <div className={cn('ml-3', !isHorizontal && 'ml-0 mt-2')}>
              <p
                className={cn(
                  'text-sm font-medium',
                  isActive && 'text-blue-600 dark:text-blue-400',
                  isCompleted && 'text-green-600 dark:text-green-400',
                  isUpcoming && 'text-gray-500 dark:text-gray-400'
                )}
              >
                {step.label}
              </p>
              {step.description && <p className="text-xs text-gray-500 dark:text-gray-400">{step.description}</p>}
            </div>
          </div>
        );
      })}
    </div>
  );
};

```

<!-- path: components/common/ui/ProgressBar/index.ts -->
```typescript
export { ProgressBar } from './ProgressBar';
```

<!-- path: components/common/ui/switch/Switch.tsx -->
```typescript
import { MouseEvent } from "react";
import { Label } from "@/components/common/ui/label/Label";

// Type definitions
type SwitchSize = "sm" | "md" | "lg";
type SwitchColor = "primary" | "secondary" | "success" | "danger" | "warning";

// Omit the onChange from ButtonHTMLAttributes since we're using our own
interface SwitchProps
  extends Omit<React.ButtonHTMLAttributes<HTMLButtonElement>, "onChange"> {
  checked?: boolean;
  onChange?: (checked: boolean) => void;
  disabled?: boolean;
  size?: SwitchSize;
  color?: SwitchColor;
  label?: string;
  labelPosition?: "left" | "right";
  id?: string;
  className?: string;
  showStatusText?: boolean;
  showIcons?: boolean;
}

// Color classes for light and dark modes
const colorClasses: Record<SwitchColor, { light: string; dark: string }> = {
  primary: {
    light: "bg-blue-600",
    dark: "bg-blue-500",
  },
  secondary: {
    light: "bg-gray-600",
    dark: "bg-gray-500",
  },
  success: {
    light: "bg-green-600",
    dark: "bg-green-500",
  },
  danger: {
    light: "bg-red-600",
    dark: "bg-red-500",
  },
  warning: {
    light: "bg-yellow-600",
    dark: "bg-yellow-500",
  },
};

// Switch Component
export const Switch: React.FC<SwitchProps> = ({
  checked = false,
  onChange = () => {},
  disabled = false,
  size = "md",
  color = "primary",
  label,
  labelPosition = "right",
  id,
  className = "",
  showStatusText = false,
  showIcons = false,
  ...props
}) => {
  // Size classes
  const sizeClasses: Record<SwitchSize, { container: string; thumb: string }> =
    {
      sm: {
        container: "h-5 w-9",
        thumb: "h-4 w-4",
      },
      md: {
        container: "h-6 w-11",
        thumb: "h-5 w-5",
      },
      lg: {
        container: "h-7 w-14",
        thumb: "h-6 w-6",
      },
    };

  // Position classes based on checked state
  const translateClasses: Record<SwitchSize, string> = {
    sm: checked ? "translate-x-4" : "translate-x-0",
    md: checked ? "translate-x-5" : "translate-x-0",
    lg: checked ? "translate-x-7" : "translate-x-0",
  };

  const handleClick = (event: MouseEvent<HTMLButtonElement>) => {
    event.preventDefault(); // Prevent form submission if inside a form
    if (!disabled) {
      onChange(!checked);
    }
  };

  return (
    <div className={`inline-flex items-center gap-3 ${className}`}>
      {label && labelPosition === "left" && (
        <Label
          id={id ? `${id}-label` : undefined}
          htmlFor={id}
          className={`${labelPosition === "left" ? "order-first" : ""} ${
            disabled ? "cursor-not-allowed" : "cursor-pointer"
          }`}
          disabled={disabled}
        >
          {label}
        </Label>
      )}

      <div className="flex items-center gap-2">
        {showStatusText && (
          <span
            className={`text-sm ${
              disabled
                ? "text-gray-400 dark:text-gray-500"
                : "text-gray-600 dark:text-gray-300"
            }`}
          >
            {checked ? "On" : "Off"}
          </span>
        )}

        <button
          type="button"
          role="switch"
          aria-checked={checked}
          aria-labelledby={label && id ? `${id}-label` : undefined}
          disabled={disabled}
          onClick={handleClick}
          className={`
            ${
              sizeClasses[size].container
            } relative inline-flex shrink-0 cursor-pointer rounded-full border-2 border-transparent 
            transition-colors duration-200 ease-in-out focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-offset-2
            ${
              checked
                ? colorClasses[color].light
                : "bg-gray-200 dark:bg-gray-600"
            }
            ${disabled ? "opacity-50 cursor-not-allowed" : "hover:opacity-90"}
            dark:${checked ? colorClasses[color].dark : "bg-gray-600"}
          `}
          {...props}
        >
          <span
            className={`
              ${sizeClasses[size].thumb} ${translateClasses[size]} pointer-events-none 
              rounded-full bg-white shadow-lg transform ring-0 transition duration-200 ease-in-out
              flex items-center justify-center
            `}
          >
            {showIcons && (
              <>
                {checked ? (
                  <svg
                    className="h-3 w-3 text-blue-600 dark:text-blue-500"
                    fill="currentColor"
                    viewBox="0 0 20 20"
                  >
                    <path
                      fillRule="evenodd"
                      d="M16.707 5.293a1 1 0 010 1.414l-8 8a1 1 0 01-1.414 0l-4-4a1 1 0 011.414-1.414L8 12.586l7.293-7.293a1 1 0 011.414 0z"
                      clipRule="evenodd"
                    />
                  </svg>
                ) : (
                  <svg
                    className="h-3 w-3 text-gray-400 dark:text-gray-500"
                    fill="currentColor"
                    viewBox="0 0 20 20"
                  >
                    <path
                      fillRule="evenodd"
                      d="M4.293 4.293a1 1 0 011.414 0L10 8.586l4.293-4.293a1 1 0 111.414 1.414L11.414 10l4.293 4.293a1 1 0 01-1.414 1.414L10 11.414l-4.293 4.293a1 1 0 01-1.414-1.414L8.586 10 4.293 5.707a1 1 0 010-1.414z"
                      clipRule="evenodd"
                    />
                  </svg>
                )}
              </>
            )}
          </span>
        </button>
      </div>

      {label && labelPosition === "right" && (
        <Label
          id={id ? `${id}-label` : undefined}
          htmlFor={id}
          className={`${disabled ? "cursor-not-allowed" : "cursor-pointer"}`}
          disabled={disabled}
        >
          {label}
        </Label>
      )}
    </div>
  );
};

```

<!-- path: components/common/ui/phoneInput/PhoneInputWithCountry.tsx -->
```typescript
"use client";

import { useState } from "react";
import { FaChevronDown } from "react-icons/fa";

interface Country {
  name: string;
  code: string;
  dialCode: string;
  flag: string;
}

// Full country list: name, code, dialCode, flag
const countries: Country[] = [
  { name: "India", code: "IN", dialCode: "+91", flag: "🇮🇳" },
  { name: "Afghanistan", code: "AF", dialCode: "+93", flag: "🇦🇫" },
  { name: "Åland Islands", code: "AX", dialCode: "+358", flag: "🇦🇽" },
  { name: "Albania", code: "AL", dialCode: "+355", flag: "🇦🇱" },
  { name: "Algeria", code: "DZ", dialCode: "+213", flag: "🇩🇿" },
  { name: "American Samoa", code: "AS", dialCode: "+1684", flag: "🇦🇸" },
  { name: "Andorra", code: "AD", dialCode: "+376", flag: "🇦🇩" },
  { name: "Angola", code: "AO", dialCode: "+244", flag: "🇦🇴" },
  { name: "Anguilla", code: "AI", dialCode: "+1264", flag: "🇦🇮" },
  { name: "Antarctica", code: "AQ", dialCode: "+672", flag: "🇦🇶" },
  { name: "Antigua and Barbuda", code: "AG", dialCode: "+1268", flag: "🇦🇬" },
  { name: "Argentina", code: "AR", dialCode: "+54", flag: "🇦🇷" },
  { name: "Armenia", code: "AM", dialCode: "+374", flag: "🇦🇲" },
  { name: "Aruba", code: "AW", dialCode: "+297", flag: "🇦🇼" },
  { name: "Australia", code: "AU", dialCode: "+61", flag: "🇦🇺" },
  { name: "Austria", code: "AT", dialCode: "+43", flag: "🇦🇹" },
  { name: "Azerbaijan", code: "AZ", dialCode: "+994", flag: "🇦🇿" },
  { name: "Bahamas", code: "BS", dialCode: "+1242", flag: "🇧🇸" },
  { name: "Bahrain", code: "BH", dialCode: "+973", flag: "🇧🇭" },
  { name: "Bangladesh", code: "BD", dialCode: "+880", flag: "🇧🇩" },
  { name: "Barbados", code: "BB", dialCode: "+1246", flag: "🇧🇧" },
  { name: "Belarus", code: "BY", dialCode: "+375", flag: "🇧🇾" },
  { name: "Belgium", code: "BE", dialCode: "+32", flag: "🇧🇪" },
  { name: "Belize", code: "BZ", dialCode: "+501", flag: "🇧🇿" },
  { name: "Benin", code: "BJ", dialCode: "+229", flag: "🇧🇯" },
  { name: "Bermuda", code: "BM", dialCode: "+1441", flag: "🇧🇲" },
  { name: "Bhutan", code: "BT", dialCode: "+975", flag: "🇧🇹" },
  { name: "Bolivia", code: "BO", dialCode: "+591", flag: "🇧🇴" },
  { name: "Bosnia and Herzegovina", code: "BA", dialCode: "+387", flag: "🇧🇦" },
  { name: "Botswana", code: "BW", dialCode: "+267", flag: "🇧🇼" },
  { name: "Brazil", code: "BR", dialCode: "+55", flag: "🇧🇷" },
  {
    name: "British Indian Ocean Territory",
    code: "IO",
    dialCode: "+246",
    flag: "🇮🇴",
  },
  { name: "Brunei Darussalam", code: "BN", dialCode: "+673", flag: "🇧🇳" },
  { name: "Bulgaria", code: "BG", dialCode: "+359", flag: "🇧🇬" },
  { name: "Burkina Faso", code: "BF", dialCode: "+226", flag: "🇧🇫" },
  { name: "Burundi", code: "BI", dialCode: "+257", flag: "🇧🇮" },
  { name: "Cambodia", code: "KH", dialCode: "+855", flag: "🇰🇭" },
  { name: "Cameroon", code: "CM", dialCode: "+237", flag: "🇨🇲" },
  { name: "Canada", code: "CA", dialCode: "+1", flag: "🇨🇦" },
  { name: "Cape Verde", code: "CV", dialCode: "+238", flag: "🇨🇻" },
  { name: "Cayman Islands", code: "KY", dialCode: "+1345", flag: "🇰🇾" },
  {
    name: "Central African Republic",
    code: "CF",
    dialCode: "+236",
    flag: "🇨🇫",
  },
  { name: "Chad", code: "TD", dialCode: "+235", flag: "🇹🇩" },
  { name: "Chile", code: "CL", dialCode: "+56", flag: "🇨🇱" },
  { name: "China", code: "CN", dialCode: "+86", flag: "🇨🇳" },
  { name: "Christmas Island", code: "CX", dialCode: "+61", flag: "🇨🇽" },
  { name: "Cocos (Keeling) Islands", code: "CC", dialCode: "+61", flag: "🇨🇨" },
  { name: "Colombia", code: "CO", dialCode: "+57", flag: "🇨🇴" },
  { name: "Comoros", code: "KM", dialCode: "+269", flag: "🇰🇲" },
  { name: "Congo", code: "CG", dialCode: "+242", flag: "🇨🇬" },
  {
    name: "Congo, The Democratic Republic of the",
    code: "CD",
    dialCode: "+243",
    flag: "🇨🇩",
  },
  { name: "Cook Islands", code: "CK", dialCode: "+682", flag: "🇨🇰" },
  { name: "Costa Rica", code: "CR", dialCode: "+506", flag: "🇨🇷" },
  { name: "Côte d'Ivoire", code: "CI", dialCode: "+225", flag: "🇨🇮" },
  { name: "Croatia", code: "HR", dialCode: "+385", flag: "🇭🇷" },
  { name: "Cuba", code: "CU", dialCode: "+53", flag: "🇨🇺" },
  { name: "Curaçao", code: "CW", dialCode: "+599", flag: "🇨🇼" },
  { name: "Cyprus", code: "CY", dialCode: "+357", flag: "🇨🇾" },
  { name: "Czech Republic", code: "CZ", dialCode: "+420", flag: "🇨🇿" },
  { name: "Denmark", code: "DK", dialCode: "+45", flag: "🇩🇰" },
  { name: "Djibouti", code: "DJ", dialCode: "+253", flag: "🇩🇯" },
  { name: "Dominica", code: "DM", dialCode: "+1767", flag: "🇩🇲" },
  { name: "Dominican Republic", code: "DO", dialCode: "+1809", flag: "🇩🇴" },
  { name: "Ecuador", code: "EC", dialCode: "+593", flag: "🇪🇨" },
  { name: "Egypt", code: "EG", dialCode: "+20", flag: "🇪🇬" },
  { name: "El Salvador", code: "SV", dialCode: "+503", flag: "🇸🇻" },
  { name: "Equatorial Guinea", code: "GQ", dialCode: "+240", flag: "🇬🇶" },
  { name: "Eritrea", code: "ER", dialCode: "+291", flag: "🇪🇷" },
  { name: "Estonia", code: "EE", dialCode: "+372", flag: "🇪🇪" },
  { name: "Ethiopia", code: "ET", dialCode: "+251", flag: "🇪🇹" },
  {
    name: "Falkland Islands (Malvinas)",
    code: "FK",
    dialCode: "+500",
    flag: "🇫🇰",
  },
  { name: "Faroe Islands", code: "FO", dialCode: "+298", flag: "🇫🇴" },
  { name: "Fiji", code: "FJ", dialCode: "+679", flag: "🇫🇯" },
  { name: "Finland", code: "FI", dialCode: "+358", flag: "🇫🇮" },
  { name: "France", code: "FR", dialCode: "+33", flag: "🇫🇷" },
  { name: "French Guiana", code: "GF", dialCode: "+594", flag: "🇬🇫" },
  { name: "French Polynesia", code: "PF", dialCode: "+689", flag: "🇵🇫" },
  { name: "Gabon", code: "GA", dialCode: "+241", flag: "🇬🇦" },
  { name: "Gambia", code: "GM", dialCode: "+220", flag: "🇬🇲" },
  { name: "Georgia", code: "GE", dialCode: "+995", flag: "🇬🇪" },
  { name: "Germany", code: "DE", dialCode: "+49", flag: "🇩🇪" },
  { name: "Ghana", code: "GH", dialCode: "+233", flag: "🇬🇭" },
  { name: "Gibraltar", code: "GI", dialCode: "+350", flag: "🇬🇮" },
  { name: "Greece", code: "GR", dialCode: "+30", flag: "🇬🇷" },
  { name: "Greenland", code: "GL", dialCode: "+299", flag: "🇬🇱" },
  { name: "Grenada", code: "GD", dialCode: "+1473", flag: "🇬🇩" },
  { name: "Guadeloupe", code: "GP", dialCode: "+590", flag: "🇬🇵" },
  { name: "Guam", code: "GU", dialCode: "+1671", flag: "🇬🇺" },
  { name: "Guatemala", code: "GT", dialCode: "+502", flag: "🇬🇹" },
  { name: "Guernsey", code: "GG", dialCode: "+44", flag: "🇬🇬" },
  { name: "Guinea", code: "GN", dialCode: "+224", flag: "🇬🇳" },
  { name: "Guinea-Bissau", code: "GW", dialCode: "+245", flag: "🇬🇼" },
  { name: "Guyana", code: "GY", dialCode: "+592", flag: "🇬🇾" },
  { name: "Haiti", code: "HT", dialCode: "+509", flag: "🇭🇹" },
  { name: "Honduras", code: "HN", dialCode: "+504", flag: "🇭🇳" },
  { name: "Hong Kong", code: "HK", dialCode: "+852", flag: "🇭🇰" },
  { name: "Hungary", code: "HU", dialCode: "+36", flag: "🇭🇺" },
  { name: "Iceland", code: "IS", dialCode: "+354", flag: "🇮🇸" },
  { name: "Indonesia", code: "ID", dialCode: "+62", flag: "🇮🇩" },
  {
    name: "Iran, Islamic Republic of",
    code: "IR",
    dialCode: "+98",
    flag: "🇮🇷",
  },
  { name: "Iraq", code: "IQ", dialCode: "+964", flag: "🇮🇶" },
  { name: "Ireland", code: "IE", dialCode: "+353", flag: "🇮🇪" },
  { name: "Isle of Man", code: "IM", dialCode: "+44", flag: "🇮🇲" },
  { name: "Israel", code: "IL", dialCode: "+972", flag: "🇮🇱" },
  { name: "Italy", code: "IT", dialCode: "+39", flag: "🇮🇹" },
  { name: "Jamaica", code: "JM", dialCode: "+1876", flag: "🇯🇲" },
  { name: "Japan", code: "JP", dialCode: "+81", flag: "🇯🇵" },
  { name: "Jersey", code: "JE", dialCode: "+44", flag: "🇯🇪" },
  { name: "Jordan", code: "JO", dialCode: "+962", flag: "🇯🇴" },
  { name: "Kazakhstan", code: "KZ", dialCode: "+7", flag: "🇰🇿" },
  { name: "Kenya", code: "KE", dialCode: "+254", flag: "🇰🇪" },
  { name: "Kiribati", code: "KI", dialCode: "+686", flag: "🇰🇮" },
  {
    name: "Korea, Democratic People's Republic of",
    code: "KP",
    dialCode: "+850",
    flag: "🇰🇵",
  },
  { name: "Korea, Republic of", code: "KR", dialCode: "+82", flag: "🇰🇷" },
  { name: "Kuwait", code: "KW", dialCode: "+965", flag: "🇰🇼" },
  { name: "Kyrgyzstan", code: "KG", dialCode: "+996", flag: "🇰🇬" },
  {
    name: "Lao People's Democratic Republic",
    code: "LA",
    dialCode: "+856",
    flag: "🇱🇦",
  },
  { name: "Latvia", code: "LV", dialCode: "+371", flag: "🇱🇻" },
  { name: "Lebanon", code: "LB", dialCode: "+961", flag: "🇱🇧" },
  { name: "Lesotho", code: "LS", dialCode: "+266", flag: "🇱🇸" },
  { name: "Liberia", code: "LR", dialCode: "+231", flag: "🇱🇷" },
  { name: "Libya", code: "LY", dialCode: "+218", flag: "🇱🇾" },
  { name: "Liechtenstein", code: "LI", dialCode: "+423", flag: "🇱🇮" },
  { name: "Lithuania", code: "LT", dialCode: "+370", flag: "🇱🇹" },
  { name: "Luxembourg", code: "LU", dialCode: "+352", flag: "🇱🇺" },
  { name: "Macao", code: "MO", dialCode: "+853", flag: "🇲🇴" },
  {
    name: "Macedonia, The Former Yugoslav Republic of",
    code: "MK",
    dialCode: "+389",
    flag: "🇲🇰",
  },
  { name: "Madagascar", code: "MG", dialCode: "+261", flag: "🇲🇬" },
  { name: "Malawi", code: "MW", dialCode: "+265", flag: "🇲🇼" },
  { name: "Malaysia", code: "MY", dialCode: "+60", flag: "🇲🇾" },
  { name: "Maldives", code: "MV", dialCode: "+960", flag: "🇲🇻" },
  { name: "Mali", code: "ML", dialCode: "+223", flag: "🇲🇱" },
  { name: "Malta", code: "MT", dialCode: "+356", flag: "🇲🇹" },
  { name: "Marshall Islands", code: "MH", dialCode: "+692", flag: "🇲🇭" },
  { name: "Martinique", code: "MQ", dialCode: "+596", flag: "🇲🇶" },
  { name: "Mauritania", code: "MR", dialCode: "+222", flag: "🇲🇷" },
  { name: "Mauritius", code: "MU", dialCode: "+230", flag: "🇲🇺" },
  { name: "Mayotte", code: "YT", dialCode: "+262", flag: "🇾🇹" },
  { name: "Mexico", code: "MX", dialCode: "+52", flag: "🇲🇽" },
  {
    name: "Micronesia, Federated States of",
    code: "FM",
    dialCode: "+691",
    flag: "🇫🇲",
  },
  { name: "Moldova, Republic of", code: "MD", dialCode: "+373", flag: "🇲🇩" },
  { name: "Monaco", code: "MC", dialCode: "+377", flag: "🇲🇨" },
  { name: "Mongolia", code: "MN", dialCode: "+976", flag: "🇲🇳" },
  { name: "Montenegro", code: "ME", dialCode: "+382", flag: "🇲🇪" },
  { name: "Montserrat", code: "MS", dialCode: "+1664", flag: "🇲🇸" },
  { name: "Morocco", code: "MA", dialCode: "+212", flag: "🇲🇦" },
  { name: "Mozambique", code: "MZ", dialCode: "+258", flag: "🇲🇿" },
  { name: "Myanmar", code: "MM", dialCode: "+95", flag: "🇲🇲" },
  { name: "Namibia", code: "NA", dialCode: "+264", flag: "🇳🇦" },
  { name: "Nauru", code: "NR", dialCode: "+674", flag: "🇳🇷" },
  { name: "Nepal", code: "NP", dialCode: "+977", flag: "🇳🇵" },
  { name: "Netherlands", code: "NL", dialCode: "+31", flag: "🇳🇱" },
  { name: "New Caledonia", code: "NC", dialCode: "+687", flag: "🇳🇨" },
  { name: "New Zealand", code: "NZ", dialCode: "+64", flag: "🇳🇿" },
  { name: "Nicaragua", code: "NI", dialCode: "+505", flag: "🇳🇮" },
  { name: "Niger", code: "NE", dialCode: "+227", flag: "🇳🇪" },
  { name: "Nigeria", code: "NG", dialCode: "+234", flag: "🇳🇬" },
  { name: "Niue", code: "NU", dialCode: "+683", flag: "🇳🇺" },
  { name: "Norfolk Island", code: "NF", dialCode: "+672", flag: "🇳🇫" },
  {
    name: "Northern Mariana Islands",
    code: "MP",
    dialCode: "+1670",
    flag: "🇲🇵",
  },
  { name: "Norway", code: "NO", dialCode: "+47", flag: "🇳🇴" },
  { name: "Oman", code: "OM", dialCode: "+968", flag: "🇴🇲" },
  { name: "Pakistan", code: "PK", dialCode: "+92", flag: "🇵🇰" },
  { name: "Palau", code: "PW", dialCode: "+680", flag: "🇵🇼" },
  { name: "Palestine, State of", code: "PS", dialCode: "+970", flag: "🇵🇸" },
  { name: "Panama", code: "PA", dialCode: "+507", flag: "🇵🇦" },
  { name: "Papua New Guinea", code: "PG", dialCode: "+675", flag: "🇵🇬" },
  { name: "Paraguay", code: "PY", dialCode: "+595", flag: "🇵🇾" },
  { name: "Peru", code: "PE", dialCode: "+51", flag: "🇵🇪" },
  { name: "Philippines", code: "PH", dialCode: "+63", flag: "🇵🇭" },
  { name: "Pitcairn", code: "PN", dialCode: "+870", flag: "🇵🇳" },
  { name: "Poland", code: "PL", dialCode: "+48", flag: "🇵🇱" },
  { name: "Portugal", code: "PT", dialCode: "+351", flag: "🇵🇹" },
  { name: "Puerto Rico", code: "PR", dialCode: "+1", flag: "🇵🇷" },
  { name: "Qatar", code: "QA", dialCode: "+974", flag: "🇶🇦" },
  { name: "Réunion", code: "RE", dialCode: "+262", flag: "🇷🇪" },
  { name: "Romania", code: "RO", dialCode: "+40", flag: "🇷🇴" },
  { name: "Russia", code: "RU", dialCode: "+7", flag: "🇷🇺" },
  { name: "Rwanda", code: "RW", dialCode: "+250", flag: "🇷🇼" },
  { name: "Saint Barthélemy", code: "BL", dialCode: "+590", flag: "🇧🇱" },
  { name: "Saint Helena", code: "SH", dialCode: "+290", flag: "🇸🇭" },
  { name: "Saint Kitts and Nevis", code: "KN", dialCode: "+1869", flag: "🇰🇳" },
  { name: "Saint Lucia", code: "LC", dialCode: "+1758", flag: "🇱🇨" },
  {
    name: "Saint Martin (French part)",
    code: "MF",
    dialCode: "+590",
    flag: "🇲🇫",
  },
  {
    name: "Saint Pierre and Miquelon",
    code: "PM",
    dialCode: "+508",
    flag: "🇵🇲",
  },
  {
    name: "Saint Vincent and the Grenadines",
    code: "VC",
    dialCode: "+1784",
    flag: "🇻🇨",
  },
  { name: "Samoa", code: "WS", dialCode: "+685", flag: "🇼🇸" },
  { name: "San Marino", code: "SM", dialCode: "+378", flag: "🇸🇲" },
  { name: "Sao Tome and Principe", code: "ST", dialCode: "+239", flag: "🇸🇹" },
  { name: "Saudi Arabia", code: "SA", dialCode: "+966", flag: "🇸🇦" },
  { name: "Senegal", code: "SN", dialCode: "+221", flag: "🇸🇳" },
  { name: "Serbia", code: "RS", dialCode: "+381", flag: "🇷🇸" },
  { name: "Seychelles", code: "SC", dialCode: "+248", flag: "🇸🇨" },
  { name: "Sierra Leone", code: "SL", dialCode: "+232", flag: "🇸🇱" },
  { name: "Singapore", code: "SG", dialCode: "+65", flag: "🇸🇬" },
  {
    name: "Sint Maarten (Dutch part)",
    code: "SX",
    dialCode: "+1721",
    flag: "🇸🇽",
  },
  { name: "Slovakia", code: "SK", dialCode: "+421", flag: "🇸🇰" },
  { name: "Slovenia", code: "SI", dialCode: "+386", flag: "🇸🇮" },
  { name: "Solomon Islands", code: "SB", dialCode: "+677", flag: "🇸🇧" },
  { name: "Somalia", code: "SO", dialCode: "+252", flag: "🇸🇴" },
  { name: "South Africa", code: "ZA", dialCode: "+27", flag: "🇿🇦" },
  { name: "South Sudan", code: "SS", dialCode: "+211", flag: "🇸🇸" },
  { name: "Spain", code: "ES", dialCode: "+34", flag: "🇪🇸" },
  { name: "Sri Lanka", code: "LK", dialCode: "+94", flag: "🇱🇰" },
  { name: "Sudan", code: "SD", dialCode: "+249", flag: "🇸🇩" },
  { name: "Suriname", code: "SR", dialCode: "+597", flag: "🇸🇷" },
  { name: "Svalbard and Jan Mayen", code: "SJ", dialCode: "+47", flag: "🇸🇯" },
  { name: "Swaziland", code: "SZ", dialCode: "+268", flag: "🇸🇿" },
  { name: "Sweden", code: "SE", dialCode: "+46", flag: "🇸🇪" },
  { name: "Switzerland", code: "CH", dialCode: "+41", flag: "🇨🇭" },
  { name: "Syrian Arab Republic", code: "SY", dialCode: "+963", flag: "🇸🇾" },
  { name: "Taiwan", code: "TW", dialCode: "+886", flag: "🇹🇼" },
  { name: "Tajikistan", code: "TJ", dialCode: "+992", flag: "🇹🇯" },
  {
    name: "Tanzania, United Republic of",
    code: "TZ",
    dialCode: "+255",
    flag: "🇹🇿",
  },
  { name: "Thailand", code: "TH", dialCode: "+66", flag: "🇹🇭" },
  { name: "Timor-Leste", code: "TL", dialCode: "+670", flag: "🇹🇱" },
  { name: "Togo", code: "TG", dialCode: "+228", flag: "🇹🇬" },
  { name: "Tokelau", code: "TK", dialCode: "+690", flag: "🇹🇰" },
  { name: "Tonga", code: "TO", dialCode: "+676", flag: "🇹🇴" },
  { name: "Trinidad and Tobago", code: "TT", dialCode: "+1868", flag: "🇹🇹" },
  { name: "Tunisia", code: "TN", dialCode: "+216", flag: "🇹🇳" },
  { name: "Turkey", code: "TR", dialCode: "+90", flag: "🇹🇷" },
  { name: "Turkmenistan", code: "TM", dialCode: "+993", flag: "🇹🇲" },
  {
    name: "Turks and Caicos Islands",
    code: "TC",
    dialCode: "+1649",
    flag: "🇹🇨",
  },
  { name: "Tuvalu", code: "TV", dialCode: "+688", flag: "🇹🇻" },
  { name: "Uganda", code: "UG", dialCode: "+256", flag: "🇺🇬" },
  { name: "Ukraine", code: "UA", dialCode: "+380", flag: "🇺🇦" },
  { name: "United Arab Emirates", code: "AE", dialCode: "+971", flag: "🇦🇪" },
  { name: "United Kingdom", code: "GB", dialCode: "+44", flag: "🇬🇧" },
  { name: "United States", code: "US", dialCode: "+1", flag: "🇺🇸" },
  { name: "Uruguay", code: "UY", dialCode: "+598", flag: "🇺🇾" },
  { name: "Uzbekistan", code: "UZ", dialCode: "+998", flag: "🇺🇿" },
  { name: "Vanuatu", code: "VU", dialCode: "+678", flag: "🇻🇺" },
  { name: "Venezuela", code: "VE", dialCode: "+58", flag: "🇻🇪" },
  { name: "Vietnam", code: "VN", dialCode: "+84", flag: "🇻🇳" },
  {
    name: "Virgin Islands, British",
    code: "VG",
    dialCode: "+1284",
    flag: "🇻🇬",
  },
  { name: "Virgin Islands, U.S.", code: "VI", dialCode: "+1340", flag: "🇻🇮" },
  { name: "Wallis and Futuna", code: "WF", dialCode: "+681", flag: "🇼🇫" },
  { name: "Western Sahara", code: "EH", dialCode: "+212", flag: "🇪🇭" },
  { name: "Yemen", code: "YE", dialCode: "+967", flag: "🇾🇪" },
  { name: "Zambia", code: "ZM", dialCode: "+260", flag: "🇿🇲" },
  { name: "Zimbabwe", code: "ZW", dialCode: "+263", flag: "🇿🇼" },
];
interface PhoneInputWithCountryProps {
  value: string | null;
  onChange: (value: string) => void;
}

export default function PhoneInputWithCountry({
  value,
  onChange,
}: PhoneInputWithCountryProps) {
  const [selectedCountry, setSelectedCountry] = useState<Country>(countries[0]);

  const handleNumberChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    const number = e.target.value.replace(/\D/g, "");
    onChange(`${selectedCountry.dialCode}${number}`);
  };

  const handleCountryChange = (e: React.ChangeEvent<HTMLSelectElement>) => {
    const country = countries.find((c) => c.code === e.target.value);
    if (country) {
      setSelectedCountry(country);
      const currentNumber = (value ?? "").replace(/^\+\d+/, "");
      const newValue = `${country.dialCode}${currentNumber}`;
      if (newValue !== value) {
        onChange(newValue);
      }
    }
  };

  return (
    <div className="flex flex-col gap-2">
      <label className="text-sm font-medium text-gray-700 dark:text-gray-300">
        Phone Number
      </label>
      <div className="flex gap-2">
        <div className="relative w-44">
          <select
            value={selectedCountry.code}
            onChange={handleCountryChange}
            className="w-full cursor-pointer appearance-none rounded-lg border border-gray-300 bg-white py-2 pr-8 pl-3 text-sm focus:ring-2 focus:ring-blue-500 focus:outline-none dark:border-gray-600 dark:bg-gray-800 dark:text-white"
          >
            {countries.map((country) => (
              <option key={country.code} value={country.code}>
                {country.flag} {country.dialCode}
              </option>
            ))}
          </select>
          <FaChevronDown className="pointer-events-none absolute top-3 right-2 text-gray-500" />
        </div>

        <input
          type="tel"
          placeholder="Enter phone number"
          value={(value ?? "").replace(selectedCountry.dialCode, "")}
          onChange={handleNumberChange}
          className="flex-1 rounded-lg border border-gray-300 px-3 py-2 text-sm focus:ring-2 focus:ring-blue-500 focus:outline-none dark:border-gray-600 dark:bg-gray-800 dark:text-white"
        />
      </div>
      <p className="text-xs text-gray-500 dark:text-gray-400">
        Full Contact Number: <span className="font-medium">{value}</span>
      </p>
    </div>
  );
}

```

<!-- path: components/common/ui/phoneInput/index.ts -->
```typescript
export { default as PhoneInputWithCountry } from './PhoneInputWithCountry';
```

<!-- path: components/common/ui/scroll-area.tsx -->
```typescript
"use client"

import * as React from "react"
import * as ScrollAreaPrimitive from "@radix-ui/react-scroll-area"

import { cn } from "@/lib/utils"

function ScrollArea({
  className,
  children,
  ...props
}: React.ComponentProps<typeof ScrollAreaPrimitive.Root>) {
  return (
    <ScrollAreaPrimitive.Root
      data-slot="scroll-area"
      className={cn("relative", className)}
      {...props}
    >
      <ScrollAreaPrimitive.Viewport
        data-slot="scroll-area-viewport"
        className="focus-visible:ring-ring/50 size-full rounded-[inherit] transition-[color,box-shadow] outline-none focus-visible:ring-[3px] focus-visible:outline-1"
      >
        {children}
      </ScrollAreaPrimitive.Viewport>
      <ScrollBar />
      <ScrollAreaPrimitive.Corner />
    </ScrollAreaPrimitive.Root>
  )
}

function ScrollBar({
  className,
  orientation = "vertical",
  ...props
}: React.ComponentProps<typeof ScrollAreaPrimitive.ScrollAreaScrollbar>) {
  return (
    <ScrollAreaPrimitive.ScrollAreaScrollbar
      data-slot="scroll-area-scrollbar"
      orientation={orientation}
      className={cn(
        "flex touch-none p-px transition-colors select-none",
        orientation === "vertical" &&
          "h-full w-2.5 border-l border-l-transparent",
        orientation === "horizontal" &&
          "h-2.5 flex-col border-t border-t-transparent",
        className
      )}
      {...props}
    >
      <ScrollAreaPrimitive.ScrollAreaThumb
        data-slot="scroll-area-thumb"
        className="bg-border relative flex-1 rounded-full"
      />
    </ScrollAreaPrimitive.ScrollAreaScrollbar>
  )
}

export { ScrollArea, ScrollBar }

```

<!-- path: components/common/ui/theme/ThemeToggle.tsx -->
```typescript

"use client";

import { useThemeStore, Theme } from "@/stores/themeStore";
import { useState, useRef, useEffect } from "react";
import { FiChevronDown, FiMonitor, FiMoon, FiSun } from "react-icons/fi";

export default function ThemeToggle() {
  const { theme, setTheme } = useThemeStore();
  const [isOpen, setIsOpen] = useState(false);
  const [hasMounted, setHasMounted] = useState(false); // **THE FIX**
  const dropdownRef = useRef<HTMLDivElement>(null);
  const timeoutRef = useRef<NodeJS.Timeout | null>(null);
  
  // ** Only render the real UI after the component has mounted on the client.**
  useEffect(() => {
    setHasMounted(true);
  }, []);


  const options = [
    { value: "light" as Theme, icon: <FiSun size={16} />, label: "Light" },
    { value: "dark" as Theme, icon: <FiMoon size={16} />, label: "Dark" },
    { value: "system" as Theme, icon: <FiMonitor size={16} />, label: "System" },
  ];

  const currentOption = options.find((opt) => opt.value === theme);

  useEffect(() => {
    return () => {
      if (timeoutRef.current) {
        clearTimeout(timeoutRef.current);
      }
    };
  }, []);

  useEffect(() => {
    const handleClickOutside = (event: MouseEvent) => {
      if (
        dropdownRef.current &&
        !dropdownRef.current.contains(event.target as Node)
      ) {
        setIsOpen(false);
      }
    };

    document.addEventListener("mousedown", handleClickOutside);
    return () => document.removeEventListener("mousedown", handleClickOutside);
  }, []);

  const handleMouseEnter = () => {
    if (timeoutRef.current) {
      clearTimeout(timeoutRef.current);
    }
    setIsOpen(true);
  };

  const handleMouseLeave = () => {
    timeoutRef.current = setTimeout(() => {
      setIsOpen(false);
    }, 300);
  };

  const handleOptionClick = (value: Theme) => {
    setTheme(value);
    setIsOpen(false);
    if (timeoutRef.current) {
      clearTimeout(timeoutRef.current);
    }
  };

  // ** Show loading skeleton until the component has mounted.**
  if (!hasMounted) {
    return (
      <div className="h-10 w-32 animate-pulse rounded-lg bg-gray-200 dark:bg-gray-700" />
    );
  }

  return (
    <div
      ref={dropdownRef}
      className="relative"
      onMouseEnter={handleMouseEnter}
      onMouseLeave={handleMouseLeave}
    >
      <button
        onClick={() => setIsOpen(!isOpen)}
        className="flex items-center gap-2 rounded-lg bg-gray-200 px-3 py-2 text-gray-700 hover:bg-gray-300 dark:bg-gray-700 dark:text-white dark:hover:bg-gray-600"
        aria-expanded={isOpen}
      >
        {currentOption?.icon}
        <span className="text-sm">{currentOption?.label}</span>
        <FiChevronDown
          size={16}
          className={`transition-transform ${isOpen ? "rotate-180" : ""}`}
        />
      </button>

      {isOpen && (
        <div
          className="absolute z-10 mt-1 w-full rounded-lg border border-gray-200 bg-white shadow-lg dark:border-gray-700 dark:bg-gray-800"
          onMouseEnter={handleMouseEnter}
          onMouseLeave={handleMouseLeave}
        >
          {options.map((opt) => (
            <button
              key={opt.value}
              onClick={() => handleOptionClick(opt.value)}
              className={`flex w-full items-center gap-2 px-3 py-2 text-left text-gray-700 dark:text-white ${
                theme === opt.value
                  ? "bg-blue-100 text-blue-700 dark:bg-blue-900/50 dark:text-blue-300"
                  : "hover:bg-gray-100 dark:hover:bg-gray-700"
              }`}
            >
              {opt.icon}
              <span>{opt.label}</span>
            </button>
          ))}
        </div>
      )}
    </div>
  );
}
```

<!-- path: components/common/ui/label/Label.tsx -->
```typescript
// Type definitions
type LabelSize = "xs" | "sm" | "md" | "lg" | "xl";
type LabelWeight = "normal" | "medium" | "semibold" | "bold";

interface LabelProps extends React.LabelHTMLAttributes<HTMLLabelElement> {
  children: React.ReactNode;
  htmlFor?: string;
  required?: boolean;
  disabled?: boolean;
  size?: LabelSize;
  weight?: LabelWeight;
  className?: string;
  showRequiredSymbol?: boolean;
  tooltip?: string;
}

// Label Component  
export const Label: React.FC<LabelProps> = ({ 
  children, 
  htmlFor, 
  required = false, 
  disabled = false,
  size = "md",
  weight = "medium",
  className = "",
  showRequiredSymbol = true,
  tooltip,
  ...props 
}) => {
  const sizeClasses: Record<LabelSize, string> = {
    xs: "text-xs",
    sm: "text-sm",
    md: "text-base", 
    lg: "text-lg",
    xl: "text-xl"
  };

  const weightClasses: Record<LabelWeight, string> = {
    normal: "font-normal",
    medium: "font-medium",
    semibold: "font-semibold",
    bold: "font-bold"
  };

  return (
    <label
      htmlFor={htmlFor}
      className={`
        ${sizeClasses[size]} 
        ${weightClasses[weight]} 
        block text-gray-900 dark:text-gray-100
        ${disabled ? 'text-gray-400 dark:text-gray-500 cursor-not-allowed' : 'cursor-pointer'}
        ${className}
        relative
      `}
      aria-disabled={disabled}
      data-tooltip={tooltip}
      {...props}
    >
      {children}
      {required && showRequiredSymbol && (
        <span className="text-red-500 dark:text-red-400 ml-1">*</span>
      )}
      {tooltip && (
        <span className="ml-2 text-gray-400 dark:text-gray-500 hover:text-gray-500 dark:hover:text-gray-400">
          <svg 
            xmlns="http://www.w3.org/2000/svg" 
            className="h-4 w-4 inline" 
            fill="none" 
            viewBox="0 0 24 24" 
            stroke="currentColor"
          >
            <path 
              strokeLinecap="round" 
              strokeLinejoin="round" 
              strokeWidth={2} 
              d="M13 16h-1v-4h-1m1-4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z" 
            />
          </svg>
        </span>
      )}
    </label>
  );
};
```

<!-- path: components/common/ui/Button/Button.tsx -->
```typescript
// src/components/common/Button/Button.tsx
import { forwardRef, type ButtonHTMLAttributes } from 'react';
import { FiChevronDown } from 'react-icons/fi';
import { cn } from '@/utils/classNames';
import { ButtonSpinner } from '../LoadingSpinner';

export interface ButtonProps extends ButtonHTMLAttributes<HTMLButtonElement> {
  variant?: 'primary' | 'secondary' | 'success' | 'warning' | 'danger' | 'ghost' | 'outline';
  size?: 'xs' | 'sm' | 'md' | 'lg' | 'xl';
  loading?: boolean;
  loadingText?: string;
  leftIcon?: React.ReactNode;
  rightIcon?: React.ReactNode;
  fullWidth?: boolean;
  rounded?: 'none' | 'sm' | 'md' | 'lg' | 'full';
  isdropdown?: boolean;
}

const variants = {
  primary: 'bg-blue-600 text-white hover:bg-blue-700 focus:ring-blue-500 disabled:bg-blue-300',
  secondary: 'bg-gray-600 text-white hover:bg-gray-700 focus:ring-gray-500 disabled:bg-gray-300',
  success: 'bg-green-600 text-white hover:bg-green-700 focus:ring-green-500 disabled:bg-green-300',
  warning: 'bg-yellow-600 text-white hover:bg-yellow-700 focus:ring-yellow-500 disabled:bg-yellow-300',
  danger: 'bg-red-600 text-white hover:bg-red-700 focus:ring-red-500 disabled:bg-red-300',
  ghost: 'text-gray-700 hover:bg-gray-100 focus:ring-gray-500 disabled:text-gray-400',
  outline: 'border border-gray-300 text-gray-700 hover:bg-gray-50 focus:ring-gray-500 disabled:text-gray-400 disabled:border-gray-200',
};

const sizes = {
  xs: 'px-2 py-1 text-xs',
  sm: 'px-3 py-1.5 text-sm',
  md: 'px-4 py-2 text-sm',
  lg: 'px-5 py-2.5 text-base',
  xl: 'px-6 py-3 text-lg',
};

const roundedOptions = {
  none: 'rounded-none',
  sm: 'rounded-sm',
  md: 'rounded-md',
  lg: 'rounded-lg',
  full: 'rounded-full',
};

export const Button = forwardRef<HTMLButtonElement, ButtonProps>(
  (
    {
      variant = 'primary',
      size = 'md',
      loading = false,
      loadingText,
      leftIcon,
      rightIcon,
      fullWidth = false,
      rounded = 'md',
      disabled,
      isdropdown,
      children,
      className,
      ...props
    },
    ref
  ) => {
    const isDisabled = disabled || loading;

    return (
      <button
        ref={ref}
        disabled={isDisabled}
        className={cn(
          // Base styles
          'inline-flex items-center justify-center font-medium transition-all duration-200 focus:outline-none focus:ring-2 focus:ring-offset-2',
          // Variant styles
          variants[variant],
          // Size styles
          sizes[size],
          // Rounded styles
          roundedOptions[rounded],
          // Full width
          fullWidth && 'w-full',
          // Disabled cursor
          isDisabled && 'cursor-not-allowed',
          // Custom className
          className
        )}
        {...props}
      >
        {/* Loading spinner */}
        {loading && (
          <ButtonSpinner
            size={size === 'xs' ? 'xs' : size === 'sm' ? 'sm' : 'sm'}
          />
        )}

        {/* Left icon */}
        {!loading && leftIcon && (
          <span className="mr-2 flex items-center">
            {leftIcon}
          </span>
        )}

        {/* Button content */}
        <span>
          {loading && loadingText ? loadingText : children}
        </span>

        {/* Right icon or dropdown indicator */}
        {!loading && (rightIcon || isdropdown) && (
          <span className="ml-2 flex items-center">
            {rightIcon || <FiChevronDown className="h-4 w-4" />}
          </span>
        )}
      </button>
    );
  }
);

Button.displayName = 'Button';

// Icon button variant
interface IconButtonProps extends Omit<ButtonProps, 'leftIcon' | 'rightIcon'> {
  icon: React.ReactNode;
  label?: string; // For accessibility
}

export const IconButton = forwardRef<HTMLButtonElement, IconButtonProps>(
  ({ icon, label, size = 'md', className, ...props }, ref) => {
    const iconSizes = {
      xs: 'h-3 w-3',
      sm: 'h-4 w-4',
      md: 'h-5 w-5',
      lg: 'h-6 w-6',
      xl: 'h-7 w-7',
    };

    return (
      <Button
        ref={ref}
        size={size}
        className={cn(
          'aspect-square !p-0',
          className
        )}
        aria-label={label}
        {...props}
      >
        <span className={iconSizes[size]}>
          {icon}
        </span>
      </Button>
    );
  }
);

IconButton.displayName = 'IconButton';

// Button group component
interface ButtonGroupProps {
  children: React.ReactNode;
  orientation?: 'horizontal' | 'vertical';
  attached?: boolean;
  className?: string;
}

export const ButtonGroup: React.FC<ButtonGroupProps> = ({
  children,
  orientation = 'horizontal',
  attached = false,
  className,
}) => {
  return (
    <div
      className={cn(
        'inline-flex',
        orientation === 'horizontal' ? 'flex-row' : 'flex-col',
        attached && orientation === 'horizontal' && '[&>*:not(:first-child)]:ml-0 [&>*:not(:first-child)]:rounded-l-none [&>*:not(:last-child)]:rounded-r-none [&>*]:border-r-0 [&>*:last-child]:border-r',
        attached && orientation === 'vertical' && '[&>*:not(:first-child)]:mt-0 [&>*:not(:first-child)]:rounded-t-none [&>*:not(:last-child)]:rounded-b-none [&>*]:border-b-0 [&>*:last-child]:border-b',
        !attached && orientation === 'horizontal' && 'space-x-2',
        !attached && orientation === 'vertical' && 'space-y-2',
        className
      )}
    >
      {children}
    </div>
  );
};

// Floating Action Button
interface FABProps extends Omit<ButtonProps, 'size' | 'variant'> {
  size?: 'md' | 'lg';
  position?: 'bottom-right' | 'bottom-left' | 'top-right' | 'top-left';
  icon?: React.ReactNode;
}

export const FloatingActionButton: React.FC<FABProps> = ({
  size = 'lg',
  position = 'bottom-right',
  icon,
  children,
  className,
  ...props
}) => {
  const positions = {
    'bottom-right': 'fixed bottom-6 right-6',
    'bottom-left': 'fixed bottom-6 left-6',
    'top-right': 'fixed top-6 right-6',
    'top-left': 'fixed top-6 left-6',
  };

  const fabSizes = {
    md: 'h-12 w-12',
    lg: 'h-14 w-14',
  };

  return (
    <Button
      variant="primary"
      rounded="full"
      className={cn(
        positions[position],
        fabSizes[size],
        'shadow-lg hover:shadow-xl z-50 !p-0',
        className
      )}
      {...props}
    >
      {icon || children}
    </Button>
  );
};

// Specialized exam buttons
export const SubmitButton: React.FC<Omit<ButtonProps, 'variant'>> = (props) => (
  <Button variant="success" {...props} />
);

export const CancelButton: React.FC<Omit<ButtonProps, 'variant'>> = (props) => (
  <Button variant="outline" {...props} />
);

export const DeleteButton: React.FC<Omit<ButtonProps, 'variant'>> = (props) => (
  <Button variant="danger" {...props} />
);

export const NextButton: React.FC<Omit<ButtonProps, 'variant' | 'rightIcon'>> = (props) => (
  <Button
    variant="primary"
    rightIcon={
      <svg className="h-4 w-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
        <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M9 5l7 7-7 7" />
      </svg>
    }
    {...props}
  />
);

export const PreviousButton: React.FC<Omit<ButtonProps, 'variant' | 'leftIcon'>> = (props) => (
  <Button
    variant="secondary"
    leftIcon={
      <svg className="h-4 w-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
        <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M15 19l-7-7 7-7" />
      </svg>
    }
    {...props}
  />
);
```

<!-- path: components/common/ui/Button/index.ts -->
```typescript
export { Button } from './Button';
```

<!-- path: components/common/ui/select/Select.tsx -->
```typescript
"use client"

import * as React from "react"
import * as SelectPrimitive from "@radix-ui/react-select"
import { CheckIcon, ChevronDownIcon, ChevronUpIcon } from "lucide-react"

import { cn } from "@/lib/utils"

function Select({
  ...props
}: React.ComponentProps<typeof SelectPrimitive.Root>) {
  return <SelectPrimitive.Root data-slot="select" {...props} />
}

function SelectGroup({
  ...props
}: React.ComponentProps<typeof SelectPrimitive.Group>) {
  return <SelectPrimitive.Group data-slot="select-group" {...props} />
}

function SelectValue({
  ...props
}: React.ComponentProps<typeof SelectPrimitive.Value>) {
  return <SelectPrimitive.Value data-slot="select-value" {...props} />
}

function SelectTrigger({
  className,
  size = "default",
  children,
  ...props
}: React.ComponentProps<typeof SelectPrimitive.Trigger> & {
  size?: "sm" | "default"
}) {
  return (
    <SelectPrimitive.Trigger
      data-slot="select-trigger"
      data-size={size}
      className={cn(
        "data-[placeholder]:text-muted-foreground [&_svg:not([class*='text-'])]:text-muted-foreground aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive flex w-full items-center justify-between gap-2 rounded-md border px-3 py-2 text-sm whitespace-nowrap shadow-xs transition-[color,box-shadow] outline-none disabled:cursor-not-allowed disabled:opacity-50 data-[size=default]:h-9 data-[size=sm]:h-8 *:data-[slot=select-value]:line-clamp-1 *:data-[slot=select-value]:flex *:data-[slot=select-value]:items-center *:data-[slot=select-value]:gap-2 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4",
        // Align with SearchableSelect visuals
        "bg-white dark:bg-gray-700 border-gray-300 dark:border-gray-600 hover:border-gray-400 dark:hover:border-gray-500 focus-visible:ring-2 focus-visible:ring-blue-500",
        className
      )}
      {...props}
    >
      {children}
      <SelectPrimitive.Icon asChild>
        <ChevronDownIcon className="size-4 opacity-50" />
      </SelectPrimitive.Icon>
    </SelectPrimitive.Trigger>
  )
}

function SelectContent({
  className,
  children,
  position = "popper",
  ...props
}: React.ComponentProps<typeof SelectPrimitive.Content>) {
  return (
    <SelectPrimitive.Portal>
      <SelectPrimitive.Content
        data-slot="select-content"
        className={cn(
          "data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 relative z-50 max-h-(--radix-select-content-available-height) min-w-[8rem] origin-(--radix-select-content-transform-origin) overflow-x-hidden overflow-y-auto rounded-md border shadow-lg",
          // Align with SearchableSelect visuals
          "bg-white dark:bg-gray-700 text-gray-900 dark:text-white border-gray-300 dark:border-gray-600",
          position === "popper" &&
            "data-[side=bottom]:translate-y-1 data-[side=left]:-translate-x-1 data-[side=right]:translate-x-1 data-[side=top]:-translate-y-1",
          className
        )}
        position={position}
        {...props}
      >
        <SelectScrollUpButton />
        <SelectPrimitive.Viewport
          className={cn(
            "p-1",
            position === "popper" &&
              "h-[var(--radix-select-trigger-height)] w-full min-w-[var(--radix-select-trigger-width)] scroll-my-1"
          )}
        >
          {children}
        </SelectPrimitive.Viewport>
        <SelectScrollDownButton />
      </SelectPrimitive.Content>
    </SelectPrimitive.Portal>
  )
}

function SelectLabel({
  className,
  ...props
}: React.ComponentProps<typeof SelectPrimitive.Label>) {
  return (
    <SelectPrimitive.Label
      data-slot="select-label"
      className={cn("text-muted-foreground px-2 py-1.5 text-xs", className)}
      {...props}
    />
  )
}

function SelectItem({
  className,
  children,
  ...props
}: React.ComponentProps<typeof SelectPrimitive.Item>) {
  return (
    <SelectPrimitive.Item
      data-slot="select-item"
      className={cn(
        "relative flex w-full cursor-default items-center gap-2 rounded-sm py-1.5 pr-8 pl-2 text-sm outline-hidden select-none [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4 *:[span]:last:flex *:[span]:last:items-center *:[span]:last:gap-2",
        // Disabled
        "data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
        // Base text colors
        "text-gray-900 dark:text-white [&_svg:not([class*='text-'])]:text-gray-400",
        // Hover/focus and selected states to mirror SearchableSelect
        "hover:bg-gray-100 dark:hover:bg-gray-600",
        "data-[highlighted]:bg-blue-100 dark:data-[highlighted]:bg-blue-900/50 data-[highlighted]:text-blue-900 dark:data-[highlighted]:text-blue-200",
        "data-[state=checked]:bg-blue-50 dark:data-[state=checked]:bg-blue-900/30 data-[state=checked]:text-blue-700 dark:data-[state=checked]:text-blue-300 font-medium",
        className
      )}
      {...props}
    >
      <span className="absolute right-2 flex size-3.5 items-center justify-center">
        <SelectPrimitive.ItemIndicator>
          <CheckIcon className="size-4" />
        </SelectPrimitive.ItemIndicator>
      </span>
      <SelectPrimitive.ItemText>{children}</SelectPrimitive.ItemText>
    </SelectPrimitive.Item>
  )
}

function SelectSeparator({
  className,
  ...props
}: React.ComponentProps<typeof SelectPrimitive.Separator>) {
  return (
    <SelectPrimitive.Separator
      data-slot="select-separator"
      className={cn("bg-border pointer-events-none -mx-1 my-1 h-px", className)}
      {...props}
    />
  )
}

function SelectScrollUpButton({
  className,
  ...props
}: React.ComponentProps<typeof SelectPrimitive.ScrollUpButton>) {
  return (
    <SelectPrimitive.ScrollUpButton
      data-slot="select-scroll-up-button"
      className={cn(
        "flex cursor-default items-center justify-center py-1",
        className
      )}
      {...props}
    >
      <ChevronUpIcon className="size-4" />
    </SelectPrimitive.ScrollUpButton>
  )
}

function SelectScrollDownButton({
  className,
  ...props
}: React.ComponentProps<typeof SelectPrimitive.ScrollDownButton>) {
  return (
    <SelectPrimitive.ScrollDownButton
      data-slot="select-scroll-down-button"
      className={cn(
        "flex cursor-default items-center justify-center py-1",
        className
      )}
      {...props}
    >
      <ChevronDownIcon className="size-4" />
    </SelectPrimitive.ScrollDownButton>
  )
}

export {
  Select,
  SelectContent,
  SelectGroup,
  SelectItem,
  SelectLabel,
  SelectScrollDownButton,
  SelectScrollUpButton,
  SelectSeparator,
  SelectTrigger,
  SelectValue,
}

```

<!-- path: components/common/ui/select/SearchableSelect.tsx -->
```typescript
// path: components/common/ui/select/SearchableSelect.tsx
"use client";

import { Label } from "@/components/common/ui/label/Label";
import { useState, useRef, useEffect, useMemo, useLayoutEffect } from "react";
import { createPortal } from "react-dom";
import { FiChevronDown, FiX, FiSearch } from "react-icons/fi";
import { ButtonSpinner } from "../LoadingSpinner";

export interface Option {
  value: string;
  label: string;
  disabled?: boolean;
}

interface SearchableSelectProps {
  options: Option[];
  value?: string | null;
  onChange: (value: string | null) => void;
  placeholder?: string;
  searchPlaceholder?: string;
  className?: string;
  disabled?: boolean;
  clearable?: boolean;
  maxHeight?: number;
  noOptionsMessage?: string;
  loading?: boolean;
  required?: boolean;
  error?: boolean;
  sortOptions?: boolean;
  label?: string;
  serverSide?: boolean;
  onSearch?: (term: string) => void;
  isLoading?: boolean;
}

export const SearchableSelect: React.FC<SearchableSelectProps> = ({
  options = [],
  value = null,
  onChange,
  placeholder = "Select an option",
  searchPlaceholder = "Search options...",
  className = "",
  disabled = false,
  clearable = true,
  maxHeight = 200,
  noOptionsMessage = "No options found",
  loading = false,
  required = false,
  error = false,
  sortOptions = true,
  label = "",
  serverSide = false,
  onSearch,
  isLoading = false,
}) => {
  const [isOpen, setIsOpen] = useState(false);
  const [searchTerm, setSearchTerm] = useState("");
  const [focusedIndex, setFocusedIndex] = useState(-1);
  const [dropdownStyle, setDropdownStyle] = useState<React.CSSProperties>({});

  const triggerRef = useRef<HTMLDivElement>(null);
  const dropdownRef = useRef<HTMLDivElement>(null);
  const searchInputRef = useRef<HTMLInputElement>(null);
  const optionRefs = useRef<(HTMLDivElement | null)[]>([]);

  const filteredOptions = useMemo(() => {
    if (serverSide) return options;
    const processedOptions = [...options];
    if (sortOptions) {
      processedOptions.sort((a, b) => a.label.localeCompare(b.label, undefined, { sensitivity: 'base', numeric: true }));
    }
    if (!searchTerm.trim()) return processedOptions;
    return processedOptions.filter(option =>
      option.label.toLowerCase().includes(searchTerm.toLowerCase())
    );
  }, [options, searchTerm, sortOptions, serverSide]);

  const selectedOption = useMemo(() => options.find(option => option.value === value), [options, value]);
  const selectedLabel = selectedOption?.label || "";
  const hasValue = !!value;

  useEffect(() => {
    if (serverSide && onSearch) {
      const handler = setTimeout(() => {
        onSearch(searchTerm);
      }, 300);
      return () => clearTimeout(handler);
    }
  }, [searchTerm, serverSide, onSearch]);
  
  useLayoutEffect(() => {
    if (isOpen && triggerRef.current) {
      const rect = triggerRef.current.getBoundingClientRect();
      setDropdownStyle({
        position: 'fixed',
        top: `${rect.bottom + 4}px`,
        left: `${rect.left}px`,
        width: `${rect.width}px`,
      });
    }
  }, [isOpen]);

  useEffect(() => {
    const handleClickOutside = (event: MouseEvent) => {
      if (
        triggerRef.current && !triggerRef.current.contains(event.target as Node) &&
        dropdownRef.current && !dropdownRef.current.contains(event.target as Node)
      ) {
        setIsOpen(false);
      }
    };
    document.addEventListener("mousedown", handleClickOutside);
    return () => document.removeEventListener("mousedown", handleClickOutside);
  }, []);

  useEffect(() => {
    if (isOpen && searchInputRef.current) {
      setTimeout(() => searchInputRef.current?.focus(), 0);
    }
  }, [isOpen]);

  const handleKeyDown = (e: React.KeyboardEvent) => {
    if (disabled) return;
    switch (e.key) {
      case "Enter":
        e.preventDefault();
        if (!isOpen) setIsOpen(true);
        else if (focusedIndex >= 0 && filteredOptions[focusedIndex]) {
          handleOptionSelect(filteredOptions[focusedIndex].value);
        }
        break;
      case "Escape":
        setIsOpen(false);
        break;
      case "ArrowDown":
        e.preventDefault();
        if (!isOpen) setIsOpen(true);
        else setFocusedIndex(prev => prev < filteredOptions.length - 1 ? prev + 1 : 0);
        break;
      case "ArrowUp":
        e.preventDefault();
        if (isOpen) setFocusedIndex(prev => prev > 0 ? prev - 1 : filteredOptions.length - 1);
        break;
      case "Tab":
        setIsOpen(false);
        break;
    }
  };

  useEffect(() => {
    if (focusedIndex >= 0 && optionRefs.current[focusedIndex]) {
      optionRefs.current[focusedIndex]?.scrollIntoView({ block: "nearest", behavior: "smooth" });
    }
  }, [focusedIndex]);

  const handleOptionSelect = (optionValue: string) => {
    onChange(optionValue);
    setIsOpen(false);
  };

  const handleClear = (e: React.MouseEvent) => {
    e.stopPropagation();
    onChange(null);
  };

  const toggleDropdown = () => {
    if (!disabled) setIsOpen(!isOpen);
  };

  const baseClasses = `relative w-full rounded-md border px-3 py-2 focus-within:ring-2 focus-within:ring-blue-500 focus-within:outline-none transition-colors cursor-pointer ${error ? "border-red-300 dark:border-red-600" : "border-gray-300 dark:border-gray-600"} ${disabled ? "bg-gray-100 cursor-not-allowed dark:bg-gray-600" : `${hasValue ? "bg-gray-50 dark:bg-gray-800" : "bg-white dark:bg-gray-900"} hover:border-gray-400 dark:hover:border-gray-500`} dark:text-white dark:focus-within:ring-blue-600`;

  const DropdownContent = (
    <div ref={dropdownRef} style={dropdownStyle} className="z-[999] bg-white dark:bg-gray-900 border border-gray-300 dark:border-gray-600 rounded-md shadow-lg">
      <div className="p-2 border-b border-gray-200 dark:border-gray-600">
        <div className="relative">
          <FiSearch className="absolute left-3 top-1/2 transform -translate-y-1/2 w-4 h-4 text-gray-400 dark:text-gray-500" />
          <input
            ref={searchInputRef} type="text" placeholder={searchPlaceholder}
            value={searchTerm} onChange={(e) => setSearchTerm(e.target.value)}
            onKeyDown={handleKeyDown}
            className="w-full pl-10 pr-3 py-2 text-sm border border-gray-300 dark:border-gray-600 rounded-md focus:ring-2 focus:ring-blue-500 focus:outline-none bg-white dark:bg-gray-900 text-gray-900 dark:text-white"
          />
          {isLoading && <div className="absolute right-3 top-1/2 transform -translate-y-1/2"><ButtonSpinner size="sm" /></div>}
        </div>
      </div>
      <div className="overflow-y-auto" style={{ maxHeight: `${maxHeight}px` }} role="listbox">
        {filteredOptions.length === 0 && !isLoading ? (
          <div className="px-3 py-2 text-sm text-gray-500 dark:text-gray-400 text-center">{noOptionsMessage}</div>
        ) : (
          filteredOptions.map((option, index) => (
            <div
              key={option.value} ref={(el) => { optionRefs.current[index] = el; }}
              className={`px-3 py-2 text-sm cursor-pointer transition-colors ${option.disabled ? "text-gray-400 dark:text-gray-500 cursor-not-allowed" : "text-gray-900 dark:text-white hover:bg-gray-100 dark:hover:bg-gray-600"} ${index === focusedIndex ? "bg-blue-100 dark:bg-blue-900/50" : ""} ${option.value === value ? "bg-blue-50 dark:bg-blue-900/30 font-medium" : ""}`}
              onClick={() => !option.disabled && handleOptionSelect(option.value)}
              role="option" aria-selected={option.value === value}
            >
              {option.label}
            </div>
          ))
        )}
      </div>
    </div>
  );

  return (
    <div ref={triggerRef} className={`relative ${className}`}>
      {label && <Label>{label}</Label>}
      <div className={`${baseClasses.trim()} ${isOpen ? "ring-2 ring-blue-500 dark:ring-blue-600" : ""}`} onClick={toggleDropdown} onKeyDown={handleKeyDown} tabIndex={disabled ? -1 : 0} role="combobox" aria-expanded={isOpen}>
        <div className="flex items-center justify-between">
          <span className={`block truncate ${!selectedLabel ? "text-gray-500 dark:text-gray-400" : ""}`}>{selectedLabel || placeholder}</span>
          <div className="flex items-center gap-1">
            {clearable && value && !disabled && (<button type="button" onClick={handleClear} className="flex items-center justify-center w-4 h-4 text-gray-400 hover:text-gray-600 dark:hover:text-gray-300" tabIndex={-1}><FiX className="w-3 h-3" /></button>)}
            <FiChevronDown className={`w-4 h-4 text-gray-400 transition-transform ${isOpen ? "rotate-180" : ""}`} />
          </div>
        </div>
      </div>
      {isOpen && typeof document !== 'undefined' && createPortal(DropdownContent, document.body)}
    </div>
  );
};
```

<!-- path: components/common/ui/textarea/Textarea.tsx -->
```typescript
/* eslint-disable @typescript-eslint/no-unused-vars */
import { useState, ChangeEvent, FocusEvent } from "react";
import { Label } from "@/components/common/ui/label/Label";

// Type definitions
type TextareaResize = "none" | "both" | "horizontal" | "vertical";
type TextareaVariant = "default" | "filled" | "outlined";

interface TextareaProps extends Omit<React.TextareaHTMLAttributes<HTMLTextAreaElement>, "onChange"> {
  value?: string;
  onChange?: (e: ChangeEvent<HTMLTextAreaElement>, value: string) => void;
  placeholder?: string;
  disabled?: boolean;
  required?: boolean;
  error?: boolean;
  errorMessage?: string;
  label?: string;
  helperText?: string;
  rows?: number;
  maxLength?: number;
  resize?: TextareaResize;
  variant?: TextareaVariant;
  className?: string;
  id?: string;
  showCharCount?: boolean;
  fullWidth?: boolean;
}

// Textarea Component
export const Textarea: React.FC<TextareaProps> = ({
  value = "",
  onChange = (e: ChangeEvent<HTMLTextAreaElement>, value: string) => {},
  placeholder = "",
  disabled = false,
  required = false,
  error = false,
  errorMessage = "",
  label,
  helperText,
  rows = 4,
  maxLength,
  resize = "vertical",
  variant = "default",
  className = "",
  id,
  showCharCount = true,
  fullWidth = true,
  ...props
}) => {
  const [focused, setFocused] = useState<boolean>(false);
  const [charCount, setCharCount] = useState<number>(value.length);
  const hasValue = String(value ?? '').length > 0;

  const handleChange = (e: ChangeEvent<HTMLTextAreaElement>) => {
    const newValue = e.target.value;
    setCharCount(newValue.length);
    onChange(e, newValue);
  };

  const handleFocus = (e: FocusEvent<HTMLTextAreaElement>) => {
    setFocused(true);
    props.onFocus?.(e);
  };

  const handleBlur = (e: FocusEvent<HTMLTextAreaElement>) => {
    setFocused(false);
    props.onBlur?.(e);
  };

  const resizeClasses: Record<TextareaResize, string> = {
    none: "resize-none",
    both: "resize",
    horizontal: "resize-x",
    vertical: "resize-y",
  };

  const variantClasses: Record<TextareaVariant, string> = {
    default: "border shadow-sm",
    filled: "border-b-2 bg-gray-50 dark:bg-gray-900",
    outlined: "border-2"
  };

  const uniqueId = id || `textarea-${Math.random().toString(36).substr(2, 9)}`;

  return (
    <div className={`${fullWidth ? "w-full" : "w-fit"} ${className}`}>
      {label && (
        <Label
          htmlFor={uniqueId}
          required={required}
          disabled={disabled}
          className="mb-2"
        >
          {label}
        </Label>
      )}

      <div className="relative">
        <textarea
          id={uniqueId}
          value={value}
          onChange={handleChange}
          onFocus={handleFocus}
          onBlur={handleBlur}
          placeholder={placeholder}
          disabled={disabled}
          required={required}
          rows={rows}
          maxLength={maxLength}
          className={`
            ${fullWidth ? "w-full" : "w-fit"} 
            px-3 py-2 rounded-lg transition-all duration-200
            ${resizeClasses[resize]}
            ${variantClasses[variant]}
            ${
              error
                ? "border-red-300 focus:border-red-500 focus:ring-red-500 dark:border-red-500 dark:focus:border-red-600"
                : focused
                ? "border-blue-500 ring-2 ring-blue-500 ring-opacity-20 dark:border-blue-400 dark:ring-blue-400"
                : "border-gray-300 hover:border-gray-400 dark:border-gray-600 dark:hover:border-gray-500"
            }
            ${
              disabled
                ? "bg-gray-50 text-gray-400 cursor-not-allowed dark:bg-gray-900 dark:text-gray-500"
                : hasValue
                  ? "bg-gray-100 text-gray-900 dark:bg-gray-800 dark:text-gray-100"
                  : "bg-white text-gray-900 dark:bg-gray-900 dark:text-gray-100"
            }
            focus:outline-none placeholder-gray-400 dark:placeholder-gray-500
          `}
          {...props}
        />

        {maxLength && showCharCount && (
          <div className="absolute bottom-2 right-2 text-xs text-gray-400 dark:text-gray-400 bg-white dark:bg-gray-900 px-1 rounded">
            {charCount}/{maxLength}
          </div>
        )}
      </div>

      {(errorMessage || helperText) && (
        <div className="mt-1">
          {error && errorMessage && (
            <p className="text-sm text-red-600 dark:text-red-400 flex items-center">
              <svg
                className="w-4 h-4 mr-1"
                fill="currentColor"
                viewBox="0 0 20 20"
              >
                <path
                  fillRule="evenodd"
                  d="M18 10a8 8 0 11-16 0 8 8 0 0116 0zm-7 4a1 1 0 11-2 0 1 1 0 012 0zm-1-9a1 1 0 00-1 1v4a1 1 0 102 0V6a1 1 0 00-1-1z"
                  clipRule="evenodd"
                />
              </svg>
              {errorMessage}
            </p>
          )}
          {!error && helperText && (
            <p className="text-sm text-gray-500 dark:text-gray-400">{helperText}</p>
          )}
        </div>
      )}
    </div>
  );
};
```

<!-- path: components/common/ui/card/card.tsx -->
```typescript
import * as React from "react"

import { cn } from "@/lib/utils"

function Card({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="card"
      className={cn(
        "bg-card text-card-foreground flex flex-col gap-6 rounded-xl border py-6 shadow-sm",
        className
      )}
      {...props}
    />
  )
}

function CardHeader({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="card-header"
      className={cn(
        "@container/card-header grid auto-rows-min grid-rows-[auto_auto] items-start gap-1.5 px-6 has-data-[slot=card-action]:grid-cols-[1fr_auto] [.border-b]:pb-6",
        className
      )}
      {...props}
    />
  )
}

function CardTitle({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="card-title"
      className={cn("leading-none font-semibold", className)}
      {...props}
    />
  )
}

function CardDescription({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="card-description"
      className={cn("text-muted-foreground text-sm", className)}
      {...props}
    />
  )
}

function CardAction({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="card-action"
      className={cn(
        "col-start-2 row-span-2 row-start-1 self-start justify-self-end",
        className
      )}
      {...props}
    />
  )
}

function CardContent({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="card-content"
      className={cn("px-6", className)}
      {...props}
    />
  )
}

function CardFooter({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="card-footer"
      className={cn("flex items-center px-6 [.border-t]:pt-6", className)}
      {...props}
    />
  )
}

export {
  Card,
  CardHeader,
  CardFooter,
  CardTitle,
  CardAction,
  CardDescription,
  CardContent,
}

```

<!-- path: components/common/ui/card/_Card.tsx -->
```typescript
import { type ReactNode, forwardRef } from 'react';
import { motion } from 'framer-motion';
import { cn } from '@/utils/classNames';

interface CardProps {
  children: ReactNode;
  className?: string;
  variant?: 'default' | 'outlined' | 'elevated' | 'ghost';
  size?: 'sm' | 'md' | 'lg';
  hover?: boolean;
  clickable?: boolean;
  onClick?: () => void;
  padding?: 'none' | 'sm' | 'md' | 'lg';
  rounded?: 'none' | 'sm' | 'md' | 'lg' | 'xl';
}

interface CardHeaderProps {
  children: ReactNode;
  className?: string;
}

interface CardBodyProps {
  children: ReactNode;
  className?: string;
}

interface CardFooterProps {
  children: ReactNode;
  className?: string;
}

const Card = forwardRef<HTMLDivElement, CardProps>(
  ({
    children,
    className,
    variant = 'default',
    size = 'md',
    hover = false,
    clickable = false,
    onClick,
    padding = 'md',
    rounded = 'lg',
    ...props
  }, ref) => {
    const variantClasses = {
      default: 'bg-white dark:bg-gray-800 border border-gray-200 dark:border-gray-700 shadow-sm dark:shadow-gray-900/20',
      outlined: 'bg-white dark:bg-gray-800 border-2 border-gray-300 dark:border-gray-600',
      elevated: 'bg-white dark:bg-gray-800 shadow-lg dark:shadow-gray-900/30 border border-gray-100 dark:border-gray-700',
      ghost: 'bg-transparent dark:bg-transparent'
    };

    const sizeClasses = {
      sm: 'text-sm',
      md: 'text-base',
      lg: 'text-lg'
    };

    const paddingClasses = {
      none: '',
      sm: 'p-3',
      md: 'p-4',
      lg: 'p-6'
    };

    const roundedClasses = {
      none: '',
      sm: 'rounded-sm',
      md: 'rounded-md',
      lg: 'rounded-lg',
      xl: 'rounded-xl'
    };

    const Component = clickable || onClick ? motion.div : 'div';
    const motionProps = clickable || onClick ? {
      whileHover: hover ? { y: -2, scale: 1.02 } : undefined,
      whileTap: { scale: 0.98 },
      transition: { type: "spring" as const, stiffness: 400, damping: 25 }
    } : {};

    return (
      <Component
        ref={ref}
        className={cn(
          'transition-all duration-200 text-gray-900 dark:text-gray-100',
          variantClasses[variant],
          sizeClasses[size],
          paddingClasses[padding],
          roundedClasses[rounded],
          clickable || onClick ? 'cursor-pointer' : '',
          hover && (clickable || onClick) ? 'hover:shadow-md hover:border-gray-300 dark:hover:border-gray-500 dark:hover:shadow-gray-900/30' : '',
          className
        )}
        onClick={onClick}
        {...motionProps}
        {...props}
      >
        {children}
      </Component>
    );
  }
);

Card.displayName = 'Card';

const CardHeader = ({ children, className }: CardHeaderProps) => (
  <div className={cn(
    'border-b border-gray-200 dark:border-gray-700 pb-3 mb-4 text-gray-900 dark:text-gray-100', 
    className
  )}>
    {children}
  </div>
);

const CardBody = ({ children, className }: CardBodyProps) => (
  <div className={cn('flex-1 text-gray-700 dark:text-gray-300', className)}>
    {children}
  </div>
);

const CardFooter = ({ children, className }: CardFooterProps) => (
  <div className={cn(
    'border-t border-gray-200 dark:border-gray-700 pt-3 mt-4 text-gray-600 dark:text-gray-400', 
    className
  )}>
    {children}
  </div>
);

export { Card, CardHeader, CardBody, CardFooter };
```

<!-- path: components/common/ui/card/index.ts -->
```typescript
export { Card } from './_Card';
export { CardHeader } from './_Card';
export { CardBody } from './_Card';
export { CardFooter } from './_Card';
```

<!-- path: components/common/ui/separator.tsx -->
```typescript
"use client"

import * as React from "react"
import * as SeparatorPrimitive from "@radix-ui/react-separator"

import { cn } from "@/lib/utils"

function Separator({
  className,
  orientation = "horizontal",
  decorative = true,
  ...props
}: React.ComponentProps<typeof SeparatorPrimitive.Root>) {
  return (
    <SeparatorPrimitive.Root
      data-slot="separator"
      decorative={decorative}
      orientation={orientation}
      className={cn(
        "bg-border shrink-0 data-[orientation=horizontal]:h-px data-[orientation=horizontal]:w-full data-[orientation=vertical]:h-full data-[orientation=vertical]:w-px",
        className
      )}
      {...props}
    />
  )
}

export { Separator }

```

<!-- path: components/common/ui/tabs.tsx -->
```typescript
"use client"

import * as React from "react"
import * as TabsPrimitive from "@radix-ui/react-tabs"

import { cn } from "@/lib/utils"

function Tabs({
  className,
  ...props
}: React.ComponentProps<typeof TabsPrimitive.Root>) {
  return (
    <TabsPrimitive.Root
      data-slot="tabs"
      className={cn("flex flex-col gap-2", className)}
      {...props}
    />
  )
}

function TabsList({
  className,
  ...props
}: React.ComponentProps<typeof TabsPrimitive.List>) {
  return (
    <TabsPrimitive.List
      data-slot="tabs-list"
      className={cn(
        "bg-muted text-muted-foreground inline-flex h-9 w-fit items-center justify-center rounded-lg p-[3px]",
        className
      )}
      {...props}
    />
  )
}

function TabsTrigger({
  className,
  ...props
}: React.ComponentProps<typeof TabsPrimitive.Trigger>) {
  return (
    <TabsPrimitive.Trigger
      data-slot="tabs-trigger"
      className={cn(
        "data-[state=active]:bg-background dark:data-[state=active]:text-foreground focus-visible:border-ring focus-visible:ring-ring/50 focus-visible:outline-ring dark:data-[state=active]:border-input dark:data-[state=active]:bg-input/30 text-foreground dark:text-muted-foreground inline-flex h-[calc(100%-1px)] flex-1 items-center justify-center gap-1.5 rounded-md border border-transparent px-2 py-1 text-sm font-medium whitespace-nowrap transition-[color,box-shadow] focus-visible:ring-[3px] focus-visible:outline-1 disabled:pointer-events-none disabled:opacity-50 data-[state=active]:shadow-sm [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4",
        className
      )}
      {...props}
    />
  )
}

function TabsContent({
  className,
  ...props
}: React.ComponentProps<typeof TabsPrimitive.Content>) {
  return (
    <TabsPrimitive.Content
      data-slot="tabs-content"
      className={cn("flex-1 outline-none", className)}
      {...props}
    />
  )
}

export { Tabs, TabsList, TabsTrigger, TabsContent }

```

<!-- path: components/common/ui/index.ts -->
```typescript
export { Button } from './Button';
export { Card } from './card';
export { CardHeader } from './card';
export { CardBody } from './card';
export { CardFooter } from './card';
export { Input } from './Input';
export { LoadingSpinner } from './LoadingSpinner';
export { ProgressBar } from './ProgressBar';
export { PhoneInputWithCountry } from './phoneInput';
export { Modal } from './Modal';
export { ChangePasswordModal } from './Modal';
export { Label } from './label/Label';
export { Switch } from './switch/Switch';
export { Textarea } from './textarea/Textarea';
export { ButtonSpinner } from './LoadingSpinner';
export { ConfirmModal } from './Modal';
export { ErrorDisplay } from './error/ErrorDisplay';
export { RoleBadge } from './badges/RoleBadge';
export { StatusBadge } from './badges/StatusBadge';
export {PageSpinner} from './LoadingSpinner';
export {Tabs, TabsContent, TabsList, TabsTrigger} from './tabs';
export {SearchableSelect} from './select/SearchableSelect';





```

<!-- path: components/common/ui/table/TableSkeleton.tsx -->
```typescript
import React from 'react';

interface SkeletonProps {
  className?: string;
  variant?: 'text' | 'rect' | 'circle' | 'rounded';
  width?: string | number;
  height?: string | number;
  animation?: 'pulse' | 'wave' | 'none';
}

const Skeleton: React.FC<SkeletonProps> = ({
  className = '',
  variant = 'text',
  width,
  height,
  animation = 'pulse',
}) => {
  const getVariantClasses = () => {
    switch (variant) {
      case 'text':
        return 'h-4 rounded';
      case 'rect':
        return 'rounded';
      case 'circle':
        return 'rounded-full';
      case 'rounded':
        return 'rounded-lg';
      default:
        return 'h-4 rounded';
    }
  };

  const getAnimationClasses = () => {
    switch (animation) {
      case 'pulse':
        return 'animate-pulse';
      case 'wave':
        return 'animate-wave';
      case 'none':
        return '';
      default:
        return 'animate-pulse';
    }
  };

  const style: React.CSSProperties = {
    width: width || '100%',
    height: height || (variant === 'text' ? '1rem' : '2rem'),
  };

  return (
    <div
      className={`bg-gray-300 dark:bg-gray-700 ${getVariantClasses()} ${getAnimationClasses()} ${className}`}
      style={style}
    />
  );
};

// Compound components for common patterns
interface TableSkeletonProps {
  rows?: number;
  columns?: number;
  showHeader?: boolean;
  className?: string;
}

export const TableSkeleton: React.FC<TableSkeletonProps> = ({
  rows = 5,
  columns = 6,
  showHeader = true,
  className = '',
}) => {
  return (
    <div className={`w-full ${className}`}>
      {showHeader && (
        <div className="mb-4 flex gap-4 border-b border-gray-200 pb-4 dark:border-gray-700">
          {Array.from({ length: columns }, (_, i) => (
            <Skeleton key={`header-${i}`} variant="text" width="100%" height="1.5rem" />
          ))}
        </div>
      )}
      <div className="space-y-3">
        {Array.from({ length: rows }, (_, rowIndex) => (
          <div key={`row-${rowIndex}`} className="flex gap-4">
            {Array.from({ length: columns }, (_, colIndex) => (
              <Skeleton
                key={`cell-${rowIndex}-${colIndex}`}
                variant="text"
                width="100%"
                height="2.5rem"
              />
            ))}
          </div>
        ))}
      </div>
    </div>
  );
};

interface CardSkeletonProps {
  showImage?: boolean;
  showTitle?: boolean;
  showDescription?: boolean;
  lines?: number;
  className?: string;
}

export const CardSkeleton: React.FC<CardSkeletonProps> = ({
  showImage = true,
  showTitle = true,
  showDescription = true,
  lines = 3,
  className = '',
}) => {
  return (
    <div className={`rounded-lg border border-gray-200 bg-white p-4 dark:border-gray-700 dark:bg-gray-800 ${className}`}>
      {showImage && (
        <Skeleton variant="rounded" width="100%" height="12rem" className="mb-4" />
      )}
      {showTitle && (
        <Skeleton variant="text" width="60%" height="1.5rem" className="mb-2" />
      )}
      {showDescription && (
        <div className="space-y-2">
          {Array.from({ length: lines }, (_, i) => (
            <Skeleton
              key={i}
              variant="text"
              width={i === lines - 1 ? '80%' : '100%'}
              height="1rem"
            />
          ))}
        </div>
      )}
    </div>
  );
};

interface StatsSkeletonProps {
  count?: number;
  className?: string;
}

export const StatsCardsSkeleton: React.FC<StatsSkeletonProps> = ({
  count = 4,
  className = '',
}) => {
  return (
    <div className={`grid grid-cols-1 gap-4 sm:grid-cols-2 md:grid-cols-4 ${className}`}>
      {Array.from({ length: count }, (_, i) => (
        <div
          key={i}
          className="rounded-lg border border-gray-200 bg-white p-4 dark:border-gray-700 dark:bg-gray-800"
        >
          <Skeleton variant="text" width="60%" height="2.5rem" className="mb-2" />
          <Skeleton variant="text" width="80%" height="1rem" />
        </div>
      ))}
    </div>
  );
};

interface PageSkeletonProps {
  showHeader?: boolean;
  showStats?: boolean;
  showFilters?: boolean;
  showTable?: boolean;
  statsCount?: number;
  tableRows?: number;
  tableColumns?: number;
  className?: string;
}

export const PageSkeleton: React.FC<PageSkeletonProps> = ({
  showHeader = true,
  showStats = true,
  showFilters = true,
  showTable = true,
  statsCount = 4,
  tableRows = 10,
  tableColumns = 6,
  className = '',
}) => {
  return (
    <div className={`min-h-screen bg-gray-50 p-6 dark:bg-gray-900 ${className}`}>
      <div className="mx-auto">
        {/* Header Skeleton */}
        {showHeader && (
          <div className="mb-6">
            <div className="mb-4 flex flex-col items-start justify-between gap-4 sm:flex-row sm:items-center">
              <div className="flex-1">
                <Skeleton variant="text" width="200px" height="2rem" className="mb-2" />
                <Skeleton variant="text" width="300px" height="1rem" />
              </div>
              <Skeleton variant="rounded" width="150px" height="40px" />
            </div>
          </div>
        )}

        {/* Stats Skeleton */}
        {showStats && <StatsCardsSkeleton count={statsCount} className="mb-6" />}

        {/* Filters Skeleton */}
        {showFilters && (
          <div className="mb-6 flex flex-wrap gap-4 rounded-lg border border-gray-200 bg-white p-4 dark:border-gray-700 dark:bg-gray-800">
            <Skeleton variant="rounded" width="200px" height="40px" />
            <Skeleton variant="rounded" width="150px" height="40px" />
            <Skeleton variant="rounded" width="150px" height="40px" />
            <Skeleton variant="rounded" width="100px" height="40px" />
          </div>
        )}

        {/* Table Skeleton */}
        {showTable && (
          <div className="rounded-lg border border-gray-200 bg-white p-4 dark:border-gray-700 dark:bg-gray-800">
            <TableSkeleton rows={tableRows} columns={tableColumns} />
            {/* Pagination Skeleton */}
            <div className="mt-4 flex items-center justify-between border-t border-gray-200 pt-4 dark:border-gray-700">
              <Skeleton variant="text" width="150px" height="1rem" />
              <div className="flex gap-2">
                {Array.from({ length: 5 }, (_, i) => (
                  <Skeleton key={i} variant="rounded" width="40px" height="40px" />
                ))}
              </div>
            </div>
          </div>
        )}
      </div>
    </div>
  );
};

export default Skeleton;
```

<!-- path: components/common/ui/LoadingSpinner/LoadingSpinner.tsx -->
```typescript
// components/common/ui/LoadingSpinner/LoadingSpinner.tsx
import { cn } from '@/utils/classNames';

interface LoadingSpinnerProps {
  size?: 'xs' | 'sm' | 'md' | 'lg' | 'xl';
  color?: 'primary' | 'secondary' | 'white' | 'gray';
  className?: string;
  text?: string;
  overlay?: boolean;
}

const sizeClasses = {
  xs: 'h-3 w-3',
  sm: 'h-4 w-4',
  md: 'h-6 w-6',
  lg: 'h-8 w-8',
  xl: 'h-12 w-12',
};

const colorClasses = {
  primary: 'text-blue-600 dark:text-blue-400',
  secondary: 'text-gray-600 dark:text-gray-400',
  white: 'text-white dark:text-white',
  gray: 'text-gray-400 dark:text-gray-500',
};

const textSizeClasses = {
  xs: 'text-xs',
  sm: 'text-sm',
  md: 'text-base',
  lg: 'text-lg',
  xl: 'text-xl',
};

export const LoadingSpinner: React.FC<LoadingSpinnerProps> = ({
  size = 'md',
  color = 'primary',
  className,
  text,
  overlay = false,
}) => {
  const spinnerContent = (
    <div className={cn('flex flex-col items-center justify-center gap-3', className)}>
      <svg
        className={cn(
          'animate-spin',
          sizeClasses[size],
          colorClasses[color]
        )}
        xmlns="http://www.w3.org/2000/svg"
        fill="none"
        viewBox="0 0 24 24"
      >
        <circle
          className="opacity-25"
          cx="12"
          cy="12"
          r="10"
          stroke="currentColor"
          strokeWidth="4"
        />
        <path
          className="opacity-75"
          fill="currentColor"
          d="M4 12a8 8 0 0 1 8-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 0 1 4 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"
        />
      </svg>
      
      {text && (
        <p className={cn(
          'font-medium text-gray-600 dark:text-gray-300',
          textSizeClasses[size]
        )}>
          {text}
        </p>
      )}
    </div>
  );

  if (overlay) {
    return (
      <div className="fixed inset-0 z-50 flex items-center justify-center bg-black bg-opacity-25 dark:bg-black dark:bg-opacity-40 backdrop-blur-sm">
        <div className="rounded-lg bg-white dark:bg-gray-800 p-6 shadow-lg">
          {spinnerContent}
        </div>
      </div>
    );
  }

  return spinnerContent;
};

// Variants for specific use cases
export const ButtonSpinner: React.FC<{ size?: 'xs' | 'sm' | 'md' }> = ({ 
  size = 'sm' 
}) => (
  <LoadingSpinner size={size} color="primary" className="inline-flex" />
);

export const PageSpinner: React.FC<{ text?: string }> = ({ 
  text = 'Loading...' 
}) => (
  <div className="flex min-h-screen items-center justify-center">
    <LoadingSpinner size="lg" text={text} />
  </div>
);

export const CardSpinner: React.FC<{ text?: string }> = ({ 
  text 
}) => (
  <div className="flex items-center justify-center py-12">
    <LoadingSpinner size="md" text={text} />
  </div>
);

// Loading skeleton components
export const LoadingSkeleton: React.FC<{
  className?: string;
  rows?: number;
}> = ({ className, rows = 1 }) => (
  <div className={cn('animate-pulse space-y-3', className)}>
    {Array.from({ length: rows }).map((_, index) => (
      <div
        key={index}
        className="h-4 rounded bg-gray-200 dark:bg-gray-700"
        style={{
          width: `${Math.random() * 40 + 60}%`,
        }}
      />
    ))}
  </div>
);

export const LoadingCard: React.FC<{
  className?: string;
}> = ({ className }) => (
  <div className={cn('animate-pulse rounded-lg border border-gray-200 dark:border-gray-700 p-6', className)}>
    <div className="space-y-4">
      <div className="h-6 w-3/4 rounded bg-gray-200 dark:bg-gray-700" />
      <div className="space-y-2">
        <div className="h-4 rounded bg-gray-200 dark:bg-gray-700" />
        <div className="h-4 w-5/6 rounded bg-gray-200 dark:bg-gray-700" />
      </div>
      <div className="h-10 w-24 rounded bg-gray-200 dark:bg-gray-700" />
    </div>
  </div>
);
```

<!-- path: components/common/ui/LoadingSpinner/AdvancedLoader.tsx -->
```typescript
"use client";

import React, { useState, useEffect } from "react";

const AdvancedLoader: React.FC<{ children: React.ReactNode }> = ({ children }) => {
  const [loadingProgress, setLoadingProgress] = useState(0);
  const [isLoading, setIsLoading] = useState(true);
  const [loadingText, setLoadingText] = useState("Initializing...");

  useEffect(() => {
    const loadingSteps = [
      { progress: 20, text: "Loading assets..." },
      { progress: 40, text: "Connecting to server..." },
      { progress: 60, text: "Fetching data..." },
      { progress: 80, text: "Preparing interface..." },
      { progress: 100, text: "Almost ready..." },
    ];

    let currentStep = 0;
    const interval = setInterval(() => {
      if (currentStep < loadingSteps.length) {
        const step = loadingSteps[currentStep];
        setLoadingProgress(step.progress);
        setLoadingText(step.text);
        currentStep++;
      } else {
        clearInterval(interval);
        setTimeout(() => {
          setIsLoading(false);
        }, 500);
      }
    }, 600);

    return () => clearInterval(interval);
  }, []);

  if (isLoading) {
    return (
      <div className='fixed inset-0 bg-gradient-to-r from-indigo-900 via-purple-900 to-pink-900 flex items-center justify-center'>
        <div className='text-center max-w-md mx-auto px-6'>
          {/* Logo or Brand */}
          <div className='mb-8'>
            <div className='w-16 h-16 mx-auto bg-white bg-opacity-20 rounded-full flex items-center justify-center'>
              <div className='w-8 h-8 bg-white rounded-sm'></div>
            </div>
          </div>

          {/* Main Loader */}
          <div className='relative mb-8'>
            <div className='w-32 h-32 mx-auto relative'>
              <svg className='w-32 h-32 transform -rotate-90' viewBox='0 0 100 100'>
                <circle cx='50' cy='50' r='40' stroke='rgba(255,255,255,0.2)' strokeWidth='8' fill='none' />
                <circle
                  cx='50'
                  cy='50'
                  r='40'
                  stroke='white'
                  strokeWidth='8'
                  fill='none'
                  strokeLinecap='round'
                  strokeDasharray={`${2 * Math.PI * 40}`}
                  strokeDashoffset={`${2 * Math.PI * 40 * (1 - loadingProgress / 100)}`}
                  className='transition-all duration-500 ease-out'
                />
              </svg>
              <div className='absolute inset-0 flex items-center justify-center'>
                <span className='text-white text-2xl font-bold'>{loadingProgress}%</span>
              </div>
            </div>
          </div>

          {/* Loading Text */}
          <div className='mb-6'>
            <p className='text-white text-lg font-medium'>{loadingText}</p>
          </div>

          {/* Progress Bar */}
          <div className='w-full bg-white bg-opacity-20 rounded-full h-2 mb-4'>
            <div className='bg-white rounded-full h-2 transition-all duration-500 ease-out' style={{ width: `${loadingProgress}%` }}></div>
          </div>

          {/* Dots Animation */}
          <div className='flex justify-center space-x-2'>
            {[0, 1, 2].map((i) => (
              <div
                key={i}
                className='w-2 h-2 bg-white rounded-full animate-pulse'
                style={{
                  animationDelay: `${i * 0.2}s`,
                  animationDuration: "1s",
                }}></div>
            ))}
          </div>
        </div>
      </div>
    );
  }

  return <>{children}</>;
};

export default AdvancedLoader;

```

<!-- path: components/common/ui/LoadingSpinner/index.ts -->
```typescript
export { LoadingSpinner } from './LoadingSpinner';
export { ButtonSpinner, PageSpinner, CardSpinner, LoadingSkeleton, LoadingCard } from './LoadingSpinner';
```

<!-- path: components/common/ui/Input/Input.tsx -->
```typescript
"use client";

import React, { forwardRef, useEffect, useId, useRef, useState } from 'react';
import { clsx } from 'clsx';
import { FiX } from 'react-icons/fi';

interface InputProps extends Omit<React.InputHTMLAttributes<HTMLInputElement>, 'size'> {
  error?: string;
  leftIcon?: React.ReactNode;
  isLoading?: boolean;
  fullWidth?: boolean;
  clearable?: boolean;
  onClear?: () => void;
}

const Input = forwardRef<HTMLInputElement, InputProps>(
  (
    {
      className,
      type = 'text',
      error,
      leftIcon,
      isLoading = false,
      disabled,
      fullWidth = true,
      clearable = false,
      onClear,
      id,
      value,
      ...props
    },
    ref
  ) => {
    const generatedId = useId();
    const inputId = id || generatedId;
    const innerRef = useRef<HTMLInputElement | null>(null);
    const [liveHasValue, setLiveHasValue] = useState<boolean>(false);

    // Merge forwarded ref with local ref
    const setRefs = (el: HTMLInputElement | null) => {
      innerRef.current = el;
      if (typeof ref === 'function') ref(el);
      else if (ref && 'current' in ref) (ref as React.MutableRefObject<HTMLInputElement | null>).current = el;
    };

    // Initialize hasValue on mount and when value/defaultValue changes
    useEffect(() => {
      const dv = (props as { defaultValue?: string | number })?.defaultValue;
      const raw = value ?? dv ?? innerRef.current?.value ?? '';
      setLiveHasValue(String(raw).length > 0);
      // eslint-disable-next-line react-hooks/exhaustive-deps
    }, [value, (props as { defaultValue?: string | number })?.defaultValue]);

    // Handle clear action
    const handleClear = () => {
      // Create a synthetic event that react-hook-form can understand
      const syntheticEvent = {
        target: { value: '' },
        currentTarget: { value: '' },
      } as React.ChangeEvent<HTMLInputElement>;
      
      // If an onChange is passed from register, call it with an empty value
      props.onChange?.(syntheticEvent);
      
      onClear?.();
      
      // Focus the input
      if (ref && 'current' in ref && ref.current) {
        ref.current.focus();
      }
    };
    
    const shouldShowClear = clearable && !disabled && !isLoading && (String((value) || '').length > 0 || liveHasValue);
    const defaultValue = (props as { defaultValue?: string | number })?.defaultValue;
    const rawVal = value ?? defaultValue ?? '';
    const hasValue = liveHasValue || String(rawVal).length > 0;

    const inputClasses = clsx(
      'rounded-lg border transition-all duration-200 font-medium w-full',
      'focus:outline-none focus:ring-2 focus:border-transparent',
      'placeholder:text-gray-400 dark:placeholder-gray-500',
      'px-4 py-2.5 text-base', // Standard size
      leftIcon && 'pl-11',
      shouldShowClear && 'pr-11',
      // Place external classes earlier so our bg utilities later will override
      className,
      error ? 'border-red-500 focus:ring-red-500 dark:border-red-600' : 'border-gray-300 dark:border-gray-600 hover:border-gray-400 dark:hover:border-gray-500 focus:ring-blue-500',
      // Disabled style
      (disabled || isLoading) && 'bg-gray-100 dark:bg-gray-900 text-gray-500 cursor-not-allowed',
      // Active background: apply bg-gray-100 in normal mode and dark:bg-gray-800 in dark mode when input has value
      !(disabled || isLoading) && hasValue && 'bg-gray-50 dark:bg-gray-800!',
      // Default background when no value
      !(disabled || isLoading) && !hasValue && 'bg-white dark:bg-gray-900',
      // Text colors
      !(disabled || isLoading) && 'text-gray-900 dark:text-gray-100'
    );
    
    return (
      <div className={clsx('relative', fullWidth && 'w-full')}>
        {leftIcon && <div className="absolute left-3 top-1/2 -translate-y-1/2 pointer-events-none text-gray-400">{leftIcon}</div>}
        <input
          id={inputId}
          ref={setRefs}
          type={type}
          className={inputClasses}
          disabled={disabled || isLoading}
          value={value}
          onChange={(e) => {
            setLiveHasValue(e.currentTarget.value.length > 0);
            props.onChange?.(e);
          }}
          aria-invalid={!!error}
          {...props}
        />
        {shouldShowClear && (
          <button type="button" onClick={handleClear} className="absolute right-3 top-1/2 -translate-y-1/2 text-gray-400 hover:text-gray-600">
            <FiX />
          </button>
        )}
        {error && <p className="mt-1.5 text-sm text-red-600">{error}</p>}
      </div>
    );
  }
);

Input.displayName = 'Input';
export default Input;
```

<!-- path: components/common/ui/Input/index.ts -->
```typescript
export { default as Input } from './Input';

```

<!-- path: components/common/ui/accordion.tsx -->
```typescript
"use client"

import * as React from "react"
import * as AccordionPrimitive from "@radix-ui/react-accordion"
import { ChevronDownIcon } from "lucide-react"

import { cn } from "@/lib/utils"

function Accordion({
  ...props
}: React.ComponentProps<typeof AccordionPrimitive.Root>) {
  return <AccordionPrimitive.Root data-slot="accordion" {...props} />
}

function AccordionItem({
  className,
  ...props
}: React.ComponentProps<typeof AccordionPrimitive.Item>) {
  return (
    <AccordionPrimitive.Item
      data-slot="accordion-item"
      className={cn("border-b last:border-b-0", className)}
      {...props}
    />
  )
}

function AccordionTrigger({
  className,
  children,
  ...props
}: React.ComponentProps<typeof AccordionPrimitive.Trigger>) {
  return (
    <AccordionPrimitive.Header className="flex">
      <AccordionPrimitive.Trigger
        data-slot="accordion-trigger"
        className={cn(
          "focus-visible:border-ring focus-visible:ring-ring/50 flex flex-1 items-start justify-between gap-4 rounded-md py-4 text-left text-sm font-medium transition-all outline-none hover:underline focus-visible:ring-[3px] disabled:pointer-events-none disabled:opacity-50 [&[data-state=open]>svg]:rotate-180",
          className
        )}
        {...props}
      >
        {children}
        <ChevronDownIcon className="text-muted-foreground pointer-events-none size-4 shrink-0 translate-y-0.5 transition-transform duration-200" />
      </AccordionPrimitive.Trigger>
    </AccordionPrimitive.Header>
  )
}

function AccordionContent({
  className,
  children,
  ...props
}: React.ComponentProps<typeof AccordionPrimitive.Content>) {
  return (
    <AccordionPrimitive.Content
      data-slot="accordion-content"
      className="data-[state=closed]:animate-accordion-up data-[state=open]:animate-accordion-down overflow-hidden text-sm"
      {...props}
    >
      <div className={cn("pt-0 pb-4", className)}>{children}</div>
    </AccordionPrimitive.Content>
  )
}

export { Accordion, AccordionItem, AccordionTrigger, AccordionContent }

```

<!-- path: components/common/BulkActions.tsx -->
```typescript
// BulkActions Component (Enhanced version)
import { FiTrash2, FiCheck, FiX } from "react-icons/fi";

interface BulkActionsProps {
  selectedCount: number;
  isOperationLoading?: boolean;
  onBulkDelete: () => void;
  onBulkUpdateStatus: (status: "active" | "inactive") => void;
  onClearSelection: () => void;
  entityName?: string;
  showStatusUpdate?: boolean;
  canDelete?: () => boolean;
  customActions?: Array<{
    label: string;
    icon?: React.ComponentType<{ className?: string }>;
    onClick: () => void;
    variant?: 'primary' | 'secondary' | 'danger';
    disabled?: boolean;
  }>;
}

export function BulkActions({
  selectedCount,
  isOperationLoading = false,
  onBulkDelete,
  onBulkUpdateStatus,
  onClearSelection,
  entityName = "item",
  showStatusUpdate = true,
  canDelete = () => true,
  customActions = [],
}: BulkActionsProps) {
  if (selectedCount === 0) return null;

  const handleStatusChange = (e: React.ChangeEvent<HTMLSelectElement>) => {
    const value = e.target.value as "active" | "inactive" | "";
    if (value) {
      onBulkUpdateStatus(value);
      // Reset select to default
      e.target.value = "";
    }
  };

  const getButtonClasses = (variant: 'primary' | 'secondary' | 'danger' = 'primary') => {
    const baseClasses = "px-3 py-1 rounded text-sm font-medium transition-colors disabled:opacity-50 disabled:cursor-not-allowed flex items-center gap-1";
    
    switch (variant) {
      case 'danger':
        return `${baseClasses} bg-red-600 text-white hover:bg-red-700 dark:bg-red-700 dark:hover:bg-red-800`;
      case 'secondary':
        return `${baseClasses} bg-gray-100 text-gray-700 hover:bg-gray-200 dark:bg-gray-700 dark:text-gray-300 dark:hover:bg-gray-600`;
      default:
        return `${baseClasses} bg-blue-600 text-white hover:bg-blue-700 dark:bg-blue-700 dark:hover:bg-blue-800`;
    }
  };

  return (
    <div className="bg-blue-50 border border-blue-200 rounded-lg p-4 mb-6 dark:bg-blue-900/20 dark:border-blue-700/50 transition-all duration-200">
      <div className="flex items-center justify-between flex-wrap gap-3">
        <div className="flex items-center gap-2">
          <FiCheck className="w-4 h-4 text-blue-600 dark:text-blue-400" />
          <p className="text-blue-900 dark:text-blue-100 font-medium">
            {selectedCount} {entityName}{selectedCount !== 1 ? 's' : ''} selected
          </p>
        </div>
        
        <div className="flex items-center gap-2 flex-wrap">
          {/* Status Update Dropdown */}
          {showStatusUpdate && (
            <select
              onChange={handleStatusChange}
              defaultValue=""
              className="text-sm border rounded px-2 py-1 min-w-[100px]
                        bg-white text-gray-900 border-gray-300
                        dark:bg-gray-700 dark:text-gray-100 dark:border-gray-600
                        disabled:opacity-50 focus:outline-none focus:ring-2 focus:ring-blue-500"
              disabled={isOperationLoading}
            >
              <option value="">Set Status</option>
              <option value="active">✅ Active</option>
              <option value="inactive">❌ Inactive</option>
            </select>
          )}

          {/* Custom Actions */}
          {customActions.map((action, index) => (
            <button
              key={index}
              onClick={action.onClick}
              disabled={isOperationLoading || action.disabled}
              className={getButtonClasses(action.variant)}
            >
              {action.icon && <action.icon className="w-4 h-4" />}
              {action.label}
            </button>
          ))}
          
          {/* Delete Button */}
          <button
            onClick={onBulkDelete}
            disabled={isOperationLoading || !canDelete()}
            className={getButtonClasses('danger')}
            title={`Delete ${selectedCount} selected ${entityName}${selectedCount !== 1 ? 's' : ''}`}
          >
            <FiTrash2 className="w-4 h-4" />
            Delete {selectedCount > 1 && `(${selectedCount})`}
          </button>
          
          {/* Clear Selection Button */}
          <button
            onClick={onClearSelection}
            disabled={isOperationLoading}
            className="text-gray-500 hover:text-gray-700 dark:text-gray-400 dark:hover:text-gray-300 
                      text-sm px-2 py-1 rounded transition-colors flex items-center gap-1"
            title="Clear selection"
          >
            <FiX className="w-4 h-4" />
            Clear
          </button>
        </div>
      </div>

      {/* Loading Indicator */}
      {isOperationLoading && (
        <div className="mt-3 flex items-center gap-2 text-sm text-blue-700 dark:text-blue-300">
          <div className="w-4 h-4 border-2 border-blue-600 border-t-transparent rounded-full animate-spin"></div>
          Processing {selectedCount} {entityName}{selectedCount !== 1 ? 's' : ''}...
        </div>
      )}
    </div>
  );
}


```

<!-- path: components/common/filters/FilterInputs.tsx -->
```typescript
import { SearchableSelect, Option } from '@/components/common/ui/select/SearchableSelect';
import { Input } from '@/components/common/ui/Input';
import { Filters } from '@/hooks/database';
import React from 'react';

// --- TYPE DEFINITIONS ---

interface FilterWrapperProps {
  label: string;
}

interface SelectFilterProps extends FilterWrapperProps {
  filterKey: string; // The key to modify in the filters object
  filters: Filters;
  setFilters: React.Dispatch<React.SetStateAction<Filters>>;
  options: Option[];
  placeholder?: string;
}

interface InputFilterProps extends FilterWrapperProps {
  filterKey: string;
  filters: Filters;
  setFilters: React.Dispatch<React.SetStateAction<Filters>>;
  placeholder?: string;
}

// --- COMPONENTS ---

export const SelectFilter: React.FC<SelectFilterProps> = ({
  label,
  filterKey,
  filters,
  setFilters,
  options,
  placeholder,
}) => {
  // Safely extract the current value, ensuring it's a string for the component.
  const currentValue = filters[filterKey];
  const valueAsString =
    typeof currentValue === 'string' || typeof currentValue === 'number'
      ? String(currentValue)
      : '';

  const handleChange = (newValue: string | null) => {
    setFilters((prevFilters) => {
      const newFilters = { ...prevFilters };
      if (newValue === null || newValue === '') {
        // When cleared, remove the key entirely for a cleaner state.
        delete newFilters[filterKey];
      } else {
        newFilters[filterKey] = newValue;
      }
      return newFilters;
    });
  };

  return (
    <div className="space-y-2">
      <label className="block text-sm font-medium text-gray-700 dark:text-gray-300">
        {label}
      </label>
      <SearchableSelect
        options={options}
        value={valueAsString}
        onChange={handleChange}
        placeholder={placeholder || `All ${label}s`}
        clearable
      />
      {/* <Select
        value={(valueAsString as string) ?? ''}
        onValueChange={(value) => handleChange(value)}
      >
        <SelectTrigger className="w-full">
          <SelectValue placeholder={placeholder ?? 'Select'} />
        </SelectTrigger>
        <SelectContent>
          {options.map((option) => (
            <SelectItem
              key={option.value}
              value={option.value}
              disabled={option.disabled}
            >
              {option.label}
            </SelectItem>
          ))}
        </SelectContent>
      </Select> */}
    </div>
  );
};

export const InputFilter: React.FC<InputFilterProps> = ({
  label,
  filterKey,
  filters,
  setFilters,
  placeholder,
}) => {
  // Safely extract the current value
  const currentValue = filters[filterKey];
  const valueAsString =
    typeof currentValue === 'string' || typeof currentValue === 'number'
      ? String(currentValue)
      : '';

  const handleChange = (newValue: string) => {
    setFilters((prevFilters) => {
      const newFilters = { ...prevFilters };
      if (newValue === '') {
        delete newFilters[filterKey];
      } else {
        newFilters[filterKey] = newValue;
      }
      return newFilters;
    });
  };

  return (
    <div className="space-y-2">
      <label className="block text-sm font-medium text-gray-700 dark:text-gray-300">
        {label}
      </label>
      <Input
        type="text"
        value={valueAsString}
        onChange={(e) => handleChange(e.target.value)}
        placeholder={placeholder || `Filter by ${label}...`}
      />
    </div>
  );
};

```

<!-- path: components/common/filters/SearchAndFilters.tsx -->
```typescript
import { motion } from "framer-motion";
import { FiSearch, FiX, FiFilter, FiChevronDown, FiChevronUp } from "react-icons/fi";

interface SearchAndFiltersProps {
  searchTerm: string;
  onSearchChange: (value: string) => void;
  showFilters: boolean;
  onToggleFilters: () => void;
  onClearFilters: () => void;
  hasActiveFilters: boolean;
  activeFilterCount: number; // More descriptive than a boolean
  searchPlaceholder?: string;
  children: React.ReactNode;
}

export function SearchAndFilters({
  searchTerm,
  onSearchChange,
  showFilters,
  onToggleFilters,
  onClearFilters,
  hasActiveFilters,
  activeFilterCount,
  searchPlaceholder = "Search...",
  children,
}: SearchAndFiltersProps) {
  return (
    <div className="space-y-3 sm:space-y-4 w-full p-4 border-b border-gray-200 dark:border-gray-700">
      {/* Search and Controls Row */}
      <div className="flex flex-col space-y-3 sm:space-y-0 sm:flex-row sm:gap-3 sm:justify-between sm:items-center">
        {/* Search Input */}
        <div className="flex-1 sm:max-w-md lg:max-w-xl">
          <div className="relative">
            <FiSearch className="absolute left-3 top-1/2 transform -translate-y-1/2 text-gray-400 w-4 h-4 sm:w-5 sm:h-5" />
            <input
              type="text"
              placeholder={searchPlaceholder}
              value={searchTerm}
              onChange={(e) => onSearchChange(e.target.value)}
              className="w-full pl-9 sm:pl-10 pr-4 py-2.5 sm:py-2 text-sm sm:text-base border border-gray-300 dark:border-gray-600 rounded-lg bg-white dark:bg-gray-700 text-gray-900 dark:text-white placeholder-gray-500 dark:placeholder-gray-400 focus:ring-2 focus:ring-blue-500 focus:border-blue-500 transition-colors"
            />
          </div>
        </div>

        {/* Filter and Clear Buttons */}
        <div className="flex gap-2 sm:gap-3">
          <button
            onClick={onToggleFilters}
            className={`flex items-center gap-2 px-3 sm:px-4 py-2.5 sm:py-2 border rounded-lg font-medium text-sm sm:text-base transition-all duration-200 flex-1 sm:flex-none justify-center sm:justify-start ${
              showFilters || activeFilterCount > 0
                ? "border-blue-500 bg-blue-50 text-blue-700 dark:border-blue-400 dark:bg-blue-900/30 dark:text-blue-300 shadow-sm"
                : "border-gray-300 dark:border-gray-600 hover:bg-gray-50 dark:hover:bg-gray-700 text-gray-700 dark:text-gray-300 hover:border-gray-400"
            }`}
          >
            <FiFilter size={16} className="w-4 h-4 sm:w-4 sm:h-4" />
            <span className="hidden sm:inline">Filters</span>
            <span className="sm:hidden">Filter</span>
            {showFilters ? <FiChevronUp size={14} /> : <FiChevronDown size={14} />}
            {activeFilterCount > 0 && (
              <span className="bg-blue-600 text-white text-xs rounded-full px-1.5 sm:px-2 py-0.5 font-semibold min-w-[18px] sm:min-w-[20px] text-center leading-none">
                {activeFilterCount}
              </span>
            )}
          </button>

          {hasActiveFilters && (
            <button
              onClick={onClearFilters}
              className="flex items-center gap-2 px-3 sm:px-4 py-2.5 sm:py-2 text-sm sm:text-base text-red-600 hover:bg-red-50 dark:hover:bg-red-900/20 rounded-lg transition-colors font-medium border border-transparent hover:border-red-200 flex-shrink-0"
            >
              <FiX className="w-4 h-4" />
              <span className="hidden sm:inline">Clear All</span>
              <span className="sm:hidden">Clear</span>
            </button>
          )}
        </div>
      </div>

      {/* Collapsible Filter Panel */}
      {showFilters && (
        <motion.div
          initial={{ opacity: 0, height: 0 }}
          animate={{ opacity: 1, height: "auto" }}
          exit={{ opacity: 0, height: 0 }}
          transition={{ duration: 0.2, ease: "easeInOut" }}
          className="overflow-hidden"
        >
          <div className="pt-3 sm:pt-4">
            <div className="p-3 sm:p-4 bg-gray-50 dark:bg-gray-800/50 rounded-lg border border-gray-200 dark:border-gray-700">
              <div className="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 gap-4">
                {children}
              </div>
            </div>
          </div>
        </motion.div>
      )}
    </div>
  );
}
```

<!-- path: components/common/TruncateTooltip.tsx -->
```typescript
// @/components/common/TruncateTooltip.tsx
import React, { useEffect, useRef, useState } from "react";

export interface TruncateTooltipProps {
  text: string;
  className?: string;
  /**
   * Optional id suffix for ARIA. If omitted, a random id will be generated.
   */
  id?: string;
  /**
   * Optional: control max width of tooltip in px. Default 320.
   */
  maxWidth?: number;
}

/**
 * Renders truncated single-line text and shows a custom tooltip on hover/focus
 * only when the content is visually truncated.
 */
export const TruncateTooltip: React.FC<TruncateTooltipProps> = ({
  text,
  className,
  id,
  maxWidth = 320,
}) => {
  const [isOverflowing, setIsOverflowing] = useState(false);
  const [showTooltip, setShowTooltip] = useState(false);
  const [pos, setPos] = useState<{ top: number; left: number }>({ top: 0, left: 0 });
  const textRef = useRef<HTMLSpanElement>(null);
  const tooltipId = `tt-${id ?? Math.random().toString(36).slice(2)}`;

  const checkOverflow = () => {
    const el = textRef.current;
    if (!el) return false;
    // Compare scrollWidth vs clientWidth on the measured element itself
    const overflow = el.scrollWidth > el.clientWidth;
    setIsOverflowing(overflow);
    return overflow;
  };

  useEffect(() => {
    const el = textRef.current;
    if (!el) return;
    checkOverflow();
    const ro = new ResizeObserver(() => checkOverflow());
    ro.observe(el);
    const onWin = () => checkOverflow();
    window.addEventListener("resize", onWin);
    return () => {
      ro.disconnect();
      window.removeEventListener("resize", onWin);
    };
  }, []);

  const show = () => {
    if (checkOverflow()) {
      const el = textRef.current!;
      const rect = el.getBoundingClientRect();
      // Clamp tooltip within viewport horizontally
      const left = Math.min(Math.max(8, rect.left), window.innerWidth - maxWidth - 8);
      setPos({ top: rect.bottom + 8, left });
      setShowTooltip(true);
    }
  };
  const hide = () => setShowTooltip(false);

  return (
    <>
      <span
        ref={textRef}
        className={`truncate block max-w-full overflow-hidden min-w-0 flex-1 ${className ?? ""}`}
        onMouseEnter={show}
        onMouseLeave={hide}
        onFocus={show}
        onBlur={hide}
        tabIndex={isOverflowing ? 0 : -1}
        aria-describedby={showTooltip && isOverflowing ? tooltipId : undefined}
      >
        {text}
      </span>
      {showTooltip && isOverflowing && (
        <div
          id={tooltipId}
          role="tooltip"
          className="fixed px-3 py-2 text-sm text-white bg-gray-900 dark:bg-gray-100 dark:text-gray-900 rounded-lg shadow-xl border border-gray-200 dark:border-gray-300 whitespace-normal break-words pointer-events-none z-[9999]"
          style={{ top: pos.top, left: pos.left, maxWidth }}
        >
          {text}
        </div>
      )}
    </>
  );
};

export default TruncateTooltip;

```

<!-- path: components/ofc/ofc-types.ts -->
```typescript
// components/ofc/ofc-types.ts
import { z } from 'zod';
import { v_ofc_cables_completeRowSchema } from "@/schemas/zod-schemas";

export interface OfcCablesFilters {
  search: string;
  ofc_type_id: string;
  status: "true" | "false" | "";
  maintenance_terminal_id: string;
}

export type OfcCablesWithRelations = z.infer<typeof v_ofc_cables_completeRowSchema> & {
  ofc_type: {
    id: string;
    name: string;
  } | null;
  maintenance_area: {
    id: string;
    name: string;
  } | null;
};

```

<!-- path: components/ofc/OfcStats.tsx -->
```typescript
// app/dashboard/employees/components/EmployeeStats.tsx
interface OfcStatsProps {
    total: number;
    active: number;
    inactive: number;
  }
  
  export const OfcStats = ({ total, active, inactive }: OfcStatsProps) => {
    return (
      <div className="mt-6 flex items-center justify-between text-sm text-gray-600 dark:text-gray-400">
        <span>
          Showing {total} ofc cable{total !== 1 ? "s" : ""}
        </span>
        <span>
          {active} active, {inactive} inactive
        </span>
      </div>
    );
  };
```

<!-- path: components/ofc/OfcForm/constants/ofcFormConfig.ts -->
```typescript
// components/ofc/OfcForm/constants/ofcFormConfig.ts
export const OFC_FORM_CONFIG = {
  CAPACITY_OPTIONS: [
    { value: '2', label: '2' },
    { value: '4', label: '4' },
    { value: '6', label: '6' },
    { value: '12', label: '12' },
    { value: '24', label: '24' },
    { value: '48', label: '48' },
    { value: '96', label: '96' },
    { value: '144', label: '144' },
    { value: '288', label: '288' },
    { value: '576', label: '576' },
    { value: '864', label: '864' },
    { value: '1728', label: '1728' },
  ],

  ALLOWED_NODE_TYPES: [
    'Transmission Nodes',
    'Joint / Splice Point',
    'Base Transceiver Station',
    'Backhaul Hub / Block HQ',
    'Customer Premises',
    'Gram Panchayat',
  ],

  NODES_FETCH_LIMIT: 1000,
  CACHE_TIME: 5 * 60 * 1000, // 5 minutes
} as const;

```

<!-- path: components/ofc/OfcForm/MaintenanceSection.tsx -->
```typescript
// components/OfcForm/MaintenanceSection.tsx
import React from 'react';
import { Settings } from 'lucide-react';
import { Control, FieldErrors } from 'react-hook-form';
import {
  FormSearchableSelect,
  FormTextarea,
} from '@/components/common/form/FormControls';
import { Option } from '@/components/common/ui/select/SearchableSelect';
import FormSection from './FormSection';
import { Ofc_cablesInsertSchema } from '@/schemas/zod-schemas';

interface MaintenanceSectionProps {
  control: Control<Ofc_cablesInsertSchema>;
  errors: FieldErrors<Ofc_cablesInsertSchema>;
  maintenanceTerminalOptions: Option[];
}

const MaintenanceSection: React.FC<MaintenanceSectionProps> = ({
  control,
  errors,
  maintenanceTerminalOptions,
}) => (
  <FormSection
    title="Maintenance Information"
    icon={Settings}
    iconColor="text-orange-600"
  >
    <div className="grid grid-cols-1 gap-6">
      <FormSearchableSelect
        name="maintenance_terminal_id"
        label="Maintenance Terminal"
        control={control}
        options={maintenanceTerminalOptions}
        error={errors.maintenance_terminal_id}
        placeholder="Select maintenance terminal"
        searchPlaceholder="Search maintenance terminals..."
      />

      <FormTextarea
        name="remark"
        label="Additional Notes"
        control={control}
        error={errors.remark}
        placeholder="Enter any maintenance notes, installation details, or other relevant information..."
      />
    </div>
  </FormSection>
);

export default MaintenanceSection;

```

<!-- path: components/ofc/OfcForm/RouteConfigurationSection.tsx -->
```typescript
// components/OfcForm/RouteConfigurationSection.tsx
import React from 'react';
import { Zap } from 'lucide-react';
import { Control, FieldErrors } from 'react-hook-form';
import { FormSearchableSelect } from '@/components/common/form/FormControls';
import { Label } from '@/components/common/ui/label/Label';
import { Option } from '@/components/common/ui/select/SearchableSelect';
import FormSection from './FormSection';
import { Ofc_cablesInsertSchema } from '@/schemas/zod-schemas';

interface RouteConfigurationSectionProps {
  control: Control<Ofc_cablesInsertSchema>;
  errors: FieldErrors<Ofc_cablesInsertSchema>;
  startingNodeOptions: Option[];
  endingNodeOptions: Option[];
  routeName: string;
}

const RouteConfigurationSection: React.FC<RouteConfigurationSectionProps> = ({
  control,
  errors,
  startingNodeOptions,
  endingNodeOptions,
  routeName,
}) => {
  // console.log('startingNodeOptions', startingNodeOptions);
  // console.log('endingNodeOptions', endingNodeOptions);
  // console.log('control', control);

  return (
    <FormSection
      title="Route Configuration"
      icon={Zap}
      iconColor="text-blue-600"
    >
      <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
        <FormSearchableSelect
          name="sn_id"
          label="Starting Node"
          control={control}
          options={startingNodeOptions}
          error={errors.sn_id}
          placeholder="Select starting node"
          searchPlaceholder="Search starting nodes..."
          aria-describedby="sn-id-help"
        />
        <div id="sn-id-help" className="sr-only">
          Select the starting point for this fiber optic cable route
        </div>

        <FormSearchableSelect
          name="en_id"
          label="Ending Node"
          control={control}
          options={endingNodeOptions}
          error={errors.en_id}
          placeholder="Select ending node"
          searchPlaceholder="Search ending nodes..."
          aria-describedby="en-id-help"
        />
        <div id="en-id-help" className="sr-only">
          Select the ending point for this fiber optic cable route
        </div>
      </div>

      {routeName && (
        <div className="mt-6 space-y-2">
          <Label className="text-gray-700 dark:text-gray-300 font-medium">
            Generated Route Name
          </Label>
          <div className="bg-blue-50 dark:bg-blue-900/20 border border-blue-200 dark:border-blue-700 rounded-md px-3 py-2">
            <span className="text-blue-900 dark:text-blue-100 font-mono text-sm">
              {routeName}
            </span>
          </div>
        </div>
      )}
    </FormSection>
  );
};

export default RouteConfigurationSection;

```

<!-- path: components/ofc/OfcForm/FormSection.tsx -->
```typescript
// components/OfcForm/FormSection.tsx
import React from "react";
import { LucideIcon } from "lucide-react";

interface FormSectionProps {
  title: string;
  icon: LucideIcon;
  iconColor: string;
  children: React.ReactNode;
}

const FormSection: React.FC<FormSectionProps> = ({
  title,
  icon: Icon,
  iconColor,
  children,
}) => (
  <div className="bg-gray-50 dark:bg-gray-800/50 rounded-lg p-6 border dark:border-gray-700">
    <h3 className="text-lg font-semibold text-gray-900 dark:text-white mb-4 flex items-center space-x-2">
      <Icon className={`w-5 h-5 ${iconColor}`} />
      <span>{title}</span>
    </h3>
    {children}
  </div>
);

export default FormSection;
```

<!-- path: components/ofc/OfcForm/hooks/useExistingRoutesQuery.ts -->
```typescript
// components/ofc/OfcForm/hooks/useExistingRoutesQuery.ts
'use client';

import { useMemo } from 'react';
import { useQuery } from '@tanstack/react-query';
import { createClient } from '@/utils/supabase/client';

/**
 * A specialized hook to query for existing OFC cables between two specific nodes.
 * @param startingNodeId The ID of the starting node.
 * @param endingNodeId The ID of the ending node.
 * @returns An object containing the fetched routes and a loading state.
 */
export const useExistingRoutesQuery = (startingNodeId: string | null, endingNodeId: string | null) => {
  const supabase = createClient();

  // The specific 'or' filter string for this query.
  const orFilter = useMemo(() => {
    if (!startingNodeId || !endingNodeId) return null;
    // This creates the PostgREST filter `or=(and(sn_id.eq.val1,en_id.eq.val2),and(sn_id.eq.val2,en_id.eq.val1))`
    return `and(sn_id.eq.${startingNodeId},en_id.eq.${endingNodeId}),and(sn_id.eq.${endingNodeId},en_id.eq.${startingNodeId})`;
  }, [startingNodeId, endingNodeId]);

  return useQuery({
    queryKey: ['existing-routes', { start: startingNodeId, end: endingNodeId }],
    queryFn: async () => {
      if (!orFilter) return []; // Don't query if nodes aren't selected

      const { data, error } = await supabase
        .from('ofc_cables')
        .select('id, route_name')
        .or(orFilter);

      if (error) throw error;
      return data || [];
    },
    enabled: !!orFilter, // Only run the query when the filter is ready
    staleTime: 30000,
  });
};
```

<!-- path: components/ofc/OfcForm/hooks/useOfcFormData.ts -->
```typescript
// components/ofc/OfcForm/hooks/useOfcFormData.ts
'use client';

import { useEffect, useMemo, useRef } from 'react';
import { useForm } from 'react-hook-form';
import { zodResolver } from '@hookform/resolvers/zod';
import isEqual from 'lodash.isequal';
import { OfcCablesWithRelations } from '@/app/dashboard/ofc/page';
import {
  Ofc_cablesInsertSchema,
  ofc_cablesInsertSchema,
} from '@/schemas/zod-schemas';

export const useOfcFormData = (ofcCable?: OfcCablesWithRelations) => {
  const isEdit = Boolean(ofcCable);

  const defaultValues = useMemo(
    () => ({
      sn_id: '',
      en_id: '',
      route_name: '',
      ofc_type_id: '',
      capacity: 0,
      current_rkm: null,
      transnet_rkm: null,
      transnet_id: null,
      asset_no: null,
      ofc_owner_id: '',
      maintenance_terminal_id: null,
      remark: null,
      status: true,
    }),
    []
  );

  const form = useForm<Ofc_cablesInsertSchema>({
    resolver: zodResolver(ofc_cablesInsertSchema),
    mode: 'onChange',
    defaultValues,
  });

  // Reset form when ofcCable changes or when switching from edit to create mode
  useEffect(() => {
    if (isEdit && ofcCable) {
      form.reset({
        sn_id: ofcCable.sn_id || '',
        en_id: ofcCable.en_id || '',
        route_name: ofcCable.route_name || '',
        ofc_type_id: ofcCable.ofc_type_id || '',
        capacity: ofcCable.capacity || 0,
        current_rkm: ofcCable.current_rkm || 0,
        transnet_rkm: ofcCable.transnet_rkm || 0,
        transnet_id: ofcCable.transnet_id || null,
        ofc_owner_id: ofcCable.ofc_owner_id || '',
        asset_no: ofcCable.asset_no || '',
        maintenance_terminal_id: ofcCable.maintenance_terminal_id || '',
        remark: ofcCable.remark || '',
        status: ofcCable.status ?? true,
      });
    } else if (!isEdit) {
      // Reset to default values when not in edit mode
      form.reset(defaultValues);
    }
  }, [isEdit, ofcCable, form, defaultValues]);

  // Create a stable reference to the ofcCable data
  const ofcCableData = useMemo(() => {
    if (!isEdit || !ofcCable) return null;
    const data = {
      sn_id: ofcCable.sn_id || '',
      en_id: ofcCable.en_id || '',
      route_name: ofcCable.route_name || '',
      ofc_type_id: ofcCable.ofc_type_id || '',
      capacity: ofcCable.capacity || 0,
      current_rkm: ofcCable.current_rkm || 0,
      transnet_rkm: ofcCable.transnet_rkm || 0,
      transnet_id: ofcCable.transnet_id || null,
      asset_no: ofcCable.asset_no || '',
      ofc_owner_id: ofcCable.ofc_owner_id || '',
      maintenance_terminal_id: ofcCable.maintenance_terminal_id || '',
      remark: ofcCable.remark || '',
      status: ofcCable.status ?? true,
    };
    return data;
  }, [isEdit, ofcCable]);

  // Track previous data to prevent unnecessary resets
  const prevOfcCableData = useRef(ofcCableData);
  const prevDefaultValues = useRef(defaultValues);
  const isInitialMount = useRef(true);

  // Reset form when ofcCable changes
  useEffect(() => {
    // Skip if this is the initial mount and we're in edit mode
    if (isInitialMount.current && isEdit) {
      isInitialMount.current = false;
      return;
    }

    // Skip if nothing has changed
    if (
      isEqual(prevOfcCableData.current, ofcCableData) &&
      isEqual(prevDefaultValues.current, defaultValues)
    ) {
      return;
    }

    // Update refs
    prevOfcCableData.current = ofcCableData;
    prevDefaultValues.current = defaultValues;

    if (ofcCableData) {
      // In edit mode, use the existing data
      form.reset(
        {
          ...ofcCableData,
          route_name: ofcCable?.route_name || '',
        },
        {
          keepDirty: true,
          keepErrors: true,
        }
      );
    } else {
      // In add mode, use default values
      form.reset(
        {
          ...defaultValues,
          route_name: '',
        },
        {
          keepDirty: true,
          keepErrors: true,
        }
      );
    }
  }, [ofcCableData, form, defaultValues, ofcCable?.route_name, isEdit]);

  return { form, isEdit };
};

```

<!-- path: components/ofc/OfcForm/hooks/useCapacityInference.ts -->
```typescript
'use client';

// components/ofc/OfcForm/hooks/useCapacityInference.ts
import { useEffect, useRef, useState } from 'react';
import { Option } from '@/components/common/ui/select/SearchableSelect';
import { UseFormSetValue, Path, PathValue } from 'react-hook-form';
import { Ofc_cablesInsertSchema } from '@/schemas/zod-schemas';

interface UseCapacityInferenceProps<T extends Ofc_cablesInsertSchema> {
  currentOfcTypeId: string;
  ofcTypeOptions: Option[];
  setValue: UseFormSetValue<T>;
}

export const useCapacityInference = <T extends Ofc_cablesInsertSchema>({
  currentOfcTypeId,
  ofcTypeOptions,
  setValue,
}: UseCapacityInferenceProps<T>) => {
  const [isCapacityLocked, setIsCapacityLocked] = useState(false);
  const lastProcessedTypeId = useRef<string | null>(null);

  useEffect(() => {
    // Skip if we've already processed this OFC type ID
    if (lastProcessedTypeId.current === currentOfcTypeId) {
      return;
    }

    if (!currentOfcTypeId) {
      setIsCapacityLocked(false);
      lastProcessedTypeId.current = null;
      return;
    }

    const selectedOption = ofcTypeOptions.find(
      (opt) => opt.value === currentOfcTypeId
    );
    if (!selectedOption) {
      setIsCapacityLocked(false);
      lastProcessedTypeId.current = null;
      return;
    }

    const match = selectedOption.label.match(/(\d+)\s*F/i);
    if (match) {
      const inferredCapacity = parseInt(match[1], 10);
      // Only update if the value has changed
      setValue(
        'capacity' as Path<T>,
        inferredCapacity as unknown as PathValue<T, Path<T>>,
        {
          shouldValidate: true,
          shouldDirty: true,
          shouldTouch: true,
        }
      );
      setIsCapacityLocked(true);
      lastProcessedTypeId.current = currentOfcTypeId;
    } else {
      setIsCapacityLocked(false);
      lastProcessedTypeId.current = null;
    }
  }, [currentOfcTypeId, ofcTypeOptions, setValue]);

  return { isCapacityLocked };
};

```

<!-- path: components/ofc/OfcForm/hooks/useRouteGeneration.ts -->
```typescript
// components/ofc/OfcForm/hooks/useRouteGeneration.ts
'use client';

import { useEffect, useMemo } from 'react';
import { UseFormSetValue, FieldValues, Path, PathValue } from 'react-hook-form';
import { useExistingRoutesQuery } from '@/components/ofc/OfcForm/hooks/useExistingRoutesQuery';

interface UseRouteGenerationProps<T extends FieldValues> {
  startingNodeId: string | null;
  endingNodeId: string | null;
  startingNodeName: string | null;
  endingNodeName: string | null;
  isEdit: boolean;
  setValue: UseFormSetValue<T>;
}

export const useRouteGeneration = <T extends FieldValues>({
  startingNodeId,
  endingNodeId,
  startingNodeName,
  endingNodeName,
  isEdit,
  setValue,
}: UseRouteGenerationProps<T>) => {
  
  // ** Removed the unnecessary generic type argument.**
  const { data: existingRoutes, isLoading: existingRoutesLoading } = 
    useExistingRoutesQuery(startingNodeId, endingNodeId);

  const routeData = useMemo(() => {
    const routes = existingRoutes || [];
    const routeCount = routes.length;
    const nextRouteNumber = routeCount + 1;

    return {
      existingRoutes: routes.map(route => route.route_name),
      routeCount,
      nextRouteNumber,
    };
  }, [existingRoutes]);

  useEffect(() => {
    if (isEdit) {
      return;
    }

    if (!startingNodeId || !endingNodeId) {
      setValue('route_name' as Path<T>, '' as PathValue<T, Path<T>>);
      return;
    }
    
    if (existingRoutesLoading) {
      return;
    }

    if (startingNodeName && endingNodeName) {
      const routeName = `${startingNodeName}⇔${endingNodeName}_${routeData.nextRouteNumber}`;
      setValue('route_name' as Path<T>, routeName as PathValue<T, Path<T>>, {
        shouldValidate: true,
        shouldDirty: true,
      });
    }
  }, [
    startingNodeId,
    endingNodeId,
    startingNodeName,
    endingNodeName,
    isEdit,
    existingRoutesLoading,
    routeData.nextRouteNumber,
    setValue,
  ]);

  return {
    ...routeData,
    isLoading: existingRoutesLoading,
    generatedRouteName: null,
  };
};
```

<!-- path: components/ofc/OfcForm/OfcForm.tsx -->
```typescript
// Main OfcForm component
import React, { useCallback, useMemo } from 'react';
import { Option } from '@/components/common/ui/select/SearchableSelect';
import { usePagedData, useTableQuery } from '@/hooks/database';
import { createClient } from '@/utils/supabase/client';
import { Modal } from '@/components/common/ui';
import { FormCard } from '@/components/common/form/FormCard';
import { useOfcFormData } from './hooks/useOfcFormData';
import { OFC_FORM_CONFIG } from '@/components/ofc/OfcForm/constants/ofcFormConfig';
import { useRouteGeneration } from '@/components/ofc/OfcForm/hooks/useRouteGeneration';
import { useCapacityInference } from '@/components/ofc/OfcForm/hooks/useCapacityInference';
import LoadingOverlay from '@/components/ofc/OfcForm/LoadingOverlay';
import ExistingRoutesAlert from '@/components/ofc/OfcForm/ExistingRoutesAlert';
import RouteConfigurationSection from '@/components/ofc/OfcForm/RouteConfigurationSection';
import CableSpecificationsSection from '@/components/ofc/OfcForm/CableSpecificationsSection';
import MaintenanceSection from '@/components/ofc/OfcForm/MaintenanceSection';
import { PathValue, SubmitErrorHandler } from 'react-hook-form';
import { OfcCablesWithRelations } from '@/app/dashboard/ofc/page';
import {
  Ofc_cablesInsertSchema,
  Ofc_cablesRowSchema,
  V_nodes_completeRowSchema,
} from '@/schemas/zod-schemas';
import { FormSearchableSelect } from '@/components/common/form';

interface OfcFormProps {
  ofcCable?: OfcCablesWithRelations;
  onSubmit: (data: Ofc_cablesInsertSchema) => void;
  onClose: () => void;
  pageLoading: boolean;
  isOpen: boolean;
}

const OfcForm: React.FC<OfcFormProps> = ({
  ofcCable,
  onSubmit,
  onClose,
  pageLoading,
  isOpen,
}) => {
  const supabase = createClient();
  const { form, isEdit } = useOfcFormData(ofcCable);
  const {
    handleSubmit,
    control,
    register,
    setValue,
    watch,
    formState: { errors },
  } = form;

  // Watch critical form values
  const startingNodeId = watch('sn_id');
  const endingNodeId = watch('en_id');
  const routeName = watch('route_name');
  const currentOfcTypeId = watch('ofc_type_id');
  const ofcOwnerId = watch('ofc_owner_id');

  // Data fetching with optimized queries
  const { data: nodesData, isLoading: nodesLoading } = usePagedData<V_nodes_completeRowSchema>(
    supabase,
    'v_nodes_complete',
    {
      filters: {
        status: true,
        node_type_name: {
          operator: 'in',
          value: OFC_FORM_CONFIG.ALLOWED_NODE_TYPES,
        },
      },
      limit: OFC_FORM_CONFIG.NODES_FETCH_LIMIT,
    }
  );

  const { data: ofcTypesData, isLoading: ofcTypesLoading } = useTableQuery(
    supabase,
    'lookup_types',
    {
      filters: {
        category: { operator: 'eq', value: 'OFC_TYPES' },
        name: { operator: 'neq', value: 'DEFAULT' },
      },
      orderBy: [{ column: 'name', ascending: true }],
      columns: 'id, name',
      staleTime: OFC_FORM_CONFIG.CACHE_TIME,
    }
  );

  const {
    data: maintenanceTerminalsData,
    isLoading: maintenanceTerminalsLoading,
  } = useTableQuery(supabase, 'maintenance_areas', {
    filters: { status: true },
    orderBy: [{ column: 'name', ascending: true }],
    columns: 'id, name',
    staleTime: OFC_FORM_CONFIG.CACHE_TIME,
  });

  // Custom hooks for complex logic
  // Create a type-safe wrapper for setValue
  const setValueWithType = useCallback(
    <K extends keyof Ofc_cablesInsertSchema>(
      name: K,
      value: Ofc_cablesInsertSchema[K],
      options?: { shouldValidate?: boolean }
    ) => {
      setValue(name, value as PathValue<Ofc_cablesInsertSchema, K>, options);
    },
    [setValue]
  );

  const startingNodeName = useMemo(() => nodesData?.data.find(node => node.id === startingNodeId)?.name || null, [nodesData, startingNodeId]);
  const endingNodeName = useMemo(() => nodesData?.data.find(node => node.id === endingNodeId)?.name || null, [nodesData, endingNodeId]);

  const { existingRoutes, isLoading: routeGenerationLoading, generatedRouteName } =
    useRouteGeneration<Ofc_cablesRowSchema>({
      startingNodeId, endingNodeId, startingNodeName, endingNodeName, isEdit, setValue: setValueWithType,
    });

  const { isCapacityLocked } = useCapacityInference<Ofc_cablesInsertSchema>({
    currentOfcTypeId,
    ofcTypeOptions:
      ofcTypesData?.map((type) => ({ value: type.id, label: type.name })) || [],
    setValue: setValueWithType,
  });

  // Memoized options to prevent unnecessary re-renders
  const nodeOptions = useMemo(
    (): Option[] =>
      nodesData?.data.map((node: V_nodes_completeRowSchema) => ({
        value: String(node.id),
        label: node.name || `Node ${node.id}`,
      })) || [],
    [nodesData]
  );

  const startingNodeOptions = useMemo(
    () => nodeOptions.filter((option) => option.value !== endingNodeId),
    [nodeOptions, endingNodeId]
  );

  const endingNodeOptions = useMemo(
    () => nodeOptions.filter((option) => option.value !== startingNodeId),
    [nodeOptions, startingNodeId]
  );

  const ofcTypeOptions = useMemo(
    (): Option[] =>
      ofcTypesData?.map((type) => ({ value: type.id, label: type.name })) || [],
    [ofcTypesData]
  );

  const maintenanceTerminalOptions = useMemo(
    (): Option[] =>
      maintenanceTerminalsData?.map((terminal) => ({
        value: terminal.id,
        label: terminal.name,
      })) || [],
    [maintenanceTerminalsData]
  );

  // Fetch OFC Owner
  const {
    data: lookupTypes = [],
    isLoading: lookupLoading,
    error: lookupError,
    refetch: refetchLookups
  } = useTableQuery(supabase, "lookup_types", {
    orderBy: [{ column: "name", ascending: true }],
    filters: {
      name: { operator: "neq", value: "DEFAULT" },
      category: { operator: "eq", value: "OFC_OWNER" },
    }
  });

  const ownerOptions = useMemo(
    (): Option[] =>
      lookupTypes?.map((owner) => ({ value: owner.id, label: owner.name })) || [],
    [lookupTypes, lookupLoading]
  );

  // Loading state aggregation
  const isLoading =
    nodesLoading ||
    ofcTypesLoading ||
    maintenanceTerminalsLoading ||
    pageLoading ||
    routeGenerationLoading;

  const onValidSubmit = (data: Ofc_cablesInsertSchema) => {
    onSubmit(data as Ofc_cablesInsertSchema);
  };

  const onInvalidSubmit: SubmitErrorHandler<Ofc_cablesInsertSchema> = (errors, data) => {
    console.log('Invalid form submission', errors, "Invalid form submission", data);

  };

  return (
    <Modal
      isOpen={isOpen}
      onClose={onClose}
      visible={false}
      className="h-screen w-screen transparent bg-gray-700 rounded-2xl"
    >
      <FormCard
        key={isEdit ? ofcCable?.id ?? 'edit' : 'new'}
        title={isEdit ? 'Edit Optical Fiber Cable' : 'Add Optical Fiber Cable'}
        subtitle={
          isEdit
            ? 'Update the cable details below'
            : 'Fill in the Optical Fiber Cable details below'
        }
        isLoading={isLoading}
        onCancel={onClose}
        onSubmit={handleSubmit(onValidSubmit, onInvalidSubmit)}
        submitText={
          isEdit ? 'Update Optical Fiber Cable' : 'Create Optical Fiber Cable'
        }
        standalone
      >
        <div className="p-6 relative">
          {isLoading && <LoadingOverlay />}

          <ExistingRoutesAlert routes={existingRoutes} />

          <div className="space-y-8">
            <RouteConfigurationSection
              control={control}
              errors={errors}
              startingNodeOptions={startingNodeOptions}
              endingNodeOptions={endingNodeOptions}
              routeName={routeName}
            />
            <FormSearchableSelect
              control={control}
              name="ofc_owner_id"
              label="Owner"
              options={ownerOptions}
            />

            <CableSpecificationsSection
              control={control}
              register={register}
              errors={errors}
              setValue={setValue}
              watch={watch}
              ofcTypeOptions={ofcTypeOptions}
              isCapacityLocked={isCapacityLocked}
            />

            <MaintenanceSection
              control={control}
              errors={errors}
              maintenanceTerminalOptions={maintenanceTerminalOptions}
            />
          </div>
        </div>
      </FormCard>
    </Modal>
  );
};

export default OfcForm;

```

<!-- path: components/ofc/OfcForm/types/ofcForm.types.ts -->
```typescript
// types/ofcForm.types.ts
export interface FormLoadingState {
    nodes: boolean;
    ofcTypes: boolean;
    maintenanceTerminals: boolean;
    routeGeneration: boolean;
    form: boolean;
  }
  
  export interface NodeOption {
    id: string;
    name: string;
    nodeType: string;
    status: boolean;
  }
  
  export interface ValidationResult {
    isValid: boolean;
    errors: Record<string, string>;
    warnings?: Record<string, string>;
  }
```

<!-- path: components/ofc/OfcForm/CableSpecificationsSection.tsx -->
```typescript
// components/OfcForm/CableSpecificationsSection.tsx
import React from 'react';
import { FileText } from 'lucide-react';
import {
  Control,
  FieldErrors,
  UseFormRegister,
  UseFormSetValue,
  UseFormWatch,
} from 'react-hook-form';
import {
  FormInput,
  FormSearchableSelect,
  FormDateInput,
} from '@/components/common/form/FormControls';
import { Switch } from '@/components/common/ui/switch/Switch';
import { Label } from '@/components/common/ui/label/Label';
import { Option } from '@/components/common/ui/select/SearchableSelect';
import { OFC_FORM_CONFIG } from '@/components/ofc/OfcForm/constants/ofcFormConfig';
import FormSection from './FormSection';
import { Ofc_cablesInsertSchema } from '@/schemas/zod-schemas';

interface CableSpecificationsSectionProps {
  control: Control<Ofc_cablesInsertSchema>;
  register: UseFormRegister<Ofc_cablesInsertSchema>;
  errors: FieldErrors<Ofc_cablesInsertSchema>;
  setValue: UseFormSetValue<Ofc_cablesInsertSchema>;
  watch: UseFormWatch<Ofc_cablesInsertSchema>;
  ofcTypeOptions: Option[];
  isCapacityLocked: boolean;
}

const CableSpecificationsSection: React.FC<CableSpecificationsSectionProps> = ({
  control,
  register,
  errors,
  setValue,
  watch,
  ofcTypeOptions,
  isCapacityLocked,
}) => {
  const currentStatus = watch('status');

  return (
    <FormSection
      title="Cable Specifications"
      icon={FileText}
      iconColor="text-green-600"
    >
      <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6">
        <FormInput
          name="asset_no"
          label="Asset Number"
          register={register}
          error={errors.asset_no}
          placeholder="Enter asset number"
        />

        <FormSearchableSelect
          name="ofc_type_id"
          label="OFC Type"
          control={control}
          options={ofcTypeOptions}
          error={errors.ofc_type_id}
          placeholder="Select OFC type"
          searchPlaceholder="Search OFC types..."
        />

        <div className="space-y-2">
          {isCapacityLocked ? (
            <FormInput
              name="capacity"
              label="Capacity"
              register={register}
              error={errors.capacity}
              placeholder="Capacity will be set from OFC type"
              type="number"
              disabled
            />
          ) : (
            <FormSearchableSelect
              name="capacity"
              control={control}
              label="Capacity"
              error={errors.capacity}
              placeholder="Select capacity"
              searchPlaceholder="Search capacities..."
              options={OFC_FORM_CONFIG.CAPACITY_OPTIONS as unknown as Option[]}
            />
          )}
          {isCapacityLocked && (
            <p className="text-xs text-gray-500 dark:text-gray-400 mt-1">
              Capacity inferred from selected OFC type and locked.
            </p>
          )}
        </div>
      </div>

      <div className="grid grid-cols-1 md:grid-cols-2 gap-6 mt-6">
        <FormInput
          name="current_rkm"
          label="Current RKM (km)"
          register={register}
          error={errors.current_rkm}
          placeholder="Enter current RKM"
          type="number"
          step="0.01"
        />

        <FormInput
          name="transnet_rkm"
          label="Transnet RKM (km)"
          register={register}
          error={errors.transnet_rkm}
          placeholder="Enter transnet RKM"
          type="number"
          step="0.01"
        />
      </div>

      <div className="grid grid-cols-1 md:grid-cols-2 gap-6 mt-6">
        <FormInput
          name="transnet_id"
          label="Transnet ID"
          register={register}
          error={errors.transnet_id}
          placeholder="Enter transnet ID"
        />

        <FormDateInput
          name="commissioned_on"
          label="Commissioned Date"
          control={control}
          error={errors.commissioned_on}
          placeholder="Select commissioned date"
        />
      </div>

      <div className="flex items-center space-x-3 pt-6">
        <Switch
          id="status"
          checked={currentStatus ?? true}
          onChange={(checked: boolean) => setValue('status', checked)}
          className="dark:bg-gray-600"
        />
        <Label
          htmlFor="status"
          className="text-gray-700 dark:text-gray-300 font-medium"
        >
          <span
            className={`inline-flex items-center px-2.5 py-0.5 rounded-full text-xs font-medium ${
              currentStatus
                ? 'bg-green-100 text-green-800 dark:bg-green-900/20 dark:text-green-300'
                : 'bg-red-100 text-red-800 dark:bg-red-900/20 dark:text-red-300'
            }`}
          >
            {currentStatus ? 'Active' : 'Inactive'}
          </span>
        </Label>
      </div>
    </FormSection>
  );
};

export default CableSpecificationsSection;

```

<!-- path: components/ofc/OfcForm/ExistingRoutesAlert.tsx -->
```typescript
// components/OfcForm/ExistingRoutesAlert.tsx
import React from "react";
import { AlertTriangle } from "lucide-react";

interface ExistingRoutesAlertProps {
  routes: string[];
}

const ExistingRoutesAlert: React.FC<ExistingRoutesAlertProps> = ({ routes }) => {
  if (!routes.length) return null;

  return (
    <div className="mb-6 bg-amber-50 dark:bg-amber-900/20 border border-amber-200 dark:border-amber-700 rounded-lg p-4">
      <div className="flex items-start space-x-3">
        <AlertTriangle className="w-5 h-5 text-amber-600 dark:text-amber-400 mt-0.5 flex-shrink-0" />
        <div className="flex-1">
          <h4 className="text-sm font-medium text-amber-800 dark:text-amber-200">
            Existing Routes Found
          </h4>
          <p className="text-sm text-amber-700 dark:text-amber-300 mt-1">
            {routes.length} cable route{routes.length > 1 ? "s" : ""} already exist between these nodes:
          </p>
          <ul className="mt-2 space-y-1 max-h-20 overflow-y-auto">
            {routes.map((route, index) => (
              <li
                key={index}
                className="text-sm text-amber-700 dark:text-amber-300 flex items-center space-x-2"
              >
                <span className="w-1.5 h-1.5 bg-amber-400 rounded-full flex-shrink-0" />
                <span className="font-mono truncate">{route}</span>
              </li>
            ))}
          </ul>
        </div>
      </div>
    </div>
  );
};

export default ExistingRoutesAlert;
```

<!-- path: components/ofc/OfcForm/LoadingOverlay.tsx -->
```typescript

// components/OfcForm/LoadingOverlay.tsx
import React from "react";
import { ButtonSpinner } from "@/components/common/ui/LoadingSpinner";

interface LoadingOverlayProps {
  message?: string;
}

const LoadingOverlay: React.FC<LoadingOverlayProps> = ({ 
  message = "Loading form data..." 
}) => (
  <div className="absolute inset-0 bg-white/80 dark:bg-gray-900/80 backdrop-blur-sm flex items-center justify-center z-10 rounded-lg">
    <div className="flex items-center space-x-3 bg-white dark:bg-gray-800 rounded-lg px-6 py-4 shadow-lg border dark:border-gray-700">
      <ButtonSpinner size="sm" />
      <span className="text-gray-600 dark:text-gray-300">
        {message}
      </span>
    </div>
  </div>
);

export default LoadingOverlay;
```

<!-- path: components/outdated/OutdatedBrowserModal.tsx -->
```typescript

// components/outdated/OutdatedBrowserModal.tsx
import React from 'react'

interface OutdatedBrowserModalProps {
  handleCloseModal: () => void;
}

const OutdatedBrowserModal: React.FC<OutdatedBrowserModalProps> = ({ handleCloseModal }) => {
  return (
    <>
    <div className="modal-overlay" id="browserModal">
          <div className="modal-content">
            <h2 className="modal-title">⚠️ Outdated or Unsupported Browser</h2>
            <p className="modal-text">
              Your browser is outdated or missing critical features. Some
              functionality may not work properly.
            </p>

            <div className="recommendation-box">
              <h3 className="recommendation-title">Recommended browsers:</h3>
              <ul className="browser-list">
                <li>Google Chrome 110+</li>
                <li>Mozilla Firefox 100+</li>
                <li>Microsoft Edge 110+</li>
                <li>Safari 15+</li>
              </ul>
            </div>

            <div className="button-container">
              <a
                href="https://www.google.com/chrome/"
                target="_blank"
                rel="noopener noreferrer"
                className="download-button chrome-button"
              >
                Download Chrome
              </a>
              <a
                href="https://www.mozilla.org/firefox/new/"
                target="_blank"
                rel="noopener noreferrer"
                className="download-button firefox-button"
              >
                Download Firefox
              </a>
              <button onClick={handleCloseModal} className="continue-button">
                Continue Anyway
              </button>
            </div>
          </div>
        </div>
    </>
  )
}

export default OutdatedBrowserModal
```

<!-- path: components/pwa/offline-status.tsx -->
```typescript
'use client'
 
import { useState, useEffect } from 'react'
import { MdWifiOff, MdWifi } from 'react-icons/md'
 
export default function OfflineStatus() {
  const [isOnline, setIsOnline] = useState(true)
  const [wasOffline, setWasOffline] = useState(false)
 
  useEffect(() => {
    const handleOnline = () => {
      setIsOnline(true)
      if (wasOffline) {
        // Show "Back online" message briefly
        setTimeout(() => setWasOffline(false), 3000)
      }
    }
 
    const handleOffline = () => {
      setIsOnline(false)
      setWasOffline(true)
    }
 
    window.addEventListener('online', handleOnline)
    window.addEventListener('offline', handleOffline)
 
    // Check initial status
    setIsOnline(navigator.onLine)
 
    return () => {
      window.removeEventListener('online', handleOnline)
      window.removeEventListener('offline', handleOffline)
    }
  }, [wasOffline])
 
  // Show offline message
  if (!isOnline) {
    return (
      <div className="fixed top-4 left-4 right-4 bg-red-500 text-white p-3 rounded-lg shadow-lg z-50">
        <div className="flex items-center space-x-2">
          <MdWifiOff className="h-5 w-5" />
          <span className="text-sm font-medium">You&apos;re offline</span>
        </div>
      </div>
    )
  }
 
  // Show "back online" message briefly
  if (isOnline && wasOffline) {
    return (
      <div className="fixed top-4 left-4 right-4 bg-green-500 text-white p-3 rounded-lg shadow-lg z-50">
        <div className="flex items-center space-x-2">
          <MdWifi className="h-5 w-5" />
          <span className="text-sm font-medium">Back online</span>
        </div>
      </div>
    )
  }
 
  return null
}
```

<!-- path: components/pwa/pwa-install-prompt.tsx -->
```typescript
'use client'
 
import { useState, useEffect } from 'react'
import { MdClose, MdDownload } from 'react-icons/md'
import { Button } from '../common/ui/Button'
 
interface BeforeInstallPromptEvent extends Event {
  readonly platforms: string[]
  readonly userChoice: Promise<{
    outcome: 'accepted' | 'dismissed'
    platform: string
  }>
  prompt(): Promise<void>
}
 
export default function PWAInstallPrompt() {
  const [deferredPrompt, setDeferredPrompt] = useState<BeforeInstallPromptEvent | null>(null)
  const [showInstallPrompt, setShowInstallPrompt] = useState(false)
  const [isInstalled, setIsInstalled] = useState(false)
 
  useEffect(() => {
    // Check if app is already installed
    if (window.matchMedia('(display-mode: standalone)').matches) {
      setIsInstalled(true)
      return
    }
 
    // Listen for beforeinstallprompt event
    const handler = (e: Event) => {
      e.preventDefault()
      setDeferredPrompt(e as BeforeInstallPromptEvent)
      setShowInstallPrompt(true)
    }
 
    window.addEventListener('beforeinstallprompt', handler)
 
    // Listen for app installed event
    window.addEventListener('appinstalled', () => {
      setIsInstalled(true)
      setShowInstallPrompt(false)
    })
 
    return () => {
      window.removeEventListener('beforeinstallprompt', handler)
    }
  }, [])
 
  const handleInstallClick = async () => {
    if (!deferredPrompt) return
 
    deferredPrompt.prompt()
    const { outcome } = await deferredPrompt.userChoice
    
    if (outcome === 'accepted') {
      setDeferredPrompt(null)
      setShowInstallPrompt(false)
    }
  }
 
  const handleDismiss = () => {
    setShowInstallPrompt(false)
    setDeferredPrompt(null)
  }
 
  if (isInstalled || !showInstallPrompt) return null
 
  return (
    <div className="fixed bottom-4 left-4 right-4 bg-white dark:bg-gray-800 border border-gray-200 dark:border-gray-700 rounded-lg shadow-lg p-4 z-50">
      <div className="flex items-center justify-between">
        <div className="flex items-center space-x-3">
          <MdDownload className="h-6 w-6 text-blue-600" />
          <div>
            <h3 className="font-semibold text-sm">Install App</h3>
            <p className="text-xs text-gray-600 dark:text-gray-400">
              Install this app for a better experience
            </p>
          </div>
        </div>
        <div className="flex items-center space-x-2">
          <Button
            size="sm"
            onClick={handleInstallClick}
            className="bg-blue-600 hover:bg-blue-700"
          >
            Install
          </Button>
          <Button
            size="sm"
            variant="ghost"
            onClick={handleDismiss}
          >
            <MdClose className="h-4 w-4" />
          </Button>
        </div>
      </div>
    </div>
  )
}
```

<!-- path: components/table/TableFilterPanel.tsx -->
```typescript
// @/components/table/TableFilterPanel.tsx
import React, { useState, useEffect } from "react";
import { Column } from "@/hooks/database/excel-queries/excel-helpers";
import { TableOrViewName, Row, Filters } from "@/hooks/database";
import { useDebounce } from "@/hooks/useDebounce";
import { DEFAULTS } from "@/config/constants";

interface TableFilterPanelProps<T extends TableOrViewName> {
  columns: Column<Row<T>>[];
  filters: Filters;
  setFilters: React.Dispatch<React.SetStateAction<Filters>>;
  showFilters: boolean;
  filterable: boolean;
}

const DebouncedInput = ({ value, onChange, placeholder, className }: { value: string; onChange: (value: string) => void; placeholder: string; className: string; }) => {
    const [internalValue, setInternalValue] = useState(value);
    const debouncedValue = useDebounce(internalValue, DEFAULTS.DEBOUNCE_DELAY);

    useEffect(() => {
        onChange(debouncedValue);
    }, [debouncedValue, onChange]);

    useEffect(() => {
        setInternalValue(value);
    }, [value]);

    return (
        <input
            type='text'
            value={internalValue}
            onChange={(e) => setInternalValue(e.target.value)}
            placeholder={placeholder}
            className={className}
        />
    );
};

export function TableFilterPanel<T extends TableOrViewName>({
  columns,
  filters,
  setFilters,
  showFilters,
  filterable,
}: TableFilterPanelProps<T>) {
  if (!showFilters || !filterable) return null;

  return (
    <div className='mt-4 grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 gap-3 p-3 bg-gray-50 dark:bg-gray-700/50 rounded-lg'>
      {columns
        .filter((col) => col.filterable)
        .map((column) => (
          <div key={column.key} className='flex flex-col gap-1'>
            <label className='text-xs font-medium text-gray-700 dark:text-gray-300'>{column.title}</label>
            {column.filterOptions ? (
              <select
                value={String(filters[column.dataIndex] ?? '')}
                onChange={(e) => setFilters({ ...filters, [column.dataIndex]: e.target.value })}
                className='px-3 py-1.5 text-sm border border-gray-300 dark:border-gray-600 rounded bg-white dark:bg-gray-700 text-gray-900 dark:text-white'
              >
                <option value=''>All</option>
                {column.filterOptions.map((option) => (
                  <option key={String(option.value)} value={String(option.value)}>
                    {option.label}
                  </option>
                ))}
              </select>
            ) : (
              <DebouncedInput
                value={typeof filters[column.dataIndex] === 'string' ? (filters[column.dataIndex] as string) : ''}
                onChange={(value) => setFilters(prev => ({ ...prev, [column.dataIndex]: value }))}
                placeholder={`Filter ${column.title.toLowerCase()}...`}
                className='px-3 py-1.5 text-sm border border-gray-300 dark:border-gray-600 rounded bg-white dark:bg-gray-700 text-gray-900 dark:text-white placeholder-gray-500 dark:placeholder-gray-400'
              />
            )}
          </div>
        ))}
      {Object.keys(filters).length > 0 && (
        <div className='flex items-end'>
          <button 
            onClick={() => setFilters({})} 
            className='px-3 py-1.5 text-sm text-red-600 dark:text-red-400 hover:bg-red-50 dark:hover:bg-red-900/20 rounded transition-colors'
          >
            Clear All
          </button>
        </div>
      )}
    </div>
  );
}
```

<!-- path: components/table/action-helpers.ts -->
```typescript
import React from "react";
import {
  FiEdit2,
  FiTrash2,
  FiToggleLeft,
  FiToggleRight,
  FiEye,
} from "react-icons/fi";
import { RecordWithId } from "@/hooks/useCrudManager";

type ActionableRecord = RecordWithId & {
  status?: boolean | string | null; // Allow both boolean and string status
};

// Define a flexible TableAction type that can work with any record type
export interface TableAction<T = unknown> {
  key: string;
  label: string;
  icon?: React.ReactNode;
  getIcon?: (record: T) => React.ReactNode;
  onClick: (record: T, index?: number) => void;
  variant?: 'primary' | 'secondary' | 'danger' | 'success';
  disabled?: boolean | ((record: T) => boolean);
  hidden?: boolean | ((record: T) => boolean);
  // Additional properties that might be used by the DataTable
  [key: string]: unknown;
}

// Defines the shape of the handlers that a page component will provide.
// The helper is now generic over `V`, which represents the data type in the table row (e.g., UserProfileData)
interface StandardActionHandlers<V extends ActionableRecord> {
  onView?: (record: V) => void;
  onEdit?: (record: V) => void;
  onToggleStatus?: (record: V) => void;
  onDelete?: (record: V) => void;

  canEdit?: (record: V) => boolean;
  canDelete?: (record: V) => boolean;
}
/**
 * Creates a standardized array of TableAction objects for CRUD operations.
 * This ensures all tables have consistent icons, labels, variants, and behaviors.
 * @param handlers - An object containing the onClick handlers and optional logic for the actions.
 * @returns An array of TableAction<T> objects.
 */
export function createStandardActions<V extends ActionableRecord>({
  onView,
  onEdit,
  onToggleStatus,
  onDelete,
  canEdit = () => true, // By default, all actions are enabled
  canDelete = () => true,
}: StandardActionHandlers<V>): TableAction<V>[] {
  const actions: TableAction<V>[] = [];

  // Narrower type guard: only treat records with a boolean `status` as toggle-able
  const hasBooleanStatus = (record: V): record is V & { status: boolean } =>
    typeof (record as unknown as V)?.status === "boolean";

  // --- Toggle Status Actions (Activate/Deactivate) ---
  if (onToggleStatus) {
    actions.push({
      key: "toggleStatus",
      label: "Toggle Status",
      getIcon: (record: V) => 
        React.createElement(record.status ? FiToggleRight : FiToggleLeft, { 
          className: `w-4 h-4 ${record.status ? 'text-green-500' : 'text-gray-400'}`,
          size: 20
        }),
      variant: 'secondary',
      onClick: (record) => onToggleStatus(record),
      hidden: (record) => !hasBooleanStatus(record)
    });
  }

  // --- View Action ---
  if (onView) {
    actions.push({
      key: "view",
      label: "View Details",
      icon: React.createElement(FiEye),
      onClick: (record) => onView(record),
      variant: "secondary",
    });
  }

  // --- Edit Action ---
  if (onEdit) {
    actions.push({
      key: "edit",
      label: "Edit",
      icon: React.createElement(FiEdit2),
      onClick: (record) => onEdit(record),
      variant: "primary",
      disabled: (record) => !canEdit(record),
    });
  }

  // --- Delete Action ---
  if (onDelete) {
    actions.push({
      key: "delete",
      label: "Delete",
      icon: React.createElement(FiTrash2),
      onClick: (record) => onDelete(record),
      variant: "danger",
      disabled: (record) => !canDelete(record),
    });
  }

  return actions;
}

```

<!-- path: components/table/TableColumnSelector.tsx -->
```typescript
// @/components/table/TableColumnSelector.tsx
import React, { useEffect, useRef } from "react";
import { Column } from "@/hooks/database/excel-queries/excel-helpers";
import { TableOrViewName, Row } from "@/hooks/database";

interface TableColumnSelectorProps<T extends TableOrViewName> {
  columns: Column<Row<T>>[];
  visibleColumns: string[];
  setVisibleColumns: (columns: string[]) => void;
  showColumnSelector: boolean;
  setShowColumnSelector: (show: boolean) => void;
}

export function TableColumnSelector<T extends TableOrViewName>({
  columns,
  visibleColumns,
  setVisibleColumns,
  showColumnSelector,
  setShowColumnSelector,
}: TableColumnSelectorProps<T>) {
  const containerRef = useRef<HTMLDivElement>(null);

  useEffect(() => {
    function handleClickOutside(e: MouseEvent) {
      const el = containerRef.current;
      if (el && !el.contains(e.target as Node)) {
        setShowColumnSelector(false);
      }
    }
    if (showColumnSelector) {
      document.addEventListener('mousedown', handleClickOutside, false);
    }
    return () => {
      document.removeEventListener('mousedown', handleClickOutside, false);
    };
  }, [showColumnSelector, setShowColumnSelector]);

  if (!showColumnSelector) return null;

  return (
    <>
      {/* Dropdown content; positioning handled by parent wrapper */}
      <div
        className='mt-2 w-64 bg-white dark:bg-gray-800 border border-gray-200 dark:border-gray-700 rounded-lg shadow-lg'
        onClick={(e) => e.stopPropagation()}
        onMouseDown={(e) => e.stopPropagation()}
        onPointerDown={(e) => e.stopPropagation()}
        ref={containerRef}
      >
        <div className='p-3 border-b border-gray-200 dark:border-gray-700'>
          <h4 className='font-medium text-gray-900 dark:text-white'>Show/Hide Columns</h4>
        </div>
        <div className='p-2 max-h-64 overflow-y-auto'>
          {columns.map((column) => (
            <label
              key={column.key}
              className='flex items-center gap-2 p-2 hover:bg-gray-50 dark:hover:bg-gray-700 rounded cursor-pointer'
              onMouseDown={(e) => e.preventDefault()}
              onClick={(e) => e.stopPropagation()}
            >
              <input
                type='checkbox'
                checked={visibleColumns.includes(column.key)}
                onClick={(e) => e.stopPropagation()}
                onChange={(e) => {
                  setVisibleColumns(e.target.checked ? [...visibleColumns, column.key] : visibleColumns.filter((k) => k !== column.key));
                }}
                className='rounded border-gray-300 text-blue-600 focus:ring-blue-500'
              />
              <span className='text-sm text-gray-700 dark:text-gray-300'>{column.title}</span>
            </label>
          ))}
        </div>
      </div>
      {/* Click outside handled via document listener */}
    </>
  );
}
```

<!-- path: components/table/TablePagination.tsx -->
```typescript
// @/components/table/TablePagination.tsx
import React from "react";
import { FiChevronLeft, FiChevronRight, FiChevronsLeft, FiChevronsRight } from "react-icons/fi";
import { TablePaginationProps } from "@/components/table/datatable-types";
import { DEFAULTS } from "@/config/constants";



export function TablePagination({ pagination, bordered }: TablePaginationProps) {
  if (!pagination || pagination.total <= 0) return null;

  return (
    <div className={`px-4 py-3 ${bordered ? "border-t border-gray-200 dark:border-gray-700" : ""} flex flex-col sm:flex-row items-center justify-between gap-4`}>
      <div className='flex items-center gap-4 text-sm text-gray-700 dark:text-gray-300'>
        <span>
          Showing {(pagination.current - 1) * pagination.pageSize + 1} to {Math.min(pagination.current * pagination.pageSize, pagination.total)} of {pagination.total} results
        </span>
        {pagination.showSizeChanger && (
          <select
            value={pagination.pageSize}
            onChange={(e) => pagination.onChange(1, Number(e.target.value))}
            className='px-2 py-1 border border-gray-300 dark:border-gray-600 rounded bg-white dark:bg-gray-700'
          >
            {(pagination.pageSizeOptions || DEFAULTS.PAGE_SIZE_OPTIONS).map((size) => (
              <option key={size} value={size}>
                {size} per page
              </option>
            ))}
          </select>
        )}
      </div>
      <div className='flex items-center gap-2'>
        <button
          onClick={() => pagination.onChange(1, pagination.pageSize)}
          disabled={pagination.current === 1}
          className='p-2 border border-gray-300 dark:border-gray-600 rounded hover:bg-gray-50 dark:hover:bg-gray-700 disabled:opacity-50 disabled:cursor-not-allowed'
        >
          <FiChevronsLeft size={16} />
        </button>
        <button
          onClick={() => pagination.onChange(pagination.current - 1, pagination.pageSize)}
          disabled={pagination.current === 1}
          className='p-2 border border-gray-300 dark:border-gray-600 rounded hover:bg-gray-50 dark:hover:bg-gray-700 disabled:opacity-50 disabled:cursor-not-allowed'
        >
          <FiChevronLeft size={16} />
        </button>
        <span className='px-4 py-2 text-sm text-gray-700 dark:text-gray-300'>
          Page {pagination.current} of {Math.ceil(pagination.total / pagination.pageSize)}
        </span>
        <button
          onClick={() => pagination.onChange(pagination.current + 1, pagination.pageSize)}
          disabled={pagination.current >= Math.ceil(pagination.total / pagination.pageSize)}
          className='p-2 border border-gray-300 dark:border-gray-600 rounded hover:bg-gray-50 dark:hover:bg-gray-700 disabled:opacity-50 disabled:cursor-not-allowed'
        >
          <FiChevronRight size={16} />
        </button>
        <button
          onClick={() => pagination.onChange(Math.ceil(pagination.total / pagination.pageSize), pagination.pageSize)}
          disabled={pagination.current >= Math.ceil(pagination.total / pagination.pageSize)}
          className='p-2 border border-gray-300 dark:border-gray-600 rounded hover:bg-gray-50 dark:hover:bg-gray-700 disabled:opacity-50 disabled:cursor-not-allowed'
        >
          <FiChevronsRight size={16} />
        </button>
      </div>
    </div>
  );
}
```

<!-- path: components/table/TableHeader.tsx -->
```typescript
// @/components/table/TableHeader.tsx
import React from "react";
import { FiArrowUp, FiArrowDown } from "react-icons/fi";
import { DataTableProps, SortConfig } from "@/components/table/datatable-types";
import { Row, TableOrViewName } from "@/hooks/database";
import { Column } from "@/hooks/database/excel-queries/excel-helpers";
import { TruncateTooltip } from "@/components/common/TruncateTooltip";

interface TableHeaderProps<T extends TableOrViewName>
  extends Pick<
    DataTableProps<T>,
    "columns" | "selectable" | "sortable" | "bordered" | "density" | "actions"
  > {
  visibleColumns: Column<Row<T>>[];
  hasActions: boolean;
  sortConfig: SortConfig<Row<T>> | null;
  onSort: (key: keyof Row<T> & string) => void;
  onSelectAll: (selected: boolean) => void;
  allSelected: boolean;
  hasData: boolean;
}


const densityClasses = {
  compact: "py-1 px-2 sm:px-3",
  default: "py-2 px-3 sm:py-3 sm:px-4",
  comfortable: "py-3 px-4 sm:py-4 sm:px-6",
};

function TableHeaderBase<
  T extends TableOrViewName
>({
  visibleColumns,
  selectable,
  sortable,
  bordered,
  density,
  hasActions,
  sortConfig,
  onSort,
  onSelectAll,
  allSelected,
  hasData,
}: TableHeaderProps<T>) {
  return (
    <thead className="bg-gray-50 dark:bg-gray-700 sticky top-0 z-10">
      <tr>
        {selectable && (
          <th
            className={`w-12 px-2 sm:px-4 py-2 sm:py-3 text-left whitespace-nowrap overflow-hidden ${
              bordered
                ? "border-b border-r border-gray-200 dark:border-gray-700"
                : ""
            }`}
            style={{ width: 48, minWidth: 48, maxWidth: 48 }}
          >
            <input
              type="checkbox"
              checked={allSelected && hasData}
              onChange={(e) => onSelectAll(e.target.checked)}
              className="rounded border-gray-300 text-blue-600 focus:ring-blue-500"
              aria-label="Select all rows"
            />
          </th>
        )}
        {hasActions && (
          <th
            className={`w-32 text-center whitespace-nowrap overflow-hidden ${
              densityClasses[density ?? "default"]
            } text-xs font-medium text-gray-500 dark:text-gray-300 uppercase tracking-wider ${
              bordered ? "border-b border-gray-200 dark:border-gray-700" : ""
            }`}
            style={{ width: 128, minWidth: 128, maxWidth: 128 }}
          >
            <span className="hidden sm:inline">Actions</span>
            <span className="sm:hidden">•••</span>
          </th>
        )}
        {visibleColumns.map((column, index) => (
          <th
            key={column.key}
            className={`${
              densityClasses[density ?? "default"]
            } text-left text-xs font-medium text-gray-500 dark:text-gray-300 uppercase tracking-wider whitespace-nowrap ${
              column.sortable && sortable
                ? "cursor-pointer hover:bg-gray-100 dark:hover:bg-gray-600"
                : ""
            } ${
              column.align === "center"
                ? "text-center"
                : column.align === "right"
                ? "text-right"
                : ""
            } ${
              bordered
                ? `border-b ${
                    index < visibleColumns.length - 1 || hasActions
                      ? "border-r"
                      : ""
                  } border-gray-200 dark:border-gray-700`
                : ""
            }`}
            style={{
              width: column.width,
              minWidth: column.width ? undefined : "100px",
              maxWidth: "350px"
            }}
            onClick={() =>
              column.sortable &&
              sortable &&
              onSort(column.dataIndex as keyof Row<T> & string)
            }
          >
            <div className="flex items-center gap-1 sm:gap-2 min-w-0">
              <div className="min-w-0 flex-1">
                <TruncateTooltip
                  text={column.title}
                  id={`header-${column.key}`}
                  className="text-xs sm:text-sm"
                />
              </div>

              {column.sortable && sortable && (
                <div className="flex flex-col flex-shrink-0" aria-hidden="true">
                  <FiArrowUp
                    size={10}
                    className={`sm:size-3 ${
                      sortConfig?.key === column.dataIndex &&
                      sortConfig.direction === "asc"
                        ? "text-blue-600 dark:text-blue-400"
                        : "text-gray-300 dark:text-gray-600"
                    }`}
                  />
                  <FiArrowDown
                    size={10}
                    className={`-mt-0.5 sm:size-3 sm:-mt-1 ${
                      sortConfig?.key === column.dataIndex &&
                      sortConfig.direction === "desc"
                        ? "text-blue-600 dark:text-blue-400"
                        : "text-gray-300 dark:text-gray-600"
                    }`}
                  />
                </div>
              )}
            </div>
          </th>
        ))}
      </tr>
    </thead>
  );
}

export const TableHeader = React.memo(TableHeaderBase) as <T extends TableOrViewName>(
  props: TableHeaderProps<T>
) => React.ReactElement;

```

<!-- path: components/table/TableBody.tsx -->
```typescript
// @/components/table/TableBody.tsx
import React, { useRef, useEffect } from "react";
import { FiEdit3, FiCheck, FiX } from "react-icons/fi";
import { DataTableProps, TableAction } from "@/components/table/datatable-types";
import { TableOrViewName, Row } from "@/hooks/database";
import { Column } from "@/hooks/database/excel-queries/excel-helpers";
import { TruncateTooltip } from "@/components/common/TruncateTooltip";
import { TableSkeleton } from "@/components/common/ui/table/TableSkeleton";
 

// Define a type for your row that guarantees a unique identifier
type DataRow<T extends TableOrViewName> = Row<T> & { id: string | number };

interface TableBodyProps<T extends TableOrViewName> extends Pick<DataTableProps<T>, "columns" | "selectable" | "bordered" | "density" | "striped" | "hoverable" | "loading" | "emptyText"> {
  actions?: TableAction<T>[];
  processedData: DataRow<T>[];
  visibleColumns: Column<Row<T>>[];
  hasActions: boolean;
  selectedRows: DataRow<T>[];
  editingCell: { rowIndex: number; columnKey: string } | null;
  editValue: string;
  setEditValue: (value: string) => void;
  onRowSelect: (record: DataRow<T>, selected: boolean) => void;
  onCellEdit: (record: DataRow<T>, column: Column<Row<T>>, rowIndex: number) => void;
  saveCellEdit: () => void;
  cancelCellEdit: () => void;
  isLoading: boolean;
}

interface TableRowProps<T extends TableOrViewName> extends Omit<TableBodyProps<T>, 'processedData' | 'loading' | 'emptyText'> {
    record: DataRow<T>;
    rowIndex: number;
    isSelected: boolean;
}

const densityClasses = { compact: "py-1 px-3", default: "py-3 px-4", comfortable: "py-4 px-6" };

// Base Table Row component (generic). We'll memoize it below with a type assertion to preserve generics.
function TableRowBase<T extends TableOrViewName>({
    record,
    rowIndex,
    isSelected,
    visibleColumns,
    selectable,
    bordered,
    density,
    actions,
    hasActions,
    striped,
    hoverable,
    selectedRows,
    editingCell,
    editValue,
    setEditValue,
    onRowSelect,
    onCellEdit,
    saveCellEdit,
    cancelCellEdit,
    // isLoading,
}: TableRowProps<T>) {
    const editInputRef = useRef<HTMLInputElement>(null);

    useEffect(() => {
        if (editingCell && editingCell.rowIndex === rowIndex) {
            editInputRef.current?.focus();
            editInputRef.current?.select();
        }
    }, [editingCell, rowIndex]);

    // Loading UI is handled at the TableBodyBase level.
    
    return (
        <tr
          className={`${striped && rowIndex % 2 === 1 ? "bg-gray-50/50 dark:bg-gray-700/25" : ""} ${hoverable ? "hover:bg-gray-50 dark:hover:bg-gray-700/50" : ""} ${
            isSelected ? "bg-blue-50 dark:bg-blue-900/20" : ""
          } transition-colors`}>
          {selectable && (
            <td className={`w-12 px-4 py-3 whitespace-nowrap overflow-hidden ${bordered ? `${rowIndex < selectedRows.length - 1 ? "border-b" : ""} border-r border-gray-200 dark:border-gray-700` : ""}`}
                style={{ width: 48, minWidth: 48, maxWidth: 48 }}>
              <input type='checkbox' checked={isSelected} onChange={(e) => onRowSelect(record, e.target.checked)} className='rounded border-gray-300 text-blue-600 focus:ring-blue-500' aria-label={`Select row ${rowIndex + 1}`} />
            </td>
          )}
          {hasActions && (
            <td className={`w-32 ${densityClasses[density ?? "default"]} text-right whitespace-nowrap overflow-hidden ${bordered ? `${rowIndex < selectedRows.length - 1 ? "border-b" : ""} border-gray-200 dark:border-gray-700` : ""}`}
                style={{ width: 128, minWidth: 128, maxWidth: 128 }}>
              <div className='flex items-center justify-end gap-1'>
                {actions?.map((action) => {
                  const isHidden = typeof action.hidden === 'function' ? action.hidden(record) : action.hidden;
                  if (isHidden) return null;
                  
                  const isDisabled = typeof action.disabled === 'function' ? action.disabled(record) : action.disabled;
                  const variants = {
                    primary: "text-blue-600 hover:text-blue-700 dark:text-blue-400 dark:hover:text-blue-300",
                    secondary: "text-gray-600 hover:text-gray-700 dark:text-gray-400 dark:hover:text-gray-300",
                    danger: "text-red-600 hover:text-red-700 dark:text-red-400 dark:hover:text-red-300",
                    success: "text-green-600 hover:text-green-700 dark:text-green-400 dark:hover:text-green-300",
                  };
                  
                  const icon = action.getIcon ? action.getIcon(record) : action.icon;
                  const variant = action.variant || 'secondary';
                  
                  return (
                    <button
                      key={action.key}
                      onClick={() => !isDisabled && action.onClick(record, rowIndex)}
                      disabled={isDisabled}
                      className={`p-1 rounded transition-colors ${isDisabled ? "opacity-50 cursor-not-allowed" : variants[variant]}`}
                      title={action.label}
                    >
                      {icon}
                    </button>
                  );
                })}
              </div>
            </td>
          )}
          {visibleColumns.map((column, colIndex) => (
            <td
              key={column.key}
              className={`${densityClasses[density ?? "default"]} text-sm text-gray-900 dark:text-white whitespace-nowrap ${column.align === "center" ? "text-center" : column.align === "right" ? "text-right" : ""} ${
                column.editable ? "cursor-pointer hover:bg-gray-100 dark:hover:bg-gray-600/50" : ""
              } ${bordered ? `${rowIndex < selectedRows.length - 1 ? "border-b" : ""} ${colIndex < visibleColumns.length - 1 || hasActions ? "border-r" : ""} border-gray-200 dark:border-gray-700` : ""} overflow-hidden`}
              style={{
                width: column.width,
                minWidth: column.width ? undefined : "100px",
                maxWidth: "350px"
              }}
              onClick={() => column.editable && onCellEdit(record, column, rowIndex)}>
              {editingCell?.rowIndex === rowIndex && editingCell?.columnKey === column.key ? (
                <div className='flex items-center gap-2'>
                  <input
                    ref={editInputRef}
                    type='text'
                    value={editValue}
                    onChange={(e) => setEditValue(e.target.value)}
                    onKeyDown={(e) => {
                      if (e.key === "Enter") saveCellEdit();
                      if (e.key === "Escape") cancelCellEdit();
                    }}
                    className='flex-1 px-2 py-1 text-sm border border-blue-500 rounded bg-white dark:bg-gray-700 focus:outline-none focus:ring-2 focus:ring-blue-500'
                  />
                  <button onClick={saveCellEdit} className='p-1 text-green-600 hover:text-green-700' aria-label="Save cell edit">
                    <FiCheck size={14} />
                  </button>
                  <button onClick={cancelCellEdit} className='p-1 text-red-600 hover:text-red-700' aria-label="Cancel cell edit">
                    <FiX size={14} />
                  </button>
                </div>
              ) : (
                <div className='flex items-center gap-2 group min-w-0'>
                  {column.render ? (
                    column.render(
                      record[column.dataIndex as keyof DataRow<T>],
                      record,
                      rowIndex
                    )
                  ) : (
                    <TruncateTooltip
                      text={String(record[column.dataIndex as keyof DataRow<T>] ?? "—")}
                      className="text-sm"
                    />
                  )}
                  {column.editable && <FiEdit3 size={12} className='opacity-0 group-hover:opacity-50 text-gray-400' />}
                </div>
              )}
            </td>
          ))}
        </tr>
    );
}

// Memoized Table Row component for performance optimization (preserve generics via assertion)
const MemoizedTableRow = React.memo(TableRowBase) as <T extends TableOrViewName>(
  props: TableRowProps<T>
) => React.ReactElement;

// Base TableBody component (generic). We'll memoize with a type assertion below to preserve generics.
function TableBodyBase<T extends TableOrViewName>({
  processedData,
  visibleColumns,
  loading,
  emptyText,
  ...rest
}: TableBodyProps<T>) {

  if (loading) {
    return (
      <tbody>
        <tr>
          <td colSpan={visibleColumns.length + (rest.selectable ? 1 : 0) + (rest.hasActions ? 1 : 0)} className={rest.bordered ? "border-b border-gray-200 dark:border-gray-700" : ""}>
            <div className='py-6'>
              <TableSkeleton
                rows={processedData.length || 5}
                columns={visibleColumns.length + (rest.selectable ? 1 : 0) + (rest.hasActions ? 1 : 0)}
                showHeader={false}
              />
            </div>
          </td>
        </tr>
      </tbody>
    );
  }

  if (processedData.length === 0) {
    return (
      <tbody>
        <tr>
          <td colSpan={visibleColumns.length + (rest.selectable ? 1 : 0) + (rest.hasActions ? 1 : 0)} className={rest.bordered ? "border-b border-gray-200 dark:border-gray-700" : ""}>
            <div className='text-center py-12'>
              <div className='text-gray-400 dark:text-gray-500 text-lg mb-2'>📄</div>
              <p className='text-gray-500 dark:text-gray-400'>{emptyText}</p>
            </div>
          </td>
        </tr>
      </tbody>
    );
  }

  const selectedRowIds = new Set(rest.selectedRows.map(r => (r as DataRow<T>).id));

  return (
    <tbody className={`bg-white dark:bg-gray-800 ${rest.striped && !rest.bordered ? "divide-y divide-gray-200 dark:divide-gray-700" : ""}`}>
      {processedData.map((record, rowIndex) => (
        <MemoizedTableRow
            key={record.id} // IMPORTANT: Use a stable, unique ID
            record={record}
            rowIndex={rowIndex}
            visibleColumns={visibleColumns}
            isSelected={selectedRowIds.has(record.id)}
            {...rest}
        />
      ))}
    </tbody>
  );
}

export const TableBody = React.memo(TableBodyBase) as <T extends TableOrViewName>(
  props: TableBodyProps<T>
) => React.ReactElement;
```

<!-- path: components/table/TableToolbar.tsx -->
```typescript
// @/components/table/TableToolbar.tsx
import React, { useState, useEffect, useRef } from "react";
import {
  FiSearch,
  FiFilter,
  FiDownload,
  FiRefreshCw,
  FiEye,
  FiChevronDown,
} from "react-icons/fi";
import { DataTableProps } from "@/components/table/datatable-types";
import { Column } from "@/hooks/database/excel-queries/excel-helpers";
import { Row } from "@/hooks/database";
import { TableColumnSelector } from "./TableColumnSelector";
import { TableOrViewName } from "@/hooks/database";
import { useDebounce } from "@/hooks/useDebounce";
import { DEFAULTS } from "@/config/constants";

interface TableToolbarProps<T extends TableOrViewName>
  extends Pick<
    DataTableProps<T>,
    | "searchable"
    | "filterable"
    | "exportable"
    | "refreshable"
    | "title"
    | "customToolbar"
    | "onRefresh"
    | "loading"
  > {
  searchQuery: string;
  setSearchQuery: (query: string) => void;
  onSearchChange?: (query: string) => void;
  showFilters: boolean;
  setShowFilters: (show: boolean) => void;
  showColumnSelector: boolean;
  setShowColumnSelector: (show: boolean) => void;
  showColumnsToggle?: boolean;
  columns: Column<Row<T>>[];
  visibleColumns: string[];
  setVisibleColumns: (cols: string[]) => void;
  onExport: () => void;
  isExporting: boolean;
}

export function TableToolbar<T extends TableOrViewName>({
  title,
  searchable,
  filterable,
  exportable,
  refreshable,
  customToolbar,
  searchQuery,
  setSearchQuery,
  onSearchChange,
  showFilters,
  setShowFilters,
  showColumnSelector,
  setShowColumnSelector,
  showColumnsToggle,
  columns,
  visibleColumns,
  setVisibleColumns,
  onRefresh,
  onExport,
  loading,
  isExporting,
}: TableToolbarProps<T>) {
  const [internalSearchQuery, setInternalSearchQuery] = useState(searchQuery);
  const debouncedSearchQuery = useDebounce(internalSearchQuery, DEFAULTS.DEBOUNCE_DELAY);
  const setSearchQueryRef = useRef(setSearchQuery);
  const onSearchChangeRef = useRef(onSearchChange);

  // Keep refs in sync with latest props without retriggering the search effect
  useEffect(() => {
    setSearchQueryRef.current = setSearchQuery;
  }, [setSearchQuery]);
  useEffect(() => {
    onSearchChangeRef.current = onSearchChange;
  }, [onSearchChange]);

  // Only react to content changes, not function identity changes
  useEffect(() => {
    setSearchQueryRef.current(debouncedSearchQuery);
    onSearchChangeRef.current?.(debouncedSearchQuery);
  }, [debouncedSearchQuery]);

  useEffect(() => {
    setInternalSearchQuery(searchQuery);
  }, [searchQuery]);

  return (
    <div className="p-3 sm:p-4 border-b border-gray-200 dark:border-gray-700">
      {title && (
        <h3 className="text-lg sm:text-xl font-semibold text-gray-900 dark:text-white mb-3 sm:mb-4">
          {title}
        </h3>
      )}

      <div className="space-y-3 sm:space-y-0 sm:flex sm:justify-between sm:items-center">
        {customToolbar ? (
          <div className="w-full">{customToolbar}</div>
        ) : (
          <div className="flex flex-col gap-2 sm:gap-3 sm:flex-row sm:items-center sm:justify-between w-full">
            <div className="flex flex-col gap-2 sm:flex-row sm:items-center sm:flex-1 sm:gap-3">
              {searchable && (
                <div className="relative flex-1 sm:max-w-sm">
                  <FiSearch className="absolute left-3 top-1/2 transform -translate-y-1/2 text-gray-400 text-sm sm:text-base" />
                  <input
                    type="text"
                    placeholder="Search..."
                    value={internalSearchQuery}
                    onChange={(e) => setInternalSearchQuery(e.target.value)}
                    className="w-full pl-9 sm:pl-10 pr-4 py-2 text-sm sm:text-base border border-gray-300 dark:border-gray-600 rounded-lg bg-white dark:bg-gray-700 text-gray-900 dark:text-white placeholder-gray-500 dark:placeholder-gray-400 focus:ring-2 focus:ring-blue-500 focus:border-blue-500"
                  />
                </div>
              )}
              {filterable && (
                <button
                  onClick={() => setShowFilters(!showFilters)}
                  className={`flex items-center justify-center gap-2 px-3 py-2 text-sm sm:text-base border rounded-lg transition-colors min-w-0 ${
                    showFilters
                      ? "border-blue-300 bg-blue-50 text-blue-700 dark:border-blue-600 dark:bg-blue-900/50 dark:text-blue-300"
                      : "border-gray-300 dark:border-gray-600 hover:bg-gray-50 dark:hover:bg-gray-700 text-gray-700 dark:text-gray-300"
                  }`}
                >
                  <FiFilter size={14} className="sm:w-4 sm:h-4" />
                  <span className="hidden sm:inline">Filters</span>
                  <span className="sm:hidden">Filter</span>
                </button>
              )}
            </div>
          </div>
        )}

        {/* Right-side controls should be available even when customToolbar is used */}
        <div className="flex w-full sm:w-auto sm:flex-none items-center gap-2 sm:gap-3 justify-end mt-1 sm:mt-0 ml-auto">
          {(showColumnsToggle || (!customToolbar && true)) && (
            <div className="relative">
              <button
                onClick={() => setShowColumnSelector(!showColumnSelector)}
                className="flex items-center justify-center gap-2 px-3 py-2 text-sm border border-gray-300 dark:border-gray-600 rounded-lg hover:bg-gray-50 dark:hover:bg-gray-700 text-gray-700 dark:text-gray-300"
                aria-label="Show/Hide Columns"
              >
                <FiEye size={14} className="sm:w-4 sm:h-4" />
                <span className="hidden sm:inline">Columns</span>
                <FiChevronDown size={12} className="sm:w-3.5 sm:h-3.5" />
              </button>
              <div className="absolute right-0 top-full z-50">
                <TableColumnSelector
                  columns={columns.filter((c) => !c.hidden)}
                  visibleColumns={visibleColumns}
                  setVisibleColumns={setVisibleColumns}
                  showColumnSelector={showColumnSelector}
                  setShowColumnSelector={setShowColumnSelector}
                />
              </div>
            </div>
          )}

          {refreshable && onRefresh && (
            <button
              onClick={onRefresh}
              disabled={loading}
              className="p-2 border border-gray-300 dark:border-gray-600 rounded-lg hover:bg-gray-50 dark:hover:bg-gray-700 text-gray-700 dark:text-gray-300 disabled:opacity-50 flex-shrink-0"
              aria-label="Refresh data"
            >
              <FiRefreshCw
                size={14}
                className={`${loading ? "animate-spin" : ""}`}
              />
            </button>
          )}

          {exportable && (
            <button
              onClick={onExport}
              disabled={isExporting}
              className="flex items-center justify-center gap-2 px-3 py-2 text-sm bg-green-600 hover:bg-green-700 disabled:bg-green-400 text-white rounded-lg transition-colors"
            >
              <FiDownload size={14} />
              <span className="hidden sm:inline">
                {isExporting ? "Exporting..." : "Export"}
              </span>
            </button>
          )}
        </div>
      </div>
    </div>
  );
}

```

<!-- path: components/table/index.ts -->
```typescript
export * from "./DataTable";
export * from "./TableHeader";
export * from "./TableBody";
export * from "./TablePagination";
export * from "./TableColumnSelector";
export * from "./TableFilterPanel";
export * from "./TableToolbar";
export * from "./datatable-types";
```

<!-- path: components/table/DataTable.tsx -->
```typescript
// @/components/table/DataTable.tsx
import React, { useMemo, useCallback, useEffect, useReducer } from 'react';
import { createClient } from '@/utils/supabase/client';
import {
  useTableExcelDownload,
  useRPCExcelDownload,
} from '@/hooks/database/excel-queries';
import {
  TableToolbar,
  TableHeader,
  TableBody,
  TablePagination,
  TableFilterPanel,
} from './';
import { DataTableProps, SortConfig } from '@/components/table/datatable-types';
import { PublicTableOrViewName, Row, Filters } from '@/hooks/database';
import {
  Column,
  DownloadOptions,
  RPCConfig,
} from '@/hooks/database/excel-queries/excel-helpers';
import { cn } from '@/lib/utils';

// Define a type for your row that guarantees a unique identifier
type DataRow<T extends PublicTableOrViewName> = Row<T> & { id: string | number };

// --- State Management with useReducer ---

type TableState<T extends PublicTableOrViewName> = {
  searchQuery: string;
  sortConfig: SortConfig<Row<T>> | null;
  filters: Filters;
  selectedRows: DataRow<T>[];
  visibleColumns: string[];
  editingCell: { rowIndex: number; columnKey: string } | null;
  editValue: string;
  showColumnSelector: boolean;
  showFilters: boolean;
};

// Base action type that works with any row type
type BaseTableAction<R> =
  | { type: 'SET_SEARCH_QUERY'; payload: string }
  | { type: 'SET_SELECTED_ROWS'; payload: R[] }
  | { type: 'SET_VISIBLE_COLUMNS'; payload: string[] }
  | {
      type: 'START_EDIT_CELL';
      payload: { rowIndex: number; columnKey: string; value: string };
    }
  | { type: 'SET_EDIT_VALUE'; payload: string }
  | { type: 'CANCEL_EDIT' }
  | { type: 'TOGGLE_COLUMN_SELECTOR'; payload?: boolean }
  | { type: 'TOGGLE_FILTERS'; payload?: boolean };

// Table-specific action type that extends the base with table-aware actions
type TableAction<T extends PublicTableOrViewName> =
  | BaseTableAction<DataRow<T>>
  | { type: 'SET_SORT_CONFIG'; payload: SortConfig<Row<T>> | null }
  | { type: 'SET_FILTERS'; payload: Filters };

function tableReducer<T extends PublicTableOrViewName>(
  state: TableState<T>,
  action: TableAction<T> | BaseTableAction<DataRow<T>>
): TableState<T> {
  switch (action.type) {
    case 'SET_SEARCH_QUERY':
      return { ...state, searchQuery: action.payload };
    case 'SET_SORT_CONFIG':
      return { ...state, sortConfig: action.payload };
    case 'SET_FILTERS':
      return { ...state, filters: action.payload };
    case 'SET_SELECTED_ROWS':
      return { ...state, selectedRows: action.payload };
    case 'SET_VISIBLE_COLUMNS':
      return { ...state, visibleColumns: action.payload };
    case 'START_EDIT_CELL':
      return {
        ...state,
        editingCell: {
          rowIndex: action.payload.rowIndex,
          columnKey: action.payload.columnKey,
        },
        editValue: action.payload.value,
      };
    case 'SET_EDIT_VALUE':
      return { ...state, editValue: action.payload };
    case 'CANCEL_EDIT':
      return { ...state, editingCell: null, editValue: '' };
    case 'TOGGLE_COLUMN_SELECTOR':
      return {
        ...state,
        showColumnSelector: action.payload ?? !state.showColumnSelector,
      };
    case 'TOGGLE_FILTERS':
      return { ...state, showFilters: action.payload ?? !state.showFilters };
    default:
      return state;
  }
}

export function DataTable<T extends PublicTableOrViewName>({
  data = [],
  tableName,
  columns,
  loading = false,
  isFetching = false,
  pagination,
  actions = [],
  searchable = true,
  serverSearch = false,
  filterable = true,
  sortable = true,
  selectable = false,
  exportable = false,
  refreshable = false,
  density = 'default',
  bordered = true,
  striped = true,
  hoverable = true,
  className = '',
  emptyText = 'No data available',
  title,
  onRefresh,
  onExport,
  onRowSelect,
  onCellEdit,
  customToolbar,
  showColumnSelector: showColumnSelectorProp,
  showColumnsToggle,
  exportOptions,
  onSearchChange,
}: DataTableProps<T>): React.ReactElement {
  const initialState: TableState<T> = {
    searchQuery: '',
    sortConfig: null,
    filters: {},
    selectedRows: [],
    visibleColumns: columns.map((col) => col.key),
    editingCell: null,
    editValue: '',
    showColumnSelector: !!showColumnSelectorProp,
    showFilters: false,
  };

  const [state, dispatch] = useReducer(tableReducer, initialState);
  const {
    searchQuery,
    sortConfig,
    filters,
    selectedRows,
    visibleColumns,
    editingCell,
    editValue,
    showColumnSelector,
    showFilters,
  } = state;

  const supabase = createClient();

  useEffect(() => {
    if (typeof showColumnSelectorProp === 'boolean') {
      dispatch({
        type: 'TOGGLE_COLUMN_SELECTOR',
        payload: showColumnSelectorProp,
      });
    }
  }, [showColumnSelectorProp]);

  useEffect(() => {
    if (!filterable) {
      dispatch({ type: 'SET_FILTERS', payload: {} });
    }
  }, [filterable]);

  // (Excel download hooks remain the same)
  const tableExcelDownload = useTableExcelDownload<T>(supabase, tableName, {
    showToasts: true,
  });
  const rpcExcelDownload = useRPCExcelDownload<T>(supabase, {
    showToasts: true,
  });

  const processedData = useMemo(() => {
    let filteredData = [...data] as DataRow<T>[];

    if (searchQuery && searchable && !serverSearch) {
      const q = searchQuery.toLowerCase();
      filteredData = filteredData.filter((item) =>
        columns.some((column) => {
          if (column.searchable === false) return false;
          const value = item[column.dataIndex as keyof typeof item];
          return String(value ?? '')
            .toLowerCase()
            .includes(q);
        })
      );
    }

    if (filterable && Object.keys(filters).length > 0) {
      Object.entries(filters).forEach(([key, value]) => {
        if (value !== undefined && value !== '') {
          filteredData = filteredData.filter((item) =>
            String(item[key as keyof DataRow<T>] ?? '')
              .toLowerCase()
              .includes(String(value).toLowerCase())
          );
        }
      });
    }

    if (sortConfig && sortable) {
      filteredData.sort((a, b) => {
        const aValue = a[sortConfig.key];
        const bValue = b[sortConfig.key];
        if (aValue === null || aValue === undefined) return 1;
        if (bValue === null || bValue === undefined) return -1;
        if (typeof aValue === 'string' && typeof bValue === 'string') {
          return sortConfig.direction === 'asc'
            ? aValue.localeCompare(bValue)
            : bValue.localeCompare(aValue);
        }
        return sortConfig.direction === 'asc'
          ? aValue > bValue
            ? 1
            : -1
          : aValue < bValue
          ? 1
          : -1;
      });
    }

    return filteredData;
  }, [
    data,
    searchQuery,
    filters,
    sortConfig,
    columns,
    searchable,
    sortable,
    filterable,
    serverSearch,
  ]);

  const handleSort = useCallback(
    (columnKey: keyof Row<T> & string) => {
      if (!sortable) return;
      const direction =
        sortConfig?.key === columnKey && sortConfig.direction === 'asc'
          ? 'desc'
          : 'asc';
      if (sortConfig?.key === columnKey && sortConfig.direction === 'desc') {
        dispatch({ type: 'SET_SORT_CONFIG', payload: null });
      } else {
        dispatch({
          type: 'SET_SORT_CONFIG',
          payload: { key: columnKey, direction },
        });
      }
    },
    [sortable, sortConfig]
  );

  const handleRowSelect = useCallback(
    (record: DataRow<T>, selected: boolean) => {
      const newSelection = selected
        ? [...selectedRows, record]
        : selectedRows.filter((row) => row.id !== record.id);
      dispatch({ type: 'SET_SELECTED_ROWS', payload: newSelection });
      onRowSelect?.(newSelection);
    },
    [selectedRows, onRowSelect]
  );

  const handleSelectAll = useCallback(
    (selected: boolean) => {
      const newSelection = selected ? [...processedData] : [];
      dispatch({ type: 'SET_SELECTED_ROWS', payload: newSelection });
      onRowSelect?.(newSelection);
    },
    [processedData, onRowSelect]
  );

  const handleCellEdit = useCallback(
    (record: DataRow<T>, column: Column<Row<T>>, rowIndex: number) => {
      if (!column.editable) return;
      dispatch({
        type: 'START_EDIT_CELL',
        payload: {
          rowIndex,
          columnKey: column.key,
          value: String(record[column.dataIndex as keyof DataRow<T>] ?? ''),
        },
      });
    },
    []
  );

  const saveCellEdit = useCallback(() => {
    if (!editingCell) return;
    const record = processedData[editingCell.rowIndex];
    const column = columns.find((col) => col.key === editingCell.columnKey);
    if (column && onCellEdit) {
      onCellEdit(record, column, editValue);
    }
    dispatch({ type: 'CANCEL_EDIT' });
  }, [editingCell, processedData, columns, onCellEdit, editValue]);

  const cancelCellEdit = useCallback(
    () => dispatch({ type: 'CANCEL_EDIT' }),
    []
  );

  const visibleColumnsData = useMemo<Column<Row<T>>[]>(
    () =>
      columns.filter((col) => visibleColumns.includes(col.key) && !col.hidden),
    [columns, visibleColumns]
  );

  const setSearchQueryCb = useCallback((query: string) => {
    dispatch({ type: 'SET_SEARCH_QUERY', payload: query });
  }, []);

  const handleExport = useCallback(async () => {
    // 1) If a custom export handler is provided by the parent, use it
    if (onExport) {
      await onExport(
        processedData as Row<T>[],
        visibleColumnsData as Column<Row<T>>[]
      );
      return;
    }

    // 2) Build export options: prefer explicit options, else use current visible columns and filters
    const columnsToExport = (exportOptions?.columns ??
      visibleColumnsData) as Column<Row<T>>[];
    const mergedFilters = exportOptions?.includeFilters
      ? { ...filters, ...(exportOptions?.filters ?? {}) }
      : exportOptions?.filters;

    const baseOptions: Omit<DownloadOptions<T>, 'rpcConfig'> = {
      fileName: exportOptions?.fileName,
      sheetName: exportOptions?.sheetName,
      maxRows: exportOptions?.maxRows,
      customStyles: exportOptions?.customStyles,
      columns: columnsToExport,
      filters: mergedFilters,
    };

    try {
      // 3) Use RPC-based download if rpcConfig is provided; otherwise, table/view download
      if (exportOptions?.rpcConfig) {
        const rpcOptions: DownloadOptions<T> & { rpcConfig: RPCConfig } = {
          ...baseOptions,
          rpcConfig: exportOptions.rpcConfig,
        };
        await rpcExcelDownload.mutateAsync(rpcOptions);
      } else {
        await tableExcelDownload.mutateAsync(baseOptions);
      }
    } catch (err) {
      // 4) Optional CSV fallback using currently processed rows
      if (exportOptions?.fallbackToCsv) {
        try {
          const headers = columnsToExport.map((c) => c.title).join(',');
          const keys = columnsToExport.map(
            (c) => c.dataIndex as keyof Row<T> & string
          );
          const rows = (processedData as Row<T>[])?.map((r) =>
            keys
              .map((k) => {
                const v = (r as Row<T>)[k] as unknown;
                if (v === null || v === undefined) return '';
                const s = String(v).replace(/"/g, '""');
                return `"${s}"`;
              })
              .join(',')
          );
          const csv = [headers, ...(rows || [])].join('\n');
          const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
          const link = document.createElement('a');
          const csvName =
            (exportOptions?.fileName?.replace(/\.xlsx$/i, '') || 'export') +
            '.csv';
          link.href = URL.createObjectURL(blob);
          link.download = csvName;
          document.body.appendChild(link);
          link.click();
          document.body.removeChild(link);
          URL.revokeObjectURL(link.href);
        } catch {
          // If CSV fallback also fails, rethrow original error
          throw err;
        }
      } else {
        throw err;
      }
    }
  }, [
    onExport,
    processedData,
    visibleColumnsData,
    exportOptions,
    filters,
    tableExcelDownload,
    rpcExcelDownload,
  ]);
  const hasActions = actions.length > 0;
  const isExporting =
    tableExcelDownload.isPending || rpcExcelDownload.isPending;

  return (
    <div 
      className={cn(
        "flex flex-col bg-white dark:bg-gray-800 rounded-lg max-h-[calc(100vh-250px)] relative", 
        bordered ? "border border-gray-200 dark:border-gray-700" : "shadow-md", 
        className
      )}
    >
      {/* Section 1: Toolbar and Filters (Non-scrolling) */}
      <div className="flex-shrink-0">
      <TableToolbar
        title={title}
        searchable={searchable}
        filterable={filterable}
        exportable={exportable}
        refreshable={refreshable}
        customToolbar={customToolbar}
        searchQuery={searchQuery}
        setSearchQuery={setSearchQueryCb}
        onSearchChange={onSearchChange}
        showFilters={showFilters}
        setShowFilters={() => dispatch({ type: 'TOGGLE_FILTERS' })}
        showColumnSelector={showColumnSelector}
        setShowColumnSelector={(show) =>
          dispatch({ type: 'TOGGLE_COLUMN_SELECTOR', payload: show })
        }
        showColumnsToggle={showColumnsToggle}
        columns={columns}
        visibleColumns={visibleColumns}
        setVisibleColumns={(cols: string[]) =>
          dispatch({ type: 'SET_VISIBLE_COLUMNS', payload: cols })
        }
        onRefresh={onRefresh}
        onExport={handleExport}
        loading={loading}
        isExporting={isExporting}
      />

      <TableFilterPanel
        columns={columns}
        filters={filters}
        setFilters={(f) =>
          dispatch({
            type: 'SET_FILTERS',
            payload:
              typeof f === 'function'
                ? (f as (prev: Filters) => Filters)(filters)
                : f,
          })
        }
        showFilters={showFilters}
        filterable={filterable}
      />
      </div>

      {/* Section 2: Scrollable Table Area */}
      <div className='flex-1 w-full overflow-auto min-h-0 relative'>
      {isFetching && !loading && (
          <div className="absolute inset-0 bg-white/70 dark:bg-gray-900/70 z-20 flex items-center justify-center backdrop-blur-sm">
            <div className="flex items-center space-x-2 text-gray-500">
              <div className="h-5 w-5 animate-spin rounded-full border-b-2 border-blue-500"></div>
              <span>Refreshing data...</span>
            </div>
          </div>
        )}
        <table className={`min-w-full w-full table-auto sm:table-fixed ${bordered ? "border-separate border-spacing-0" : ""}`}>
            <TableHeader
              columns={columns}
              visibleColumns={visibleColumnsData}
              selectable={selectable}
              sortable={sortable}
              bordered={bordered}
              density={density}
              actions={actions}
              hasActions={hasActions}
              sortConfig={sortConfig}
              onSort={handleSort}
              onSelectAll={handleSelectAll}
              allSelected={
                processedData.length > 0 &&
                selectedRows.length === processedData.length
              }
              hasData={processedData.length > 0}
            />
            <TableBody
              columns={columns}
              processedData={processedData}
              visibleColumns={visibleColumnsData}
              selectable={selectable}
              bordered={bordered}
              density={density}
              actions={actions}
              hasActions={hasActions}
              striped={striped}
              hoverable={hoverable}
              loading={loading}
              emptyText={emptyText}
              selectedRows={selectedRows}
              editingCell={editingCell}
              editValue={editValue}
              setEditValue={(value) =>
                dispatch({ type: 'SET_EDIT_VALUE', payload: value })
              }
              onRowSelect={handleRowSelect}
              onCellEdit={handleCellEdit}
              saveCellEdit={saveCellEdit}
              cancelCellEdit={cancelCellEdit}
              isLoading={loading}
            />
          </table>
      </div>

      {/* Section 3: Pagination (Non-scrolling) */}
      <div className="flex-shrink-0">
        <TablePagination pagination={pagination} bordered={bordered} />
      </div>
    </div>
  );
}

```

<!-- path: components/table/datatable-types.ts -->
```typescript
// @/components/table/types.ts
import { TableOrViewName, Row, Filters } from "@/hooks/database";
import { Column, RPCConfig, ExcelStyles } from "@/hooks/database/excel-queries/excel-helpers";

export interface TableAction<T extends TableOrViewName> {
  key: string;
  label: string;
  icon?: React.ReactNode;
  getIcon?: (record: Row<T>) => React.ReactNode;
  onClick: (record: Row<T>, index?: number) => void;
  variant?: "primary" | "secondary" | "danger" | "success";
  disabled?: boolean | ((record: Row<T>) => boolean);
  hidden?: boolean | ((record: Row<T>) => boolean);
  [key: string]: unknown;
}

export interface DownloadOptions<T extends TableOrViewName> {
  fileName?: string;
  filters?: Filters;
  columns?: Column<Row<T>>[];
  sheetName?: string;
  maxRows?: number;
  customStyles?: ExcelStyles;
  rpcConfig?: RPCConfig;
}

export interface DataTableProps<T extends TableOrViewName> {
  data: Row<T>[];
  tableName: T;
  columns: Column<Row<T>>[];
  loading?: boolean;
  isFetching?: boolean;
  showColumnSelector?: boolean;
  // Controls visibility of the Columns toggle button in the toolbar
  showColumnsToggle?: boolean;
  pagination?: {
    current: number;
    pageSize: number;
    total: number;
    showSizeChanger?: boolean;
    pageSizeOptions?: number[];
    onChange: (page: number, pageSize: number) => void;
  };
  actions?: TableAction<T>[];
  searchable?: boolean;
  // If true, DataTable will not perform client-side search and will delegate to parent via onSearchChange
  serverSearch?: boolean;
  filterable?: boolean;
  sortable?: boolean;
  selectable?: boolean;
  exportable?: boolean;
  refreshable?: boolean;
  density?: "compact" | "default" | "comfortable";
  bordered?: boolean;
  striped?: boolean;
  hoverable?: boolean;
  className?: string;
  emptyText?: string;
  title?: string;
  onRefresh?: () => void;
  // Called when the search query changes; useful for server-side search or fetching more rows
  onSearchChange?: (query: string) => void;
  onExport?: (data: Row<T>[], columns: Column<Row<T>>[]) => void | Promise<void>;
  onRowSelect?: (selectedRows: Row<T>[]) => void;
  onCellEdit?: (record: Row<T>, column: Column<Row<T>>, newValue: string) => void;
  customToolbar?: React.ReactNode;
  exportOptions?: {
    fileName?: string;
    sheetName?: string;
    includeFilters?: boolean;
    maxRows?: number;
    rpcConfig?: RPCConfig;
    fallbackToCsv?: boolean;
  } & Omit<DownloadOptions<T>, "rpcConfig">;
}

export type SortDirection = "asc" | "desc";
export interface SortConfig<T> {
  key: keyof T & string;
  direction: SortDirection;
}

export type TablePaginationProps = Pick<DataTableProps<TableOrViewName>, 'pagination' | 'bordered'>;

```

<!-- path: components/bsnl/useDashboardOverview.ts -->
```typescript
// path: components/bsnl/useDashboardOverview.ts
"use client";

import { useQuery } from '@tanstack/react-query';
import { createClient } from '@/utils/supabase/client';
import { z } from 'zod';

// CORRECTED: The z.record schema now correctly specifies both a key and a value type.
const dashboardOverviewSchema = z.object({
  system_status_counts: z.object({
    Active: z.number().optional(),
    Inactive: z.number().optional(),
  }).nullable(),
  node_status_counts: z.object({
    Active: z.number().optional(),
    Inactive: z.number().optional(),
  }).nullable(),
  path_operational_status: z.record(z.string(), z.number()).nullable(),
  cable_utilization_summary: z.object({
    average_utilization_percent: z.number().nullable(),
    high_utilization_count: z.number().nullable(),
    total_cables: z.number().nullable(),
  }).nullable(),
  user_activity_last_30_days: z.array(z.object({
    date: z.string(),
    count: z.number(),
  })).nullable(),
  systems_per_maintenance_area: z.record(z.string(), z.number()).nullable(),
});

export type DashboardOverviewData = z.infer<typeof dashboardOverviewSchema>;

export function useDashboardOverview() {
  const supabase = createClient();

  return useQuery({
    queryKey: ['dashboard-overview'],
    queryFn: async (): Promise<DashboardOverviewData | null> => {
      const { data, error } = await supabase.rpc('get_dashboard_overview');
      
      if (error) {
        console.error("Error fetching dashboard overview:", error);
        throw new Error(error.message);
      }
      
      const parsed = dashboardOverviewSchema.safeParse(data);
      if (!parsed.success) {
        console.error("Zod validation error for dashboard overview:", parsed.error);
        throw new Error("Received invalid data structure from dashboard overview function.");
      }

      return parsed.data;
    },
    staleTime: 5 * 60 * 1000,
  });
}
```

<!-- path: components/bsnl/types.ts -->
```typescript
// path: components/bsnl/types.ts
import {
  v_nodes_completeRowSchema,
  v_ofc_cables_completeRowSchema,
  v_systems_completeRowSchema,
} from '@/schemas/zod-schemas';
import { z } from 'zod';
import { bsnlSearchFiltersSchema } from '@/schemas/custom-schemas'; // Import the schema

export type BsnlNode = z.infer<typeof v_nodes_completeRowSchema>;
export type BsnlCable = z.infer<typeof v_ofc_cables_completeRowSchema>;
export type BsnlSystem = z.infer<typeof v_systems_completeRowSchema>;

export interface FiberRoutePath {
  nodeId: string;
  ofcId: string;
  fiberNumber: number;
  action: 'terminate' | 'pass_through' | 'tap' | 'cascade';
  tapTo?: {
    ofcId: string;
    fiberNumber: number;
  };
}

export interface FiberAllocation {
  fiberNumber: number;
  systemId: string;
  allocatedAt: string;
  routePath: FiberRoutePath[];
  status: 'active' | 'standby' | 'faulty';
}

export interface AllocationSaveData {
  systemId: string;
  topology: 'p2p-unprotected' | 'p2p-protected' | 'ring' | 'tap-spur';
  paths: {
    working: FiberRoutePath[];
    protection: FiberRoutePath[];
    taps: { [key: string]: FiberRoutePath[] };
  };
}

// ** Infer the type directly from the Zod schema.**
export type SearchFilters = z.infer<typeof bsnlSearchFiltersSchema>;
```

<!-- path: components/bsnl/NewAllocationModal.tsx -->
```typescript
"use client"

import React, { useState, useMemo } from 'react';
import { X, GitBranch, Plus, Trash2 } from 'lucide-react';
import { BsnlNode, BsnlCable, BsnlSystem, FiberRoutePath, FiberAllocation } from '@/components/bsnl/types';

// The mock data is now only used as a fallback and is correctly typed.
export const mockData = {
  nodes: [] as BsnlNode[],
  ofcCables: [] as BsnlCable[],
  systems: [] as BsnlSystem[],
};

type AllocationTopology = 'p2p-unprotected' | 'p2p-protected' | 'ring' | 'tap-spur';

export interface AllocationSaveData {
  systemId: string;
  topology: AllocationTopology;
  paths: {
    working: FiberRoutePath[];
    protection: FiberRoutePath[];
    taps: { [key: string]: FiberRoutePath[] };
  };
}

// --- REUSABLE PATH BUILDER COMPONENT ---
interface PathBuilderProps {
  path: FiberRoutePath[];
  onPathChange: (newPath: FiberRoutePath[]) => void;
  startNodeId: string;
  nodes: BsnlNode[];
  cables: BsnlCable[];
  allAllocatedFibers: Set<string>;
}

function PathBuilder({ path, onPathChange, startNodeId, nodes, cables, allAllocatedFibers }: PathBuilderProps) {
  const [nextCableId, setNextCableId] = useState('');
  const [nextFiber1, setNextFiber1] = useState('');
  const [nextFiber2, setNextFiber2] = useState('');
  const [nextAction, setNextAction] = useState<'pass_through' | 'terminate'>('pass_through');

  const lastNodeIdInPath = useMemo(() => {
    if (path.length === 0) return startNodeId;
    const lastStep = path[path.length - 1];
    const lastCable = cables.find(c => c.id === lastStep.ofcId);
    if (!lastCable) return lastStep.nodeId;
    return lastCable.sn_id === lastStep.nodeId ? lastCable.en_id : lastCable.sn_id;
  }, [path, startNodeId, cables]);

  const availableCables = useMemo(() => cables.filter(c => c.sn_id === lastNodeIdInPath || c.en_id === lastNodeIdInPath), [cables, lastNodeIdInPath]);

  const availableFibers = useMemo(() => {
    const cable = cables.find(c => c.id === nextCableId);
    if (!cable || !cable.capacity) return [];
    const available = [];
    for (let i = 1; i <= cable.capacity; i++) {
      if (!allAllocatedFibers.has(`${cable.id}-${i}`)) available.push(i);
    }
    return available;
  }, [cables, nextCableId, allAllocatedFibers]);

  const handleAddStep = () => {
    if (!nextCableId || !nextFiber1 || !nextFiber2 || !lastNodeIdInPath || nextFiber1 === nextFiber2) return;
    const newSteps = [
      { nodeId: lastNodeIdInPath, ofcId: nextCableId, fiberNumber: parseInt(nextFiber1), action: nextAction },
      { nodeId: lastNodeIdInPath, ofcId: nextCableId, fiberNumber: parseInt(nextFiber2), action: nextAction }
    ];
    onPathChange([...path, ...newSteps]);
    setNextCableId(''); setNextFiber1(''); setNextFiber2(''); setNextAction('pass_through');
  };

  const handleRemoveLastStep = () => onPathChange(path.slice(0, -2));
  const getNodeName = (id: string | null) => nodes.find(n => n.id === id)?.name || 'Unknown';

  return (
    <div className="space-y-4">
      {path.filter((_, i) => i % 2 === 0).map((step, pairIndex) => {
        const fiber2 = path[pairIndex * 2 + 1];
        const cable = cables.find(c => c.id === step.ofcId);
        return (
          <div key={pairIndex} className="flex items-center bg-gray-50 dark:bg-gray-700/50 p-2 rounded">
            <div className="w-6 h-6 flex items-center justify-center bg-blue-100 text-blue-700 dark:bg-blue-900 dark:text-blue-200 rounded-full text-xs font-bold mr-3">{pairIndex + 1}</div>
            <div className="flex-1 text-sm">
              <span className="font-medium text-gray-800 dark:text-gray-200">{getNodeName(step.nodeId)}</span>
              <span className="text-gray-500 dark:text-gray-400 mx-1">→</span>
              <span className="text-gray-700 dark:text-gray-300">{cable?.route_name}</span>
              <span className="font-bold text-blue-600 dark:text-blue-400 ml-2">F{step.fiberNumber}/{fiber2.fiberNumber}</span>
              <span className="ml-3 px-2 py-0.5 text-xs bg-gray-200 dark:bg-gray-600 rounded-full">{step.action.replace('_', ' ')}</span>
            </div>
            {pairIndex === Math.floor(path.length / 2) - 1 && (
              <button onClick={handleRemoveLastStep} className="p-1 text-gray-400 hover:text-red-500">
                <Trash2 className="h-4 w-4" />
              </button>
            )}
          </div>
        )
      })}
      {path.length === 0 && <p className="text-sm text-gray-500 dark:text-gray-400 text-center py-2">Path starts at <span className='font-semibold text-gray-700 dark:text-gray-200'>{getNodeName(startNodeId)}</span>.</p>}
      <div className="border-t border-gray-200 dark:border-gray-600 pt-4">
        <p className="text-sm font-medium text-gray-600 dark:text-gray-300 mb-2">Add Step (from {getNodeName(lastNodeIdInPath!)})</p>
        <div className="grid grid-cols-1 md:grid-cols-5 gap-4 items-end">
          <div className="md:col-span-2">
            <label className="block text-xs font-medium text-gray-700 dark:text-gray-300 mb-1">OFC Cable</label>
            <select value={nextCableId} onChange={e => { setNextCableId(e.target.value); setNextFiber1(''); setNextFiber2(''); }} className="w-full border border-gray-300 dark:border-gray-600 rounded-md p-2 text-sm bg-white dark:bg-gray-700 dark:text-white">
              <option value="" disabled>Select cable...</option>
              {availableCables.map(c => <option key={c.id} value={c.id!}>{c.route_name}</option>)}
            </select>
          </div>
          <div>
            <label className="block text-xs font-medium text-gray-700 dark:text-gray-300 mb-1">Fiber A (Tx)</label>
            <select value={nextFiber1} onChange={e => setNextFiber1(e.target.value)} className="w-full border border-gray-300 dark:border-gray-600 rounded-md p-2 text-sm bg-white dark:bg-gray-700 dark:text-white" disabled={!nextCableId}>
              <option value="" disabled>...</option>
              {availableFibers.filter(f => f.toString() !== nextFiber2).map(f => <option key={f} value={f}>{f}</option>)}
            </select>
          </div>
          <div>
            <label className="block text-xs font-medium text-gray-700 dark:text-gray-300 mb-1">Fiber B (Rx)</label>
            <select value={nextFiber2} onChange={e => setNextFiber2(e.target.value)} className="w-full border border-gray-300 dark:border-gray-600 rounded-md p-2 text-sm bg-white dark:bg-gray-700 dark:text-white" disabled={!nextCableId}>
              <option value="" disabled>...</option>
              {availableFibers.filter(f => f.toString() !== nextFiber1).map(f => <option key={f} value={f}>{f}</option>)}
            </select>
          </div>
          <div>
            <label className="block text-xs font-medium text-gray-700 dark:text-gray-300 mb-1">Action</label>
            <select value={nextAction} onChange={e => setNextAction(e.target.value as 'pass_through' | 'terminate')} className="w-full border border-gray-300 dark:border-gray-600 rounded-md p-2 text-sm bg-white dark:bg-gray-700 dark:text-white">
              <option value="pass_through">Pass Through</option>
              <option value="terminate">Terminate</option>
            </select>
          </div>
        </div>
        <button onClick={handleAddStep} className="mt-4 w-full flex items-center justify-center px-4 py-2 border border-dashed border-gray-300 dark:border-gray-600 text-sm font-medium rounded-md text-gray-700 dark:text-gray-300 hover:bg-gray-50 dark:hover:bg-gray-700">
          <Plus className="h-4 w-4 mr-2" />Add Fiber Pair
        </button>
      </div>
    </div>
  );
}

// --- THE MULTI-TOPOLOGY WIZARD MODAL ---
interface AdvancedAllocationModalProps {
  isOpen: boolean;
  onClose: () => void;
  onSave: (data: AllocationSaveData) => void;
  systems: BsnlSystem[];
  nodes: BsnlNode[];
  cables: BsnlCable[];
}

function AdvancedAllocationModal({ isOpen, onClose, onSave, systems, nodes, cables }: AdvancedAllocationModalProps) {
  const [step, setStep] = useState(1);
  const [selectedSystemId, setSelectedSystemId] = useState('');
  const [topology, setTopology] = useState<AllocationTopology>('p2p-unprotected');
  const [paths, setPaths] = useState<{ working: FiberRoutePath[], protection: FiberRoutePath[], taps: { [key: string]: FiberRoutePath[] } }>({ working: [], protection: [], taps: {} });
  const [error, setError] = useState<string | null>(null);

  const selectedSystem = useMemo(() => systems.find(s => s.id === selectedSystemId), [systems, selectedSystemId]);

  const allAllocatedFibers = useMemo(() => new Set<string>(), [cables, paths]);

  const resetState = () => {
    setStep(1); setSelectedSystemId(''); setTopology('p2p-unprotected'); setPaths({ working: [], protection: [], taps: {} }); setError(null);
  };
  const handleClose = () => { resetState(); onClose(); };
  const handleSave = () => {
    setError(null);
    onSave({ systemId: selectedSystemId, topology, paths });
    handleClose();
  };

  if (!isOpen) return null;

  const renderStep = () => {
    switch (step) {
      case 1:
        return (
          <div className="space-y-6">
            <h3 className="text-lg font-medium text-gray-800 dark:text-gray-200">1. Basic Setup</h3>
            <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
              <div>
                <label className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-1">Select System</label>
                <select value={selectedSystemId} onChange={e => setSelectedSystemId(e.target.value)} className="w-full border border-gray-300 dark:border-gray-600 rounded-md p-2 bg-white dark:bg-gray-700 dark:text-white">
                  <option value="" disabled>Choose a system...</option>
                  {systems.map(s => <option key={s.id} value={s.id!}>{s.system_name}</option>)}
                </select>
              </div>
              <div>
                <label className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-1">Select Allocation Topology</label>
                <select value={topology} onChange={e => setTopology(e.target.value as AllocationTopology)} className="w-full border border-gray-300 dark:border-gray-600 rounded-md p-2 bg-white dark:bg-gray-700 dark:text-white">
                  <option value="p2p-unprotected">Point-to-Point (Unprotected)</option>
                  <option value="p2p-protected">Point-to-Point (Protected)</option>
                  <option value="ring">Protected Ring</option>
                  <option value="tap-spur">Tap / Spur (Point-to-Multipoint)</option>
                </select>
              </div>
            </div>
          </div>
        );
      case 2:
        if (!selectedSystem) {
            return <p className="text-red-500">Please go back and select a system first.</p>;
        }
        return (
          <div className="space-y-6">
            <h3 className="text-lg font-medium text-gray-800 dark:text-gray-200">2. Build Fiber Paths</h3>
             <div className="border rounded-lg border-gray-200 dark:border-gray-600">
                <div className="p-3 bg-gray-50 dark:bg-gray-700/50 border-b border-gray-200 dark:border-gray-600 font-medium text-gray-700 dark:text-gray-300">Working Path</div>
                <div className="p-4">
                  <PathBuilder 
                    path={paths.working} 
                    onPathChange={p => setPaths(c => ({ ...c, working: p }))} 
                    startNodeId={selectedSystem.node_id!} 
                    nodes={nodes} 
                    cables={cables} 
                    allAllocatedFibers={allAllocatedFibers} 
                  />
                </div>
              </div>
          </div>
        );
      default: return null;
    }
  };

  return (
    <div className="fixed inset-0 bg-black bg-opacity-60 flex items-center justify-center z-50 p-4">
      <div className="bg-white dark:bg-gray-800 rounded-lg shadow-xl w-full max-w-4xl max-h-[90vh] flex flex-col">
        <div className="flex justify-between items-center p-4 border-b border-gray-200 dark:border-gray-700">
          <div className="flex items-center">
            <GitBranch className="h-6 w-6 text-green-600 mr-3" />
            <h2 className="text-xl font-semibold text-gray-800 dark:text-white">Allocation Wizard (Step {step}/2)</h2>
          </div>
          <button onClick={handleClose} className="p-1 rounded-full hover:bg-gray-200 dark:hover:bg-gray-700">
            <X className="h-5 w-5 text-gray-500 dark:text-gray-400" />
          </button>
        </div>
        <div className="p-6 overflow-y-auto">
          {renderStep()}
          {error && <p className="mt-4 text-sm text-red-600 text-center animate-pulse">{error}</p>}
        </div>
        <div className="flex justify-between items-center p-4 border-t border-gray-200 dark:border-gray-700 bg-gray-50 dark:bg-gray-900/50">
          <button onClick={handleClose} className="px-4 py-2 text-sm font-medium text-gray-700 bg-white border border-gray-300 rounded-md hover:bg-gray-50 dark:bg-gray-700 dark:text-gray-300 dark:border-gray-600 dark:hover:bg-gray-600">Cancel</button>
          <div className="space-x-3">
            {step > 1 && <button onClick={() => setStep(s => s - 1)} className="px-4 py-2 text-sm font-medium text-gray-700 bg-white border border-gray-300 rounded-md hover:bg-gray-50 dark:bg-gray-700 dark:text-gray-300 dark:border-gray-600 dark:hover:bg-gray-600">Back</button>}
            {step < 2 ? 
              <button onClick={() => setStep(s => s + 1)} disabled={!selectedSystemId} className="px-4 py-2 text-sm font-medium text-white bg-blue-600 rounded-md hover:bg-blue-700 disabled:bg-gray-400 dark:disabled:bg-gray-500">Next</button> : 
              <button onClick={handleSave} className="px-4 py-2 text-sm font-medium text-white bg-green-600 rounded-md hover:bg-green-700">Create Allocation</button>}
          </div>
        </div>
      </div>
    </div>
  );
}

export default AdvancedAllocationModal;
```

<!-- path: components/bsnl/useBsnlDashboardData.ts -->
```typescript
"use client";

import { useMemo } from 'react';
import { useQuery } from '@tanstack/react-query';
import { createClient } from '@/utils/supabase/client';
import { BsnlNode, BsnlCable, BsnlSystem, SearchFilters } from './types';

interface BsnlDashboardData {
  nodes: BsnlNode[];
  ofcCables: BsnlCable[];
  systems: BsnlSystem[];
}

export function useBsnlDashboardData(filters: SearchFilters) {
  const supabase = createClient();

  const queryParams = useMemo(() => ({
    p_query: filters.query || null,
    p_status: filters.status.length > 0 ? filters.status[0] === 'active' : null,
    p_system_types: filters.type.length > 0 ? filters.type : null,
    p_cable_types: filters.type.length > 0 ? filters.type : null,
    p_regions: filters.region.length > 0 ? filters.region : null,
    p_node_types: filters.nodeType.length > 0 ? filters.nodeType : null,
  }), [filters]);

  const { data, isLoading, isError, error, refetch, isFetching } = useQuery<BsnlDashboardData>({
    queryKey: ['bsnl-dashboard-data', queryParams],
    queryFn: async () => {
      const { data: rpcData, error: rpcError } = await supabase.rpc('get_bsnl_dashboard_data', queryParams);

      if (rpcError) {
        throw new Error(`Failed to fetch dashboard data: ${rpcError.message}`);
      }

      // The RPC returns a single JSON object with the keys we defined.
      return rpcData as BsnlDashboardData;
    },
    // Set a longer stale time for this heavy query
    staleTime: 5 * 60 * 1000, // 5 minutes
    // CRITICAL FIX: Keep previous data while fetching new data
    placeholderData: (previousData) => previousData,
    // Alternative for React Query v4 (if you're using older version):
    // keepPreviousData: true,
  });

  return { 
    data: data ?? { nodes: [], ofcCables: [], systems: [] }, 
    isLoading, 
    isError, 
    error, 
    refetchAll: refetch,
    isFetching 
  };
}
```

<!-- path: components/bsnl/PaginatedTable.tsx -->
```typescript
// path: components/bsnl/PaginatedTable.tsx
"use client";

import React, { useState } from 'react';

// Paginated data table component
export function PaginatedTable<T>({
  data,
  columns,
  pageSize = 50,
  onItemClick
}: {
  data: T[];
  columns: { key: string; label: string; render: (item: T) => React.ReactNode }[];
  pageSize?: number;
  onItemClick?: (item: T) => void;
}) {
  const [currentPage, setCurrentPage] = useState(1);

  const totalPages = Math.ceil(data.length / pageSize);
  const startIndex = (currentPage - 1) * pageSize;
  const paginatedData = data.slice(startIndex, startIndex + pageSize);

  // Helper function to generate a unique key for each row
  const getRowKey = (item: T, index: number): string | number => {
    if (typeof item === 'object' && item !== null && 'id' in item && item.id) {
      return item.id as string | number;
    }
    return index;
  };
  
  return (
    <div>
      <div className="overflow-x-auto">
        <table className="min-w-full divide-y divide-gray-200 dark:divide-gray-700">
          <thead className="bg-gray-50 dark:bg-gray-700/50">
            <tr>
              {columns.map((column) => (
                <th
                  key={column.key}
                  className="px-6 py-3 text-left text-xs font-medium text-gray-500 dark:text-gray-400 uppercase tracking-wider"
                >
                  {column.label}
                </th>
              ))}
            </tr>
          </thead>
          <tbody className="bg-white dark:bg-gray-800 divide-y divide-gray-200 dark:divide-gray-700">
            {paginatedData.map((item, index) => (
              <tr
                key={getRowKey(item, index)}
                className="hover:bg-gray-50 dark:hover:bg-gray-700/50 cursor-pointer transition-colors"
                onClick={() => onItemClick?.(item)}
              >
                {columns.map((column) => (
                  <td key={column.key} className="px-6 py-4 whitespace-nowrap text-sm text-gray-700 dark:text-gray-300">
                    {column.render(item)}
                  </td>
                ))}
              </tr>
            ))}
          </tbody>
        </table>
      </div>

      {totalPages > 1 && (
        <div className="flex items-center justify-between mt-4 px-4 py-3 border-t border-gray-200 dark:border-gray-700">
          <div className="text-sm text-gray-700 dark:text-gray-300">
            Showing {startIndex + 1} to {Math.min(startIndex + pageSize, data.length)} of {data.length} results
          </div>
          <div className="flex space-x-2 items-center">
            <button
              onClick={() => setCurrentPage(Math.max(1, currentPage - 1))}
              disabled={currentPage === 1}
              className="px-3 py-1 border border-gray-300 dark:border-gray-600 rounded-md text-sm hover:bg-gray-50 dark:hover:bg-gray-700 disabled:opacity-50 disabled:cursor-not-allowed"
            >
              Previous
            </button>
            <span className="px-3 py-1 text-sm text-gray-600 dark:text-gray-400">
              Page {currentPage} of {totalPages}
            </span>
            <button
              onClick={() => setCurrentPage(Math.min(totalPages, currentPage + 1))}
              disabled={currentPage === totalPages}
              className="px-3 py-1 border border-gray-300 dark:border-gray-600 rounded-md text-sm hover:bg-gray-50 dark:hover:bg-gray-700 disabled:opacity-50 disabled:cursor-not-allowed"
            >
              Next
            </button>
          </div>
        </div>
      )}
    </div>
  );
}
```

<!-- path: components/bsnl/OptimizedNetworkMap.tsx -->
```typescript
// path: components/bsnl/OptimizedNetworkMap.tsx
"use client";

import React, { useMemo, useState, useEffect, memo, useCallback } from 'react';
import { MapContainer, TileLayer, Marker, Popup, Polyline, useMap, TileLayerProps } from 'react-leaflet';
import { LatLngBounds } from 'leaflet';
import { BsnlNode, BsnlCable, BsnlSystem } from './types';
import 'leaflet/dist/leaflet.css';
import L from 'leaflet';
import { Maximize, Minimize } from 'lucide-react';
import { useThemeStore } from '@/stores/themeStore';

// Component to handle map events like pan and zoom
function MapEventHandler({ setBounds, setZoom }: { setBounds: (bounds: LatLngBounds | null) => void; setZoom: (zoom: number) => void; }) {
  const map = useMap();

  useEffect(() => {
    const handler = () => {
      try {
        // Check if map is ready before getting bounds
        if (!map || !map.getBounds || !map.getContainer()) return;
        
        const newBounds = map.getBounds();
        const newZoom = map.getZoom();
        
        // Validate bounds before proceeding
        const sw = newBounds.getSouthWest();
        const ne = newBounds.getNorthEast();
        
        if (!isFinite(sw.lat) || !isFinite(sw.lng) || !isFinite(ne.lat) || !isFinite(ne.lng)) {
          return; // Skip if bounds are invalid
        }
        
        if (!isFinite(newZoom) || newZoom <= 0) {
          return; // Skip if zoom is invalid
        }
        
        // Only update if bounds or zoom actually changed
        setBounds(newBounds);
        
        setZoom(newZoom);
      } catch (error) {
        // Silently ignore errors during map initialization
        console.debug('Map not ready yet:', error);
      }
    };
    
    // This forces the map to re-evaluate its size, crucial for the full-screen toggle
    const invalidateSize = () => setTimeout(() => {
      if (map && map.invalidateSize) {
        map.invalidateSize();
      }
    }, 100);
    
    map.on('zoomend moveend', handler);
    window.addEventListener('resize', invalidateSize);
    
    // Delay initial call to ensure map is ready
    setTimeout(handler, 100);
    
    return () => { 
      map.off('zoomend moveend', handler); 
      window.removeEventListener('resize', invalidateSize);
    };
  }, [map, setBounds, setZoom]);

  return null;
}

// Helper function to validate coordinates
const isValidCoordinate = (lat: number | null | undefined, lng: number | null | undefined): boolean => {
  return lat != null && lng != null && 
         isFinite(lat) && isFinite(lng) && 
         lat >= -90 && lat <= 90 && 
         lng >= -180 && lng <= 180;
};

// Memoized Map Content Component
const MapContent = memo<{
  cables: BsnlCable[];
  visibleLayers: { nodes: boolean; cables: boolean; systems: boolean };
  visibleNodes: BsnlNode[];
  nodeMap: Map<string, BsnlNode>;
  mapUrl: string;
  mapAttribution: string;
  setMapBounds: (bounds: LatLngBounds | null) => void;
  setZoom: (zoom: number) => void;
}>(({ cables, visibleLayers, visibleNodes, nodeMap, mapUrl, mapAttribution, setMapBounds, setZoom }) => (
  <>
    <MapEventHandler setBounds={setMapBounds} setZoom={setZoom} />
    <TileLayer {...({ url: mapUrl, attribution: mapAttribution } as TileLayerProps)} />

    {visibleLayers.cables && cables.map((cable: BsnlCable) => {
        const startNode = nodeMap.get(cable.sn_id!);
        const endNode = nodeMap.get(cable.en_id!);
        if (startNode?.latitude && startNode.longitude && endNode?.latitude && endNode.longitude) {
            return (
                <Polyline
                    key={cable.id}
                    positions={[[startNode.latitude, startNode.longitude], [endNode.latitude, endNode.longitude]]}
                    pathOptions={{ color: cable.status ? '#3b82f6' : '#ef4444', weight: 3, opacity: 0.7 }}
                >
                  <Popup>
                      <div className="min-w-48 max-w-72">
                          <h3 className="font-semibold text-base">{cable.route_name}</h3>
                          <p className="text-sm">Type: {cable.ofc_type_name}</p>
                          <p className="text-sm">Capacity: {cable.capacity}F</p>
                          <p className="text-sm">Status: {cable.status ? 'Active' : 'Inactive'}</p>
                          <p className="text-sm">Owner: {cable.ofc_owner_name}</p>
                      </div>
                  </Popup>
                </Polyline>
            );
        }
        return null;
    })}

    {visibleNodes.map((node: BsnlNode) => (
      (node.latitude && node.longitude) && (
          <Marker key={node.id} position={[node.latitude, node.longitude]}>
              <Popup>
                  <div className="min-w-48 max-w-72">
                      <h3 className="font-semibold text-base">{node.name}</h3>
                      <p className="text-sm">Type: {node.node_type_code}</p>
                      {/* <p className="text-sm">Status: {node.status ? 'Active' : 'Inactive'}</p> */}
                      <p className="text-sm">Region: {node.maintenance_area_name}</p>
                      {node.latitude && <p className="text-sm">Lat: {node.latitude}</p>}
                      {node.longitude && <p className="text-sm">Long: {node.longitude}</p>}
                      {node.remark && <p className="text-sm">Remark: {node.remark}</p>}

                  </div>
              </Popup>
          </Marker>
      )
    ))}
  </>
));

MapContent.displayName = 'MapContent';

export function OptimizedNetworkMap({ nodes, cables, visibleLayers = { nodes: true, cables: true, systems: true } }: { nodes: BsnlNode[]; cables: BsnlCable[]; selectedSystem: BsnlSystem | null; visibleLayers?: { nodes: boolean; cables: boolean; systems: boolean }; }) {
  const [isFullScreen, setIsFullScreen] = useState(false);
  const { theme } = useThemeStore();

  // This one-time effect corrects the default icon path issue with Next.js and Leaflet.
  useEffect(() => {
    // The `_getIconUrl` is a private property not included in the type definitions,
    // so we cast to a record to safely delete it without using `any`.
    delete (L.Icon.Default.prototype as unknown as Record<string, unknown>)._getIconUrl;
    L.Icon.Default.mergeOptions({
        iconRetinaUrl: 'https://unpkg.com/leaflet@1.7.1/dist/images/marker-icon-2x.png',
        iconUrl: 'https://unpkg.com/leaflet@1.7.1/dist/images/marker-icon.png',
        shadowUrl: 'https://unpkg.com/leaflet@1.7.1/dist/images/marker-shadow.png',
    });
  }, []);

  // Handle body overflow when fullscreen
  useEffect(() => {
    if (isFullScreen) {
      document.body.style.overflow = 'hidden';
      return () => {
        document.body.style.overflow = '';
      };
    }
  }, [isFullScreen]);

  const bounds = useMemo(() => {
    if (nodes.length === 0) return null;
    const lats = nodes.map(n => n.latitude ?? 0).filter(lat => lat !== 0 && isFinite(lat));
    const lngs = nodes.map(n => n.longitude ?? 0).filter(lng => lng !== 0 && isFinite(lng));
    if (lats.length === 0 || lngs.length === 0) return null;
    return [[Math.min(...lats), Math.min(...lngs)], [Math.max(...lats), Math.max(...lngs)]] as [[number, number], [number, number]];
  }, [nodes]);

  const [zoom, setZoom] = useState(13);
  const [mapBounds, setMapBounds] = useState<LatLngBounds | null>(null);

  const stableSetBounds = useCallback((bounds: LatLngBounds | null) => {
    setMapBounds(bounds);
  }, []);

  const stableSetZoom = useCallback((zoom: number) => {
    setZoom(zoom);
  }, []);
  const nodeMap = useMemo(() => new Map<string, BsnlNode>(nodes.map(node => [node.id!, node])), [nodes]);

  const visibleNodes = useMemo(() => {
    if (!mapBounds || !visibleLayers.nodes) return [];
    const maxItems = zoom > 14 ? 1000 : zoom > 12 ? 500 : 100;
    return nodes.slice(0, maxItems).filter(node => {
        const lat = node.latitude;
        const lng = node.longitude;
        if (lat == null || lng == null || !isFinite(lat) || !isFinite(lng)) return false;
        return lat >= mapBounds.getSouth() && lat <= mapBounds.getNorth() && lng >= mapBounds.getWest() && lng <= mapBounds.getEast();
    });
  }, [nodes, mapBounds, zoom, visibleLayers.nodes]);
  
  if (!bounds) return <div className="flex items-center justify-center h-full bg-gray-100 dark:bg-gray-700"><p className="text-gray-500 dark:text-gray-300">No location data available to display map.</p></div>;

  const mapUrl = theme === 'dark' 
    ? "https://{s}.basemaps.cartocdn.com/dark_all/{z}/{x}/{y}{r}.png"
    : "https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png";
  
  const mapAttribution = theme === 'dark'
    ? '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors &copy; <a href="https://carto.com/attributions">CARTO</a>'
    : '&copy; OpenStreetMap contributors';

  return (
    <>
      {/* Regular map container */}
      <div className={`relative h-full w-full transition-all duration-300 ${isFullScreen ? 'invisible' : 'visible'}`}>
        <MapContainer key="normal" bounds={bounds} className="h-full w-full rounded-lg bg-gray-200 dark:bg-gray-800">
          <MapContent
            cables={cables}
            visibleLayers={visibleLayers}
            visibleNodes={visibleNodes}
            nodeMap={nodeMap}
            mapUrl={mapUrl}
            mapAttribution={mapAttribution}
            setMapBounds={stableSetBounds}
            setZoom={stableSetZoom}
          />
        </MapContainer>
        
        <button
          onClick={() => setIsFullScreen(true)}
          className="absolute top-4 right-4 z-[1000] p-2 bg-white dark:bg-gray-800 text-gray-700 dark:text-gray-200 rounded-full shadow-lg hover:bg-gray-100 dark:hover:bg-gray-700 transition-colors"
          title="Enter Full Screen"
        >
          <Maximize className="h-5 w-5" />
        </button>
      </div>

      {/* Fullscreen overlay */}
      {isFullScreen && (
        <div className="fixed inset-0 z-[9999] bg-white dark:bg-gray-900">
          <MapContainer key="fullscreen" bounds={bounds} className="h-full w-full bg-gray-200 dark:bg-gray-800">
            <MapContent
              cables={cables}
              visibleLayers={visibleLayers}
              visibleNodes={visibleNodes}
              nodeMap={nodeMap}
              mapUrl={mapUrl}
              mapAttribution={mapAttribution}
              setMapBounds={stableSetBounds}
              setZoom={stableSetZoom}
            />
          </MapContainer>
          
          <button
            onClick={() => setIsFullScreen(false)}
            className="absolute top-4 right-4 z-[10000] p-3 bg-white dark:bg-gray-800 text-gray-700 dark:text-gray-200 rounded-full shadow-lg hover:bg-gray-100 dark:hover:bg-gray-700 transition-colors"
            title="Exit Full Screen"
          >
            <Minimize className="h-6 w-6" />
          </button>
        </div>
      )}
    </>
  );
}
```

<!-- path: components/bsnl/DashboardStatsGrid.tsx -->
```typescript
// path: components/bsnl/DashboardStatsGrid.tsx
"use client";

import React from 'react';
import { Network, Activity, AlertTriangle, CheckCircle, GitBranch, Cable } from 'lucide-react';
import { useDashboardOverview } from './useDashboardOverview';
import { Card } from '@/components/common/ui';

// Stat Card subcomponent for consistent styling
const StatCard: React.FC<{ icon: React.ReactNode; label: string; value: string | number; color: string; }> = ({ icon, label, value, color }) => (
  <Card className={`p-4 border-l-4 ${color} bg-white dark:bg-gray-800 dark:border-l-4`}>
    <div className="flex items-center">
      <div className="p-3 rounded-full bg-gray-100 dark:bg-gray-700 mr-4">
        {icon}
      </div>
      <div>
        <p className="text-sm font-medium text-gray-500 dark:text-gray-400 truncate">{label}</p>
        <p className="text-2xl font-semibold text-gray-900 dark:text-white">{value}</p>
      </div>
    </div>
  </Card>
);

// Skeleton loader for when data is being fetched
const StatsGridSkeleton: React.FC = () => (
  <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4 animate-pulse">
    {Array.from({ length: 6 }).map((_, i) => (
      <div key={i} className="p-4 bg-white dark:bg-gray-800 rounded-lg shadow-sm border border-gray-200 dark:border-gray-700">
        <div className="flex items-center">
          <div className="p-3 rounded-full bg-gray-200 dark:bg-gray-700 mr-4 w-12 h-12"></div>
          <div>
            <div className="h-4 bg-gray-200 dark:bg-gray-700 rounded w-24 mb-2"></div>
            <div className="h-8 bg-gray-300 dark:bg-gray-600 rounded w-16"></div>
          </div>
        </div>
      </div>
    ))}
  </div>
);

export const DashboardStatsGrid: React.FC = () => {
  const { data, isLoading, isError, error } = useDashboardOverview();

  if (isLoading) {
    return <StatsGridSkeleton />;
  }

  if (isError) {
    return (
      <div className="p-4 bg-red-50 dark:bg-red-900/20 text-red-700 dark:text-red-300 border border-red-200 dark:border-red-700 rounded-lg">
        <h4 className="font-semibold">Error Loading Stats</h4>
        <p className="text-sm">{error.message}</p>
      </div>
    );
  }

  if (!data) {
    return (
        <div className="p-4 bg-gray-100 dark:bg-gray-800 text-gray-600 dark:text-gray-400 rounded-lg">
            No overview data available.
        </div>
    );
  }

  const { system_status_counts, node_status_counts, cable_utilization_summary } = data;

  const stats = [
    { icon: <Network className="h-6 w-6 text-blue-500" />, label: 'Active Systems', value: system_status_counts?.Active?.toLocaleString() ?? 0, color: 'border-blue-500' },
    { icon: <Activity className="h-6 w-6 text-green-500" />, label: 'Active Nodes', value: node_status_counts?.Active?.toLocaleString() ?? 0, color: 'border-green-500' },
    { icon: <Cable className="h-6 w-6 text-indigo-500" />, label: 'Total Cables', value: cable_utilization_summary?.total_cables?.toLocaleString() ?? 0, color: 'border-indigo-500' },
    { icon: <AlertTriangle className="h-6 w-6 text-red-500" />, label: 'Inactive Systems', value: system_status_counts?.Inactive?.toLocaleString() ?? 0, color: 'border-red-500' },
    { icon: <GitBranch className="h-6 w-6 text-yellow-500" />, label: 'High Utilization Cables', value: cable_utilization_summary?.high_utilization_count?.toLocaleString() ?? 0, color: 'border-yellow-500' },
    { icon: <CheckCircle className="h-6 w-6 text-purple-500" />, label: 'Avg. Utilization', value: `${(cable_utilization_summary?.average_utilization_percent ?? 0).toFixed(1)}%`, color: 'border-purple-500' },
  ];

  return (
    <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4">
      {stats.map(stat => (
        <StatCard key={stat.label} {...stat} />
      ))}
    </div>
  );
};
```

<!-- path: components/bsnl/AdvancedSearchBar.tsx -->
```typescript
"use client";

import { useState } from 'react';
import { ChevronDown, Filter, Search, ChevronUp } from 'lucide-react'; // Import ChevronUp
import { SearchFilters } from '@/components/bsnl/types';

interface AdvancedSearchBarProps {
  filters: SearchFilters;
  onFiltersChange: (filters: SearchFilters) => void;
  onClear: () => void;
  typeOptions?: string[];
  regionOptions?: string[];
  nodeTypeOptions?: string[];
}

export function AdvancedSearchBar({ 
  filters, 
  onFiltersChange, 
  onClear,
  typeOptions = [],
  regionOptions = [],
  nodeTypeOptions = [],
}: AdvancedSearchBarProps) {
  const [showFilters, setShowFilters] = useState(false);

  return (
    <div className="bg-white dark:bg-gray-800 rounded-lg border border-gray-200 dark:border-gray-700 p-4 mb-6 shadow-sm">
      <div className="flex flex-col sm:flex-row items-center space-y-3 sm:space-y-0 sm:space-x-4">
        <div className="flex-1 relative w-full">
          <Search className="absolute left-3 top-1/2 transform -translate-y-1/2 text-gray-400 h-4 w-4" />
          <input
            type="text"
            placeholder="Search by name, asset no, etc..."
            value={filters.query}
            onChange={(e) => onFiltersChange({ ...filters, query: e.target.value })}
            className="w-full pl-10 pr-4 py-2 border border-gray-300 dark:border-gray-600 rounded-md focus:ring-2 focus:ring-blue-500 dark:focus:ring-blue-400 focus:border-transparent dark:bg-gray-700 dark:text-white"
          />
        </div>

        <div className="flex items-center space-x-2 w-full sm:w-auto">
          <button
            onClick={() => setShowFilters(!showFilters)}
            className="flex-1 sm:flex-none flex items-center justify-center px-4 py-2 border border-gray-300 dark:border-gray-600 rounded-md hover:bg-gray-50 dark:hover:bg-gray-700 text-gray-700 dark:text-gray-300"
          >
            <Filter className="h-4 w-4 mr-2" />
            Filters
            {showFilters ? <ChevronUp className="h-4 w-4 ml-1" /> : <ChevronDown className="h-4 w-4 ml-1" />}
          </button>
          <button onClick={onClear} className="flex-1 sm:flex-none px-4 py-2 text-gray-600 dark:text-gray-400 hover:text-gray-800 dark:hover:text-white rounded-md hover:bg-gray-100 dark:hover:bg-gray-700">
            Clear
          </button>
        </div>
      </div>

      {showFilters && (
        <div className="mt-4 pt-4 border-t border-gray-200 dark:border-gray-700 grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-4">
          <div>
            <label className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-1">Status</label>
            <select
              value={filters.status?.[0] || ''}
              onChange={(e) => onFiltersChange({ ...filters, status: e.target.value ? [e.target.value] : [] })}
              className="w-full border border-gray-300 dark:border-gray-600 rounded-md p-2 text-sm bg-white dark:bg-gray-700 dark:text-white"
            >
              <option value="">All</option>
              <option value="active">Active</option>
              <option value="inactive">Inactive</option>
            </select>
          </div>
          <div>
            <label className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-1">System/Cable Type</label>
            <select
              value={filters.type?.[0] || ''}
              onChange={(e) => onFiltersChange({ ...filters, type: e.target.value ? [e.target.value] : [] })}
              className="w-full border border-gray-300 dark:border-gray-600 rounded-md p-2 text-sm bg-white dark:bg-gray-700 dark:text-white"
            >
              <option value="">All Types</option>
              {/*  Added key prop */}
              {typeOptions.map(opt => <option key={opt} value={opt}>{opt}</option>)}
            </select>
          </div>
          <div>
            <label className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-1">Region</label>
            <select
              value={filters.region?.[0] || ''}
              onChange={(e) => onFiltersChange({ ...filters, region: e.target.value ? [e.target.value] : [] })}
              className="w-full border border-gray-300 dark:border-gray-600 rounded-md p-2 text-sm bg-white dark:bg-gray-700 dark:text-white"
            >
              <option value="">All Regions</option>
              {/*  Added key prop */}
              {regionOptions.map(opt => <option key={opt} value={opt}>{opt}</option>)}
            </select>
          </div>
          <div>
            <label className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-1">Node Type</label>
            <select
              value={filters.nodeType?.[0] || ''}
              onChange={(e) => onFiltersChange({ ...filters, nodeType: e.target.value ? [e.target.value] : [] })}
              className="w-full border border-gray-300 dark:border-gray-600 rounded-md p-2 text-sm bg-white dark:bg-gray-700 dark:text-white"
            >
              <option value="">All Node Types</option>
              {/*  Added key prop */}
              {nodeTypeOptions.map(opt => <option key={opt} value={opt}>{opt}</option>)}
            </select>
          </div>
        </div>
      )}
    </div>
  );
}
```

<!-- path: components/systems/CreatePathModal.tsx -->
```typescript
"use client";

import { useForm, Controller } from "react-hook-form";
import { zodResolver } from "@hookform/resolvers/zod";
import { logical_fiber_pathsInsertSchema } from "@/schemas/zod-schemas";
import { z } from "zod";
import { useTableInsert, useTableQuery } from "@/hooks/database";
import { createClient } from "@/utils/supabase/client";
import { Modal } from "../common/ui/Modal";
import { Button } from "../common/ui/Button";
import { Input } from "../common/ui/Input";
import { SearchableSelect } from "../common/ui/select/SearchableSelect";
import { toast } from "sonner";
import { Row } from "@/hooks/database";

interface Props {
  isOpen: boolean;
  onClose: () => void;
  system: Row<'systems'>;
  onPathCreated: () => void;
}

const createPathFormSchema = logical_fiber_pathsInsertSchema.pick({
  path_name: true,
  path_type_id: true,
  destination_system_id: true,
  remark: true,
});
type CreatePathForm = z.infer<typeof createPathFormSchema>;

export function CreatePathModal({ isOpen, onClose, system, onPathCreated }: Props) {
  const supabase = createClient();
  const { control, handleSubmit, register, formState: { errors, isSubmitting } } = useForm<CreatePathForm>({
    resolver: zodResolver(createPathFormSchema),
  });

  const { data: fetchedPathTypes } = useTableQuery(supabase, 'lookup_types', { filters: { category: 'OFC_PATH_TYPES'} });
  const pathTypes = fetchedPathTypes?.filter(pt => pt.name !== "DEFAULT");
  const { data: systems } = useTableQuery(supabase, 'systems', { filters: { id: { operator: 'neq', value: system.id } } });

  const { mutate: createPath } = useTableInsert(supabase, 'logical_fiber_paths', {
    onSuccess: () => {
      toast.success("Logical path created successfully.");
      onPathCreated();
      onClose();
    },
    onError: (err) => toast.error(`Failed to create path: ${err.message}`),
  });

  const onSubmit = (formData: CreatePathForm) => {
    createPath({
      ...formData,
      source_system_id: system.id,
    });
  };

  return (
    <Modal isOpen={isOpen} onClose={onClose} title="Create New Logical Path" visible={false} className="h-screen w-screen transparent bg-gray-700 rounded-2xl">
      <form onSubmit={handleSubmit(onSubmit)} className="space-y-4">
        <div>
          <label className="block text-sm font-medium mb-1">Path Name*</label>
          <Input {...register("path_name")} placeholder="e.g., Primary Ring to Site B" />
          {errors.path_name && <p className="text-red-500 text-xs mt-1">{errors.path_name.message}</p>}
        </div>

        <Controller
          name="path_type_id"
          control={control}
          render={({ field }) => (
            <SearchableSelect
              label="Path Type"
              options={pathTypes?.map(pt => ({ value: pt.id, label: pt.name })) || []}
              value={field.value || ""}
              onChange={val => field.onChange(val)}
              placeholder="Select path type..."
            />
          )}
        />
        
        <Controller
          name="destination_system_id"
          control={control}
          render={({ field }) => (
            <SearchableSelect
              label="Destination System"
              options={systems?.map(s => ({ value: s.id, label: s.system_name || s.id })) || []}
              value={field.value || ""}
              onChange={val => field.onChange(val)}
              placeholder="Select destination system..."
            />
          )}
        />
        
        <div>
          <label className="block text-sm font-medium mb-1">Remarks</label>
          <textarea {...register("remark")} className="w-full rounded-md border-gray-300 dark:bg-gray-700" rows={3} />
        </div>

        <div className="flex justify-end gap-2 pt-4">
          <Button type="button" variant="outline" onClick={onClose} disabled={isSubmitting}>Cancel</Button>
          <Button type="submit" disabled={isSubmitting}>
            {isSubmitting ? "Creating..." : "Create Path"}
          </Button>
        </div>
      </form>
    </Modal>
  );
}
```

<!-- path: components/systems/PathSegmentList.tsx -->
```typescript
"use client";

import { Row } from "@/hooks/database";
import { DndContext, closestCenter, PointerSensor, useSensor, useSensors, DragEndEvent } from '@dnd-kit/core';
import { SortableContext, useSortable, verticalListSortingStrategy } from '@dnd-kit/sortable';
import { CSS } from '@dnd-kit/utilities';
import { Button } from "../common/ui/Button";
import { FiTrash2, FiMove } from "react-icons/fi";

interface SortableItemProps {
    segment: Row<'v_system_ring_paths_detailed'>;
    onDelete: () => void;
}

function SortableSegmentItem({ segment, onDelete }: SortableItemProps) {
    const { attributes, listeners, setNodeRef, transform, transition } = useSortable({ id: segment.id || '' });
    const style = { transform: CSS.Transform.toString(transform), transition };

    return (
        <li ref={setNodeRef} style={style} className="mb-6 ml-6 flex items-center gap-4">
             <span className="absolute flex items-center justify-center w-8 h-8 bg-blue-100 rounded-full -left-4 ring-8 ring-white dark:ring-gray-800 dark:bg-blue-900">
                {segment.path_order}
            </span>
            <div className="flex-1 p-3 bg-gray-50 dark:bg-gray-700 rounded-lg border dark:border-gray-600">
                <h4 className="font-semibold text-gray-900 dark:text-white">{segment.route_name}</h4>
                <p className="text-sm text-gray-500 dark:text-gray-400">
                    {segment.start_node_name} → {segment.end_node_name}
                </p>
            </div>
            <div className="flex items-center gap-2">
                <Button variant="ghost" size="sm" onClick={onDelete} className="text-red-500 hover:bg-red-100 dark:hover:bg-red-900/50">
                    <FiTrash2 />
                </Button>
                <Button variant="ghost" size="sm" {...attributes} {...listeners} className="cursor-grab active:cursor-grabbing">
                    <FiMove />
                </Button>
            </div>
        </li>
    );
}

interface ListProps {
    segments: Row<'v_system_ring_paths_detailed'>[];
    onDragEnd: (event: DragEndEvent) => void;
    onDelete: (id: string) => void;
}

export function PathSegmentList({ segments, onDragEnd, onDelete }: ListProps) {
    const sensors = useSensors(useSensor(PointerSensor, {
      activationConstraint: {
        distance: 8,
      },
    }));

    return (
        <DndContext sensors={sensors} collisionDetection={closestCenter} onDragEnd={onDragEnd}>
            <SortableContext items={segments.map(s => s.id || '')} strategy={verticalListSortingStrategy}>
                <ol className="relative border-l border-gray-200 dark:border-gray-700 ml-4">
                    {segments.map(segment => (
                        <SortableSegmentItem
                            key={segment.id}
                            segment={segment}
                            onDelete={() => onDelete(segment.id || '')}
                        />
                    ))}
                </ol>
            </SortableContext>
        </DndContext>
    );
}
```

<!-- path: components/systems/SystemRingPath.tsx -->
```typescript
// path: components/systems/SystemRingPath.tsx
"use client";

import { useState, useMemo, useCallback } from "react";
import { createClient } from "@/utils/supabase/client";
import { useTableQuery, useTableInsert, Row, useRpcQuery } from "@/hooks/database";
import { Button, PageSpinner, SearchableSelect } from "@/components/common/ui";
import { FiPlus, FiZap, FiCheckCircle, FiXCircle, FiAlertTriangle } from "react-icons/fi";
import { useSystemPath } from "@/hooks/database/path-queries";
import { useDeletePathSegment, useReorderPathSegments } from "@/hooks/database/path-mutations";
import { DragEndEvent } from "@dnd-kit/core";
import { CreatePathModal } from "./CreatePathModal";
import { PathSegmentList } from "./PathSegmentList";
import { FiberProvisioning } from "./FiberProvisioning";
import ClientRingMap from "@/components/map/ClientRingMap";
import { toast } from "sonner";
import { SystemsRowSchema, NodesRowSchema, V_nodes_completeRowSchema } from "@/schemas/zod-schemas";
import { Option } from "../common/ui/select/SearchableSelect";
import { MapNode } from "@/components/map/types/node";
import { Edit, Eye } from "lucide-react";

// ... (PathValidationResult and PathStatusIndicator components remain the same)
interface PathValidationResult {
  status: 'empty' | 'broken' | 'valid_ring' | 'open_path';
  message: string;
}

const PathStatusIndicator = ({ status, message }: PathValidationResult) => {
  const config = useMemo(() => {
    switch (status) {
      case 'valid_ring': return { icon: FiCheckCircle, color: 'text-green-500', bgColor: 'bg-green-50 dark:bg-green-900/20' };
      case 'open_path': return { icon: FiCheckCircle, color: 'text-blue-500', bgColor: 'bg-blue-50 dark:bg-blue-900/20' };
      case 'broken': return { icon: FiXCircle, color: 'text-red-500', bgColor: 'bg-red-50 dark:bg-red-900/20' };
      default: return { icon: FiAlertTriangle, color: 'text-yellow-500', bgColor: 'bg-yellow-50 dark:bg-yellow-900/20' };
    }
  }, [status]);
  const Icon = config.icon;
  return (
    <div className={`p-3 rounded-lg flex items-center gap-3 border ${config.bgColor} border-current`}>
      <Icon className={`w-6 h-6 flex-shrink-0 ${config.color}`} />
      <div>
        <p className={`font-semibold ${config.color}`}>{status.replace(/_/g, ' ').toUpperCase()}</p>
        <p className="text-sm text-gray-600 dark:text-gray-300">{message}</p>
      </div>
    </div>
  );
};


interface Props {
  system: SystemsRowSchema & { node: NodesRowSchema | null };
}

type BuilderMode = 'view' | 'build';

export function SystemRingPath({ system }: Props) {
  const supabase = createClient();
  const [isCreatePathModalOpen, setIsCreatePathModalOpen] = useState(false);
  const [flyToCoords, setFlyToCoords] = useState<[number, number] | null>(null);
  const [mode, setMode] = useState<BuilderMode>('view');

  const { data: logicalPathData, refetch: refetchLogicalPath, isLoading: isLoadingPath } = useTableQuery(supabase, 'logical_fiber_paths', { filters: { source_system_id: system.id }, limit: 1 });
  const path = logicalPathData?.[0];
  const { data: pathSegments = [], isLoading: isLoadingSegments, refetch: refetchSegments } = useSystemPath(path?.id || null);
  const { data: validationResult, isLoading: isValidating } = useRpcQuery<"validate_ring_path", PathValidationResult>(supabase, 'validate_ring_path', { p_path_id: path?.id! }, { enabled: !!path?.id && pathSegments.length > 0 });
  const { data: nodesInArea = [], isLoading: isLoadingNodes } = useTableQuery(supabase, 'v_nodes_complete', { filters: { maintenance_terminal_id: system.maintenance_terminal_id! }, enabled: !!system.maintenance_terminal_id });
  
  const pathNodeIdsToFetch = useMemo(() => {
    if (!pathSegments || pathSegments.length === 0) return [];
    const ids = new Set(pathSegments.flatMap(s => [s.start_node_id, s.end_node_id]));
    return Array.from(ids).filter((id): id is string => id !== null);
  }, [pathSegments]);

  const { data: pathNodesData, isLoading: isLoadingPathNodes } = useTableQuery(supabase, 'v_nodes_complete', { filters: { id: { operator: 'in', value: pathNodeIdsToFetch } }, enabled: pathNodeIdsToFetch.length > 0 });

  const deleteSegmentMutation = useDeletePathSegment();
  const reorderSegmentsMutation = useReorderPathSegments();
  const { mutate: addSegment } = useTableInsert(supabase, 'logical_path_segments', {
    onSuccess: () => { toast.success("Segment added!"); refetchSegments(); },
    onError: (err) => toast.error(`Failed to add segment: ${err.message}`),
  });

  const pathNodeIds = useMemo((): string[] => {
    if (!pathSegments || pathSegments.length === 0) return system.node_id ? [system.node_id] : [];
    const ids = [pathSegments[0].start_node_id, ...pathSegments.map(s => s.end_node_id)];
    return [...new Set(ids)].filter((id): id is string => id !== null);
  }, [pathSegments, system.node_id]);

  const lastNodeInPathId = useMemo(() => (pathSegments?.length > 0) ? pathSegments[pathSegments.length - 1].end_node_id : system.node_id, [pathSegments, system.node_id]);
  
  const mapNodes = useMemo((): MapNode[] => {
    const allNodes = new Map<string, V_nodes_completeRowSchema>();
    (nodesInArea || []).forEach(node => { if(node.id) allNodes.set(node.id, node) });
    (pathNodesData || []).forEach(node => { if(node.id) allNodes.set(node.id, node) });
    return Array.from(allNodes.values())
      .filter(node => node.latitude != null && node.longitude != null)
      .map(node => ({ id: node.id!, name: node.name!, lat: node.latitude!, long: node.longitude!, type: node.node_type_name, status: node.status, remark: node.remark, ip: null }));
  }, [nodesInArea, pathNodesData]);
  
  const nodeOptionsForSearch = useMemo((): Option[] => mapNodes.map(n => ({ value: n.id, label: n.name })), [mapNodes]);

  const handleNodeClick = useCallback(async (clickedNodeId: string) => {
    if (mode !== 'build') {
      toast.info("Switch to 'Build Mode' to add segments.");
      return;
    }
    if (!path || !lastNodeInPathId || clickedNodeId === lastNodeInPathId) return;
    if (clickedNodeId === system.node_id && pathSegments.length > 0) {
      toast.info("Attempting to close the loop...");
    }
    try {
      const { data: cable, error } = await supabase.rpc('find_cable_between_nodes', { p_node1_id: lastNodeInPathId, p_node2_id: clickedNodeId });
      if (error) throw new Error(`Could not find cable: ${error.message}`);
      if (!cable || (Array.isArray(cable) && cable.length === 0)) {
        toast.warning("No direct cable route found between the selected nodes.");
        return;
      }
      const foundCable = Array.isArray(cable) ? cable[0] : cable;
      addSegment({ logical_path_id: path.id, ofc_cable_id: (foundCable as { id: string }).id, path_order: (pathSegments?.length || 0) + 1 });
    } catch (err) {
      toast.error(err instanceof Error ? err.message : "An unknown error occurred");
    }
  }, [path, lastNodeInPathId, pathSegments, addSegment, supabase, mode, system.node_id]);

  const handleNodeSearchSelect = (nodeId: string | null) => {
    const node = mapNodes.find(n => n.id === nodeId);
    if (node) {
      setFlyToCoords([node.lat, node.long]);
    }
  };
  
  const handleDragEnd = (event: DragEndEvent) => {
    const { active, over } = event;
    if (over && active.id !== over.id && pathSegments && path) {
      const oldIndex = pathSegments.findIndex(s => s.id === active.id);
      const newIndex = pathSegments.findIndex(s => s.id === over.id);
      const reorderedSegments = Array.from(pathSegments);
      const [movedItem] = reorderedSegments.splice(oldIndex, 1);
      reorderedSegments.splice(newIndex, 0, movedItem);
      const newSegmentIds = reorderedSegments.map(s => s.id).filter((id): id is string => !!id);
      reorderSegmentsMutation.mutate({ pathId: path.id, segmentIds: newSegmentIds });
    }
  };

  const handleDeleteSegment = (segmentId: string) => {
    if (window.confirm("Are you sure you want to remove this segment from the path?") && path) {
      deleteSegmentMutation.mutate({ segmentId, pathId: path.id });
    }
  };

  if (isLoadingPath || isLoadingNodes || isLoadingPathNodes) return <PageSpinner text="Loading path builder..." />;

  const shouldShowProvisioning = path && pathSegments && pathSegments.length > 0 && validationResult && (validationResult.status === 'valid_ring' || validationResult.status === 'open_path');

  return (
    <div className="space-y-6">
      <div className="bg-white dark:bg-gray-800 rounded-lg shadow-md border dark:border-gray-700">
        <div className="p-4 border-b dark:border-gray-700 flex flex-wrap gap-4 justify-between items-center">
          <h3 className="text-xl font-semibold">Ring Path Builder</h3>
          {!path ? (
            <Button onClick={() => setIsCreatePathModalOpen(true)}>Initialize Path</Button>
          ) : (
            <div className="flex items-center gap-2 p-1 bg-gray-100 dark:bg-gray-700 rounded-lg">
              <Button size="sm" variant={mode === 'view' ? 'primary' : 'ghost'} onClick={() => setMode('view')} leftIcon={<Eye />}>View Mode</Button>
              <Button size="sm" variant={mode === 'build' ? 'primary' : 'ghost'} onClick={() => setMode('build')} leftIcon={<Edit />}>Build Mode</Button>
            </div>
          )}
        </div>
        
        {path ? (
          <div className="grid grid-cols-1 lg:grid-cols-2 gap-6 p-4">
            {/* --- LEFT COLUMN: MAP & SEARCH --- */}
            <div className="space-y-4 flex flex-col">
              <SearchableSelect options={nodeOptionsForSearch} onChange={handleNodeSearchSelect} placeholder="Search and fly to a node..." clearable />
              <div className="flex-grow min-h-[500px] rounded-lg overflow-hidden border dark:border-gray-700">
                <ClientRingMap
                  nodes={mapNodes}
                  solidLines={pathSegments?.map((seg) => {
                    const start = mapNodes.find(n => n.id === seg.start_node_id);
                    const end = mapNodes.find(n => n.id === seg.end_node_id);
                    return (start && end) ? [start, end] : null;
                  }).filter((p): p is [MapNode, MapNode] => p !== null)}
                  highlightedNodeIds={pathNodeIds}
                  onNodeClick={handleNodeClick}
                  flyToCoordinates={flyToCoords}
                  showControls={false}
                />
              </div>
            </div>

            {/* --- RIGHT COLUMN: STATUS, SEGMENTS, PROVISIONING --- */}
            <div className="space-y-6 flex flex-col">
              <div className="flex-shrink-0">
                {isValidating && <p className="text-sm text-gray-500">Validating path...</p>}
                {validationResult && typeof validationResult === 'object' && <PathStatusIndicator {...validationResult} />}
              </div>
              <div className="flex-grow overflow-y-auto pr-2 max-h-[calc(100vh-450px)]">
                {isLoadingSegments ? <PageSpinner text="Loading path segments..." /> : (!pathSegments || pathSegments.length === 0) ? (
                  <div className="text-center py-16">
                    <p className="text-gray-500">Switch to 'Build Mode' and click a node on the map to start.</p>
                    <p className="text-sm text-gray-400 mt-2">Path starts at: <span className="font-semibold">{system.node?.name}</span></p>
                  </div>
                ) : (
                  <PathSegmentList segments={pathSegments} onDragEnd={handleDragEnd} onDelete={handleDeleteSegment} />
                )}
              </div>
              {shouldShowProvisioning && (
                <div className="flex-shrink-0 pt-4 border-t dark:border-gray-700">
                  <FiberProvisioning
                    path={path}
                    pathName={path.path_name ?? ""}
                    systemId={system.id}
                    physicalPathId={path.id}
                    validationStatus={validationResult.status}
                  />
                </div>
              )}
            </div>
          </div>
        ) : (
          <div className="p-8 text-center text-gray-500">
            Click "Initialize Path" to begin building the ring topology.
          </div>
        )}
      </div>

      {isCreatePathModalOpen && <CreatePathModal isOpen={isCreatePathModalOpen} onClose={() => setIsCreatePathModalOpen(false)} system={system} onPathCreated={refetchLogicalPath} />}
    </div>
  );
}
```

<!-- path: components/systems/AddSegmentModal.tsx -->
```typescript
"use client";

import { Modal } from "../common/ui/Modal";
import { useState} from "react";
import { Button } from "../common/ui/Button";
import { useTableInsert, useTableQuery } from "@/hooks/database";
import { createClient } from "@/utils/supabase/client";
import { toast } from "sonner";
import { Row } from "@/hooks/database";

interface Props {
  isOpen: boolean;
  onClose: () => void;
  logicalPathId: string;
  currentSegments: Row<'v_system_ring_paths_detailed'>[];
  onSegmentAdded: () => void;
}

export function AddSegmentModal({ isOpen, onClose, logicalPathId, currentSegments, onSegmentAdded }: Props) {
  const [selectedCableId, setSelectedCableId] = useState<string | null>(null);
  const supabase = createClient();
  
  const lastSegment = currentSegments.length > 0 ? currentSegments[currentSegments.length - 1] : null;
  const nextNodeId = lastSegment ? lastSegment.end_node_id : null;

  const { data: availableCables, isLoading } = useTableQuery(supabase, 'ofc_cables', {
      columns: 'id, route_name, sn:sn_id(name), en:en_id(name)',
      filters: nextNodeId ? { or: `(sn_id.eq.${nextNodeId},en_id.eq.${nextNodeId})` } : {},
      enabled: !!nextNodeId
  });

  const { mutate: addSegment, isPending } = useTableInsert(supabase, 'logical_path_segments', {
    onSuccess: () => {
        toast.success("Segment added to path!");
        onSegmentAdded();
    },
    onError: (err) => toast.error(`Failed to add segment: ${err.message}`)
  });

  const handleAdd = () => {
    if (!selectedCableId) {
        toast.error("Please select a cable segment.");
        return;
    }
    addSegment({
        logical_path_id: logicalPathId,
        ofc_cable_id: selectedCableId,
        path_order: (currentSegments.length || 0) + 1,
    });
  };

  return (
    <Modal isOpen={isOpen} onClose={onClose} title="Add Next Path Segment">
      <div className="space-y-4">
        <label htmlFor="cable-select" className="block text-sm font-medium text-gray-700 dark:text-gray-300">
          Available Cables from {lastSegment?.end_node_name || "Start Node"}
        </label>
        {isLoading && <p>Loading available cables...</p>}
        {!isLoading && (!availableCables || availableCables.length === 0) && (
            <p className="text-gray-500">No further connecting cables found.</p>
        )}
        {availableCables && availableCables.length > 0 && (
            <select
                id="cable-select"
                className="w-full rounded-md border-gray-300 dark:bg-gray-700 dark:border-gray-600 dark:text-white"
                value={selectedCableId || ""}
                onChange={(e) => setSelectedCableId(e.target.value)}
            >
                <option value="" disabled>Select a cable...</option>
                {availableCables?.map((cable) => (
                    <option key={cable.id} value={cable.id}>
                        {cable.route_name}
                    </option>
                ))}
            </select>
        )}
        <div className="flex justify-end gap-2 pt-4">
            <Button variant="outline" onClick={onClose} disabled={isPending}>Cancel</Button>
            <Button onClick={handleAdd} disabled={isPending || !selectedCableId}>
                {isPending ? "Adding..." : "Add to Path"}
            </Button>
        </div>
      </div>
    </Modal>
  );
}
```

<!-- path: components/systems/SystemModal.tsx -->
```typescript
// path: components/systems/SystemModal.tsx

'use client';

import { FC, useCallback, useEffect, useMemo, useState } from 'react';
import { toast } from 'sonner';
import { useTableQuery } from '@/hooks/database';
import { useRpcMutation } from '@/hooks/database/rpc-queries';
import type { RpcFunctionArgs } from '@/hooks/database/queries-type-helpers';
import { createClient } from '@/utils/supabase/client';
import { useForm, FieldErrors } from 'react-hook-form'; // Import FieldErrors
import { zodResolver } from '@hookform/resolvers/zod';
import { Button, Modal } from '@/components/common/ui';
import { FormCard, FormDateInput, FormInput, FormIPAddressInput, FormSearchableSelect, FormSwitch, FormTextarea } from '@/components/common/form';
import { V_systems_completeRowSchema } from '@/schemas/zod-schemas';
import { systemFormValidationSchema, SystemFormData } from '@/schemas/system-schemas';
import { AnimatePresence, motion } from 'framer-motion';

type SystemFormValues = SystemFormData;

const createDefaultFormValues = (): SystemFormValues => ({
  system_name: '',
  system_type_id: '',
  node_id: '',
  maintenance_terminal_id: null,
  ip_address: '',
  commissioned_on: null,
  remark: '',
  s_no: '',
  status: true,
  ring_id: null,
  gne: '',
  make: '',
  vm_id: '',
});

interface SystemModalProps {
  isOpen: boolean;
  onClose: () => void;
  rowData: V_systems_completeRowSchema | null;
  refetch: () => void;
}

export const SystemModal: FC<SystemModalProps> = ({ isOpen, onClose, rowData, refetch }) => {
  const supabase = createClient();
  const isEditMode = !!rowData;
  const [step, setStep] = useState(1);

  const { data: systemTypes = [] } = useTableQuery(supabase, 'lookup_types', { columns: 'id, name, category', filters: { category: 'SYSTEM_TYPES' } });
  const { data: nodes = [] } = useTableQuery(supabase, 'nodes', { columns: 'id, name, maintenance_terminal_id' });
  const { data: maintenanceTerminals = [] } = useTableQuery(supabase, 'maintenance_areas', { columns: 'id, name' });
  const { data: rings = [] } = useTableQuery(supabase, 'rings', { columns: 'id, name' });

  const systemTypeOptions = useMemo(() => systemTypes.map(st => ({ value: st.id, label: st.name })), [systemTypes]);
  const nodeOptions = useMemo(() => nodes.map(n => ({ value: n.id, label: n.name })), [nodes]);
  const maintenanceTerminalOptions = useMemo(() => maintenanceTerminals.map(mt => ({ value: mt.id, label: mt.name })), [maintenanceTerminals]);
  const ringOptions = useMemo(() => rings.map(r => ({ value: r.id, label: r.name })), [rings]);

  const {
    register,
    handleSubmit,
    formState: { errors, isSubmitting },
    reset,
    control,
    watch,
    setValue,
    trigger,
  } = useForm<SystemFormValues>({
    resolver: zodResolver(systemFormValidationSchema),
    defaultValues: createDefaultFormValues(),
    mode: 'onChange'
  });

  const selectedSystemTypeId = watch('system_type_id');
  const selectedNodeId = watch('node_id');

  const selectedSystemType = useMemo(() => systemTypes.find(st => st.id === selectedSystemTypeId), [systemTypes, selectedSystemTypeId]);

  const isRingBasedSystem = useMemo(() => selectedSystemType?.category?.includes('RING_BASED'), [selectedSystemType]);
  const isSdhSystem = useMemo(() => selectedSystemType?.name.includes('SDH'), [selectedSystemType]);
  const isVmuxSystem = useMemo(() => selectedSystemType?.name === 'VMUX', [selectedSystemType]);
  const needsStep2 = isRingBasedSystem || isSdhSystem || isVmuxSystem;

  const handleClose = useCallback(() => {
    onClose();
    setTimeout(() => {
        reset(createDefaultFormValues());
        setStep(1);
    }, 200);
  }, [onClose, reset]);

  useEffect(() => {
    if (isOpen) {
        if (isEditMode && rowData) {
            reset({
                system_name: rowData.system_name || '',
                system_type_id: rowData.system_type_id || '',
                node_id: rowData.node_id || '',
                maintenance_terminal_id: rowData.maintenance_terminal_id,
                ip_address: (rowData.ip_address as string) || '',
                commissioned_on: rowData.commissioned_on || null,
                remark: rowData.remark || '',
                s_no: rowData.s_no || '',
                status: rowData.status ?? true,
                ring_id: rowData.ring_id,
                gne: rowData.sdh_gne,
                make: rowData.make,
                vm_id: rowData.vmux_vm_id,
            });
        } else {
            reset(createDefaultFormValues());
        }
    }
  }, [isOpen, isEditMode, rowData, reset]);

  useEffect(() => {
    if (selectedNodeId) {
      const matchedNode = nodes.find((node) => node.id === selectedNodeId);
      if (matchedNode?.maintenance_terminal_id) {
        setValue('maintenance_terminal_id', matchedNode.maintenance_terminal_id);
      }
    }
  }, [selectedNodeId, nodes, setValue]);

  const upsertSystemMutation = useRpcMutation(supabase, 'upsert_system_with_details', {
    onSuccess: () => {
      toast.success(`System ${isEditMode ? 'updated' : 'created'} successfully.`);
      refetch();
      handleClose();
    },
    onError: (err) => toast.error(`Failed to save system: ${err.message}`),
  });

  const onValidSubmit = useCallback((formData: SystemFormValues) => {
    const payload: RpcFunctionArgs<'upsert_system_with_details'> = {
        p_system_name: formData.system_name!,
        p_system_type_id: formData.system_type_id!,
        p_node_id: formData.node_id!,
        p_status: formData.status ?? true,
        p_ip_address: formData.ip_address || undefined,
        p_maintenance_terminal_id: formData.maintenance_terminal_id || undefined,
        p_commissioned_on: formData.commissioned_on ? formData.commissioned_on : undefined,
        p_s_no: formData.s_no || undefined,
        p_remark: formData.remark || undefined,
        p_id: isEditMode ? rowData!.id! : undefined,
        p_ring_id: isRingBasedSystem ? (formData.ring_id || undefined) : undefined,
        p_gne: isSdhSystem ? (formData.gne || undefined) : undefined,
        p_make: formData.make || undefined,
        p_vm_id: isVmuxSystem ? (formData.vm_id || undefined) : undefined,
    };
    upsertSystemMutation.mutate(payload);
  }, [isEditMode, rowData, upsertSystemMutation, isRingBasedSystem, isSdhSystem, isVmuxSystem]);
  
  // ** Create the onInvalid handler.**
  const onInvalidSubmit = (errors: FieldErrors<SystemFormValues>) => {
    toast.error("Validation failed. Please check required fields on all steps.");
    // If the error is not in the current step, switch to step 1 to show it.
    const step1Fields: (keyof SystemFormValues)[] = ['system_name', 'system_type_id', 'node_id'];
    const hasErrorInStep1 = Object.keys(errors).some(key => step1Fields.includes(key as keyof SystemFormValues));
    if (hasErrorInStep1 && step !== 1) {
        setStep(1);
    }
  };

  const handleNext = async () => {
    const fieldsToValidate: (keyof SystemFormValues)[] = ['system_name', 'system_type_id', 'node_id'];
    const isValid = await trigger(fieldsToValidate);
    if (isValid) {
      if (needsStep2) {
        setStep(2);
      } else {
        handleSubmit(onValidSubmit, onInvalidSubmit)();
      }
    } else {
      toast.error("Please fill in all required fields to continue.");
    }
  };

  const renderFooter = () => (
    <div className="flex justify-end gap-2">
      {step > 1 && (
        <Button type="button" variant="outline" onClick={() => setStep(1)} disabled={isSubmitting || upsertSystemMutation.isPending}>
          Back
        </Button>
      )}
      <Button type="button" variant="secondary" onClick={handleClose} disabled={isSubmitting || upsertSystemMutation.isPending}>
        Cancel
      </Button>
      {step === 1 ? (
        <Button type="button" onClick={handleNext} disabled={isSubmitting}>
          {needsStep2 ? 'Next' : (isEditMode ? 'Update System' : 'Create System')}
        </Button>
      ) : (
        <Button type="submit" disabled={isSubmitting || upsertSystemMutation.isPending}>
          {isEditMode ? 'Update System' : 'Create System'}
        </Button>
      )}
    </div>
  );

  const step1Fields = (
    <motion.div key="step1" initial={{ opacity: 0, x: -20 }} animate={{ opacity: 1, x: 0 }} exit={{ opacity: 0, x: 20 }} transition={{ duration: 0.3 }}>
      <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
        <FormInput name="system_name" label="System Name" register={register} error={errors.system_name} required />
        <FormSearchableSelect name="system_type_id" label="System Type" control={control} options={systemTypeOptions} error={errors.system_type_id} required />
        <FormSearchableSelect name="node_id" label="Node / Location" control={control} options={nodeOptions} error={errors.node_id} required />
        <FormSearchableSelect name="maintenance_terminal_id" label="Maintenance Terminal" control={control} options={maintenanceTerminalOptions} error={errors.maintenance_terminal_id} />
        <FormIPAddressInput name="ip_address" label="IP Address" control={control} error={errors.ip_address} />
        <FormDateInput name="commissioned_on" label="Commissioned On" control={control} error={errors.commissioned_on} />
      </div>
    </motion.div>
  );

  const step2Fields = (
    <motion.div key="step2" initial={{ opacity: 0, x: -20 }} animate={{ opacity: 1, x: 0 }} exit={{ opacity: 0, x: 20 }} transition={{ duration: 0.3 }}>
      <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
        {isRingBasedSystem && (
            <FormSearchableSelect name="ring_id" label="Ring" control={control} options={ringOptions} error={errors.ring_id} />
        )}
        {isSdhSystem && (
            <>
                <FormInput name="gne" label="GNE" register={register} error={errors.gne} />
                <FormInput name="make" label="Make" register={register} error={errors.make} />
            </>
        )}
        {isVmuxSystem && (
            <FormInput name="vm_id" label="VM ID" register={register} error={errors.vm_id} />
        )}
        <div className="md:col-span-2">
            <FormInput name="s_no" label="Serial Number" register={register} error={errors.s_no} />
        </div>
        <div className="md:col-span-2">
            <FormTextarea name="remark" label="Remark" control={control} error={errors.remark} />
        </div>
        <div className="md:col-span-2">
            <FormSwitch name="status" label="Status" control={control} className="my-4" />
        </div>
      </div>
    </motion.div>
  );

  const modalTitle = isEditMode
    ? 'Edit System'
    : `Add System ${needsStep2 ? `(Step ${step} of 2)` : ''}`;

  return (
    <Modal isOpen={isOpen} onClose={handleClose} title={modalTitle} size="xl" visible={false} className="h-screen w-screen transparent bg-gray-700 rounded-2xl">
      <FormCard
        onSubmit={handleSubmit(onValidSubmit, onInvalidSubmit)}
        onCancel={handleClose}
        isLoading={upsertSystemMutation.isPending || isSubmitting}
        standalone
        title={modalTitle}
        footerContent={renderFooter()}
      >
        <AnimatePresence mode="wait">
          {step === 1 ? step1Fields : step2Fields}
        </AnimatePresence>
      </FormCard>
    </Modal>
  );
};
```

<!-- path: components/systems/FiberProvisioning.tsx -->
```typescript
// path: components/systems/FiberProvisioning.tsx
"use client";

import React, { useState, useMemo, useEffect } from "react";
import { useAvailableFibers, useProvisionedFibers } from "@/hooks/database/path-queries";
import { useProvisionRingPath, useDeprovisionPath } from "@/hooks/database/path-mutations";
import { Button, SearchableSelect } from "../common/ui";
import { toast } from "sonner";
import { FiZap, FiZapOff, FiEdit, FiSave, FiX } from "react-icons/fi";
import { Row } from "@/hooks/database";
import { Option } from "@/components/common/ui/select/SearchableSelect";

interface Props {
  path: Row<'logical_fiber_paths'>;
  pathName: string;
  systemId: string;
  physicalPathId: string;
  validationStatus: 'valid_ring' | 'open_path' | 'broken' | 'empty';
}

export function FiberProvisioning({ path, pathName, systemId, physicalPathId, validationStatus }: Props) {
  const [editMode, setEditMode] = useState(false);
  const [workingFiber, setWorkingFiber] = useState<string | null>(null);
  const [protectionFiber, setProtectionFiber] = useState<string | null>(null);

  const { data: availableFibersData, isLoading: isLoadingAvailable, refetch: refetchAvailable } = useAvailableFibers(physicalPathId);
  const { data: provisionedFibers, isLoading: isLoadingProvisioned, refetch: refetchProvisioned } = useProvisionedFibers(path.id);

  const provisionMutation = useProvisionRingPath();
  const deprovisionMutation = useDeprovisionPath();

  const isProvisioned = !!path.operational_status_id;

  useEffect(() => {
    if (isProvisioned && provisionedFibers) {
      setWorkingFiber(provisionedFibers.working?.toString() || null);
      setProtectionFiber(provisionedFibers.protection?.toString() || null);
      setEditMode(false);
    } else {
      setWorkingFiber(null);
      setProtectionFiber(null);
      setEditMode(true);
    }
  }, [isProvisioned, provisionedFibers]);

  const allContinuouslyAvailableFibers = useMemo(() => {
    const available = availableFibersData || [];
    if (isProvisioned && provisionedFibers?.working) {
      if (!available.some(f => f.fiber_no === provisionedFibers.working)) {
        available.push({ fiber_no: provisionedFibers.working });
      }
    }
    if (isProvisioned && provisionedFibers?.protection) {
      if (!available.some(f => f.fiber_no === provisionedFibers.protection)) {
        available.push({ fiber_no: provisionedFibers.protection });
      }
    }
    return [...new Map(available.map(item => [item.fiber_no, item])).values()].sort((a,b) => a.fiber_no - b.fiber_no);
  }, [availableFibersData, isProvisioned, provisionedFibers]);

  const fiberOptions: Option[] = useMemo(() => 
    allContinuouslyAvailableFibers.map(f => ({ value: f.fiber_no.toString(), label: `Fiber #${f.fiber_no}` })), 
  [allContinuouslyAvailableFibers]);

  const title = validationStatus === 'valid_ring' ? "Provision Protected Ring Service" : "Provision Protected Path Service";

  const handleSave = () => {
    if (!workingFiber || !protectionFiber) {
      toast.error("Please select both a working and a protection fiber.");
      return;
    }
    provisionMutation.mutate({
      systemId, pathName, physicalPathId,
      workingFiber: parseInt(workingFiber),
      protectionFiber: parseInt(protectionFiber),
    }, { onSuccess: () => { refetchProvisioned(); refetchAvailable(); setEditMode(false); }});
  };

  const handleDeprovision = () => {
    if (window.confirm("Are you sure you want to de-provision this path? This will free up the fibers.")) {
      deprovisionMutation.mutate({ pathId: path.id }, {
        onSuccess: () => {
          setWorkingFiber(null);
          setProtectionFiber(null);
          refetchAvailable();
          refetchProvisioned();
        }
      });
    }
  };
  
  if (isLoadingAvailable || isLoadingProvisioned) {
    return <div className="mt-6 p-4 bg-gray-50 dark:bg-gray-800/50 rounded-lg"><p className="text-sm text-gray-500 animate-pulse">Loading Fiber Details...</p></div>;
  }
  
  return (
    <div className={`mt-6 p-4 rounded-lg border ${isProvisioned && !editMode ? 'bg-green-50 dark:bg-green-900/20 border-green-200 dark:border-green-700' : 'bg-gray-50 dark:bg-gray-800/50 border-dashed dark:border-gray-700'}`}>
      <div className="flex justify-between items-start mb-3">
        <h4 className={`text-lg font-semibold flex items-center gap-2 ${isProvisioned && !editMode ? 'text-green-800 dark:text-green-300' : 'dark:text-white'}`}>
          <FiZap className={isProvisioned && !editMode ? '' : 'text-yellow-500'} />
          {isProvisioned && !editMode ? 'Path is Provisioned' : title}
        </h4>
        {isProvisioned && !editMode && (
           <div className="flex gap-2">
                <Button variant="outline" size="sm" onClick={() => setEditMode(true)} leftIcon={<FiEdit />}>Change</Button>
                <Button variant="danger" size="sm" onClick={handleDeprovision} disabled={deprovisionMutation.isPending} leftIcon={<FiZapOff />}>
                    {deprovisionMutation.isPending ? "..." : "De-provision"}
                </Button>
            </div>
        )}
      </div>
      
      {editMode ? (
        <div className="grid grid-cols-1 md:grid-cols-3 gap-4 items-end">
          <div>
            <label className="block text-sm font-medium mb-1 dark:text-gray-300">Working Fiber</label>
            <SearchableSelect
                options={fiberOptions}
                value={workingFiber}
                onChange={setWorkingFiber}
                placeholder="Select fiber..."
            />
          </div>
          <div>
            <label className="block text-sm font-medium mb-1 dark:text-gray-300">Protection Fiber</label>
            <SearchableSelect
                options={fiberOptions.filter(f => f.value !== workingFiber)}
                value={protectionFiber}
                onChange={setProtectionFiber}
                placeholder="Select fiber..."
                disabled={!workingFiber}
            />
          </div>
          <div className="flex gap-2">
            {isProvisioned && <Button variant="secondary" onClick={() => setEditMode(false)} leftIcon={<FiX />}>Cancel</Button>}
            <Button onClick={handleSave} disabled={!workingFiber || !protectionFiber || provisionMutation.isPending} leftIcon={<FiSave />}>
              {provisionMutation.isPending ? "Saving..." : "Save Changes"}
            </Button>
          </div>
        </div>
      ) : isProvisioned ? (
        <div className="flex gap-6 text-sm text-gray-700 dark:text-gray-200">
          <p>Working Fiber: <span className="font-bold text-base ml-1">#{provisionedFibers?.working}</span></p>
          <p>Protection Fiber: <span className="font-bold text-base ml-1">#{provisionedFibers?.protection}</span></p>
        </div>
      ) : (
        <p className="text-sm text-gray-500 dark:text-gray-400">
            Not enough available fibers for a protected path. At least 2 continuous fibers are required.
        </p>
      )}
    </div>
  );
}
```

<!-- path: components/nodes/NodesFilters.tsx -->
```typescript
"use client";

import { useState, useEffect, memo } from "react";
import { useDebounce } from "use-debounce";
import { FiSearch } from "react-icons/fi";
import { Input } from "@/components/common/ui/Input";
import { SearchableSelect, Option } from "@/components/common/ui/select/SearchableSelect";
import { DEFAULTS } from "@/config/constants";

interface NodesFiltersProps {
  searchQuery: string;
  onSearchChange: (value: string) => void;
  nodeTypes: Array<{ id: string; name: string }>;
  selectedNodeType?: string;
  onNodeTypeChange: (value: string | null) => void;
}

const NodesFiltersComponent = memo(({
  searchQuery,
  onSearchChange,
  nodeTypes,
  selectedNodeType = "",
  onNodeTypeChange
}: NodesFiltersProps) => {
  const [internalSearch, setInternalSearch] = useState(searchQuery);
  const [debouncedSearch] = useDebounce(internalSearch, DEFAULTS.DEBOUNCE_DELAY); 
  // Effect to call the parent's onSearchChange only when the debounced value changes
  useEffect(() => {
    onSearchChange(debouncedSearch);
  }, [debouncedSearch, onSearchChange]);

  // Effect to sync the internal state if the parent's state changes
  useEffect(() => {
    setInternalSearch(searchQuery);
  }, [searchQuery]);

  const nodeTypeOptions: Option[] = (nodeTypes || []).map((nt) => ({ value: nt.id, label: nt.name }));

  return (
    <div className='w-full'>
      <div className='flex flex-col sm:flex-row gap-3 sm:items-center sm:justify-start'>
        <div className='relative flex-1 sm:max-w-md lg:max-w-xl'>
          <Input
            type='text'
            placeholder='Search nodes...'
            value={internalSearch} // Use internal state
            onChange={(e) => setInternalSearch(e.target.value)} // Update internal state
            leftIcon={<FiSearch className="text-gray-400 dark:text-gray-500" />}
            clearable={true}
            onClear={() => setInternalSearch("")} // Clear internal state
            className="dark:bg-gray-800 dark:border-gray-700 dark:text-white dark:placeholder-gray-400"
          />
        </div>
        <div className='w-full sm:w-64'>
          <SearchableSelect
            options={nodeTypeOptions}
            value={selectedNodeType}
            onChange={(v) => onNodeTypeChange(v)}
            placeholder='Filter by node type'
            searchPlaceholder='Search node types...'
            clearable={true}
          />
        </div>
      </div>
    </div>
  );
});

NodesFiltersComponent.displayName = "NodesFilters";
export const NodesFilters = NodesFiltersComponent;
```

<!-- path: components/nodes/NodeFormModal.tsx -->
```typescript
'use client';

import React, { useCallback, useEffect, useMemo } from 'react';
import { Modal } from '@/components/common/ui/Modal';
import { useTableQuery } from '@/hooks/database';
import { useForm } from 'react-hook-form';
import { zodResolver } from '@hookform/resolvers/zod';
import { FormCard } from '@/components/common/form/FormCard';
import {
  FormInput,
  FormSearchableSelect,
  FormSwitch,
  FormTextarea,
} from '@/components/common/form/FormControls';
import {
  NodesInsertSchema,
  nodesInsertSchema,
  NodesRowSchema,
} from '@/schemas/zod-schemas';
import { createClient } from '@/utils/supabase/client';

interface NodeFormModalProps {
  isOpen: boolean;
  onClose: () => void;
  editingNode?: NodesRowSchema | null;
  onSubmit: (data: NodesInsertSchema) => void; // <--  Single onSubmit handler
  isLoading: boolean; // <--  Receive loading state from parent
}

export function NodeFormModal({
  isOpen,
  onClose,
  editingNode,
  onSubmit,
  isLoading,
}: NodeFormModalProps) {
  const {
    register,
    handleSubmit,
    formState: { errors },
    reset,
    control,
  } = useForm<NodesInsertSchema>({
    resolver: zodResolver(nodesInsertSchema),
    defaultValues: {
      name: '',
      node_type_id: null,
      latitude: null,
      longitude: null,
      maintenance_terminal_id: null,
      remark: null,
      status: true,
    },
  });

  const supabase = createClient();
  const isEdit = useMemo(() => Boolean(editingNode), [editingNode]);

  const { data: nodeTypes = [] } = useTableQuery(supabase, 'lookup_types', {
    filters: {
      category: { operator: 'eq', value: 'NODE_TYPES' },
      name: { operator: 'neq', value: 'DEFAULT' },
    },
    orderBy: [{ column: 'name', ascending: true }],
  });
  const { data: maintenanceAreas = [] } = useTableQuery(
    supabase,
    'maintenance_areas',
    {
      filters: { status: { operator: 'eq', value: true } },
      orderBy: [{ column: 'name', ascending: true }],
    }
  );

  useEffect(() => {
    if (!isOpen) return;
    if (editingNode) {
      reset({
        name: editingNode.name ?? '',
        node_type_id: editingNode.node_type_id ?? null,
        latitude: editingNode.latitude,
        longitude: editingNode.longitude,
        maintenance_terminal_id: editingNode.maintenance_terminal_id ?? null,
        remark: typeof editingNode.remark === 'string' ? editingNode.remark : null,
        status: editingNode.status ?? true,
      });
    } else {
      reset({
        name: '',
        node_type_id: null,
        latitude: null,
        longitude: null,
        maintenance_terminal_id: null,
        remark: null,
        status: true,
      });
    }
  }, [isOpen, editingNode, reset]);

  //  The form's submit handler now just calls the prop.
  const onValidSubmit = useCallback(
    (formData: NodesInsertSchema) => {
      onSubmit(formData);
    },
    [onSubmit]
  );

  return (
    <Modal
      isOpen={isOpen}
      onClose={onClose}
      title={''}
      size="full"
      visible={false}
      className="h-screen w-screen transparent bg-gray-700 rounded-2xl"
    >
      <div className="h-full w-full overflow-y-auto">
        <div className="min-h-full flex items-center justify-center p-4 sm:p-6 md:p-8">
          <div className="w-full max-w-5xl">
            <FormCard
              title={isEdit ? 'Edit Node' : 'Add Node'}
              onSubmit={handleSubmit(onValidSubmit)}
              onCancel={onClose}
              isLoading={isLoading} // <-- Use the loading state from props
              standalone
            >
              <div className="space-y-6">
                <div>
                  <h3 className="text-lg font-semibold text-gray-900 dark:text-gray-100 mb-4 pb-2 border-b border-gray-200 dark:border-gray-700">
                    Basic Information
                  </h3>
                  <div className="grid grid-cols-1 md:grid-cols-2 gap-4 md:gap-6">
                    <div className="md:col-span-2">
                      <FormInput name="name" label="Node Name" register={register} error={errors.name} disabled={isLoading} placeholder="Enter node name" />
                    </div>
                    <FormSearchableSelect name="node_type_id" label="Node Type" control={control} options={nodeTypes.map(type => ({ value: type.id, label: type.name }))} error={errors.node_type_id} disabled={isLoading} placeholder="Select node type" />
                    <FormSearchableSelect name="maintenance_terminal_id" label="Maintenance Terminal" control={control} options={maintenanceAreas.map(mt => ({ value: mt.id, label: mt.name }))} error={errors.maintenance_terminal_id} disabled={isLoading} placeholder="Select maintenance terminal" />
                  </div>
                </div>

                <div>
                  <h3 className="text-lg font-semibold text-gray-900 dark:text-gray-100 mb-4 pb-2 border-b border-gray-200 dark:border-gray-700">
                    Location Coordinates
                  </h3>
                  <div className="grid grid-cols-1 sm:grid-cols-2 gap-4 md:gap-6">
                    <FormInput name="latitude" label="Latitude" register={register} error={errors.latitude} disabled={isLoading} type="number" step="any" placeholder="e.g., 22.5726" />
                    <FormInput name="longitude" label="Longitude" register={register} error={errors.longitude} disabled={isLoading} type="number" step="any" placeholder="e.g., 88.3639" />
                  </div>
                </div>

                <div>
                  <h3 className="text-lg font-semibold text-gray-900 dark:text-gray-100 mb-4 pb-2 border-b border-gray-200 dark:border-gray-700">
                    Additional Information
                  </h3>
                  <div className="space-y-4 md:space-y-6">
                    <FormTextarea name="remark" label="Remark" control={control} error={errors.remark} disabled={isLoading} placeholder="Add any additional notes or remarks" rows={4} />
                    <div className="flex items-center justify-between p-4 bg-gray-50 dark:bg-gray-800/50 rounded-lg">
                      <div>
                        <p className="font-medium text-gray-900 dark:text-gray-100">Node Status</p>
                        <p className="text-sm text-gray-500 dark:text-gray-400 mt-1">Enable or disable this node</p>
                      </div>
                      <FormSwitch name="status" label="" control={control} error={errors.status} />
                    </div>
                  </div>
                </div>
              </div>
            </FormCard>
          </div>
        </div>
      </div>
    </Modal>
  );
}
```

<!-- path: components/users/UserFilters.tsx -->
```typescript
import { motion } from "framer-motion";
import { FiSearch, FiX, FiFilter, FiChevronDown, FiChevronUp } from "react-icons/fi";
import { UserRole } from "@/types/user-roles";

interface UserFiltersProps {
  searchQuery: string;
  roleFilter: string;
  statusFilter: string;
  emailVerificationFilter: string;
  showFilters: boolean;
  onSearchChange: (value: string) => void;
  onRoleFilterChange: (value: string) => void;
  onStatusFilterChange: (value: string) => void;
  onEmailVerificationFilterChange: (value: string) => void;
  onToggleFilters: () => void;
  onClearFilters: () => void;
}

export function UserFilters({
  searchQuery,
  roleFilter,
  statusFilter,
  emailVerificationFilter,
  showFilters,
  onSearchChange,
  onRoleFilterChange,
  onStatusFilterChange,
  onEmailVerificationFilterChange,
  onToggleFilters,
  onClearFilters,
}: UserFiltersProps) {
  const hasActiveFilters = !!(searchQuery || roleFilter || statusFilter || emailVerificationFilter);
  const activeFilterCount = [roleFilter, statusFilter, emailVerificationFilter].filter(Boolean).length;

  return (
    <div className="space-y-3 sm:space-y-4 w-full">
      {/* Search and Controls Row */}
      <div className="flex flex-col space-y-3 sm:space-y-0 sm:flex-row sm:gap-3 sm:justify-between sm:items-center">
        {/* Search Input */}
        <div className="flex-1 sm:max-w-md lg:max-w-xl">
          <div className="relative">
            <FiSearch className="absolute left-3 top-1/2 transform -translate-y-1/2 text-gray-400 w-4 h-4 sm:w-5 sm:h-5" />
            <input
              type="text"
              placeholder="Search users..."
              value={searchQuery}
              onChange={(e) => onSearchChange(e.target.value)}
              className="w-full pl-9 sm:pl-10 pr-4 py-2.5 sm:py-2 text-sm sm:text-base border border-gray-300 dark:border-gray-600 rounded-lg bg-white dark:bg-gray-700 text-gray-900 dark:text-white placeholder-gray-500 dark:placeholder-gray-400 focus:ring-2 focus:ring-blue-500 focus:border-blue-500 transition-colors"
            />
          </div>
        </div>

        {/* Filter and Clear Buttons */}
        <div className="flex gap-2 sm:gap-3">
          <button
            onClick={onToggleFilters}
            className={`flex items-center gap-2 px-3 sm:px-4 py-2.5 sm:py-2 border rounded-lg font-medium text-sm sm:text-base transition-all duration-200 flex-1 sm:flex-none justify-center sm:justify-start ${
              showFilters || activeFilterCount > 0
                ? "border-blue-500 bg-blue-50 text-blue-700 dark:border-blue-400 dark:bg-blue-900/30 dark:text-blue-300 shadow-sm"
                : "border-gray-300 dark:border-gray-600 hover:bg-gray-50 dark:hover:bg-gray-700 text-gray-700 dark:text-gray-300 hover:border-gray-400"
            }`}
          >
            <FiFilter size={16} className="w-4 h-4 sm:w-4 sm:h-4" />
            <span className="hidden sm:inline">Filters</span>
            <span className="sm:hidden">Filter</span>
            {showFilters ? (
              <FiChevronUp size={14} className="w-3 h-3 sm:w-3.5 sm:h-3.5" />
            ) : (
              <FiChevronDown size={14} className="w-3 h-3 sm:w-3.5 sm:h-3.5" />
            )}
            {activeFilterCount > 0 && (
              <span className="bg-blue-600 text-white text-xs rounded-full px-1.5 sm:px-2 py-0.5 font-semibold min-w-[18px] sm:min-w-[20px] text-center leading-none">
                {activeFilterCount}
              </span>
            )}
          </button>

          {hasActiveFilters && (
            <button
              onClick={onClearFilters}
              className="flex items-center gap-2 px-3 sm:px-4 py-2.5 sm:py-2 text-sm sm:text-base text-red-600 hover:bg-red-50 dark:hover:bg-red-900/20 rounded-lg transition-colors font-medium border border-transparent hover:border-red-200 flex-shrink-0"
            >
              <FiX className="w-4 h-4" />
              <span className="hidden sm:inline">Clear All</span>
              <span className="sm:hidden">Clear</span>
            </button>
          )}
        </div>
      </div>

      {/* Collapsible Filter Panel */}
      {showFilters && (
        <motion.div
          initial={{ opacity: 0, height: 0 }}
          animate={{ opacity: 1, height: "auto" }}
          exit={{ opacity: 0, height: 0 }}
          transition={{ duration: 0.2, ease: "easeInOut" }}
          className="overflow-hidden"
        >
          <div className="p-3 sm:p-4 bg-gray-50 dark:bg-gray-800/50 rounded-lg border border-gray-200 dark:border-gray-600">
            {/* Mobile: Stack all filters, Desktop: Grid layout */}
            <div className="space-y-4 sm:space-y-0 sm:grid sm:grid-cols-2 lg:grid-cols-3 sm:gap-4">
              {/* Role Filter */}
              <div className="space-y-2">
                <label className="block text-sm font-medium text-gray-700 dark:text-gray-300">
                  Filter by Role
                </label>
                <select
                  value={roleFilter}
                  onChange={(e) => onRoleFilterChange(e.target.value)}
                  className="w-full px-3 py-2.5 sm:py-2 text-sm sm:text-base border border-gray-300 dark:border-gray-600 rounded-lg bg-white dark:bg-gray-700 text-gray-900 dark:text-white focus:ring-2 focus:ring-blue-500 focus:border-blue-500 transition-colors"
                >
                  <option value="">All Roles</option>
                  {Object.values(UserRole).map((role) => (
                    <option key={role} value={role}>
                      {role.replace(/_/g, " ").replace(/\b\w/g, (l) => l.toUpperCase())}
                    </option>
                  ))}
                </select>
              </div>

              {/* Status Filter */}
              <div className="space-y-2">
                <label className="block text-sm font-medium text-gray-700 dark:text-gray-300">
                  Filter by Status
                </label>
                <select
                  value={statusFilter}
                  onChange={(e) => onStatusFilterChange(e.target.value)}
                  className="w-full px-3 py-2.5 sm:py-2 text-sm sm:text-base border border-gray-300 dark:border-gray-600 rounded-lg bg-white dark:bg-gray-700 text-gray-900 dark:text-white focus:ring-2 focus:ring-blue-500 focus:border-blue-500 transition-colors"
                >
                  <option value="">All Status</option>
                  <option value="active">Active</option>
                  <option value="inactive">Inactive</option>
                  <option value="suspended">Suspended</option>
                  <option value="pending">Pending</option>
                </select>
              </div>

              {/* Email Verification Filter */}
              <div className="space-y-2">
                <label className="block text-sm font-medium text-gray-700 dark:text-gray-300">
                  Email Status
                </label>
                <select
                  value={emailVerificationFilter}
                  onChange={(e) => onEmailVerificationFilterChange(e.target.value)}
                  className="w-full px-3 py-2.5 sm:py-2 text-sm sm:text-base border border-gray-300 dark:border-gray-600 rounded-lg bg-white dark:bg-gray-700 text-gray-900 dark:text-white focus:ring-2 focus:ring-blue-500 focus:border-blue-500 transition-colors"
                >
                  <option value="">All</option>
                  <option value="verified">Verified</option>
                  <option value="unverified">Unverified</option>
                </select>
              </div>
            </div>

            {/* Mobile: Show clear filters button inside panel */}
            {hasActiveFilters && (
              <div className="mt-4 pt-3 border-t border-gray-200 dark:border-gray-600 sm:hidden">
                <button
                  onClick={onClearFilters}
                  className="w-full flex items-center justify-center gap-2 px-4 py-2.5 text-sm text-red-600 hover:bg-red-50 dark:hover:bg-red-900/20 rounded-lg transition-colors font-medium border border-red-200 dark:border-red-800"
                >
                  <FiX className="w-4 h-4" />
                  Clear All Filters
                </button>
              </div>
            )}
          </div>
        </motion.div>
      )}
    </div>
  );
}
```

<!-- path: components/users/BulkActions.tsx -->
```typescript
import { motion } from "framer-motion";
import { FiTrash2 } from "react-icons/fi";
import { UserRole } from "@/types/user-roles";

interface BulkActionsProps {
  selectedCount: number;
  isSuperAdmin: boolean;
  isOperationLoading: boolean;
  onBulkDelete: () => void;
  onBulkUpdateRole: (role: string) => void;
  onBulkUpdateStatus: (status: string) => void;
  onClearSelection: () => void;
}

export function BulkActions({
  selectedCount,
  isSuperAdmin,
  isOperationLoading,
  onBulkDelete,
  onBulkUpdateRole,
  onBulkUpdateStatus,
  onClearSelection,
}: BulkActionsProps) {
  if (selectedCount === 0) return null;

  return (
    <motion.div 
      initial={{ opacity: 0, y: -8 }} 
      animate={{ opacity: 1, y: 0 }} 
      className="bg-blue-50 dark:bg-blue-900/20 border border-blue-200 dark:border-blue-800 rounded-lg p-4 mb-6"
    >
      <div className="flex items-center justify-between">
        <p className="text-blue-900 dark:text-blue-200">
          {selectedCount} user(s) selected
        </p>
        <div className="flex items-center gap-3">
          <select
            onChange={(e) => e.target.value && onBulkUpdateRole(e.target.value)}
            defaultValue=""
            className="text-sm border rounded px-2 py-1 bg-white dark:bg-gray-800 dark:border-gray-700 dark:text-gray-200"
            disabled={isOperationLoading}
          >
            <option value="">Set Role</option>
            {Object.values(UserRole).map((role) => (
              <option key={role} value={role}>
                {role.replace("_", " ").toUpperCase()}
              </option>
            ))}
          </select>
          <select
            onChange={(e) => e.target.value && onBulkUpdateStatus(e.target.value)}
            defaultValue=""
            className="text-sm border rounded px-2 py-1 bg-white dark:bg-gray-800 dark:border-gray-700 dark:text-gray-200"
            disabled={isOperationLoading}
          >
            <option value="">Set Status</option>
            <option value="active">Active</option>
            <option value="inactive">Inactive</option>
            <option value="suspended">Suspended</option>
            <option value="pending">Pending</option>
          </select>
          {isSuperAdmin && (
            <button
              onClick={onBulkDelete}
              disabled={isOperationLoading}
              className="bg-red-600 dark:bg-red-700 text-white px-3 py-1 rounded hover:bg-red-700 dark:hover:bg-red-800 text-sm disabled:opacity-50"
            >
              <FiTrash2 className="inline mr-1" /> Delete
            </button>
          )}
          <button
            onClick={onClearSelection}
            className="text-gray-500 dark:text-gray-400 hover:text-gray-700 dark:hover:text-gray-300 text-sm"
          >
            Cancel
          </button>
        </div>
      </div>
    </motion.div>
  );
}
```

<!-- path: components/users/UserProfileEditModal.tsx -->
```typescript
'use client';

import React, { useEffect } from 'react';
import { FiShield } from 'react-icons/fi';
import {
  useAdminUpdateUserProfile,
  useGetMyRole,
  useIsSuperAdmin,
} from '@/hooks/useAdminUsers';
import { toast } from 'sonner';
import { UserRole } from '@/types/user-roles';
import Image from 'next/image';
import { useForm } from 'react-hook-form';
import { zodResolver } from '@hookform/resolvers/zod';
import { FormInput, FormDateInput } from '../common/form/FormControls';
import { Input, Label, Modal } from '@/components/common/ui';
import { FormCard } from '@/components/common/form';
import { user_profilesUpdateSchema } from '@/schemas/zod-schemas';
import { z } from 'zod';

// ** Define types based on the Zod schema, not manually.**
const addressSchema = z.object({
    street: z.string().optional().nullable(),
    city: z.string().optional().nullable(),
    state: z.string().optional().nullable(),
    zip_code: z.string().optional().nullable(),
}).nullable();

const preferencesSchema = z.object({
    language: z.string().optional().nullable(),
    theme: z.string().optional().nullable(),
}).nullable();

// Extend the auto-generated schema to handle nested objects for the form
const userProfileFormSchema = user_profilesUpdateSchema.extend({
    address: addressSchema,
    preferences: preferencesSchema,
});

type UserProfileFormData = z.infer<typeof userProfileFormSchema>;

interface UserProfileEditProps {
  user: UserProfileFormData | null; // The component now accepts the Zod-inferred type
  onClose: () => void;
  onSave?: () => void;
  isOpen: boolean;
}

const toObject = (val: unknown): Record<string, unknown> => {
  if (!val) return {};
  if (typeof val === 'object') return val as Record<string, unknown>;
  return {};
};

const UserProfileEditModal: React.FC<UserProfileEditProps> = ({
  isOpen,
  user,
  onClose,
  onSave,
}) => {
  const {
    register,
    handleSubmit,
    formState: { errors, isSubmitting, isDirty },
    reset,
    control,
    watch,
  } = useForm<UserProfileFormData>({
    resolver: zodResolver(userProfileFormSchema),
    defaultValues: {
      first_name: '', last_name: '', avatar_url: null, phone_number: null, date_of_birth: null,
      address: {}, preferences: {}, role: UserRole.VIEWER, designation: null, status: 'inactive',
    },
  });

  useEffect(() => {
    if (!isOpen) return;
    if (user) {
      reset({
        ...user,
        address: toObject(user.address),
        preferences: toObject(user.preferences),
      });
    } else {
      reset({
        first_name: '', last_name: '', avatar_url: null, phone_number: null, date_of_birth: null,
        address: {}, preferences: {}, role: UserRole.VIEWER, designation: null, status: 'inactive',
      });
    }
  }, [isOpen, reset, user]);

  const avatarUrl = watch('avatar_url');
  const { data: currentUserRole } = useGetMyRole();
  const { data: isSuperAdmin } = useIsSuperAdmin();
  const updateProfile = useAdminUpdateUserProfile();

  const onValidSubmit = async (data: UserProfileFormData) => {
    if (!isDirty || !user?.id) {
      toast.info('No changes to save.');
      onClose();
      return;
    }
    
    // The payload now perfectly matches the expected type for the RPC function
    const updateParams: { user_id: string; [key: string]: unknown } = { user_id: user.id };
    
    (Object.keys(data) as Array<keyof UserProfileFormData>).forEach(key => {
      updateParams[`update_${key}`] = data[key];
    });

    try {
      await updateProfile.mutateAsync(updateParams);
      onSave?.();
    } catch (error) {
      console.error('Update failed:', error);
    }
    onClose();
  };

  return (
    <Modal isOpen={isOpen} onClose={onClose} title="Edit User Profile" size="full" visible={false} className="h-screen w-screen transparent bg-gray-700 rounded-2xl">
      <FormCard onSubmit={handleSubmit(onValidSubmit)} isLoading={isSubmitting} title="Edit User Profile" onCancel={onClose}>
        <div className="p-6 space-y-6">
          <div className="flex items-center gap-4">
            <Image src={avatarUrl || '/default-avatar.png'} alt="Profile" width={64} height={64} className="w-16 h-16 rounded-full object-cover bg-gray-200" />
            <div className="flex-1">
              <FormInput name="avatar_url" label="Avatar URL" register={register} error={errors.avatar_url} placeholder="https://example.com/avatar.jpg" />
            </div>
          </div>

          <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
            <FormInput name="first_name" label="First Name" register={register} error={errors.first_name} required />
            <FormInput name="last_name" label="Last Name" register={register} error={errors.last_name} required />
          </div>

          <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
            <FormInput name="phone_number" label="Phone Number" register={register} error={errors.phone_number} type="tel" />
            <FormDateInput name="date_of_birth" label="Date of Birth" control={control} error={errors.date_of_birth} placeholder="YYYY-MM-DD" />
          </div>

          <FormInput name="designation" label="Designation" register={register} error={errors.designation} placeholder="e.g., Senior Engineer" />
          
          <div>
            <Label>Address</Label>
            <div className="grid grid-cols-1 md:grid-cols-2 gap-4 mt-1">
              <Input {...register("address.street")} placeholder="Street Address" error={errors.address?.street?.message} />
              <Input {...register("address.city")} placeholder="City" error={errors.address?.city?.message} />
              <Input {...register("address.state")} placeholder="State/Province" error={errors.address?.state?.message} />
              <Input {...register("address.zip_code")} placeholder="ZIP/Postal Code" error={errors.address?.zip_code?.message} />
            </div>
          </div>
          
          <div>
            <Label>Preferences</Label>
            <div className="grid grid-cols-1 md:grid-cols-2 gap-4 mt-1">
              <Label>Language</Label>
              <select {...register('preferences.language')} className="w-full mt-1 px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-lg dark:bg-gray-700 dark:text-white">
                <option value="en">English</option>
              </select>
            </div>
          </div>

          {(isSuperAdmin || currentUserRole === 'admin') && (
            <div className="border-t border-gray-200 dark:border-gray-700 pt-6">
              <h3 className="text-lg font-medium text-gray-900 dark:text-white mb-4 flex items-center gap-2"><FiShield className="text-orange-500" /> Administrative Settings</h3>
              <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
                <div>
                  <Label htmlFor="role" required>Role</Label>
                  <select id="role" {...register('role')} className="w-full mt-1 px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-lg dark:bg-gray-700 dark:text-white">
                    {Object.values(UserRole).map((role) => (<option key={role} value={role}>{role.replace(/_/g, ' ').toUpperCase()}</option>))}
                  </select>
                </div>
                <div>
                  <Label htmlFor="status" required>Status</Label>
                  <select id="status" {...register('status')} className="w-full mt-1 px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-lg dark:bg-gray-700 dark:text-white">
                    <option value="active">Active</option>
                    <option value="inactive">Inactive</option>
                    <option value="suspended">Suspended</option>
                  </select>
                </div>
              </div>
            </div>
          )}
        </div>
      </FormCard>
    </Modal>
  );
};

export default UserProfileEditModal;
```

<!-- path: components/users/UserCreateModal.tsx -->
```typescript
import React from 'react';
import { useForm, Controller } from 'react-hook-form';
import { z } from 'zod';
import { zodResolver } from '@hookform/resolvers/zod';
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from '@/components/common/ui/select/Select';
import { Modal } from '@/components/common/ui/Modal/Modal';
import { FormCard, FormInput } from '@/components/common/form';
import { v4 as uuidv4 } from 'uuid';

const userSchema = z.object({
  id: z.uuid().optional(),
  email: z.email('Please enter a valid email address'),
  password: z.string().min(8, 'Password must be at least 8 characters'),
  first_name: z.string().min(1, 'First name is required'),
  last_name: z.string().min(1, 'Last name is required'),
  role: z.string().min(1, 'Role is required'),
  email_confirm: z.boolean().catch(false),
});

type UserFormData = z.infer<typeof userSchema>;

interface UserCreateModalProps {
  isOpen: boolean;
  onClose: () => void;
  onCreate: (data: UserFormData) => Promise<void>;
  isLoading: boolean;
}

export function UserCreateModal({
  isOpen,
  onClose,
  onCreate,
  isLoading,
}: UserCreateModalProps) {
  const form = useForm<UserFormData>({
    resolver: zodResolver(userSchema),
    defaultValues: {
      id: '',
      email: '',
      password: '',
      first_name: '',
      last_name: '',
      role: 'viewer',
      email_confirm: false,
    },
  });

  const {
    register,
    handleSubmit,
    control,
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    formState: { errors, isDirty, isValid },
    reset,
  } = form;

  const onValidSubmit = async (data: UserFormData) => {
    try {
      // Auto-generate UUID if not provided
      const payload = {
        ...data,
        id: data.id && data.id.trim() !== '' ? data.id : uuidv4(),
      };

      await onCreate(payload);
      reset();
      onClose();
    } catch (error: unknown) {
      console.error('Error creating user:', error);
    }
  };

  return (
    <Modal isOpen={isOpen} onClose={onClose} title="Create New User" visible={false}
      className="transparent bg-gray-700 rounded-2xl">
      <FormCard
        title="Create New User"
        onCancel={onClose}
        onSubmit={handleSubmit(onValidSubmit)}
        isLoading={isLoading}
        standalone
      >
        <div className="space-y-4">
          {/* Optional ID */}
          <FormInput
            name="id"
            label="User ID (optional)"
            placeholder="Leave blank to auto-generate"
            register={register}
            error={errors.id}
          />

          <div className="grid grid-cols-2 gap-4">
            <FormInput
              name="first_name"
              label="First Name"
              register={register}
              error={errors.first_name}
              required
            />
            <FormInput
              name="last_name"
              label="Last Name"
              register={register}
              error={errors.last_name}
              required
            />
          </div>

          <FormInput
            name="email"
            placeholder="user@example.com"
            label="Email"
            error={errors.email}
            register={register}
            required
          />

          <FormInput
            name="password"
            type="password"
            placeholder="••••••••"
            label="Password"
            error={errors.password}
            register={register}
            required
          />

          {/* Role Select with Controller */}
          <Controller
            control={control}
            name="role"
            defaultValue="viewer" // ✅ add this
            render={({ field }) => (
              <div>
                <label className="block text-sm font-medium mb-1">Role</label>
                <Select onValueChange={field.onChange} value={field.value}>
                  <SelectTrigger>
                    <SelectValue placeholder="Select a role" />
                  </SelectTrigger>
                  <SelectContent>
                    <SelectItem value="viewer">Viewer</SelectItem>
                    <SelectItem value="admin">Admin</SelectItem>
                    <SelectItem value="maan_admin">MAAN Admin</SelectItem>
                    <SelectItem value="sdh_admin">SDH Admin</SelectItem>
                    <SelectItem value="vmux_admin">VMUX Admin</SelectItem>
                    <SelectItem value="mng_admin">MNG Admin</SelectItem>
                  </SelectContent>
                </Select>
                {errors.role && (
                  <p className="text-sm text-red-500 mt-1">
                    {errors.role.message}
                  </p>
                )}
              </div>
            )}
          />

          {/* Email Confirm Checkbox */}
          <Controller
            control={control}
            name="email_confirm"
            defaultValue={false} // ✅ add this
            render={({ field }) => (
              <label className="flex items-center space-x-2">
                <input
                  type="checkbox"
                  checked={field.value}
                  onChange={(e) => field.onChange(e.target.checked)}
                  className="h-4 w-4"
                />
                <span className="text-sm">Confirm Email Immediately</span>
              </label>
            )}
          />
        </div>
      </FormCard>
    </Modal>
  );
}

```

<!-- path: components/employee/EmployeeFilters.tsx -->
```typescript
// path: components/employee/EmployeeFilters.tsx
'use client';

import React, { memo, useState, useEffect } from 'react';
import { useDebounce } from 'use-debounce';
import { FiFilter, FiSearch } from 'react-icons/fi';
import { SearchableSelect } from '@/components/common/ui/select/SearchableSelect';
import { Filters } from '@/hooks/database';
import { DEFAULTS } from '@/config/constants';
import {
  Employee_designationsRowSchema,
  Maintenance_areasRowSchema,
} from '@/schemas/zod-schemas';

interface EmployeeFiltersProps {
  searchQuery: string;
  filters: Filters;
  showFilters: boolean;
  designations: Employee_designationsRowSchema[];
  maintenanceAreas: Maintenance_areasRowSchema[];
  onSearchChange: (value: string) => void;
  onFilterToggle: () => void;
  setFilters: React.Dispatch<React.SetStateAction<Filters>>;
}

const EmployeeFiltersComponent = memo(
  ({
    searchQuery,
    filters,
    showFilters,
    designations,
    maintenanceAreas,
    onSearchChange,
    onFilterToggle,
    setFilters,
  }: EmployeeFiltersProps) => {
    const [internalSearch, setInternalSearch] = useState(searchQuery);
    const [debouncedSearch] = useDebounce(internalSearch, DEFAULTS.DEBOUNCE_DELAY);

    useEffect(() => {
      onSearchChange(debouncedSearch);
    }, [debouncedSearch, onSearchChange]);

    useEffect(() => {
      setInternalSearch(searchQuery);
    }, [searchQuery]);

    // REVISED: These handlers now safely update the state without type conflicts.
    const onDesignationChange = (value: string | null) => {
      setFilters(prev => {
        const newFilters: Filters = { ...prev };
        if (value) {
          newFilters.employee_designation_id = value;
        } else {
          delete newFilters.employee_designation_id;
        }
        return newFilters;
      });
    };

    const onStatusChange = (value: 'true' | 'false' | '') => {
      setFilters(prev => {
        const newFilters: Filters = { ...prev };
        if (value) {
          newFilters.status = value;
        } else {
          delete newFilters.status;
        }
        return newFilters;
      });
    };

    const onMaintenanceAreaChange = (value: string | null) => {
      setFilters(prev => {
        const newFilters: Filters = { ...prev };
        if (value) {
          newFilters.maintenance_terminal_id = value;
        } else {
          delete newFilters.maintenance_terminal_id;
        }
        return newFilters;
      });
    };

    return (
      <div className="mb-6 rounded-lg border bg-white p-4 shadow-sm dark:border-gray-700 dark:bg-gray-800">
        <div className="flex flex-col items-start justify-between gap-4 sm:flex-row sm:items-center">
          <div className="flex flex-1 flex-col gap-3 sm:flex-row">
            <div className="relative">
              <FiSearch className="absolute top-1/2 left-3 h-4 w-4 -translate-y-1/2 transform text-gray-400 dark:text-gray-500" />
              <input
                type="text"
                placeholder="Search employees..."
                value={internalSearch}
                onChange={(e) => setInternalSearch(e.target.value)}
                onKeyDown={(e) => e.stopPropagation()}
                className="w-full rounded-md border border-gray-300 py-2 pr-4 pl-10 focus:ring-2 focus:ring-blue-500 focus:outline-none dark:border-gray-600 dark:bg-gray-700 dark:text-white dark:focus:ring-blue-600 sm:w-80"
              />
            </div>
            <button
              type="button"
              onClick={onFilterToggle}
              className={`flex items-center gap-2 rounded-md border px-3 py-2 transition-colors ${
                showFilters
                  ? 'border-blue-200 bg-blue-50 text-blue-700 dark:border-blue-800 dark:bg-blue-900/50 dark:text-blue-200'
                  : 'border-gray-300 bg-white text-gray-700 hover:bg-gray-50 dark:border-gray-600 dark:bg-gray-700 dark:text-gray-300 dark:hover:bg-gray-600'
              }`}
            >
              <FiFilter className="h-4 w-4" />
              Filters
            </button>
          </div>
        </div>

        {showFilters && (
          <div className="mt-4 grid grid-cols-1 gap-3 border-t pt-4 dark:border-gray-700 sm:grid-cols-3">
            <SearchableSelect
              options={designations.map((d) => ({ value: d.id, label: d.name }))}
              value={filters.employee_designation_id as string}
              onChange={onDesignationChange}
              placeholder="All Designations"
              searchPlaceholder="Search designations..."
              clearable={true}
            />
            <select
              value={filters.status as string}
              onChange={(e) => onStatusChange(e.target.value as 'true' | 'false' | '')}
              className="rounded-md border border-gray-300 px-3 py-2 focus:ring-2 focus:ring-blue-500 focus:outline-none dark:border-gray-600 dark:bg-gray-700 dark:text-white dark:focus:ring-blue-600"
            >
              <option value="">All Status</option>
              <option value="true">Active</option>
              <option value="false">Inactive</option>
            </select>
            <SearchableSelect
              options={maintenanceAreas.map((area) => ({
                value: area.id,
                label: `${area.name}${area.code ? ` (${area.code})` : ''}`,
              }))}
              value={filters.maintenance_terminal_id as string}
              onChange={onMaintenanceAreaChange}
              placeholder="All Maintenance Areas"
              searchPlaceholder="Search areas..."
              clearable={true}
            />
          </div>
        )}
      </div>
    );
  }
);

EmployeeFiltersComponent.displayName = 'EmployeeFilters';
export default EmployeeFiltersComponent;
```

<!-- path: components/employee/EmployeeTableActions.tsx -->
```typescript
import { FiEdit, FiTrash2, FiToggleRight, FiEye } from "react-icons/fi";
import { TableAction } from "@/components/table/datatable-types";
import { Row } from "@/hooks/database";

interface EmployeeTableActionsProps {
  onView: (employeeId: string) => void;
  onEdit: (employeeId: string) => void;
  onToggleStatus: (record: Row<"employees">) => void;
  onDelete: (employeeId: string, displayName?: string) => void;
}

export const getEmployeeTableActions = ({
  onView,
  onEdit,
  onToggleStatus,
  onDelete,
}: EmployeeTableActionsProps): TableAction<"employees">[] => [
  {
    key: "view",
    label: "View",
    icon: <FiEye className='w-4 h-4' />,
    onClick: (record) => onView(record.id || ""),
    variant: "primary",
  },
  {
    key: "toggle",
    label: "Toggle Status",
    icon: <FiToggleRight className='w-4 h-4' />,
    onClick: (record) => onToggleStatus(record),
    variant: "secondary",
  },
  {
    key: "edit",
    label: "Edit",
    icon: <FiEdit className='w-4 h-4' />,
    onClick: (record) => onEdit(record.id || ""),
    variant: "primary",
  },
  {
    key: "delete",
    label: "Delete",
    icon: <FiTrash2 className='w-4 h-4' />,
    onClick: (record) => onDelete(record.id || "", String(record.employee_name || "this employee")),
    variant: "danger",
  },
];

```

<!-- path: components/employee/EmployeeDetailsModal.tsx -->
```typescript
// components/employee/EmployeeDetailsModal.tsx
import { FiX, FiMail, FiPhone, FiUser, FiBriefcase, FiCalendar, FiEdit3 } from "react-icons/fi";
import { createClient } from "@/utils/supabase/client";
import { useTableRecord } from "@/hooks/database";
import { EmployeesRowSchema } from "@/schemas/zod-schemas";

type EmployeeData = EmployeesRowSchema & {
  employee_designations?: { name: string } | null;
  maintenance_areas?: { name: string } | null;
};

type Props = {
  // Accept either employee data or employeeId
  employee?: EmployeeData;
  employeeId?: string;
  onClose: () => void;
  onEdit?: () => void;  // Make onEdit optional
  isOpen?: boolean;     // Add isOpen prop
};

const formatDate = (dateString: string | null | undefined) => {
  if (!dateString) return "Not provided";
  try {
    return new Date(dateString).toLocaleDateString("en-US", {
      year: "numeric",
      month: "long",
      day: "numeric",
    });
  } catch {
    return "Invalid date";
  }
};

const EmployeeDetailsModal = ({ employee, employeeId, onClose, onEdit }: Props) => {
  const supabase = createClient();

  // Only fetch if employeeId is provided and employee data is not provided
  const { data: fetchedEmployee, isLoading, isError, error } = useTableRecord(
    supabase,
    "employees",
    employeeId || "",
    employeeId ? {
      columns: "*, employee_designations(name), maintenance_areas(name)",
    } : undefined
  );

  // Use the passed employee or the fetched employee
  const currentEmployee = employee || fetchedEmployee;

  if (isLoading) {
    return (
      <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50">
        <div className="bg-white p-8 rounded-lg shadow-xl max-w-md w-full mx-4">
          <div className="animate-spin rounded-full h-8 w-8 border-b-2 border-blue-600 mx-auto mb-4" />
          <p className="text-gray-700 text-center">Loading employee details...</p>
        </div>
      </div>
    );
  }

  if (isError || !currentEmployee) {
    return (
      <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50">
        <div className="bg-white p-8 rounded-lg shadow-xl max-w-md w-full mx-4">
          <h3 className="text-lg font-medium text-red-600 mb-4">Error</h3>
          <p className="text-gray-700 mb-4">
            {error?.message || 'Failed to load employee details'}
          </p>
          <button
            onClick={onClose}
            className="w-full bg-gray-200 text-gray-800 py-2 px-4 rounded-md hover:bg-gray-300 transition-colors"
          >
            Close
          </button>
        </div>
      </div>
    );
  }

  // Rest of your component remains the same
  // Just make sure to use currentEmployee instead of employee
  return (
    <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50">
      <div className="bg-white p-8 rounded-lg shadow-xl max-w-md w-full mx-4 max-h-[90vh] overflow-y-auto">
        <div className="flex justify-between items-center mb-6">
          <h2 className="text-2xl font-bold text-gray-900">Employee Details</h2>
          <button
            onClick={onClose}
            className="text-gray-500 hover:text-gray-700"
          >
            <FiX size={24} />
          </button>
        </div>

        <div className="space-y-4">
          <div className="flex items-center space-x-4">
            <div className="bg-gray-100 p-3 rounded-full">
              <FiUser className="text-gray-600" size={24} />
            </div>
            <div>
              <p className="text-sm text-gray-500">Name</p>
              <p className="font-medium">
                {currentEmployee.employee_name || 'Not provided'}
              </p>
            </div>
          </div>

          {/* Add other employee details here */}
          <div className="flex items-center space-x-4">
            <div className="bg-gray-100 p-3 rounded-full">
              <FiMail className="text-gray-600" size={24} />
            </div>
            <div>
              <p className="text-sm text-gray-500">Email</p>
              <p className="font-medium">
                {currentEmployee.employee_email || 'Not provided'}
              </p>
            </div>
          </div>

          <div className="flex items-center space-x-4">
            <div className="bg-gray-100 p-3 rounded-full">
              <FiPhone className="text-gray-600" size={24} />
            </div>
            <div>
              <p className="text-sm text-gray-500">Contact</p>
              <p className="font-medium">
                {currentEmployee.employee_contact || 'Not provided'}
              </p>
            </div>
          </div>

          <div className="flex items-center space-x-4">
            <div className="bg-gray-100 p-3 rounded-full">
              <FiBriefcase className="text-gray-600" size={24} />
            </div>
            <div>
              <p className="text-sm text-gray-500">Designation</p>
              <p className="font-medium">
                {typeof currentEmployee.employee_designation_id === 'object' 
                  ? currentEmployee.employee_name
                  : 'Not provided'}
              </p>
            </div>
          </div>

          <div className="flex items-center space-x-4">
            <div className="bg-gray-100 p-3 rounded-full">
              <FiCalendar className="text-gray-600" size={24} />
            </div>
            <div>
              <p className="text-sm text-gray-500">Date of Joining</p>
              <p className="font-medium">
                {formatDate(currentEmployee.employee_doj)}
              </p>
            </div>
          </div>

          {/* Add more fields as needed */}

          <div className="pt-4 flex justify-end space-x-3">
            <button
              onClick={onClose}
              className="px-4 py-2 border border-gray-300 rounded-md text-gray-700 hover:bg-gray-50"
            >
              Close
            </button>
            <button
              onClick={onEdit}
              className="px-4 py-2 bg-blue-600 text-white rounded-md hover:bg-blue-700 flex items-center space-x-2"
            >
              <FiEdit3 size={16} />
              <span>Edit</span>
            </button>
          </div>
        </div>
      </div>
    </div>
  );
};

export default EmployeeDetailsModal;
```

<!-- path: components/employee/EmployeeStats.tsx -->
```typescript
// app/dashboard/employees/components/EmployeeStats.tsx
interface EmployeeStatsProps {
    total: number;
    active: number;
    inactive: number;
  }
  
  export const EmployeeStats = ({ total, active, inactive }: EmployeeStatsProps) => {
    return (
      <div className="mt-6 flex items-center justify-between text-sm text-gray-600 dark:text-gray-400">
        <span>
          Showing {total} employee{total !== 1 ? "s" : ""}
        </span>
        <span>
          {active} active, {inactive} inactive
        </span>
      </div>
    );
  };
```

<!-- path: components/employee/EmployeeForm.tsx -->
```typescript
// path: components/employee/EmployeeForm.tsx

import { useForm } from 'react-hook-form';
import { zodResolver } from '@hookform/resolvers/zod';
import { Option } from '@/components/common/ui/select/SearchableSelect';
import {
  FormDateInput,
  FormInput,
  FormSearchableSelect,
  FormTextarea,
} from '@/components/common/form/FormControls';
import { Modal } from '@/components/common/ui';
import { FormCard } from '@/components/common/form';
import { useEffect } from 'react';
import {
  Employee_designationsRowSchema,
  employeesInsertSchema,
  EmployeesInsertSchema,
  Maintenance_areasRowSchema,
  V_employeesRowSchema, // Import the view schema
} from '@/schemas/zod-schemas';

interface EmployeeFormProps {
  isOpen: boolean;
  onClose: () => void;
  // The form now accepts the record directly from the view
  employee?: V_employeesRowSchema | null;
  onSubmit: (data: EmployeesInsertSchema) => void;
  onCancel: () => void;
  isLoading: boolean;
  designations: Employee_designationsRowSchema[];
  maintenanceAreas: Maintenance_areasRowSchema[];
}

const EmployeeForm = ({
  isOpen,
  onClose,
  employee,
  onSubmit,
  isLoading,
  designations,
  maintenanceAreas,
}: EmployeeFormProps) => {
  const {
    control,
    handleSubmit,
    register,
    formState: { errors },
    reset,
  } = useForm<EmployeesInsertSchema>({
    resolver: zodResolver(employeesInsertSchema),
    // Default values are for the base table insert schema
    defaultValues: {
      employee_name: '',
      employee_pers_no: null,
      employee_designation_id: null,
      employee_contact: null,
      employee_email: null,
      employee_dob: null,
      employee_doj: null,
      employee_addr: null,
      maintenance_terminal_id: null,
      remark: null,
      status: true, // Default to true for new employees
    },
  });

  // This effect correctly maps the view data to the form's state
  useEffect(() => {
    if (isOpen) {
      if (employee) {
        reset({
          employee_name: employee.employee_name || '',
          employee_pers_no: employee.employee_pers_no,
          employee_designation_id: employee.employee_designation_id,
          employee_contact: employee.employee_contact,
          employee_email: employee.employee_email,
          employee_dob: employee.employee_dob,
          employee_doj: employee.employee_doj,
          employee_addr: employee.employee_addr,
          maintenance_terminal_id: employee.maintenance_terminal_id,
          remark: employee.remark,
          status: employee.status ?? true,
        });
      } else {
        // Reset to default for a new entry
        reset({
          employee_name: '',
          employee_pers_no: null,
          employee_designation_id: null,
          employee_contact: null,
          employee_email: null,
          employee_dob: null,
          employee_doj: null,
          employee_addr: null,
          maintenance_terminal_id: null,
          remark: null,
          status: true,
        });
      }
    }
  }, [employee, reset, isOpen]);

  const designationOptions: Option[] = designations.map((d) => ({
    value: d.id,
    label: d.name,
  }));

  const maintenanceAreaOptions: Option[] = maintenanceAreas.map((area) => ({
    value: area.id,
    label: `${area.name}${area.code ? ` (${area.code})` : ''}`,
  }));

  const onValidFormSubmit = (data: EmployeesInsertSchema) => {
    onSubmit(data);
  };

  return (
    <Modal
      isOpen={isOpen}
      onClose={onClose}
      title={employee ? 'Edit Employee' : 'Add New Employee'}
      size="full"
      visible={false}
      className="transparent h-0 w-0"
    >
      <FormCard
        title={employee ? 'Edit Employee' : 'Add New Employee'}
        onSubmit={handleSubmit(onValidFormSubmit)}
        onCancel={onClose}
        isLoading={isLoading}
        disableSubmit={isLoading}
        standalone
      >
        {/* Form fields remain unchanged */}
        <div className="space-y-4">
          <div className="grid grid-cols-1 gap-4 md:grid-cols-2">
            <FormInput
              name="employee_name"
              label="Employee Name"
              register={register}
              error={errors.employee_name}
              required
              placeholder="Enter employee name"
            />
            <FormInput
              name="employee_pers_no"
              label="Personnel Number"
              register={register}
              error={errors.employee_pers_no}
              placeholder="Enter personnel number"
            />
            <FormSearchableSelect
              name="employee_designation_id"
              label="Designation"
              control={control}
              options={designationOptions}
              error={errors.employee_designation_id}
              placeholder="Select designation"
            />
            <FormInput
              name="employee_contact"
              label="Contact Number"
              register={register}
              error={errors.employee_contact}
              type="tel"
              placeholder="Enter contact number"
            />
            <FormInput
              name="employee_email"
              label="Email Address"
              register={register}
              error={errors.employee_email}
              type="email"
              placeholder="Enter email address"
            />
            <FormDateInput
              name="employee_dob"
              label="Date of Birth"
              control={control}
              error={errors.employee_dob}
            />
            <FormDateInput
              name="employee_doj"
              label="Date of Joining"
              control={control}
              error={errors.employee_doj}
            />
            <FormSearchableSelect
              name="maintenance_terminal_id"
              label="Maintenance Area"
              control={control}
              options={maintenanceAreaOptions}
              error={errors.maintenance_terminal_id}
              placeholder="Select maintenance area"
            />
          </div>
          <FormTextarea
            name="employee_addr"
            label="Address"
            control={control}
            error={errors.employee_addr}
            rows={3}
            placeholder="Enter address"
          />
          <FormTextarea
            name="remark"
            label="Remarks"
            control={control}
            error={errors.remark}
            rows={2}
            placeholder="Enter remarks"
          />
        </div>
      </FormCard>
    </Modal>
  );
};

export default EmployeeForm;

```

<!-- path: components/employee/EmployeeTableColumns.tsx -->
```typescript
import { Column } from '@/hooks/database/excel-queries/excel-helpers';
import { StatusBadge } from '@/components/common/ui/badges/StatusBadge';
import { V_employeesRowSchema } from '@/schemas/zod-schemas';

// Columns for employees table using DataTable component
// Note: We type columns against Row<"employees">; relation fields are accessed via custom render using any casts.
type LookupOptions = {
  designationMap?: Record<string, string>;
  areaMap?: Record<string, string>;
};

export const getEmployeeTableColumns = (
  options?: LookupOptions
): Column<V_employeesRowSchema>[] => [
  {
    title: 'Employee',
    dataIndex: 'employee_name',
    key: 'employee_name',
    width: 220,
    searchable: true,
    render: (_, record: V_employeesRowSchema) => (
      <div className="min-w-[180px]">
        <div className="font-medium text-gray-900 dark:text-white">
          {record.employee_name || '—'}
        </div>
        {record.employee_pers_no && (
          <div className="text-xs text-gray-500 dark:text-gray-400">
            ID: {record.employee_pers_no}
          </div>
        )}
      </div>
    ),
  },
  {
    title: 'Contact',
    dataIndex: 'employee_contact',
    key: 'contact',
    width: 220,
    searchable: true,
    render: (_, record: V_employeesRowSchema) => (
      <div className="space-y-1">
        {record.employee_contact && (
          <div className="text-sm text-gray-700 dark:text-gray-300">
            {record.employee_contact}
          </div>
        )}
      </div>
    ),
  },
  {
    title: 'Email',
    dataIndex: 'employee_contact',
    key: 'email',
    width: 220,
    searchable: true,
    render: (_, record: V_employeesRowSchema) => (
      <div className="space-y-1">
        {record.employee_email && (
          <div className="text-sm text-gray-700 dark:text-gray-300">
            {record.employee_email}
          </div>
        )}
      </div>
    ),
  },
  {
    title: 'Designation',
    dataIndex: 'employee_designation_id',
    key: 'designation',
    width: 180,
    render: (_, record: V_employeesRowSchema) => {
      const id = record?.employee_designation_id as unknown as string | null;
      return (id && options?.designationMap?.[id]) || 'Not set';
    },
  },
  {
    title: 'Maintenance Area',
    dataIndex: 'maintenance_terminal_id',
    key: 'maintenance_area',
    width: 200,
    render: (_, record: V_employeesRowSchema) => {
      const id = record?.maintenance_terminal_id as unknown as string | null;
      return (id && options?.areaMap?.[id]) || 'Not set';
    },
  },
  {
    title: 'Address',
    dataIndex: 'employee_addr',
    key: 'employee_addr',
    width: 300,
  },
  {
    title: 'Status',
    dataIndex: 'status',
    key: 'status',
    width: 120,
    render: (value: unknown) => <StatusBadge status={!!value} />,
  },
  // {
  //   title: "Created",
  //   dataIndex: "created_at",
  //   key: "created_at",
  //   width: 180,
  //   render: (value: string | null) => (value ? formatDate(value, { format: "dd/mm/yyyy" }) : "—"),
  // },
  // {
  //   title: "Updated",
  //   dataIndex: "updated_at",
  //   key: "updated_at",
  //   width: 180,
  //   render: (value: string | null) => (value ? formatDate(value, { format: "dd/mm/yyyy" }) : "—"),
  // },
];

```

<!-- path: types/error-types.ts -->
```typescript
export type DetailedError = Error & { details?: unknown; hint?: unknown; code?: unknown };

export function hasDetails(error: unknown): error is DetailedError {
  return typeof error === "object" && error !== null && "details" in error;
}
```

<!-- path: types/pollyfills.d.ts -->
```typescript
declare module 'core-js/stable';
declare module 'regenerator-runtime/runtime';
declare module 'whatwg-fetch';
declare module 'intersection-observer';
declare module 'url-polyfill';
```

<!-- path: types/supabase-types.ts -->
```typescript
export type Json =
  | string
  | number
  | boolean
  | null
  | { [key: string]: Json | undefined }
  | Json[]

export type Database = {
  // Allows to automatically instantiate createClient with right options
  // instead of createClient<Database, { PostgrestVersion: 'XX' }>(URL, KEY)
  __InternalSupabase: {
    PostgrestVersion: "13.0.4"
  }
  auth: {
    Tables: {
      audit_log_entries: {
        Row: {
          created_at: string | null
          id: string
          instance_id: string | null
          ip_address: string
          payload: Json | null
        }
        Insert: {
          created_at?: string | null
          id: string
          instance_id?: string | null
          ip_address?: string
          payload?: Json | null
        }
        Update: {
          created_at?: string | null
          id?: string
          instance_id?: string | null
          ip_address?: string
          payload?: Json | null
        }
        Relationships: []
      }
      flow_state: {
        Row: {
          auth_code: string
          auth_code_issued_at: string | null
          authentication_method: string
          code_challenge: string
          code_challenge_method: Database["auth"]["Enums"]["code_challenge_method"]
          created_at: string | null
          id: string
          provider_access_token: string | null
          provider_refresh_token: string | null
          provider_type: string
          updated_at: string | null
          user_id: string | null
        }
        Insert: {
          auth_code: string
          auth_code_issued_at?: string | null
          authentication_method: string
          code_challenge: string
          code_challenge_method: Database["auth"]["Enums"]["code_challenge_method"]
          created_at?: string | null
          id: string
          provider_access_token?: string | null
          provider_refresh_token?: string | null
          provider_type: string
          updated_at?: string | null
          user_id?: string | null
        }
        Update: {
          auth_code?: string
          auth_code_issued_at?: string | null
          authentication_method?: string
          code_challenge?: string
          code_challenge_method?: Database["auth"]["Enums"]["code_challenge_method"]
          created_at?: string | null
          id?: string
          provider_access_token?: string | null
          provider_refresh_token?: string | null
          provider_type?: string
          updated_at?: string | null
          user_id?: string | null
        }
        Relationships: []
      }
      identities: {
        Row: {
          created_at: string | null
          email: string | null
          id: string
          identity_data: Json
          last_sign_in_at: string | null
          provider: string
          provider_id: string
          updated_at: string | null
          user_id: string
        }
        Insert: {
          created_at?: string | null
          email?: string | null
          id?: string
          identity_data: Json
          last_sign_in_at?: string | null
          provider: string
          provider_id: string
          updated_at?: string | null
          user_id: string
        }
        Update: {
          created_at?: string | null
          email?: string | null
          id?: string
          identity_data?: Json
          last_sign_in_at?: string | null
          provider?: string
          provider_id?: string
          updated_at?: string | null
          user_id?: string
        }
        Relationships: [
          {
            foreignKeyName: "identities_user_id_fkey"
            columns: ["user_id"]
            isOneToOne: false
            referencedRelation: "users"
            referencedColumns: ["id"]
          },
        ]
      }
      instances: {
        Row: {
          created_at: string | null
          id: string
          raw_base_config: string | null
          updated_at: string | null
          uuid: string | null
        }
        Insert: {
          created_at?: string | null
          id: string
          raw_base_config?: string | null
          updated_at?: string | null
          uuid?: string | null
        }
        Update: {
          created_at?: string | null
          id?: string
          raw_base_config?: string | null
          updated_at?: string | null
          uuid?: string | null
        }
        Relationships: []
      }
      mfa_amr_claims: {
        Row: {
          authentication_method: string
          created_at: string
          id: string
          session_id: string
          updated_at: string
        }
        Insert: {
          authentication_method: string
          created_at: string
          id: string
          session_id: string
          updated_at: string
        }
        Update: {
          authentication_method?: string
          created_at?: string
          id?: string
          session_id?: string
          updated_at?: string
        }
        Relationships: [
          {
            foreignKeyName: "mfa_amr_claims_session_id_fkey"
            columns: ["session_id"]
            isOneToOne: false
            referencedRelation: "sessions"
            referencedColumns: ["id"]
          },
        ]
      }
      mfa_challenges: {
        Row: {
          created_at: string
          factor_id: string
          id: string
          ip_address: unknown
          otp_code: string | null
          verified_at: string | null
          web_authn_session_data: Json | null
        }
        Insert: {
          created_at: string
          factor_id: string
          id: string
          ip_address: unknown
          otp_code?: string | null
          verified_at?: string | null
          web_authn_session_data?: Json | null
        }
        Update: {
          created_at?: string
          factor_id?: string
          id?: string
          ip_address?: unknown
          otp_code?: string | null
          verified_at?: string | null
          web_authn_session_data?: Json | null
        }
        Relationships: [
          {
            foreignKeyName: "mfa_challenges_auth_factor_id_fkey"
            columns: ["factor_id"]
            isOneToOne: false
            referencedRelation: "mfa_factors"
            referencedColumns: ["id"]
          },
        ]
      }
      mfa_factors: {
        Row: {
          created_at: string
          factor_type: Database["auth"]["Enums"]["factor_type"]
          friendly_name: string | null
          id: string
          last_challenged_at: string | null
          phone: string | null
          secret: string | null
          status: Database["auth"]["Enums"]["factor_status"]
          updated_at: string
          user_id: string
          web_authn_aaguid: string | null
          web_authn_credential: Json | null
        }
        Insert: {
          created_at: string
          factor_type: Database["auth"]["Enums"]["factor_type"]
          friendly_name?: string | null
          id: string
          last_challenged_at?: string | null
          phone?: string | null
          secret?: string | null
          status: Database["auth"]["Enums"]["factor_status"]
          updated_at: string
          user_id: string
          web_authn_aaguid?: string | null
          web_authn_credential?: Json | null
        }
        Update: {
          created_at?: string
          factor_type?: Database["auth"]["Enums"]["factor_type"]
          friendly_name?: string | null
          id?: string
          last_challenged_at?: string | null
          phone?: string | null
          secret?: string | null
          status?: Database["auth"]["Enums"]["factor_status"]
          updated_at?: string
          user_id?: string
          web_authn_aaguid?: string | null
          web_authn_credential?: Json | null
        }
        Relationships: [
          {
            foreignKeyName: "mfa_factors_user_id_fkey"
            columns: ["user_id"]
            isOneToOne: false
            referencedRelation: "users"
            referencedColumns: ["id"]
          },
        ]
      }
      oauth_clients: {
        Row: {
          client_id: string
          client_name: string | null
          client_secret_hash: string
          client_uri: string | null
          created_at: string
          deleted_at: string | null
          grant_types: string
          id: string
          logo_uri: string | null
          redirect_uris: string
          registration_type: Database["auth"]["Enums"]["oauth_registration_type"]
          updated_at: string
        }
        Insert: {
          client_id: string
          client_name?: string | null
          client_secret_hash: string
          client_uri?: string | null
          created_at?: string
          deleted_at?: string | null
          grant_types: string
          id: string
          logo_uri?: string | null
          redirect_uris: string
          registration_type: Database["auth"]["Enums"]["oauth_registration_type"]
          updated_at?: string
        }
        Update: {
          client_id?: string
          client_name?: string | null
          client_secret_hash?: string
          client_uri?: string | null
          created_at?: string
          deleted_at?: string | null
          grant_types?: string
          id?: string
          logo_uri?: string | null
          redirect_uris?: string
          registration_type?: Database["auth"]["Enums"]["oauth_registration_type"]
          updated_at?: string
        }
        Relationships: []
      }
      one_time_tokens: {
        Row: {
          created_at: string
          id: string
          relates_to: string
          token_hash: string
          token_type: Database["auth"]["Enums"]["one_time_token_type"]
          updated_at: string
          user_id: string
        }
        Insert: {
          created_at?: string
          id: string
          relates_to: string
          token_hash: string
          token_type: Database["auth"]["Enums"]["one_time_token_type"]
          updated_at?: string
          user_id: string
        }
        Update: {
          created_at?: string
          id?: string
          relates_to?: string
          token_hash?: string
          token_type?: Database["auth"]["Enums"]["one_time_token_type"]
          updated_at?: string
          user_id?: string
        }
        Relationships: [
          {
            foreignKeyName: "one_time_tokens_user_id_fkey"
            columns: ["user_id"]
            isOneToOne: false
            referencedRelation: "users"
            referencedColumns: ["id"]
          },
        ]
      }
      refresh_tokens: {
        Row: {
          created_at: string | null
          id: number
          instance_id: string | null
          parent: string | null
          revoked: boolean | null
          session_id: string | null
          token: string | null
          updated_at: string | null
          user_id: string | null
        }
        Insert: {
          created_at?: string | null
          id?: number
          instance_id?: string | null
          parent?: string | null
          revoked?: boolean | null
          session_id?: string | null
          token?: string | null
          updated_at?: string | null
          user_id?: string | null
        }
        Update: {
          created_at?: string | null
          id?: number
          instance_id?: string | null
          parent?: string | null
          revoked?: boolean | null
          session_id?: string | null
          token?: string | null
          updated_at?: string | null
          user_id?: string | null
        }
        Relationships: [
          {
            foreignKeyName: "refresh_tokens_session_id_fkey"
            columns: ["session_id"]
            isOneToOne: false
            referencedRelation: "sessions"
            referencedColumns: ["id"]
          },
        ]
      }
      saml_providers: {
        Row: {
          attribute_mapping: Json | null
          created_at: string | null
          entity_id: string
          id: string
          metadata_url: string | null
          metadata_xml: string
          name_id_format: string | null
          sso_provider_id: string
          updated_at: string | null
        }
        Insert: {
          attribute_mapping?: Json | null
          created_at?: string | null
          entity_id: string
          id: string
          metadata_url?: string | null
          metadata_xml: string
          name_id_format?: string | null
          sso_provider_id: string
          updated_at?: string | null
        }
        Update: {
          attribute_mapping?: Json | null
          created_at?: string | null
          entity_id?: string
          id?: string
          metadata_url?: string | null
          metadata_xml?: string
          name_id_format?: string | null
          sso_provider_id?: string
          updated_at?: string | null
        }
        Relationships: [
          {
            foreignKeyName: "saml_providers_sso_provider_id_fkey"
            columns: ["sso_provider_id"]
            isOneToOne: false
            referencedRelation: "sso_providers"
            referencedColumns: ["id"]
          },
        ]
      }
      saml_relay_states: {
        Row: {
          created_at: string | null
          flow_state_id: string | null
          for_email: string | null
          id: string
          redirect_to: string | null
          request_id: string
          sso_provider_id: string
          updated_at: string | null
        }
        Insert: {
          created_at?: string | null
          flow_state_id?: string | null
          for_email?: string | null
          id: string
          redirect_to?: string | null
          request_id: string
          sso_provider_id: string
          updated_at?: string | null
        }
        Update: {
          created_at?: string | null
          flow_state_id?: string | null
          for_email?: string | null
          id?: string
          redirect_to?: string | null
          request_id?: string
          sso_provider_id?: string
          updated_at?: string | null
        }
        Relationships: [
          {
            foreignKeyName: "saml_relay_states_flow_state_id_fkey"
            columns: ["flow_state_id"]
            isOneToOne: false
            referencedRelation: "flow_state"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "saml_relay_states_sso_provider_id_fkey"
            columns: ["sso_provider_id"]
            isOneToOne: false
            referencedRelation: "sso_providers"
            referencedColumns: ["id"]
          },
        ]
      }
      schema_migrations: {
        Row: {
          version: string
        }
        Insert: {
          version: string
        }
        Update: {
          version?: string
        }
        Relationships: []
      }
      sessions: {
        Row: {
          aal: Database["auth"]["Enums"]["aal_level"] | null
          created_at: string | null
          factor_id: string | null
          id: string
          ip: unknown | null
          not_after: string | null
          refreshed_at: string | null
          tag: string | null
          updated_at: string | null
          user_agent: string | null
          user_id: string
        }
        Insert: {
          aal?: Database["auth"]["Enums"]["aal_level"] | null
          created_at?: string | null
          factor_id?: string | null
          id: string
          ip?: unknown | null
          not_after?: string | null
          refreshed_at?: string | null
          tag?: string | null
          updated_at?: string | null
          user_agent?: string | null
          user_id: string
        }
        Update: {
          aal?: Database["auth"]["Enums"]["aal_level"] | null
          created_at?: string | null
          factor_id?: string | null
          id?: string
          ip?: unknown | null
          not_after?: string | null
          refreshed_at?: string | null
          tag?: string | null
          updated_at?: string | null
          user_agent?: string | null
          user_id?: string
        }
        Relationships: [
          {
            foreignKeyName: "sessions_user_id_fkey"
            columns: ["user_id"]
            isOneToOne: false
            referencedRelation: "users"
            referencedColumns: ["id"]
          },
        ]
      }
      sso_domains: {
        Row: {
          created_at: string | null
          domain: string
          id: string
          sso_provider_id: string
          updated_at: string | null
        }
        Insert: {
          created_at?: string | null
          domain: string
          id: string
          sso_provider_id: string
          updated_at?: string | null
        }
        Update: {
          created_at?: string | null
          domain?: string
          id?: string
          sso_provider_id?: string
          updated_at?: string | null
        }
        Relationships: [
          {
            foreignKeyName: "sso_domains_sso_provider_id_fkey"
            columns: ["sso_provider_id"]
            isOneToOne: false
            referencedRelation: "sso_providers"
            referencedColumns: ["id"]
          },
        ]
      }
      sso_providers: {
        Row: {
          created_at: string | null
          disabled: boolean | null
          id: string
          resource_id: string | null
          updated_at: string | null
        }
        Insert: {
          created_at?: string | null
          disabled?: boolean | null
          id: string
          resource_id?: string | null
          updated_at?: string | null
        }
        Update: {
          created_at?: string | null
          disabled?: boolean | null
          id?: string
          resource_id?: string | null
          updated_at?: string | null
        }
        Relationships: []
      }
      users: {
        Row: {
          aud: string | null
          banned_until: string | null
          confirmation_sent_at: string | null
          confirmation_token: string | null
          confirmed_at: string | null
          created_at: string | null
          deleted_at: string | null
          email: string | null
          email_change: string | null
          email_change_confirm_status: number | null
          email_change_sent_at: string | null
          email_change_token_current: string | null
          email_change_token_new: string | null
          email_confirmed_at: string | null
          encrypted_password: string | null
          id: string
          instance_id: string | null
          invited_at: string | null
          is_anonymous: boolean
          is_sso_user: boolean
          is_super_admin: boolean | null
          last_sign_in_at: string | null
          phone: string | null
          phone_change: string | null
          phone_change_sent_at: string | null
          phone_change_token: string | null
          phone_confirmed_at: string | null
          raw_app_meta_data: Json | null
          raw_user_meta_data: Json | null
          reauthentication_sent_at: string | null
          reauthentication_token: string | null
          recovery_sent_at: string | null
          recovery_token: string | null
          role: string | null
          updated_at: string | null
        }
        Insert: {
          aud?: string | null
          banned_until?: string | null
          confirmation_sent_at?: string | null
          confirmation_token?: string | null
          confirmed_at?: string | null
          created_at?: string | null
          deleted_at?: string | null
          email?: string | null
          email_change?: string | null
          email_change_confirm_status?: number | null
          email_change_sent_at?: string | null
          email_change_token_current?: string | null
          email_change_token_new?: string | null
          email_confirmed_at?: string | null
          encrypted_password?: string | null
          id: string
          instance_id?: string | null
          invited_at?: string | null
          is_anonymous?: boolean
          is_sso_user?: boolean
          is_super_admin?: boolean | null
          last_sign_in_at?: string | null
          phone?: string | null
          phone_change?: string | null
          phone_change_sent_at?: string | null
          phone_change_token?: string | null
          phone_confirmed_at?: string | null
          raw_app_meta_data?: Json | null
          raw_user_meta_data?: Json | null
          reauthentication_sent_at?: string | null
          reauthentication_token?: string | null
          recovery_sent_at?: string | null
          recovery_token?: string | null
          role?: string | null
          updated_at?: string | null
        }
        Update: {
          aud?: string | null
          banned_until?: string | null
          confirmation_sent_at?: string | null
          confirmation_token?: string | null
          confirmed_at?: string | null
          created_at?: string | null
          deleted_at?: string | null
          email?: string | null
          email_change?: string | null
          email_change_confirm_status?: number | null
          email_change_sent_at?: string | null
          email_change_token_current?: string | null
          email_change_token_new?: string | null
          email_confirmed_at?: string | null
          encrypted_password?: string | null
          id?: string
          instance_id?: string | null
          invited_at?: string | null
          is_anonymous?: boolean
          is_sso_user?: boolean
          is_super_admin?: boolean | null
          last_sign_in_at?: string | null
          phone?: string | null
          phone_change?: string | null
          phone_change_sent_at?: string | null
          phone_change_token?: string | null
          phone_confirmed_at?: string | null
          raw_app_meta_data?: Json | null
          raw_user_meta_data?: Json | null
          reauthentication_sent_at?: string | null
          reauthentication_token?: string | null
          recovery_sent_at?: string | null
          recovery_token?: string | null
          role?: string | null
          updated_at?: string | null
        }
        Relationships: []
      }
    }
    Views: {
      [_ in never]: never
    }
    Functions: {
      email: {
        Args: Record<PropertyKey, never>
        Returns: string
      }
      jwt: {
        Args: Record<PropertyKey, never>
        Returns: Json
      }
      role: {
        Args: Record<PropertyKey, never>
        Returns: string
      }
      uid: {
        Args: Record<PropertyKey, never>
        Returns: string
      }
    }
    Enums: {
      aal_level: "aal1" | "aal2" | "aal3"
      code_challenge_method: "s256" | "plain"
      factor_status: "unverified" | "verified"
      factor_type: "totp" | "webauthn" | "phone"
      oauth_registration_type: "dynamic" | "manual"
      one_time_token_type:
        | "confirmation_token"
        | "reauthentication_token"
        | "recovery_token"
        | "email_change_token_new"
        | "email_change_token_current"
        | "phone_change_token"
    }
    CompositeTypes: {
      [_ in never]: never
    }
  }
  public: {
    Tables: {
      cable_segments: {
        Row: {
          created_at: string | null
          distance_km: number
          end_node_id: string
          end_node_type: string
          fiber_count: number
          id: string
          original_cable_id: string
          segment_order: number
          start_node_id: string
          start_node_type: string
          updated_at: string | null
        }
        Insert: {
          created_at?: string | null
          distance_km: number
          end_node_id: string
          end_node_type: string
          fiber_count: number
          id?: string
          original_cable_id: string
          segment_order: number
          start_node_id: string
          start_node_type: string
          updated_at?: string | null
        }
        Update: {
          created_at?: string | null
          distance_km?: number
          end_node_id?: string
          end_node_type?: string
          fiber_count?: number
          id?: string
          original_cable_id?: string
          segment_order?: number
          start_node_id?: string
          start_node_type?: string
          updated_at?: string | null
        }
        Relationships: [
          {
            foreignKeyName: "cable_segments_original_cable_id_fkey"
            columns: ["original_cable_id"]
            isOneToOne: false
            referencedRelation: "ofc_cables"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "cable_segments_original_cable_id_fkey"
            columns: ["original_cable_id"]
            isOneToOne: false
            referencedRelation: "v_cable_utilization"
            referencedColumns: ["cable_id"]
          },
          {
            foreignKeyName: "cable_segments_original_cable_id_fkey"
            columns: ["original_cable_id"]
            isOneToOne: false
            referencedRelation: "v_ofc_cables_complete"
            referencedColumns: ["id"]
          },
        ]
      }
      employee_designations: {
        Row: {
          created_at: string | null
          id: string
          name: string
          parent_id: string | null
          status: boolean | null
          updated_at: string | null
        }
        Insert: {
          created_at?: string | null
          id?: string
          name: string
          parent_id?: string | null
          status?: boolean | null
          updated_at?: string | null
        }
        Update: {
          created_at?: string | null
          id?: string
          name?: string
          parent_id?: string | null
          status?: boolean | null
          updated_at?: string | null
        }
        Relationships: [
          {
            foreignKeyName: "employee_designations_parent_id_fkey"
            columns: ["parent_id"]
            isOneToOne: false
            referencedRelation: "employee_designations"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "employee_designations_parent_id_fkey"
            columns: ["parent_id"]
            isOneToOne: false
            referencedRelation: "v_employee_designations"
            referencedColumns: ["id"]
          },
        ]
      }
      employees: {
        Row: {
          created_at: string | null
          employee_addr: string | null
          employee_contact: string | null
          employee_designation_id: string | null
          employee_dob: string | null
          employee_doj: string | null
          employee_email: string | null
          employee_name: string
          employee_pers_no: string | null
          id: string
          maintenance_terminal_id: string | null
          remark: string | null
          status: boolean | null
          updated_at: string | null
        }
        Insert: {
          created_at?: string | null
          employee_addr?: string | null
          employee_contact?: string | null
          employee_designation_id?: string | null
          employee_dob?: string | null
          employee_doj?: string | null
          employee_email?: string | null
          employee_name: string
          employee_pers_no?: string | null
          id?: string
          maintenance_terminal_id?: string | null
          remark?: string | null
          status?: boolean | null
          updated_at?: string | null
        }
        Update: {
          created_at?: string | null
          employee_addr?: string | null
          employee_contact?: string | null
          employee_designation_id?: string | null
          employee_dob?: string | null
          employee_doj?: string | null
          employee_email?: string | null
          employee_name?: string
          employee_pers_no?: string | null
          id?: string
          maintenance_terminal_id?: string | null
          remark?: string | null
          status?: boolean | null
          updated_at?: string | null
        }
        Relationships: [
          {
            foreignKeyName: "employees_employee_designation_id_fkey"
            columns: ["employee_designation_id"]
            isOneToOne: false
            referencedRelation: "employee_designations"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "employees_employee_designation_id_fkey"
            columns: ["employee_designation_id"]
            isOneToOne: false
            referencedRelation: "v_employee_designations"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "employees_maintenance_terminal_id_fkey"
            columns: ["maintenance_terminal_id"]
            isOneToOne: false
            referencedRelation: "maintenance_areas"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "employees_maintenance_terminal_id_fkey"
            columns: ["maintenance_terminal_id"]
            isOneToOne: false
            referencedRelation: "v_maintenance_areas"
            referencedColumns: ["id"]
          },
        ]
      }
      fiber_splices: {
        Row: {
          created_at: string | null
          id: string
          incoming_fiber_no: number
          incoming_segment_id: string
          jc_id: string
          logical_path_id: string | null
          loss_db: number | null
          outgoing_fiber_no: number | null
          outgoing_segment_id: string | null
          splice_type_id: string
          updated_at: string | null
        }
        Insert: {
          created_at?: string | null
          id?: string
          incoming_fiber_no: number
          incoming_segment_id: string
          jc_id: string
          logical_path_id?: string | null
          loss_db?: number | null
          outgoing_fiber_no?: number | null
          outgoing_segment_id?: string | null
          splice_type_id: string
          updated_at?: string | null
        }
        Update: {
          created_at?: string | null
          id?: string
          incoming_fiber_no?: number
          incoming_segment_id?: string
          jc_id?: string
          logical_path_id?: string | null
          loss_db?: number | null
          outgoing_fiber_no?: number | null
          outgoing_segment_id?: string | null
          splice_type_id?: string
          updated_at?: string | null
        }
        Relationships: [
          {
            foreignKeyName: "fiber_splices_incoming_segment_id_fkey"
            columns: ["incoming_segment_id"]
            isOneToOne: false
            referencedRelation: "cable_segments"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "fiber_splices_incoming_segment_id_fkey"
            columns: ["incoming_segment_id"]
            isOneToOne: false
            referencedRelation: "v_cable_segments_at_jc"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "fiber_splices_jc_id_fkey"
            columns: ["jc_id"]
            isOneToOne: false
            referencedRelation: "junction_closures"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "fiber_splices_jc_id_fkey"
            columns: ["jc_id"]
            isOneToOne: false
            referencedRelation: "v_junction_closures_complete"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "fiber_splices_logical_path_id_fkey"
            columns: ["logical_path_id"]
            isOneToOne: false
            referencedRelation: "logical_fiber_paths"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "fiber_splices_logical_path_id_fkey"
            columns: ["logical_path_id"]
            isOneToOne: false
            referencedRelation: "v_end_to_end_paths"
            referencedColumns: ["path_id"]
          },
          {
            foreignKeyName: "fiber_splices_outgoing_segment_id_fkey"
            columns: ["outgoing_segment_id"]
            isOneToOne: false
            referencedRelation: "cable_segments"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "fiber_splices_outgoing_segment_id_fkey"
            columns: ["outgoing_segment_id"]
            isOneToOne: false
            referencedRelation: "v_cable_segments_at_jc"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "fiber_splices_splice_type_id_fkey"
            columns: ["splice_type_id"]
            isOneToOne: false
            referencedRelation: "lookup_types"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "fiber_splices_splice_type_id_fkey"
            columns: ["splice_type_id"]
            isOneToOne: false
            referencedRelation: "v_lookup_types"
            referencedColumns: ["id"]
          },
        ]
      }
      files: {
        Row: {
          file_name: string
          file_route: string
          file_size: string
          file_type: string
          file_url: string
          folder_id: string | null
          id: string
          uploaded_at: string | null
          user_id: string
        }
        Insert: {
          file_name: string
          file_route: string
          file_size: string
          file_type: string
          file_url: string
          folder_id?: string | null
          id?: string
          uploaded_at?: string | null
          user_id: string
        }
        Update: {
          file_name?: string
          file_route?: string
          file_size?: string
          file_type?: string
          file_url?: string
          folder_id?: string | null
          id?: string
          uploaded_at?: string | null
          user_id?: string
        }
        Relationships: [
          {
            foreignKeyName: "files_folder_id_fkey"
            columns: ["folder_id"]
            isOneToOne: false
            referencedRelation: "folders"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "files_user_id_fkey"
            columns: ["user_id"]
            isOneToOne: false
            referencedRelation: "v_user_profiles_extended"
            referencedColumns: ["id"]
          },
        ]
      }
      folders: {
        Row: {
          created_at: string | null
          id: string
          name: string
          user_id: string
        }
        Insert: {
          created_at?: string | null
          id?: string
          name: string
          user_id: string
        }
        Update: {
          created_at?: string | null
          id?: string
          name?: string
          user_id?: string
        }
        Relationships: [
          {
            foreignKeyName: "folders_user_id_fkey"
            columns: ["user_id"]
            isOneToOne: false
            referencedRelation: "v_user_profiles_extended"
            referencedColumns: ["id"]
          },
        ]
      }
      junction_closures: {
        Row: {
          created_at: string | null
          id: string
          node_id: string
          ofc_cable_id: string
          position_km: number | null
          updated_at: string | null
        }
        Insert: {
          created_at?: string | null
          id?: string
          node_id: string
          ofc_cable_id: string
          position_km?: number | null
          updated_at?: string | null
        }
        Update: {
          created_at?: string | null
          id?: string
          node_id?: string
          ofc_cable_id?: string
          position_km?: number | null
          updated_at?: string | null
        }
        Relationships: [
          {
            foreignKeyName: "junction_closures_node_id_fkey"
            columns: ["node_id"]
            isOneToOne: false
            referencedRelation: "nodes"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "junction_closures_node_id_fkey"
            columns: ["node_id"]
            isOneToOne: false
            referencedRelation: "v_nodes_complete"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "junction_closures_node_id_fkey"
            columns: ["node_id"]
            isOneToOne: false
            referencedRelation: "v_ring_nodes"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "junction_closures_ofc_cable_id_fkey"
            columns: ["ofc_cable_id"]
            isOneToOne: false
            referencedRelation: "ofc_cables"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "junction_closures_ofc_cable_id_fkey"
            columns: ["ofc_cable_id"]
            isOneToOne: false
            referencedRelation: "v_cable_utilization"
            referencedColumns: ["cable_id"]
          },
          {
            foreignKeyName: "junction_closures_ofc_cable_id_fkey"
            columns: ["ofc_cable_id"]
            isOneToOne: false
            referencedRelation: "v_ofc_cables_complete"
            referencedColumns: ["id"]
          },
        ]
      }
      logical_fiber_paths: {
        Row: {
          bandwidth_gbps: number | null
          commissioned_date: string | null
          created_at: string | null
          destination_port: string | null
          destination_system_id: string | null
          id: string
          operational_status_id: string | null
          path_name: string | null
          path_role: string
          path_type_id: string | null
          remark: string | null
          service_type: string | null
          source_port: string | null
          source_system_id: string | null
          total_distance_km: number | null
          total_loss_db: number | null
          updated_at: string | null
          wavelength_nm: number | null
          working_path_id: string | null
        }
        Insert: {
          bandwidth_gbps?: number | null
          commissioned_date?: string | null
          created_at?: string | null
          destination_port?: string | null
          destination_system_id?: string | null
          id?: string
          operational_status_id?: string | null
          path_name?: string | null
          path_role?: string
          path_type_id?: string | null
          remark?: string | null
          service_type?: string | null
          source_port?: string | null
          source_system_id?: string | null
          total_distance_km?: number | null
          total_loss_db?: number | null
          updated_at?: string | null
          wavelength_nm?: number | null
          working_path_id?: string | null
        }
        Update: {
          bandwidth_gbps?: number | null
          commissioned_date?: string | null
          created_at?: string | null
          destination_port?: string | null
          destination_system_id?: string | null
          id?: string
          operational_status_id?: string | null
          path_name?: string | null
          path_role?: string
          path_type_id?: string | null
          remark?: string | null
          service_type?: string | null
          source_port?: string | null
          source_system_id?: string | null
          total_distance_km?: number | null
          total_loss_db?: number | null
          updated_at?: string | null
          wavelength_nm?: number | null
          working_path_id?: string | null
        }
        Relationships: [
          {
            foreignKeyName: "fk_lfp_destination_system"
            columns: ["destination_system_id"]
            isOneToOne: false
            referencedRelation: "systems"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "fk_lfp_destination_system"
            columns: ["destination_system_id"]
            isOneToOne: false
            referencedRelation: "v_systems_complete"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "fk_lfp_source_system"
            columns: ["source_system_id"]
            isOneToOne: false
            referencedRelation: "systems"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "fk_lfp_source_system"
            columns: ["source_system_id"]
            isOneToOne: false
            referencedRelation: "v_systems_complete"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "logical_fiber_paths_operational_status_id_fkey"
            columns: ["operational_status_id"]
            isOneToOne: false
            referencedRelation: "lookup_types"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "logical_fiber_paths_operational_status_id_fkey"
            columns: ["operational_status_id"]
            isOneToOne: false
            referencedRelation: "v_lookup_types"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "logical_fiber_paths_path_type_id_fkey"
            columns: ["path_type_id"]
            isOneToOne: false
            referencedRelation: "lookup_types"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "logical_fiber_paths_path_type_id_fkey"
            columns: ["path_type_id"]
            isOneToOne: false
            referencedRelation: "v_lookup_types"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "logical_fiber_paths_working_path_id_fkey"
            columns: ["working_path_id"]
            isOneToOne: false
            referencedRelation: "logical_fiber_paths"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "logical_fiber_paths_working_path_id_fkey"
            columns: ["working_path_id"]
            isOneToOne: false
            referencedRelation: "v_end_to_end_paths"
            referencedColumns: ["path_id"]
          },
        ]
      }
      logical_path_segments: {
        Row: {
          created_at: string | null
          id: string
          logical_path_id: string
          ofc_cable_id: string | null
          path_order: number
          updated_at: string | null
        }
        Insert: {
          created_at?: string | null
          id?: string
          logical_path_id: string
          ofc_cable_id?: string | null
          path_order: number
          updated_at?: string | null
        }
        Update: {
          created_at?: string | null
          id?: string
          logical_path_id?: string
          ofc_cable_id?: string | null
          path_order?: number
          updated_at?: string | null
        }
        Relationships: [
          {
            foreignKeyName: "logical_path_segments_logical_path_id_fkey"
            columns: ["logical_path_id"]
            isOneToOne: false
            referencedRelation: "logical_fiber_paths"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "logical_path_segments_logical_path_id_fkey"
            columns: ["logical_path_id"]
            isOneToOne: false
            referencedRelation: "v_end_to_end_paths"
            referencedColumns: ["path_id"]
          },
          {
            foreignKeyName: "logical_path_segments_ofc_cable_id_fkey"
            columns: ["ofc_cable_id"]
            isOneToOne: false
            referencedRelation: "ofc_cables"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "logical_path_segments_ofc_cable_id_fkey"
            columns: ["ofc_cable_id"]
            isOneToOne: false
            referencedRelation: "v_cable_utilization"
            referencedColumns: ["cable_id"]
          },
          {
            foreignKeyName: "logical_path_segments_ofc_cable_id_fkey"
            columns: ["ofc_cable_id"]
            isOneToOne: false
            referencedRelation: "v_ofc_cables_complete"
            referencedColumns: ["id"]
          },
        ]
      }
      lookup_types: {
        Row: {
          category: string
          code: string | null
          created_at: string | null
          description: string | null
          id: string
          is_system_default: boolean | null
          name: string
          sort_order: number | null
          status: boolean | null
          updated_at: string | null
        }
        Insert: {
          category: string
          code?: string | null
          created_at?: string | null
          description?: string | null
          id?: string
          is_system_default?: boolean | null
          name: string
          sort_order?: number | null
          status?: boolean | null
          updated_at?: string | null
        }
        Update: {
          category?: string
          code?: string | null
          created_at?: string | null
          description?: string | null
          id?: string
          is_system_default?: boolean | null
          name?: string
          sort_order?: number | null
          status?: boolean | null
          updated_at?: string | null
        }
        Relationships: []
      }
      maintenance_areas: {
        Row: {
          address: string | null
          area_type_id: string | null
          code: string | null
          contact_number: string | null
          contact_person: string | null
          created_at: string | null
          email: string | null
          id: string
          latitude: number | null
          longitude: number | null
          name: string
          parent_id: string | null
          status: boolean | null
          updated_at: string | null
        }
        Insert: {
          address?: string | null
          area_type_id?: string | null
          code?: string | null
          contact_number?: string | null
          contact_person?: string | null
          created_at?: string | null
          email?: string | null
          id?: string
          latitude?: number | null
          longitude?: number | null
          name: string
          parent_id?: string | null
          status?: boolean | null
          updated_at?: string | null
        }
        Update: {
          address?: string | null
          area_type_id?: string | null
          code?: string | null
          contact_number?: string | null
          contact_person?: string | null
          created_at?: string | null
          email?: string | null
          id?: string
          latitude?: number | null
          longitude?: number | null
          name?: string
          parent_id?: string | null
          status?: boolean | null
          updated_at?: string | null
        }
        Relationships: [
          {
            foreignKeyName: "maintenance_areas_area_type_id_fkey"
            columns: ["area_type_id"]
            isOneToOne: false
            referencedRelation: "lookup_types"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "maintenance_areas_area_type_id_fkey"
            columns: ["area_type_id"]
            isOneToOne: false
            referencedRelation: "v_lookup_types"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "maintenance_areas_parent_id_fkey"
            columns: ["parent_id"]
            isOneToOne: false
            referencedRelation: "maintenance_areas"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "maintenance_areas_parent_id_fkey"
            columns: ["parent_id"]
            isOneToOne: false
            referencedRelation: "v_maintenance_areas"
            referencedColumns: ["id"]
          },
        ]
      }
      management_ports: {
        Row: {
          commissioned_on: string | null
          created_at: string | null
          id: string
          name: string | null
          node_id: string | null
          port_no: string
          remark: string | null
          status: boolean | null
          system_id: string | null
          updated_at: string | null
        }
        Insert: {
          commissioned_on?: string | null
          created_at?: string | null
          id?: string
          name?: string | null
          node_id?: string | null
          port_no: string
          remark?: string | null
          status?: boolean | null
          system_id?: string | null
          updated_at?: string | null
        }
        Update: {
          commissioned_on?: string | null
          created_at?: string | null
          id?: string
          name?: string | null
          node_id?: string | null
          port_no?: string
          remark?: string | null
          status?: boolean | null
          system_id?: string | null
          updated_at?: string | null
        }
        Relationships: [
          {
            foreignKeyName: "management_ports_node_id_fkey"
            columns: ["node_id"]
            isOneToOne: false
            referencedRelation: "nodes"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "management_ports_node_id_fkey"
            columns: ["node_id"]
            isOneToOne: false
            referencedRelation: "v_nodes_complete"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "management_ports_node_id_fkey"
            columns: ["node_id"]
            isOneToOne: false
            referencedRelation: "v_ring_nodes"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "management_ports_system_id_fkey"
            columns: ["system_id"]
            isOneToOne: false
            referencedRelation: "systems"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "management_ports_system_id_fkey"
            columns: ["system_id"]
            isOneToOne: false
            referencedRelation: "v_systems_complete"
            referencedColumns: ["id"]
          },
        ]
      }
      nodes: {
        Row: {
          created_at: string | null
          id: string
          latitude: number | null
          longitude: number | null
          maintenance_terminal_id: string | null
          name: string
          node_type_id: string | null
          remark: string | null
          status: boolean | null
          updated_at: string | null
        }
        Insert: {
          created_at?: string | null
          id?: string
          latitude?: number | null
          longitude?: number | null
          maintenance_terminal_id?: string | null
          name: string
          node_type_id?: string | null
          remark?: string | null
          status?: boolean | null
          updated_at?: string | null
        }
        Update: {
          created_at?: string | null
          id?: string
          latitude?: number | null
          longitude?: number | null
          maintenance_terminal_id?: string | null
          name?: string
          node_type_id?: string | null
          remark?: string | null
          status?: boolean | null
          updated_at?: string | null
        }
        Relationships: [
          {
            foreignKeyName: "nodes_maintenance_terminal_id_fkey"
            columns: ["maintenance_terminal_id"]
            isOneToOne: false
            referencedRelation: "maintenance_areas"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "nodes_maintenance_terminal_id_fkey"
            columns: ["maintenance_terminal_id"]
            isOneToOne: false
            referencedRelation: "v_maintenance_areas"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "nodes_node_type_id_fkey"
            columns: ["node_type_id"]
            isOneToOne: false
            referencedRelation: "lookup_types"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "nodes_node_type_id_fkey"
            columns: ["node_type_id"]
            isOneToOne: false
            referencedRelation: "v_lookup_types"
            referencedColumns: ["id"]
          },
        ]
      }
      ofc_cables: {
        Row: {
          asset_no: string | null
          capacity: number
          commissioned_on: string | null
          created_at: string | null
          current_rkm: number | null
          en_id: string
          id: string
          maintenance_terminal_id: string | null
          ofc_owner_id: string
          ofc_type_id: string
          remark: string | null
          route_name: string
          sn_id: string
          status: boolean | null
          transnet_id: string | null
          transnet_rkm: number | null
          updated_at: string | null
        }
        Insert: {
          asset_no?: string | null
          capacity: number
          commissioned_on?: string | null
          created_at?: string | null
          current_rkm?: number | null
          en_id: string
          id?: string
          maintenance_terminal_id?: string | null
          ofc_owner_id: string
          ofc_type_id: string
          remark?: string | null
          route_name: string
          sn_id: string
          status?: boolean | null
          transnet_id?: string | null
          transnet_rkm?: number | null
          updated_at?: string | null
        }
        Update: {
          asset_no?: string | null
          capacity?: number
          commissioned_on?: string | null
          created_at?: string | null
          current_rkm?: number | null
          en_id?: string
          id?: string
          maintenance_terminal_id?: string | null
          ofc_owner_id?: string
          ofc_type_id?: string
          remark?: string | null
          route_name?: string
          sn_id?: string
          status?: boolean | null
          transnet_id?: string | null
          transnet_rkm?: number | null
          updated_at?: string | null
        }
        Relationships: [
          {
            foreignKeyName: "ofc_cables_en_id_fkey"
            columns: ["en_id"]
            isOneToOne: false
            referencedRelation: "nodes"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "ofc_cables_en_id_fkey"
            columns: ["en_id"]
            isOneToOne: false
            referencedRelation: "v_nodes_complete"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "ofc_cables_en_id_fkey"
            columns: ["en_id"]
            isOneToOne: false
            referencedRelation: "v_ring_nodes"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "ofc_cables_maintenance_terminal_id_fkey"
            columns: ["maintenance_terminal_id"]
            isOneToOne: false
            referencedRelation: "maintenance_areas"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "ofc_cables_maintenance_terminal_id_fkey"
            columns: ["maintenance_terminal_id"]
            isOneToOne: false
            referencedRelation: "v_maintenance_areas"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "ofc_cables_ofc_owner_id_fkey"
            columns: ["ofc_owner_id"]
            isOneToOne: false
            referencedRelation: "lookup_types"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "ofc_cables_ofc_owner_id_fkey"
            columns: ["ofc_owner_id"]
            isOneToOne: false
            referencedRelation: "v_lookup_types"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "ofc_cables_ofc_type_id_fkey"
            columns: ["ofc_type_id"]
            isOneToOne: false
            referencedRelation: "lookup_types"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "ofc_cables_ofc_type_id_fkey"
            columns: ["ofc_type_id"]
            isOneToOne: false
            referencedRelation: "v_lookup_types"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "ofc_cables_sn_id_fkey"
            columns: ["sn_id"]
            isOneToOne: false
            referencedRelation: "nodes"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "ofc_cables_sn_id_fkey"
            columns: ["sn_id"]
            isOneToOne: false
            referencedRelation: "v_nodes_complete"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "ofc_cables_sn_id_fkey"
            columns: ["sn_id"]
            isOneToOne: false
            referencedRelation: "v_ring_nodes"
            referencedColumns: ["id"]
          },
        ]
      }
      ofc_connections: {
        Row: {
          connection_category: string
          connection_type: string
          created_at: string | null
          destination_port: string | null
          en_dom: string | null
          en_power_dbm: number | null
          fiber_no_en: number
          fiber_no_sn: number
          fiber_role: string | null
          id: string
          logical_path_id: string | null
          ofc_id: string
          otdr_distance_en_km: number | null
          otdr_distance_sn_km: number | null
          path_segment_order: number | null
          remark: string | null
          route_loss_db: number | null
          sn_dom: string | null
          sn_power_dbm: number | null
          source_port: string | null
          status: boolean | null
          system_id: string | null
          updated_at: string | null
          updated_en_id: string | null
          updated_fiber_no_en: number | null
          updated_fiber_no_sn: number | null
          updated_sn_id: string | null
        }
        Insert: {
          connection_category?: string
          connection_type?: string
          created_at?: string | null
          destination_port?: string | null
          en_dom?: string | null
          en_power_dbm?: number | null
          fiber_no_en: number
          fiber_no_sn: number
          fiber_role?: string | null
          id?: string
          logical_path_id?: string | null
          ofc_id: string
          otdr_distance_en_km?: number | null
          otdr_distance_sn_km?: number | null
          path_segment_order?: number | null
          remark?: string | null
          route_loss_db?: number | null
          sn_dom?: string | null
          sn_power_dbm?: number | null
          source_port?: string | null
          status?: boolean | null
          system_id?: string | null
          updated_at?: string | null
          updated_en_id?: string | null
          updated_fiber_no_en?: number | null
          updated_fiber_no_sn?: number | null
          updated_sn_id?: string | null
        }
        Update: {
          connection_category?: string
          connection_type?: string
          created_at?: string | null
          destination_port?: string | null
          en_dom?: string | null
          en_power_dbm?: number | null
          fiber_no_en?: number
          fiber_no_sn?: number
          fiber_role?: string | null
          id?: string
          logical_path_id?: string | null
          ofc_id?: string
          otdr_distance_en_km?: number | null
          otdr_distance_sn_km?: number | null
          path_segment_order?: number | null
          remark?: string | null
          route_loss_db?: number | null
          sn_dom?: string | null
          sn_power_dbm?: number | null
          source_port?: string | null
          status?: boolean | null
          system_id?: string | null
          updated_at?: string | null
          updated_en_id?: string | null
          updated_fiber_no_en?: number | null
          updated_fiber_no_sn?: number | null
          updated_sn_id?: string | null
        }
        Relationships: [
          {
            foreignKeyName: "fk_connection_type"
            columns: ["connection_category", "connection_type"]
            isOneToOne: false
            referencedRelation: "lookup_types"
            referencedColumns: ["category", "name"]
          },
          {
            foreignKeyName: "fk_connection_type"
            columns: ["connection_category", "connection_type"]
            isOneToOne: false
            referencedRelation: "v_lookup_types"
            referencedColumns: ["category", "name"]
          },
          {
            foreignKeyName: "fk_connection_type"
            columns: ["connection_category", "connection_type"]
            isOneToOne: false
            referencedRelation: "v_systems_complete"
            referencedColumns: ["system_category", "node_type_name"]
          },
          {
            foreignKeyName: "fk_connection_type"
            columns: ["connection_category", "connection_type"]
            isOneToOne: false
            referencedRelation: "v_systems_complete"
            referencedColumns: ["system_category", "system_type_name"]
          },
          {
            foreignKeyName: "fk_ofc_connections_logical_path"
            columns: ["logical_path_id"]
            isOneToOne: false
            referencedRelation: "logical_fiber_paths"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "fk_ofc_connections_logical_path"
            columns: ["logical_path_id"]
            isOneToOne: false
            referencedRelation: "v_end_to_end_paths"
            referencedColumns: ["path_id"]
          },
          {
            foreignKeyName: "fk_ofc_connections_system"
            columns: ["system_id"]
            isOneToOne: false
            referencedRelation: "systems"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "fk_ofc_connections_system"
            columns: ["system_id"]
            isOneToOne: false
            referencedRelation: "v_systems_complete"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "ofc_connections_ofc_id_fkey"
            columns: ["ofc_id"]
            isOneToOne: false
            referencedRelation: "ofc_cables"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "ofc_connections_ofc_id_fkey"
            columns: ["ofc_id"]
            isOneToOne: false
            referencedRelation: "v_cable_utilization"
            referencedColumns: ["cable_id"]
          },
          {
            foreignKeyName: "ofc_connections_ofc_id_fkey"
            columns: ["ofc_id"]
            isOneToOne: false
            referencedRelation: "v_ofc_cables_complete"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "ofc_connections_updated_en_id_fkey"
            columns: ["updated_en_id"]
            isOneToOne: false
            referencedRelation: "nodes"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "ofc_connections_updated_en_id_fkey"
            columns: ["updated_en_id"]
            isOneToOne: false
            referencedRelation: "v_nodes_complete"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "ofc_connections_updated_en_id_fkey"
            columns: ["updated_en_id"]
            isOneToOne: false
            referencedRelation: "v_ring_nodes"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "ofc_connections_updated_sn_id_fkey"
            columns: ["updated_sn_id"]
            isOneToOne: false
            referencedRelation: "nodes"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "ofc_connections_updated_sn_id_fkey"
            columns: ["updated_sn_id"]
            isOneToOne: false
            referencedRelation: "v_nodes_complete"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "ofc_connections_updated_sn_id_fkey"
            columns: ["updated_sn_id"]
            isOneToOne: false
            referencedRelation: "v_ring_nodes"
            referencedColumns: ["id"]
          },
        ]
      }
      ring_based_systems: {
        Row: {
          maintenance_area_id: string | null
          ring_id: string | null
          system_id: string
        }
        Insert: {
          maintenance_area_id?: string | null
          ring_id?: string | null
          system_id: string
        }
        Update: {
          maintenance_area_id?: string | null
          ring_id?: string | null
          system_id?: string
        }
        Relationships: [
          {
            foreignKeyName: "ring_based_systems_maintenance_area_id_fkey"
            columns: ["maintenance_area_id"]
            isOneToOne: false
            referencedRelation: "maintenance_areas"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "ring_based_systems_maintenance_area_id_fkey"
            columns: ["maintenance_area_id"]
            isOneToOne: false
            referencedRelation: "v_maintenance_areas"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "ring_based_systems_ring_id_fkey"
            columns: ["ring_id"]
            isOneToOne: false
            referencedRelation: "rings"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "ring_based_systems_ring_id_fkey"
            columns: ["ring_id"]
            isOneToOne: false
            referencedRelation: "v_ring_nodes"
            referencedColumns: ["ring_id"]
          },
          {
            foreignKeyName: "ring_based_systems_ring_id_fkey"
            columns: ["ring_id"]
            isOneToOne: false
            referencedRelation: "v_rings"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "ring_based_systems_system_id_fkey"
            columns: ["system_id"]
            isOneToOne: true
            referencedRelation: "systems"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "ring_based_systems_system_id_fkey"
            columns: ["system_id"]
            isOneToOne: true
            referencedRelation: "v_systems_complete"
            referencedColumns: ["id"]
          },
        ]
      }
      rings: {
        Row: {
          created_at: string | null
          description: string | null
          id: string
          maintenance_terminal_id: string | null
          name: string
          ring_type_id: string | null
          status: boolean | null
          total_nodes: number | null
          updated_at: string | null
        }
        Insert: {
          created_at?: string | null
          description?: string | null
          id?: string
          maintenance_terminal_id?: string | null
          name: string
          ring_type_id?: string | null
          status?: boolean | null
          total_nodes?: number | null
          updated_at?: string | null
        }
        Update: {
          created_at?: string | null
          description?: string | null
          id?: string
          maintenance_terminal_id?: string | null
          name?: string
          ring_type_id?: string | null
          status?: boolean | null
          total_nodes?: number | null
          updated_at?: string | null
        }
        Relationships: [
          {
            foreignKeyName: "rings_maintenance_terminal_id_fkey"
            columns: ["maintenance_terminal_id"]
            isOneToOne: false
            referencedRelation: "maintenance_areas"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "rings_maintenance_terminal_id_fkey"
            columns: ["maintenance_terminal_id"]
            isOneToOne: false
            referencedRelation: "v_maintenance_areas"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "rings_ring_type_id_fkey"
            columns: ["ring_type_id"]
            isOneToOne: false
            referencedRelation: "lookup_types"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "rings_ring_type_id_fkey"
            columns: ["ring_type_id"]
            isOneToOne: false
            referencedRelation: "v_lookup_types"
            referencedColumns: ["id"]
          },
        ]
      }
      sdh_connections: {
        Row: {
          a_customer: string | null
          a_slot: string | null
          b_customer: string | null
          b_slot: string | null
          carrier: string | null
          stm_no: string | null
          system_connection_id: string
        }
        Insert: {
          a_customer?: string | null
          a_slot?: string | null
          b_customer?: string | null
          b_slot?: string | null
          carrier?: string | null
          stm_no?: string | null
          system_connection_id: string
        }
        Update: {
          a_customer?: string | null
          a_slot?: string | null
          b_customer?: string | null
          b_slot?: string | null
          carrier?: string | null
          stm_no?: string | null
          system_connection_id?: string
        }
        Relationships: [
          {
            foreignKeyName: "sdh_connections_system_connection_id_fkey"
            columns: ["system_connection_id"]
            isOneToOne: true
            referencedRelation: "system_connections"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "sdh_connections_system_connection_id_fkey"
            columns: ["system_connection_id"]
            isOneToOne: true
            referencedRelation: "v_system_connections_complete"
            referencedColumns: ["id"]
          },
        ]
      }
      sdh_node_associations: {
        Row: {
          id: string
          node_id: string
          node_ip: unknown | null
          node_position: string | null
          sdh_system_id: string
        }
        Insert: {
          id?: string
          node_id: string
          node_ip?: unknown | null
          node_position?: string | null
          sdh_system_id: string
        }
        Update: {
          id?: string
          node_id?: string
          node_ip?: unknown | null
          node_position?: string | null
          sdh_system_id?: string
        }
        Relationships: [
          {
            foreignKeyName: "sdh_node_associations_node_id_fkey"
            columns: ["node_id"]
            isOneToOne: false
            referencedRelation: "nodes"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "sdh_node_associations_node_id_fkey"
            columns: ["node_id"]
            isOneToOne: false
            referencedRelation: "v_nodes_complete"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "sdh_node_associations_node_id_fkey"
            columns: ["node_id"]
            isOneToOne: false
            referencedRelation: "v_ring_nodes"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "sdh_node_associations_sdh_system_id_fkey"
            columns: ["sdh_system_id"]
            isOneToOne: false
            referencedRelation: "sdh_systems"
            referencedColumns: ["system_id"]
          },
        ]
      }
      sdh_systems: {
        Row: {
          gne: string | null
          system_id: string
        }
        Insert: {
          gne?: string | null
          system_id: string
        }
        Update: {
          gne?: string | null
          system_id?: string
        }
        Relationships: [
          {
            foreignKeyName: "sdh_systems_system_id_fkey"
            columns: ["system_id"]
            isOneToOne: true
            referencedRelation: "systems"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "sdh_systems_system_id_fkey"
            columns: ["system_id"]
            isOneToOne: true
            referencedRelation: "v_systems_complete"
            referencedColumns: ["id"]
          },
        ]
      }
      sfp_based_connections: {
        Row: {
          bandwidth_allocated_mbps: number | null
          customer_name: string | null
          fiber_in: number | null
          fiber_out: number | null
          sfp_capacity: string | null
          sfp_port: string | null
          sfp_serial_no: string | null
          sfp_type_id: string | null
          system_connection_id: string
        }
        Insert: {
          bandwidth_allocated_mbps?: number | null
          customer_name?: string | null
          fiber_in?: number | null
          fiber_out?: number | null
          sfp_capacity?: string | null
          sfp_port?: string | null
          sfp_serial_no?: string | null
          sfp_type_id?: string | null
          system_connection_id: string
        }
        Update: {
          bandwidth_allocated_mbps?: number | null
          customer_name?: string | null
          fiber_in?: number | null
          fiber_out?: number | null
          sfp_capacity?: string | null
          sfp_port?: string | null
          sfp_serial_no?: string | null
          sfp_type_id?: string | null
          system_connection_id?: string
        }
        Relationships: [
          {
            foreignKeyName: "sfp_based_connections_sfp_type_id_fkey"
            columns: ["sfp_type_id"]
            isOneToOne: false
            referencedRelation: "lookup_types"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "sfp_based_connections_sfp_type_id_fkey"
            columns: ["sfp_type_id"]
            isOneToOne: false
            referencedRelation: "v_lookup_types"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "sfp_based_connections_system_connection_id_fkey"
            columns: ["system_connection_id"]
            isOneToOne: true
            referencedRelation: "system_connections"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "sfp_based_connections_system_connection_id_fkey"
            columns: ["system_connection_id"]
            isOneToOne: true
            referencedRelation: "v_system_connections_complete"
            referencedColumns: ["id"]
          },
        ]
      }
      system_connections: {
        Row: {
          bandwidth_mbps: number | null
          commissioned_on: string | null
          connected_system_id: string | null
          created_at: string | null
          en_id: string | null
          en_interface: string | null
          en_ip: unknown | null
          id: string
          media_type_id: string | null
          remark: string | null
          sn_id: string | null
          sn_interface: string | null
          sn_ip: unknown | null
          status: boolean | null
          system_id: string
          updated_at: string | null
          vlan: string | null
        }
        Insert: {
          bandwidth_mbps?: number | null
          commissioned_on?: string | null
          connected_system_id?: string | null
          created_at?: string | null
          en_id?: string | null
          en_interface?: string | null
          en_ip?: unknown | null
          id?: string
          media_type_id?: string | null
          remark?: string | null
          sn_id?: string | null
          sn_interface?: string | null
          sn_ip?: unknown | null
          status?: boolean | null
          system_id: string
          updated_at?: string | null
          vlan?: string | null
        }
        Update: {
          bandwidth_mbps?: number | null
          commissioned_on?: string | null
          connected_system_id?: string | null
          created_at?: string | null
          en_id?: string | null
          en_interface?: string | null
          en_ip?: unknown | null
          id?: string
          media_type_id?: string | null
          remark?: string | null
          sn_id?: string | null
          sn_interface?: string | null
          sn_ip?: unknown | null
          status?: boolean | null
          system_id?: string
          updated_at?: string | null
          vlan?: string | null
        }
        Relationships: [
          {
            foreignKeyName: "system_connections_connected_system_id_fkey"
            columns: ["connected_system_id"]
            isOneToOne: false
            referencedRelation: "systems"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "system_connections_connected_system_id_fkey"
            columns: ["connected_system_id"]
            isOneToOne: false
            referencedRelation: "v_systems_complete"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "system_connections_en_id_fkey"
            columns: ["en_id"]
            isOneToOne: false
            referencedRelation: "systems"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "system_connections_en_id_fkey"
            columns: ["en_id"]
            isOneToOne: false
            referencedRelation: "v_systems_complete"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "system_connections_media_type_id_fkey"
            columns: ["media_type_id"]
            isOneToOne: false
            referencedRelation: "lookup_types"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "system_connections_media_type_id_fkey"
            columns: ["media_type_id"]
            isOneToOne: false
            referencedRelation: "v_lookup_types"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "system_connections_sn_id_fkey"
            columns: ["sn_id"]
            isOneToOne: false
            referencedRelation: "systems"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "system_connections_sn_id_fkey"
            columns: ["sn_id"]
            isOneToOne: false
            referencedRelation: "v_systems_complete"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "system_connections_system_id_fkey"
            columns: ["system_id"]
            isOneToOne: false
            referencedRelation: "systems"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "system_connections_system_id_fkey"
            columns: ["system_id"]
            isOneToOne: false
            referencedRelation: "v_systems_complete"
            referencedColumns: ["id"]
          },
        ]
      }
      systems: {
        Row: {
          commissioned_on: string | null
          created_at: string | null
          id: string
          ip_address: unknown | null
          maintenance_terminal_id: string | null
          make: string | null
          node_id: string
          remark: string | null
          s_no: string | null
          status: boolean | null
          system_name: string | null
          system_type_id: string
          updated_at: string | null
        }
        Insert: {
          commissioned_on?: string | null
          created_at?: string | null
          id?: string
          ip_address?: unknown | null
          maintenance_terminal_id?: string | null
          make?: string | null
          node_id: string
          remark?: string | null
          s_no?: string | null
          status?: boolean | null
          system_name?: string | null
          system_type_id: string
          updated_at?: string | null
        }
        Update: {
          commissioned_on?: string | null
          created_at?: string | null
          id?: string
          ip_address?: unknown | null
          maintenance_terminal_id?: string | null
          make?: string | null
          node_id?: string
          remark?: string | null
          s_no?: string | null
          status?: boolean | null
          system_name?: string | null
          system_type_id?: string
          updated_at?: string | null
        }
        Relationships: [
          {
            foreignKeyName: "systems_maintenance_terminal_id_fkey"
            columns: ["maintenance_terminal_id"]
            isOneToOne: false
            referencedRelation: "maintenance_areas"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "systems_maintenance_terminal_id_fkey"
            columns: ["maintenance_terminal_id"]
            isOneToOne: false
            referencedRelation: "v_maintenance_areas"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "systems_node_id_fkey"
            columns: ["node_id"]
            isOneToOne: false
            referencedRelation: "nodes"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "systems_node_id_fkey"
            columns: ["node_id"]
            isOneToOne: false
            referencedRelation: "v_nodes_complete"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "systems_node_id_fkey"
            columns: ["node_id"]
            isOneToOne: false
            referencedRelation: "v_ring_nodes"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "systems_system_type_id_fkey"
            columns: ["system_type_id"]
            isOneToOne: false
            referencedRelation: "lookup_types"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "systems_system_type_id_fkey"
            columns: ["system_type_id"]
            isOneToOne: false
            referencedRelation: "v_lookup_types"
            referencedColumns: ["id"]
          },
        ]
      }
      user_profiles: {
        Row: {
          address: Json | null
          avatar_url: string | null
          created_at: string | null
          date_of_birth: string | null
          designation: string | null
          first_name: string
          id: string
          last_name: string
          phone_number: string | null
          preferences: Json | null
          role: string | null
          status: string | null
          updated_at: string | null
        }
        Insert: {
          address?: Json | null
          avatar_url?: string | null
          created_at?: string | null
          date_of_birth?: string | null
          designation?: string | null
          first_name: string
          id: string
          last_name: string
          phone_number?: string | null
          preferences?: Json | null
          role?: string | null
          status?: string | null
          updated_at?: string | null
        }
        Update: {
          address?: Json | null
          avatar_url?: string | null
          created_at?: string | null
          date_of_birth?: string | null
          designation?: string | null
          first_name?: string
          id?: string
          last_name?: string
          phone_number?: string | null
          preferences?: Json | null
          role?: string | null
          status?: string | null
          updated_at?: string | null
        }
        Relationships: [
          {
            foreignKeyName: "user_profiles_id_fkey"
            columns: ["id"]
            isOneToOne: true
            referencedRelation: "v_user_profiles_extended"
            referencedColumns: ["id"]
          },
        ]
      }
      vmux_connections: {
        Row: {
          c_code: string | null
          channel: string | null
          subscriber: string | null
          system_connection_id: string
          tk: string | null
        }
        Insert: {
          c_code?: string | null
          channel?: string | null
          subscriber?: string | null
          system_connection_id: string
          tk?: string | null
        }
        Update: {
          c_code?: string | null
          channel?: string | null
          subscriber?: string | null
          system_connection_id?: string
          tk?: string | null
        }
        Relationships: [
          {
            foreignKeyName: "vmux_connections_system_connection_id_fkey"
            columns: ["system_connection_id"]
            isOneToOne: true
            referencedRelation: "system_connections"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "vmux_connections_system_connection_id_fkey"
            columns: ["system_connection_id"]
            isOneToOne: true
            referencedRelation: "v_system_connections_complete"
            referencedColumns: ["id"]
          },
        ]
      }
      vmux_systems: {
        Row: {
          system_id: string
          vm_id: string | null
        }
        Insert: {
          system_id: string
          vm_id?: string | null
        }
        Update: {
          system_id?: string
          vm_id?: string | null
        }
        Relationships: [
          {
            foreignKeyName: "vmux_systems_system_id_fkey"
            columns: ["system_id"]
            isOneToOne: true
            referencedRelation: "systems"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "vmux_systems_system_id_fkey"
            columns: ["system_id"]
            isOneToOne: true
            referencedRelation: "v_systems_complete"
            referencedColumns: ["id"]
          },
        ]
      }
    }
    Views: {
      v_cable_segments_at_jc: {
        Row: {
          end_node_id: string | null
          fiber_count: number | null
          id: string | null
          jc_node_id: string | null
          original_cable_id: string | null
          segment_order: number | null
          start_node_id: string | null
        }
        Relationships: [
          {
            foreignKeyName: "cable_segments_original_cable_id_fkey"
            columns: ["original_cable_id"]
            isOneToOne: false
            referencedRelation: "ofc_cables"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "cable_segments_original_cable_id_fkey"
            columns: ["original_cable_id"]
            isOneToOne: false
            referencedRelation: "v_cable_utilization"
            referencedColumns: ["cable_id"]
          },
          {
            foreignKeyName: "cable_segments_original_cable_id_fkey"
            columns: ["original_cable_id"]
            isOneToOne: false
            referencedRelation: "v_ofc_cables_complete"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "junction_closures_node_id_fkey"
            columns: ["jc_node_id"]
            isOneToOne: false
            referencedRelation: "nodes"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "junction_closures_node_id_fkey"
            columns: ["jc_node_id"]
            isOneToOne: false
            referencedRelation: "v_nodes_complete"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "junction_closures_node_id_fkey"
            columns: ["jc_node_id"]
            isOneToOne: false
            referencedRelation: "v_ring_nodes"
            referencedColumns: ["id"]
          },
        ]
      }
      v_cable_utilization: {
        Row: {
          available_fibers: number | null
          cable_id: string | null
          capacity: number | null
          route_name: string | null
          used_fibers: number | null
          utilization_percent: number | null
        }
        Relationships: []
      }
      v_employee_designations: {
        Row: {
          created_at: string | null
          id: string | null
          name: string | null
          parent_id: string | null
          status: boolean | null
          updated_at: string | null
        }
        Insert: {
          created_at?: string | null
          id?: string | null
          name?: string | null
          parent_id?: string | null
          status?: boolean | null
          updated_at?: string | null
        }
        Update: {
          created_at?: string | null
          id?: string | null
          name?: string | null
          parent_id?: string | null
          status?: boolean | null
          updated_at?: string | null
        }
        Relationships: [
          {
            foreignKeyName: "employee_designations_parent_id_fkey"
            columns: ["parent_id"]
            isOneToOne: false
            referencedRelation: "employee_designations"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "employee_designations_parent_id_fkey"
            columns: ["parent_id"]
            isOneToOne: false
            referencedRelation: "v_employee_designations"
            referencedColumns: ["id"]
          },
        ]
      }
      v_employees: {
        Row: {
          created_at: string | null
          employee_addr: string | null
          employee_contact: string | null
          employee_designation_id: string | null
          employee_designation_name: string | null
          employee_dob: string | null
          employee_doj: string | null
          employee_email: string | null
          employee_name: string | null
          employee_pers_no: string | null
          id: string | null
          maintenance_terminal_id: string | null
          remark: string | null
          status: boolean | null
          updated_at: string | null
        }
        Relationships: [
          {
            foreignKeyName: "employees_employee_designation_id_fkey"
            columns: ["employee_designation_id"]
            isOneToOne: false
            referencedRelation: "employee_designations"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "employees_employee_designation_id_fkey"
            columns: ["employee_designation_id"]
            isOneToOne: false
            referencedRelation: "v_employee_designations"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "employees_maintenance_terminal_id_fkey"
            columns: ["maintenance_terminal_id"]
            isOneToOne: false
            referencedRelation: "maintenance_areas"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "employees_maintenance_terminal_id_fkey"
            columns: ["maintenance_terminal_id"]
            isOneToOne: false
            referencedRelation: "v_maintenance_areas"
            referencedColumns: ["id"]
          },
        ]
      }
      v_end_to_end_paths: {
        Row: {
          destination_system_id: string | null
          operational_status: string | null
          path_id: string | null
          path_name: string | null
          route_names: string | null
          segment_count: number | null
          source_system_id: string | null
          total_distance_km: number | null
          total_loss_db: number | null
        }
        Relationships: [
          {
            foreignKeyName: "fk_lfp_destination_system"
            columns: ["destination_system_id"]
            isOneToOne: false
            referencedRelation: "systems"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "fk_lfp_destination_system"
            columns: ["destination_system_id"]
            isOneToOne: false
            referencedRelation: "v_systems_complete"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "fk_lfp_source_system"
            columns: ["source_system_id"]
            isOneToOne: false
            referencedRelation: "systems"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "fk_lfp_source_system"
            columns: ["source_system_id"]
            isOneToOne: false
            referencedRelation: "v_systems_complete"
            referencedColumns: ["id"]
          },
        ]
      }
      v_junction_closures_complete: {
        Row: {
          id: string | null
          latitude: number | null
          longitude: number | null
          name: string | null
          node_id: string | null
          ofc_cable_id: string | null
          position_km: number | null
        }
        Relationships: [
          {
            foreignKeyName: "junction_closures_node_id_fkey"
            columns: ["node_id"]
            isOneToOne: false
            referencedRelation: "nodes"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "junction_closures_node_id_fkey"
            columns: ["node_id"]
            isOneToOne: false
            referencedRelation: "v_nodes_complete"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "junction_closures_node_id_fkey"
            columns: ["node_id"]
            isOneToOne: false
            referencedRelation: "v_ring_nodes"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "junction_closures_ofc_cable_id_fkey"
            columns: ["ofc_cable_id"]
            isOneToOne: false
            referencedRelation: "ofc_cables"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "junction_closures_ofc_cable_id_fkey"
            columns: ["ofc_cable_id"]
            isOneToOne: false
            referencedRelation: "v_cable_utilization"
            referencedColumns: ["cable_id"]
          },
          {
            foreignKeyName: "junction_closures_ofc_cable_id_fkey"
            columns: ["ofc_cable_id"]
            isOneToOne: false
            referencedRelation: "v_ofc_cables_complete"
            referencedColumns: ["id"]
          },
        ]
      }
      v_lookup_types: {
        Row: {
          category: string | null
          code: string | null
          created_at: string | null
          description: string | null
          id: string | null
          is_system_default: boolean | null
          name: string | null
          sort_order: number | null
          status: boolean | null
          updated_at: string | null
        }
        Insert: {
          category?: string | null
          code?: string | null
          created_at?: string | null
          description?: string | null
          id?: string | null
          is_system_default?: boolean | null
          name?: string | null
          sort_order?: number | null
          status?: boolean | null
          updated_at?: string | null
        }
        Update: {
          category?: string | null
          code?: string | null
          created_at?: string | null
          description?: string | null
          id?: string | null
          is_system_default?: boolean | null
          name?: string | null
          sort_order?: number | null
          status?: boolean | null
          updated_at?: string | null
        }
        Relationships: []
      }
      v_maintenance_areas: {
        Row: {
          address: string | null
          area_type_id: string | null
          code: string | null
          contact_number: string | null
          contact_person: string | null
          created_at: string | null
          email: string | null
          id: string | null
          latitude: number | null
          longitude: number | null
          maintenance_area_type_code: string | null
          maintenance_area_type_name: string | null
          name: string | null
          parent_id: string | null
          status: boolean | null
          updated_at: string | null
        }
        Relationships: [
          {
            foreignKeyName: "maintenance_areas_area_type_id_fkey"
            columns: ["area_type_id"]
            isOneToOne: false
            referencedRelation: "lookup_types"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "maintenance_areas_area_type_id_fkey"
            columns: ["area_type_id"]
            isOneToOne: false
            referencedRelation: "v_lookup_types"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "maintenance_areas_parent_id_fkey"
            columns: ["parent_id"]
            isOneToOne: false
            referencedRelation: "maintenance_areas"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "maintenance_areas_parent_id_fkey"
            columns: ["parent_id"]
            isOneToOne: false
            referencedRelation: "v_maintenance_areas"
            referencedColumns: ["id"]
          },
        ]
      }
      v_nodes_complete: {
        Row: {
          created_at: string | null
          id: string | null
          latitude: number | null
          longitude: number | null
          maintenance_area_name: string | null
          maintenance_terminal_id: string | null
          name: string | null
          node_type_code: string | null
          node_type_id: string | null
          node_type_name: string | null
          remark: string | null
          status: boolean | null
          updated_at: string | null
        }
        Relationships: [
          {
            foreignKeyName: "nodes_maintenance_terminal_id_fkey"
            columns: ["maintenance_terminal_id"]
            isOneToOne: false
            referencedRelation: "maintenance_areas"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "nodes_maintenance_terminal_id_fkey"
            columns: ["maintenance_terminal_id"]
            isOneToOne: false
            referencedRelation: "v_maintenance_areas"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "nodes_node_type_id_fkey"
            columns: ["node_type_id"]
            isOneToOne: false
            referencedRelation: "lookup_types"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "nodes_node_type_id_fkey"
            columns: ["node_type_id"]
            isOneToOne: false
            referencedRelation: "v_lookup_types"
            referencedColumns: ["id"]
          },
        ]
      }
      v_ofc_cables_complete: {
        Row: {
          asset_no: string | null
          capacity: number | null
          commissioned_on: string | null
          created_at: string | null
          current_rkm: number | null
          en_id: string | null
          en_name: string | null
          en_node_type_name: string | null
          id: string | null
          maintenance_area_code: string | null
          maintenance_area_name: string | null
          maintenance_terminal_id: string | null
          ofc_owner_code: string | null
          ofc_owner_id: string | null
          ofc_owner_name: string | null
          ofc_type_code: string | null
          ofc_type_id: string | null
          ofc_type_name: string | null
          remark: string | null
          route_name: string | null
          sn_id: string | null
          sn_name: string | null
          sn_node_type_name: string | null
          status: boolean | null
          transnet_id: string | null
          transnet_rkm: number | null
          updated_at: string | null
        }
        Relationships: [
          {
            foreignKeyName: "ofc_cables_en_id_fkey"
            columns: ["en_id"]
            isOneToOne: false
            referencedRelation: "nodes"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "ofc_cables_en_id_fkey"
            columns: ["en_id"]
            isOneToOne: false
            referencedRelation: "v_nodes_complete"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "ofc_cables_en_id_fkey"
            columns: ["en_id"]
            isOneToOne: false
            referencedRelation: "v_ring_nodes"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "ofc_cables_maintenance_terminal_id_fkey"
            columns: ["maintenance_terminal_id"]
            isOneToOne: false
            referencedRelation: "maintenance_areas"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "ofc_cables_maintenance_terminal_id_fkey"
            columns: ["maintenance_terminal_id"]
            isOneToOne: false
            referencedRelation: "v_maintenance_areas"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "ofc_cables_ofc_owner_id_fkey"
            columns: ["ofc_owner_id"]
            isOneToOne: false
            referencedRelation: "lookup_types"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "ofc_cables_ofc_owner_id_fkey"
            columns: ["ofc_owner_id"]
            isOneToOne: false
            referencedRelation: "v_lookup_types"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "ofc_cables_ofc_type_id_fkey"
            columns: ["ofc_type_id"]
            isOneToOne: false
            referencedRelation: "lookup_types"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "ofc_cables_ofc_type_id_fkey"
            columns: ["ofc_type_id"]
            isOneToOne: false
            referencedRelation: "v_lookup_types"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "ofc_cables_sn_id_fkey"
            columns: ["sn_id"]
            isOneToOne: false
            referencedRelation: "nodes"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "ofc_cables_sn_id_fkey"
            columns: ["sn_id"]
            isOneToOne: false
            referencedRelation: "v_nodes_complete"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "ofc_cables_sn_id_fkey"
            columns: ["sn_id"]
            isOneToOne: false
            referencedRelation: "v_ring_nodes"
            referencedColumns: ["id"]
          },
        ]
      }
      v_ofc_connections_complete: {
        Row: {
          connection_category: string | null
          connection_type: string | null
          created_at: string | null
          destination_port: string | null
          en_dom: string | null
          en_id: string | null
          en_name: string | null
          en_power_dbm: number | null
          fiber_no_en: number | null
          fiber_no_sn: number | null
          fiber_role: string | null
          id: string | null
          logical_path_id: string | null
          maintenance_area_name: string | null
          ofc_id: string | null
          ofc_route_name: string | null
          ofc_type_name: string | null
          otdr_distance_en_km: number | null
          otdr_distance_sn_km: number | null
          path_segment_order: number | null
          remark: string | null
          route_loss_db: number | null
          sn_dom: string | null
          sn_id: string | null
          sn_name: string | null
          sn_power_dbm: number | null
          source_port: string | null
          status: boolean | null
          system_id: string | null
          system_name: string | null
          updated_at: string | null
          updated_en_id: string | null
          updated_en_name: string | null
          updated_fiber_no_en: number | null
          updated_fiber_no_sn: number | null
          updated_sn_id: string | null
          updated_sn_name: string | null
        }
        Relationships: [
          {
            foreignKeyName: "fk_connection_type"
            columns: ["connection_category", "connection_type"]
            isOneToOne: false
            referencedRelation: "lookup_types"
            referencedColumns: ["category", "name"]
          },
          {
            foreignKeyName: "fk_connection_type"
            columns: ["connection_category", "connection_type"]
            isOneToOne: false
            referencedRelation: "v_lookup_types"
            referencedColumns: ["category", "name"]
          },
          {
            foreignKeyName: "fk_connection_type"
            columns: ["connection_category", "connection_type"]
            isOneToOne: false
            referencedRelation: "v_systems_complete"
            referencedColumns: ["system_category", "node_type_name"]
          },
          {
            foreignKeyName: "fk_connection_type"
            columns: ["connection_category", "connection_type"]
            isOneToOne: false
            referencedRelation: "v_systems_complete"
            referencedColumns: ["system_category", "system_type_name"]
          },
          {
            foreignKeyName: "fk_ofc_connections_logical_path"
            columns: ["logical_path_id"]
            isOneToOne: false
            referencedRelation: "logical_fiber_paths"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "fk_ofc_connections_logical_path"
            columns: ["logical_path_id"]
            isOneToOne: false
            referencedRelation: "v_end_to_end_paths"
            referencedColumns: ["path_id"]
          },
          {
            foreignKeyName: "fk_ofc_connections_system"
            columns: ["system_id"]
            isOneToOne: false
            referencedRelation: "systems"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "fk_ofc_connections_system"
            columns: ["system_id"]
            isOneToOne: false
            referencedRelation: "v_systems_complete"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "ofc_cables_en_id_fkey"
            columns: ["en_id"]
            isOneToOne: false
            referencedRelation: "nodes"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "ofc_cables_en_id_fkey"
            columns: ["en_id"]
            isOneToOne: false
            referencedRelation: "v_nodes_complete"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "ofc_cables_en_id_fkey"
            columns: ["en_id"]
            isOneToOne: false
            referencedRelation: "v_ring_nodes"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "ofc_cables_sn_id_fkey"
            columns: ["sn_id"]
            isOneToOne: false
            referencedRelation: "nodes"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "ofc_cables_sn_id_fkey"
            columns: ["sn_id"]
            isOneToOne: false
            referencedRelation: "v_nodes_complete"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "ofc_cables_sn_id_fkey"
            columns: ["sn_id"]
            isOneToOne: false
            referencedRelation: "v_ring_nodes"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "ofc_connections_ofc_id_fkey"
            columns: ["ofc_id"]
            isOneToOne: false
            referencedRelation: "ofc_cables"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "ofc_connections_ofc_id_fkey"
            columns: ["ofc_id"]
            isOneToOne: false
            referencedRelation: "v_cable_utilization"
            referencedColumns: ["cable_id"]
          },
          {
            foreignKeyName: "ofc_connections_ofc_id_fkey"
            columns: ["ofc_id"]
            isOneToOne: false
            referencedRelation: "v_ofc_cables_complete"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "ofc_connections_updated_en_id_fkey"
            columns: ["updated_en_id"]
            isOneToOne: false
            referencedRelation: "nodes"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "ofc_connections_updated_en_id_fkey"
            columns: ["updated_en_id"]
            isOneToOne: false
            referencedRelation: "v_nodes_complete"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "ofc_connections_updated_en_id_fkey"
            columns: ["updated_en_id"]
            isOneToOne: false
            referencedRelation: "v_ring_nodes"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "ofc_connections_updated_sn_id_fkey"
            columns: ["updated_sn_id"]
            isOneToOne: false
            referencedRelation: "nodes"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "ofc_connections_updated_sn_id_fkey"
            columns: ["updated_sn_id"]
            isOneToOne: false
            referencedRelation: "v_nodes_complete"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "ofc_connections_updated_sn_id_fkey"
            columns: ["updated_sn_id"]
            isOneToOne: false
            referencedRelation: "v_ring_nodes"
            referencedColumns: ["id"]
          },
        ]
      }
      v_ring_nodes: {
        Row: {
          id: string | null
          ip: string | null
          lat: number | null
          long: number | null
          name: string | null
          order_in_ring: number | null
          remark: string | null
          ring_id: string | null
          ring_name: string | null
          ring_status: boolean | null
          system_status: boolean | null
          type: string | null
        }
        Relationships: []
      }
      v_rings: {
        Row: {
          created_at: string | null
          description: string | null
          id: string | null
          maintenance_area_name: string | null
          maintenance_terminal_id: string | null
          name: string | null
          ring_type_code: string | null
          ring_type_id: string | null
          ring_type_name: string | null
          status: boolean | null
          total_nodes: number | null
          updated_at: string | null
        }
        Relationships: [
          {
            foreignKeyName: "rings_maintenance_terminal_id_fkey"
            columns: ["maintenance_terminal_id"]
            isOneToOne: false
            referencedRelation: "maintenance_areas"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "rings_maintenance_terminal_id_fkey"
            columns: ["maintenance_terminal_id"]
            isOneToOne: false
            referencedRelation: "v_maintenance_areas"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "rings_ring_type_id_fkey"
            columns: ["ring_type_id"]
            isOneToOne: false
            referencedRelation: "lookup_types"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "rings_ring_type_id_fkey"
            columns: ["ring_type_id"]
            isOneToOne: false
            referencedRelation: "v_lookup_types"
            referencedColumns: ["id"]
          },
        ]
      }
      v_system_connections_complete: {
        Row: {
          bandwidth_allocated_mbps: number | null
          bandwidth_mbps: number | null
          commissioned_on: string | null
          connected_system_name: string | null
          connected_system_type_name: string | null
          created_at: string | null
          customer_name: string | null
          en_interface: string | null
          en_ip: unknown | null
          en_name: string | null
          en_node_name: string | null
          fiber_in: number | null
          fiber_out: number | null
          id: string | null
          media_type_name: string | null
          remark: string | null
          sdh_a_customer: string | null
          sdh_a_slot: string | null
          sdh_b_customer: string | null
          sdh_b_slot: string | null
          sdh_carrier: string | null
          sdh_stm_no: string | null
          sfp_capacity: string | null
          sfp_port: string | null
          sfp_serial_no: string | null
          sfp_type_name: string | null
          sn_interface: string | null
          sn_ip: unknown | null
          sn_name: string | null
          sn_node_name: string | null
          status: boolean | null
          system_id: string | null
          system_name: string | null
          system_type_name: string | null
          updated_at: string | null
          vlan: string | null
          vmux_c_code: string | null
          vmux_channel: string | null
          vmux_subscriber: string | null
          vmux_tk: string | null
        }
        Relationships: [
          {
            foreignKeyName: "system_connections_system_id_fkey"
            columns: ["system_id"]
            isOneToOne: false
            referencedRelation: "systems"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "system_connections_system_id_fkey"
            columns: ["system_id"]
            isOneToOne: false
            referencedRelation: "v_systems_complete"
            referencedColumns: ["id"]
          },
        ]
      }
      v_system_ring_paths_detailed: {
        Row: {
          created_at: string | null
          end_node_id: string | null
          end_node_name: string | null
          id: string | null
          logical_path_id: string | null
          ofc_cable_id: string | null
          path_name: string | null
          path_order: number | null
          route_name: string | null
          source_system_id: string | null
          start_node_id: string | null
          start_node_name: string | null
        }
        Relationships: [
          {
            foreignKeyName: "fk_lfp_source_system"
            columns: ["source_system_id"]
            isOneToOne: false
            referencedRelation: "systems"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "fk_lfp_source_system"
            columns: ["source_system_id"]
            isOneToOne: false
            referencedRelation: "v_systems_complete"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "logical_path_segments_logical_path_id_fkey"
            columns: ["logical_path_id"]
            isOneToOne: false
            referencedRelation: "logical_fiber_paths"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "logical_path_segments_logical_path_id_fkey"
            columns: ["logical_path_id"]
            isOneToOne: false
            referencedRelation: "v_end_to_end_paths"
            referencedColumns: ["path_id"]
          },
          {
            foreignKeyName: "logical_path_segments_ofc_cable_id_fkey"
            columns: ["ofc_cable_id"]
            isOneToOne: false
            referencedRelation: "ofc_cables"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "logical_path_segments_ofc_cable_id_fkey"
            columns: ["ofc_cable_id"]
            isOneToOne: false
            referencedRelation: "v_cable_utilization"
            referencedColumns: ["cable_id"]
          },
          {
            foreignKeyName: "logical_path_segments_ofc_cable_id_fkey"
            columns: ["ofc_cable_id"]
            isOneToOne: false
            referencedRelation: "v_ofc_cables_complete"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "ofc_cables_en_id_fkey"
            columns: ["end_node_id"]
            isOneToOne: false
            referencedRelation: "nodes"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "ofc_cables_en_id_fkey"
            columns: ["end_node_id"]
            isOneToOne: false
            referencedRelation: "v_nodes_complete"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "ofc_cables_en_id_fkey"
            columns: ["end_node_id"]
            isOneToOne: false
            referencedRelation: "v_ring_nodes"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "ofc_cables_sn_id_fkey"
            columns: ["start_node_id"]
            isOneToOne: false
            referencedRelation: "nodes"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "ofc_cables_sn_id_fkey"
            columns: ["start_node_id"]
            isOneToOne: false
            referencedRelation: "v_nodes_complete"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "ofc_cables_sn_id_fkey"
            columns: ["start_node_id"]
            isOneToOne: false
            referencedRelation: "v_ring_nodes"
            referencedColumns: ["id"]
          },
        ]
      }
      v_systems_complete: {
        Row: {
          commissioned_on: string | null
          created_at: string | null
          id: string | null
          ip_address: unknown | null
          latitude: number | null
          longitude: number | null
          maintenance_terminal_id: string | null
          make: string | null
          node_id: string | null
          node_name: string | null
          node_type_name: string | null
          remark: string | null
          ring_id: string | null
          ring_logical_area_name: string | null
          s_no: string | null
          sdh_gne: string | null
          status: boolean | null
          system_category: string | null
          system_maintenance_terminal_name: string | null
          system_name: string | null
          system_type_code: string | null
          system_type_id: string | null
          system_type_name: string | null
          updated_at: string | null
          vmux_vm_id: string | null
        }
        Relationships: [
          {
            foreignKeyName: "ring_based_systems_ring_id_fkey"
            columns: ["ring_id"]
            isOneToOne: false
            referencedRelation: "rings"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "ring_based_systems_ring_id_fkey"
            columns: ["ring_id"]
            isOneToOne: false
            referencedRelation: "v_ring_nodes"
            referencedColumns: ["ring_id"]
          },
          {
            foreignKeyName: "ring_based_systems_ring_id_fkey"
            columns: ["ring_id"]
            isOneToOne: false
            referencedRelation: "v_rings"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "systems_maintenance_terminal_id_fkey"
            columns: ["maintenance_terminal_id"]
            isOneToOne: false
            referencedRelation: "maintenance_areas"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "systems_maintenance_terminal_id_fkey"
            columns: ["maintenance_terminal_id"]
            isOneToOne: false
            referencedRelation: "v_maintenance_areas"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "systems_node_id_fkey"
            columns: ["node_id"]
            isOneToOne: false
            referencedRelation: "nodes"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "systems_node_id_fkey"
            columns: ["node_id"]
            isOneToOne: false
            referencedRelation: "v_nodes_complete"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "systems_node_id_fkey"
            columns: ["node_id"]
            isOneToOne: false
            referencedRelation: "v_ring_nodes"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "systems_system_type_id_fkey"
            columns: ["system_type_id"]
            isOneToOne: false
            referencedRelation: "lookup_types"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "systems_system_type_id_fkey"
            columns: ["system_type_id"]
            isOneToOne: false
            referencedRelation: "v_lookup_types"
            referencedColumns: ["id"]
          },
        ]
      }
      v_user_profiles_extended: {
        Row: {
          account_age_days: number | null
          address: Json | null
          auth_updated_at: string | null
          avatar_url: string | null
          computed_status: string | null
          created_at: string | null
          date_of_birth: string | null
          designation: string | null
          email: string | null
          email_confirmed_at: string | null
          first_name: string | null
          full_name: string | null
          id: string | null
          is_email_verified: boolean | null
          is_phone_verified: boolean | null
          is_super_admin: boolean | null
          last_activity_period: string | null
          last_name: string | null
          last_sign_in_at: string | null
          phone_confirmed_at: string | null
          phone_number: string | null
          preferences: Json | null
          raw_app_meta_data: Json | null
          raw_user_meta_data: Json | null
          role: string | null
          status: string | null
          updated_at: string | null
        }
        Relationships: []
      }
    }
    Functions: {
      add_junction_closure: {
        Args: {
          p_node_id: string
          p_ofc_cable_id: string
          p_position_km: number
        }
        Returns: {
          created_at: string
          id: string
          node_id: string
          ofc_cable_id: string
          position_km: number
        }[]
      }
      add_lookup_type: {
        Args: {
          p_category: string
          p_code?: string
          p_description?: string
          p_name: string
          p_sort_order?: number
        }
        Returns: string
      }
      admin_bulk_delete_users: {
        Args: { user_ids: string[] }
        Returns: boolean
      }
      admin_bulk_update_role: {
        Args: { new_role: string; user_ids: string[] }
        Returns: boolean
      }
      admin_bulk_update_status: {
        Args: { new_status: string; user_ids: string[] }
        Returns: boolean
      }
      admin_get_all_users_extended: {
        Args: {
          date_from?: string
          date_to?: string
          filter_activity?: string
          filter_role?: string
          filter_status?: string
          page_limit?: number
          page_offset?: number
          search_query?: string
        }
        Returns: Json
      }
      admin_get_user_by_id: {
        Args: { user_id: string }
        Returns: {
          address: Json
          avatar_url: string
          created_at: string
          date_of_birth: string
          designation: string
          email: string
          first_name: string
          id: string
          is_email_verified: boolean
          last_name: string
          last_sign_in_at: string
          phone_number: string
          preferences: Json
          role: string
          status: string
          updated_at: string
        }[]
      }
      admin_update_user_profile: {
        Args: {
          update_address?: Json
          update_avatar_url?: string
          update_date_of_birth?: string
          update_designation?: string
          update_first_name?: string
          update_last_name?: string
          update_phone_number?: string
          update_preferences?: Json
          update_role?: string
          update_status?: string
          user_id: string
        }
        Returns: boolean
      }
      aggregate_query: {
        Args: {
          aggregation_options: Json
          filters?: Json
          order_by?: Json
          table_name: string
        }
        Returns: {
          result: Json
        }[]
      }
      apply_logical_path_update: {
        Args:
          | {
              p_end_fiber_no: number
              p_end_node_id: string
              p_physical_fibers: Json
              p_start_fiber_no: number
              p_start_node_id: string
            }
          | { p_trace_result: Json }
        Returns: undefined
      }
      auto_splice_straight_segments: {
        Args: {
          p_jc_id: string
          p_loss_db?: number
          p_segment1_id: string
          p_segment2_id: string
        }
        Returns: Json
      }
      build_where_clause: {
        Args: { p_alias?: string; p_filters: Json; p_view_name: string }
        Returns: string
      }
      bulk_update: {
        Args: { p_table_name: string; p_updates: Json }
        Returns: Json
      }
      column_exists: {
        Args: {
          p_column_name: string
          p_schema_name: string
          p_table_name: string
        }
        Returns: boolean
      }
      deprovision_logical_path: {
        Args: { p_path_id: string }
        Returns: undefined
      }
      execute_sql: {
        Args: { sql_query: string }
        Returns: Json
      }
      find_cable_between_nodes: {
        Args: { p_node1_id: string; p_node2_id: string }
        Returns: {
          id: string
          route_name: string
        }[]
      }
      get_all_fibers_at_jc: {
        Args: { p_jc_id: string }
        Returns: {
          fiber_no: number
          segment_id: string
        }[]
      }
      get_all_splices: {
        Args: Record<PropertyKey, never>
        Returns: {
          incoming_fiber_no: number
          incoming_segment_id: string
          jc_id: string
          jc_name: string
          jc_position_km: number
          loss_db: number
          outgoing_fiber_no: number
          outgoing_segment_id: string
          splice_id: string
        }[]
      }
      get_bsnl_dashboard_data: {
        Args: {
          p_cable_types?: string[]
          p_node_types?: string[]
          p_query?: string
          p_regions?: string[]
          p_status?: boolean
          p_system_types?: string[]
        }
        Returns: Json
      }
      get_continuous_available_fibers: {
        Args: { p_path_id: string }
        Returns: {
          fiber_no: number
        }[]
      }
      get_dashboard_overview: {
        Args: Record<PropertyKey, never>
        Returns: Json
      }
      get_entity_counts: {
        Args: { p_entity_name: string; p_filters?: Json }
        Returns: {
          active_count: number
          inactive_count: number
          total_count: number
        }[]
      }
      get_jc_splicing_details: {
        Args: { p_jc_id: string }
        Returns: Json
      }
      get_lookup_type_id: {
        Args: { p_category: string; p_name: string }
        Returns: string
      }
      get_lookup_types_by_category: {
        Args: { p_category: string }
        Returns: {
          code: string
          description: string
          id: string
          name: string
          sort_order: number
        }[]
      }
      get_my_role: {
        Args: Record<PropertyKey, never>
        Returns: string
      }
      get_my_user_details: {
        Args: Record<PropertyKey, never>
        Returns: {
          address: Json
          avatar_url: string
          created_at: string
          date_of_birth: string
          designation: string
          email: string
          first_name: string
          id: string
          is_email_verified: boolean
          is_super_admin: boolean
          last_name: string
          last_sign_in_at: string
          phone_number: string
          preferences: Json
          role: string
          updated_at: string
        }[]
      }
      get_paged_data: {
        Args: {
          p_filters?: Json
          p_limit: number
          p_offset: number
          p_order_by?: string
          p_order_dir?: string
          p_view_name: string
        }
        Returns: Json
      }
      get_segments_at_jc: {
        Args: { p_jc_id: string }
        Returns: {
          fiber_count: number
          id: string
          original_cable_name: string
          segment_order: number
        }[]
      }
      get_system_path_details: {
        Args: { p_path_id: string }
        Returns: {
          created_at: string | null
          end_node_id: string | null
          end_node_name: string | null
          id: string | null
          logical_path_id: string | null
          ofc_cable_id: string | null
          path_name: string | null
          path_order: number | null
          route_name: string | null
          source_system_id: string | null
          start_node_id: string | null
          start_node_name: string | null
        }[]
      }
      get_unique_values: {
        Args: {
          p_column_name: string
          p_filters?: Json
          p_limit_count?: number
          p_order_by?: Json
          p_table_name: string
        }
        Returns: {
          value: Json
        }[]
      }
      is_super_admin: {
        Args: Record<PropertyKey, never>
        Returns: boolean
      }
      manage_splice: {
        Args: {
          p_action: string
          p_incoming_fiber_no?: number
          p_incoming_segment_id?: string
          p_jc_id: string
          p_loss_db?: number
          p_outgoing_fiber_no?: number
          p_outgoing_segment_id?: string
          p_splice_id?: string
          p_splice_type_id?: string
        }
        Returns: Record<string, unknown>
      }
      provision_logical_path: {
        Args: {
          p_path_name: string
          p_physical_path_id: string
          p_protection_fiber_no: number
          p_system_id: string
          p_working_fiber_no: number
        }
        Returns: {
          protection_path_id: string
          working_path_id: string
        }[]
      }
      recalculate_segments_for_cable: {
        Args: { p_cable_id: string }
        Returns: undefined
      }
      search_nodes_for_select: {
        Args: { p_limit?: number; p_search_term?: string }
        Returns: {
          id: string
          name: string
        }[]
      }
      trace_fiber_path: {
        Args: { p_start_fiber_no: number; p_start_segment_id: string }
        Returns: {
          details: string
          distance_km: number
          element_id: string
          element_name: string
          element_type: string
          fiber_in: number
          fiber_out: number
          loss_db: number
          original_cable_id: string
          step_order: number
        }[]
      }
      update_path_for_fiber: {
        Args: { p_fiber_no: number; p_segment_id: string }
        Returns: undefined
      }
      update_paths_after_splice: {
        Args:
          | { p_fibers_to_update: Json }
          | { p_fibers_to_update: Json; p_operation: string }
        Returns: undefined
      }
      update_paths_for_jc: {
        Args: { p_jc_id: string }
        Returns: undefined
      }
      update_ring_system_associations: {
        Args: { p_ring_id: string; p_system_ids: string[] }
        Returns: undefined
      }
      upsert_system_with_details: {
        Args: {
          p_commissioned_on?: string
          p_gne?: string
          p_id?: string
          p_ip_address?: unknown
          p_maintenance_terminal_id?: string
          p_make?: string
          p_node_id: string
          p_remark?: string
          p_ring_id?: string
          p_s_no?: string
          p_status: boolean
          p_system_name: string
          p_system_type_id: string
          p_vm_id?: string
        }
        Returns: {
          commissioned_on: string | null
          created_at: string | null
          id: string
          ip_address: unknown | null
          maintenance_terminal_id: string | null
          make: string | null
          node_id: string
          remark: string | null
          s_no: string | null
          status: boolean | null
          system_name: string | null
          system_type_id: string
          updated_at: string | null
        }[]
      }
      validate_ring_path: {
        Args: { p_path_id: string }
        Returns: Json
      }
    }
    Enums: {
      [_ in never]: never
    }
    CompositeTypes: {
      splice_connection: {
        splice_id: string | null
        jc_id: string | null
        jc_name: string | null
        jc_position_km: number | null
        incoming_cable_id: string | null
        incoming_fiber_no: number | null
        outgoing_cable_id: string | null
        outgoing_fiber_no: number | null
        otdr_length_km: number | null
        loss_db: number | null
      }
    }
  }
}

type DatabaseWithoutInternals = Omit<Database, "__InternalSupabase">

type DefaultSchema = DatabaseWithoutInternals[Extract<keyof Database, "public">]

export type Tables<
  DefaultSchemaTableNameOrOptions extends
    | keyof (DefaultSchema["Tables"] & DefaultSchema["Views"])
    | { schema: keyof DatabaseWithoutInternals },
  TableName extends DefaultSchemaTableNameOrOptions extends {
    schema: keyof DatabaseWithoutInternals
  }
    ? keyof (DatabaseWithoutInternals[DefaultSchemaTableNameOrOptions["schema"]]["Tables"] &
        DatabaseWithoutInternals[DefaultSchemaTableNameOrOptions["schema"]]["Views"])
    : never = never,
> = DefaultSchemaTableNameOrOptions extends {
  schema: keyof DatabaseWithoutInternals
}
  ? (DatabaseWithoutInternals[DefaultSchemaTableNameOrOptions["schema"]]["Tables"] &
      DatabaseWithoutInternals[DefaultSchemaTableNameOrOptions["schema"]]["Views"])[TableName] extends {
      Row: infer R
    }
    ? R
    : never
  : DefaultSchemaTableNameOrOptions extends keyof (DefaultSchema["Tables"] &
        DefaultSchema["Views"])
    ? (DefaultSchema["Tables"] &
        DefaultSchema["Views"])[DefaultSchemaTableNameOrOptions] extends {
        Row: infer R
      }
      ? R
      : never
    : never

export type TablesInsert<
  DefaultSchemaTableNameOrOptions extends
    | keyof DefaultSchema["Tables"]
    | { schema: keyof DatabaseWithoutInternals },
  TableName extends DefaultSchemaTableNameOrOptions extends {
    schema: keyof DatabaseWithoutInternals
  }
    ? keyof DatabaseWithoutInternals[DefaultSchemaTableNameOrOptions["schema"]]["Tables"]
    : never = never,
> = DefaultSchemaTableNameOrOptions extends {
  schema: keyof DatabaseWithoutInternals
}
  ? DatabaseWithoutInternals[DefaultSchemaTableNameOrOptions["schema"]]["Tables"][TableName] extends {
      Insert: infer I
    }
    ? I
    : never
  : DefaultSchemaTableNameOrOptions extends keyof DefaultSchema["Tables"]
    ? DefaultSchema["Tables"][DefaultSchemaTableNameOrOptions] extends {
        Insert: infer I
      }
      ? I
      : never
    : never

export type TablesUpdate<
  DefaultSchemaTableNameOrOptions extends
    | keyof DefaultSchema["Tables"]
    | { schema: keyof DatabaseWithoutInternals },
  TableName extends DefaultSchemaTableNameOrOptions extends {
    schema: keyof DatabaseWithoutInternals
  }
    ? keyof DatabaseWithoutInternals[DefaultSchemaTableNameOrOptions["schema"]]["Tables"]
    : never = never,
> = DefaultSchemaTableNameOrOptions extends {
  schema: keyof DatabaseWithoutInternals
}
  ? DatabaseWithoutInternals[DefaultSchemaTableNameOrOptions["schema"]]["Tables"][TableName] extends {
      Update: infer U
    }
    ? U
    : never
  : DefaultSchemaTableNameOrOptions extends keyof DefaultSchema["Tables"]
    ? DefaultSchema["Tables"][DefaultSchemaTableNameOrOptions] extends {
        Update: infer U
      }
      ? U
      : never
    : never

export type Enums<
  DefaultSchemaEnumNameOrOptions extends
    | keyof DefaultSchema["Enums"]
    | { schema: keyof DatabaseWithoutInternals },
  EnumName extends DefaultSchemaEnumNameOrOptions extends {
    schema: keyof DatabaseWithoutInternals
  }
    ? keyof DatabaseWithoutInternals[DefaultSchemaEnumNameOrOptions["schema"]]["Enums"]
    : never = never,
> = DefaultSchemaEnumNameOrOptions extends {
  schema: keyof DatabaseWithoutInternals
}
  ? DatabaseWithoutInternals[DefaultSchemaEnumNameOrOptions["schema"]]["Enums"][EnumName]
  : DefaultSchemaEnumNameOrOptions extends keyof DefaultSchema["Enums"]
    ? DefaultSchema["Enums"][DefaultSchemaEnumNameOrOptions]
    : never

export type CompositeTypes<
  PublicCompositeTypeNameOrOptions extends
    | keyof DefaultSchema["CompositeTypes"]
    | { schema: keyof DatabaseWithoutInternals },
  CompositeTypeName extends PublicCompositeTypeNameOrOptions extends {
    schema: keyof DatabaseWithoutInternals
  }
    ? keyof DatabaseWithoutInternals[PublicCompositeTypeNameOrOptions["schema"]]["CompositeTypes"]
    : never = never,
> = PublicCompositeTypeNameOrOptions extends {
  schema: keyof DatabaseWithoutInternals
}
  ? DatabaseWithoutInternals[PublicCompositeTypeNameOrOptions["schema"]]["CompositeTypes"][CompositeTypeName]
  : PublicCompositeTypeNameOrOptions extends keyof DefaultSchema["CompositeTypes"]
    ? DefaultSchema["CompositeTypes"][PublicCompositeTypeNameOrOptions]
    : never

export const Constants = {
  auth: {
    Enums: {
      aal_level: ["aal1", "aal2", "aal3"],
      code_challenge_method: ["s256", "plain"],
      factor_status: ["unverified", "verified"],
      factor_type: ["totp", "webauthn", "phone"],
      oauth_registration_type: ["dynamic", "manual"],
      one_time_token_type: [
        "confirmation_token",
        "reauthentication_token",
        "recovery_token",
        "email_change_token_new",
        "email_change_token_current",
        "phone_change_token",
      ],
    },
  },
  public: {
    Enums: {},
  },
} as const

```

<!-- path: types/flattened-types.ts -->
```typescript
// Auto-generated from types/supabase-types.ts

import type { Json, Database } from "@/types/supabase-types";

// ============= TABLES =============

export type AuthAudit_log_entriesRow = {
    created_at: string | null;
    id: string;
    instance_id: string | null;
    ip_address: string;
    payload: Json | null;
};

export type AuthAudit_log_entriesInsert = {
    created_at?: string | null;
    id: string;
    instance_id?: string | null;
    ip_address?: string;
    payload?: Json | null;
};

export type AuthAudit_log_entriesUpdate = {
    created_at?: string | null;
    id?: string;
    instance_id?: string | null;
    ip_address?: string;
    payload?: Json | null;
};

export type AuthFlow_stateRow = {
    auth_code: string;
    auth_code_issued_at: string | null;
    authentication_method: string;
    code_challenge: string;
    code_challenge_method: Database["auth"]["Enums"]["code_challenge_method"];
    created_at: string | null;
    id: string;
    provider_access_token: string | null;
    provider_refresh_token: string | null;
    provider_type: string;
    updated_at: string | null;
    user_id: string | null;
};

export type AuthFlow_stateInsert = {
    auth_code: string;
    auth_code_issued_at?: string | null;
    authentication_method: string;
    code_challenge: string;
    code_challenge_method: Database["auth"]["Enums"]["code_challenge_method"];
    created_at?: string | null;
    id: string;
    provider_access_token?: string | null;
    provider_refresh_token?: string | null;
    provider_type: string;
    updated_at?: string | null;
    user_id?: string | null;
};

export type AuthFlow_stateUpdate = {
    auth_code?: string;
    auth_code_issued_at?: string | null;
    authentication_method?: string;
    code_challenge?: string;
    code_challenge_method?: Database["auth"]["Enums"]["code_challenge_method"];
    created_at?: string | null;
    id?: string;
    provider_access_token?: string | null;
    provider_refresh_token?: string | null;
    provider_type?: string;
    updated_at?: string | null;
    user_id?: string | null;
};

export type AuthIdentitiesRow = {
    created_at: string | null;
    email: string | null;
    id: string;
    identity_data: Json;
    last_sign_in_at: string | null;
    provider: string;
    provider_id: string;
    updated_at: string | null;
    user_id: string;
};

export type AuthIdentitiesInsert = {
    created_at?: string | null;
    email?: string | null;
    id?: string;
    identity_data: Json;
    last_sign_in_at?: string | null;
    provider: string;
    provider_id: string;
    updated_at?: string | null;
    user_id: string;
};

export type AuthIdentitiesUpdate = {
    created_at?: string | null;
    email?: string | null;
    id?: string;
    identity_data?: Json;
    last_sign_in_at?: string | null;
    provider?: string;
    provider_id?: string;
    updated_at?: string | null;
    user_id?: string;
};

export type AuthInstancesRow = {
    created_at: string | null;
    id: string;
    raw_base_config: string | null;
    updated_at: string | null;
    uuid: string | null;
};

export type AuthInstancesInsert = {
    created_at?: string | null;
    id: string;
    raw_base_config?: string | null;
    updated_at?: string | null;
    uuid?: string | null;
};

export type AuthInstancesUpdate = {
    created_at?: string | null;
    id?: string;
    raw_base_config?: string | null;
    updated_at?: string | null;
    uuid?: string | null;
};

export type AuthMfa_amr_claimsRow = {
    authentication_method: string;
    created_at: string;
    id: string;
    session_id: string;
    updated_at: string;
};

export type AuthMfa_amr_claimsInsert = {
    authentication_method: string;
    created_at: string;
    id: string;
    session_id: string;
    updated_at: string;
};

export type AuthMfa_amr_claimsUpdate = {
    authentication_method?: string;
    created_at?: string;
    id?: string;
    session_id?: string;
    updated_at?: string;
};

export type AuthMfa_challengesRow = {
    created_at: string;
    factor_id: string;
    id: string;
    ip_address: unknown;
    otp_code: string | null;
    verified_at: string | null;
    web_authn_session_data: Json | null;
};

export type AuthMfa_challengesInsert = {
    created_at: string;
    factor_id: string;
    id: string;
    ip_address: unknown;
    otp_code?: string | null;
    verified_at?: string | null;
    web_authn_session_data?: Json | null;
};

export type AuthMfa_challengesUpdate = {
    created_at?: string;
    factor_id?: string;
    id?: string;
    ip_address?: unknown;
    otp_code?: string | null;
    verified_at?: string | null;
    web_authn_session_data?: Json | null;
};

export type AuthMfa_factorsRow = {
    created_at: string;
    factor_type: Database["auth"]["Enums"]["factor_type"];
    friendly_name: string | null;
    id: string;
    last_challenged_at: string | null;
    phone: string | null;
    secret: string | null;
    status: Database["auth"]["Enums"]["factor_status"];
    updated_at: string;
    user_id: string;
    web_authn_aaguid: string | null;
    web_authn_credential: Json | null;
};

export type AuthMfa_factorsInsert = {
    created_at: string;
    factor_type: Database["auth"]["Enums"]["factor_type"];
    friendly_name?: string | null;
    id: string;
    last_challenged_at?: string | null;
    phone?: string | null;
    secret?: string | null;
    status: Database["auth"]["Enums"]["factor_status"];
    updated_at: string;
    user_id: string;
    web_authn_aaguid?: string | null;
    web_authn_credential?: Json | null;
};

export type AuthMfa_factorsUpdate = {
    created_at?: string;
    factor_type?: Database["auth"]["Enums"]["factor_type"];
    friendly_name?: string | null;
    id?: string;
    last_challenged_at?: string | null;
    phone?: string | null;
    secret?: string | null;
    status?: Database["auth"]["Enums"]["factor_status"];
    updated_at?: string;
    user_id?: string;
    web_authn_aaguid?: string | null;
    web_authn_credential?: Json | null;
};

export type AuthOauth_clientsRow = {
    client_id: string;
    client_name: string | null;
    client_secret_hash: string;
    client_uri: string | null;
    created_at: string;
    deleted_at: string | null;
    grant_types: string;
    id: string;
    logo_uri: string | null;
    redirect_uris: string;
    registration_type: Database["auth"]["Enums"]["oauth_registration_type"];
    updated_at: string;
};

export type AuthOauth_clientsInsert = {
    client_id: string;
    client_name?: string | null;
    client_secret_hash: string;
    client_uri?: string | null;
    created_at?: string;
    deleted_at?: string | null;
    grant_types: string;
    id: string;
    logo_uri?: string | null;
    redirect_uris: string;
    registration_type: Database["auth"]["Enums"]["oauth_registration_type"];
    updated_at?: string;
};

export type AuthOauth_clientsUpdate = {
    client_id?: string;
    client_name?: string | null;
    client_secret_hash?: string;
    client_uri?: string | null;
    created_at?: string;
    deleted_at?: string | null;
    grant_types?: string;
    id?: string;
    logo_uri?: string | null;
    redirect_uris?: string;
    registration_type?: Database["auth"]["Enums"]["oauth_registration_type"];
    updated_at?: string;
};

export type AuthOne_time_tokensRow = {
    created_at: string;
    id: string;
    relates_to: string;
    token_hash: string;
    token_type: Database["auth"]["Enums"]["one_time_token_type"];
    updated_at: string;
    user_id: string;
};

export type AuthOne_time_tokensInsert = {
    created_at?: string;
    id: string;
    relates_to: string;
    token_hash: string;
    token_type: Database["auth"]["Enums"]["one_time_token_type"];
    updated_at?: string;
    user_id: string;
};

export type AuthOne_time_tokensUpdate = {
    created_at?: string;
    id?: string;
    relates_to?: string;
    token_hash?: string;
    token_type?: Database["auth"]["Enums"]["one_time_token_type"];
    updated_at?: string;
    user_id?: string;
};

export type AuthRefresh_tokensRow = {
    created_at: string | null;
    id: number;
    instance_id: string | null;
    parent: string | null;
    revoked: boolean | null;
    session_id: string | null;
    token: string | null;
    updated_at: string | null;
    user_id: string | null;
};

export type AuthRefresh_tokensInsert = {
    created_at?: string | null;
    id?: number;
    instance_id?: string | null;
    parent?: string | null;
    revoked?: boolean | null;
    session_id?: string | null;
    token?: string | null;
    updated_at?: string | null;
    user_id?: string | null;
};

export type AuthRefresh_tokensUpdate = {
    created_at?: string | null;
    id?: number;
    instance_id?: string | null;
    parent?: string | null;
    revoked?: boolean | null;
    session_id?: string | null;
    token?: string | null;
    updated_at?: string | null;
    user_id?: string | null;
};

export type AuthSaml_providersRow = {
    attribute_mapping: Json | null;
    created_at: string | null;
    entity_id: string;
    id: string;
    metadata_url: string | null;
    metadata_xml: string;
    name_id_format: string | null;
    sso_provider_id: string;
    updated_at: string | null;
};

export type AuthSaml_providersInsert = {
    attribute_mapping?: Json | null;
    created_at?: string | null;
    entity_id: string;
    id: string;
    metadata_url?: string | null;
    metadata_xml: string;
    name_id_format?: string | null;
    sso_provider_id: string;
    updated_at?: string | null;
};

export type AuthSaml_providersUpdate = {
    attribute_mapping?: Json | null;
    created_at?: string | null;
    entity_id?: string;
    id?: string;
    metadata_url?: string | null;
    metadata_xml?: string;
    name_id_format?: string | null;
    sso_provider_id?: string;
    updated_at?: string | null;
};

export type AuthSaml_relay_statesRow = {
    created_at: string | null;
    flow_state_id: string | null;
    for_email: string | null;
    id: string;
    redirect_to: string | null;
    request_id: string;
    sso_provider_id: string;
    updated_at: string | null;
};

export type AuthSaml_relay_statesInsert = {
    created_at?: string | null;
    flow_state_id?: string | null;
    for_email?: string | null;
    id: string;
    redirect_to?: string | null;
    request_id: string;
    sso_provider_id: string;
    updated_at?: string | null;
};

export type AuthSaml_relay_statesUpdate = {
    created_at?: string | null;
    flow_state_id?: string | null;
    for_email?: string | null;
    id?: string;
    redirect_to?: string | null;
    request_id?: string;
    sso_provider_id?: string;
    updated_at?: string | null;
};

export type AuthSchema_migrationsRow = {
    version: string;
};

export type AuthSchema_migrationsInsert = {
    version: string;
};

export type AuthSchema_migrationsUpdate = {
    version?: string;
};

export type AuthSessionsRow = {
    aal: Database["auth"]["Enums"]["aal_level"] | null;
    created_at: string | null;
    factor_id: string | null;
    id: string;
    ip: unknown | null;
    not_after: string | null;
    refreshed_at: string | null;
    tag: string | null;
    updated_at: string | null;
    user_agent: string | null;
    user_id: string;
};

export type AuthSessionsInsert = {
    aal?: Database["auth"]["Enums"]["aal_level"] | null;
    created_at?: string | null;
    factor_id?: string | null;
    id: string;
    ip?: unknown | null;
    not_after?: string | null;
    refreshed_at?: string | null;
    tag?: string | null;
    updated_at?: string | null;
    user_agent?: string | null;
    user_id: string;
};

export type AuthSessionsUpdate = {
    aal?: Database["auth"]["Enums"]["aal_level"] | null;
    created_at?: string | null;
    factor_id?: string | null;
    id?: string;
    ip?: unknown | null;
    not_after?: string | null;
    refreshed_at?: string | null;
    tag?: string | null;
    updated_at?: string | null;
    user_agent?: string | null;
    user_id?: string;
};

export type AuthSso_domainsRow = {
    created_at: string | null;
    domain: string;
    id: string;
    sso_provider_id: string;
    updated_at: string | null;
};

export type AuthSso_domainsInsert = {
    created_at?: string | null;
    domain: string;
    id: string;
    sso_provider_id: string;
    updated_at?: string | null;
};

export type AuthSso_domainsUpdate = {
    created_at?: string | null;
    domain?: string;
    id?: string;
    sso_provider_id?: string;
    updated_at?: string | null;
};

export type AuthSso_providersRow = {
    created_at: string | null;
    disabled: boolean | null;
    id: string;
    resource_id: string | null;
    updated_at: string | null;
};

export type AuthSso_providersInsert = {
    created_at?: string | null;
    disabled?: boolean | null;
    id: string;
    resource_id?: string | null;
    updated_at?: string | null;
};

export type AuthSso_providersUpdate = {
    created_at?: string | null;
    disabled?: boolean | null;
    id?: string;
    resource_id?: string | null;
    updated_at?: string | null;
};

export type AuthUsersRow = {
    aud: string | null;
    banned_until: string | null;
    confirmation_sent_at: string | null;
    confirmation_token: string | null;
    confirmed_at: string | null;
    created_at: string | null;
    deleted_at: string | null;
    email: string | null;
    email_change: string | null;
    email_change_confirm_status: number | null;
    email_change_sent_at: string | null;
    email_change_token_current: string | null;
    email_change_token_new: string | null;
    email_confirmed_at: string | null;
    encrypted_password: string | null;
    id: string;
    instance_id: string | null;
    invited_at: string | null;
    is_anonymous: boolean;
    is_sso_user: boolean;
    is_super_admin: boolean | null;
    last_sign_in_at: string | null;
    phone: string | null;
    phone_change: string | null;
    phone_change_sent_at: string | null;
    phone_change_token: string | null;
    phone_confirmed_at: string | null;
    raw_app_meta_data: Json | null;
    raw_user_meta_data: Json | null;
    reauthentication_sent_at: string | null;
    reauthentication_token: string | null;
    recovery_sent_at: string | null;
    recovery_token: string | null;
    role: string | null;
    updated_at: string | null;
};

export type AuthUsersInsert = {
    aud?: string | null;
    banned_until?: string | null;
    confirmation_sent_at?: string | null;
    confirmation_token?: string | null;
    confirmed_at?: string | null;
    created_at?: string | null;
    deleted_at?: string | null;
    email?: string | null;
    email_change?: string | null;
    email_change_confirm_status?: number | null;
    email_change_sent_at?: string | null;
    email_change_token_current?: string | null;
    email_change_token_new?: string | null;
    email_confirmed_at?: string | null;
    encrypted_password?: string | null;
    id: string;
    instance_id?: string | null;
    invited_at?: string | null;
    is_anonymous?: boolean;
    is_sso_user?: boolean;
    is_super_admin?: boolean | null;
    last_sign_in_at?: string | null;
    phone?: string | null;
    phone_change?: string | null;
    phone_change_sent_at?: string | null;
    phone_change_token?: string | null;
    phone_confirmed_at?: string | null;
    raw_app_meta_data?: Json | null;
    raw_user_meta_data?: Json | null;
    reauthentication_sent_at?: string | null;
    reauthentication_token?: string | null;
    recovery_sent_at?: string | null;
    recovery_token?: string | null;
    role?: string | null;
    updated_at?: string | null;
};

export type AuthUsersUpdate = {
    aud?: string | null;
    banned_until?: string | null;
    confirmation_sent_at?: string | null;
    confirmation_token?: string | null;
    confirmed_at?: string | null;
    created_at?: string | null;
    deleted_at?: string | null;
    email?: string | null;
    email_change?: string | null;
    email_change_confirm_status?: number | null;
    email_change_sent_at?: string | null;
    email_change_token_current?: string | null;
    email_change_token_new?: string | null;
    email_confirmed_at?: string | null;
    encrypted_password?: string | null;
    id?: string;
    instance_id?: string | null;
    invited_at?: string | null;
    is_anonymous?: boolean;
    is_sso_user?: boolean;
    is_super_admin?: boolean | null;
    last_sign_in_at?: string | null;
    phone?: string | null;
    phone_change?: string | null;
    phone_change_sent_at?: string | null;
    phone_change_token?: string | null;
    phone_confirmed_at?: string | null;
    raw_app_meta_data?: Json | null;
    raw_user_meta_data?: Json | null;
    reauthentication_sent_at?: string | null;
    reauthentication_token?: string | null;
    recovery_sent_at?: string | null;
    recovery_token?: string | null;
    role?: string | null;
    updated_at?: string | null;
};

export type Cable_segmentsRow = {
    created_at: string | null;
    distance_km: number;
    end_node_id: string;
    end_node_type: string;
    fiber_count: number;
    id: string;
    original_cable_id: string;
    segment_order: number;
    start_node_id: string;
    start_node_type: string;
    updated_at: string | null;
};

export type Cable_segmentsInsert = {
    created_at?: string | null;
    distance_km: number;
    end_node_id: string;
    end_node_type: string;
    fiber_count: number;
    id?: string;
    original_cable_id: string;
    segment_order: number;
    start_node_id: string;
    start_node_type: string;
    updated_at?: string | null;
};

export type Cable_segmentsUpdate = {
    created_at?: string | null;
    distance_km?: number;
    end_node_id?: string;
    end_node_type?: string;
    fiber_count?: number;
    id?: string;
    original_cable_id?: string;
    segment_order?: number;
    start_node_id?: string;
    start_node_type?: string;
    updated_at?: string | null;
};

export type Employee_designationsRow = {
    created_at: string | null;
    id: string;
    name: string;
    parent_id: string | null;
    status: boolean | null;
    updated_at: string | null;
};

export type Employee_designationsInsert = {
    created_at?: string | null;
    id?: string;
    name: string;
    parent_id?: string | null;
    status?: boolean | null;
    updated_at?: string | null;
};

export type Employee_designationsUpdate = {
    created_at?: string | null;
    id?: string;
    name?: string;
    parent_id?: string | null;
    status?: boolean | null;
    updated_at?: string | null;
};

export type EmployeesRow = {
    created_at: string | null;
    employee_addr: string | null;
    employee_contact: string | null;
    employee_designation_id: string | null;
    employee_dob: string | null;
    employee_doj: string | null;
    employee_email: string | null;
    employee_name: string;
    employee_pers_no: string | null;
    id: string;
    maintenance_terminal_id: string | null;
    remark: string | null;
    status: boolean | null;
    updated_at: string | null;
};

export type EmployeesInsert = {
    created_at?: string | null;
    employee_addr?: string | null;
    employee_contact?: string | null;
    employee_designation_id?: string | null;
    employee_dob?: string | null;
    employee_doj?: string | null;
    employee_email?: string | null;
    employee_name: string;
    employee_pers_no?: string | null;
    id?: string;
    maintenance_terminal_id?: string | null;
    remark?: string | null;
    status?: boolean | null;
    updated_at?: string | null;
};

export type EmployeesUpdate = {
    created_at?: string | null;
    employee_addr?: string | null;
    employee_contact?: string | null;
    employee_designation_id?: string | null;
    employee_dob?: string | null;
    employee_doj?: string | null;
    employee_email?: string | null;
    employee_name?: string;
    employee_pers_no?: string | null;
    id?: string;
    maintenance_terminal_id?: string | null;
    remark?: string | null;
    status?: boolean | null;
    updated_at?: string | null;
};

export type Fiber_splicesRow = {
    created_at: string | null;
    id: string;
    incoming_fiber_no: number;
    incoming_segment_id: string;
    jc_id: string;
    logical_path_id: string | null;
    loss_db: number | null;
    outgoing_fiber_no: number | null;
    outgoing_segment_id: string | null;
    splice_type_id: string;
    updated_at: string | null;
};

export type Fiber_splicesInsert = {
    created_at?: string | null;
    id?: string;
    incoming_fiber_no: number;
    incoming_segment_id: string;
    jc_id: string;
    logical_path_id?: string | null;
    loss_db?: number | null;
    outgoing_fiber_no?: number | null;
    outgoing_segment_id?: string | null;
    splice_type_id: string;
    updated_at?: string | null;
};

export type Fiber_splicesUpdate = {
    created_at?: string | null;
    id?: string;
    incoming_fiber_no?: number;
    incoming_segment_id?: string;
    jc_id?: string;
    logical_path_id?: string | null;
    loss_db?: number | null;
    outgoing_fiber_no?: number | null;
    outgoing_segment_id?: string | null;
    splice_type_id?: string;
    updated_at?: string | null;
};

export type FilesRow = {
    file_name: string;
    file_route: string;
    file_size: string;
    file_type: string;
    file_url: string;
    folder_id: string | null;
    id: string;
    uploaded_at: string | null;
    user_id: string;
};

export type FilesInsert = {
    file_name: string;
    file_route: string;
    file_size: string;
    file_type: string;
    file_url: string;
    folder_id?: string | null;
    id?: string;
    uploaded_at?: string | null;
    user_id: string;
};

export type FilesUpdate = {
    file_name?: string;
    file_route?: string;
    file_size?: string;
    file_type?: string;
    file_url?: string;
    folder_id?: string | null;
    id?: string;
    uploaded_at?: string | null;
    user_id?: string;
};

export type FoldersRow = {
    created_at: string | null;
    id: string;
    name: string;
    user_id: string;
};

export type FoldersInsert = {
    created_at?: string | null;
    id?: string;
    name: string;
    user_id: string;
};

export type FoldersUpdate = {
    created_at?: string | null;
    id?: string;
    name?: string;
    user_id?: string;
};

export type Junction_closuresRow = {
    created_at: string | null;
    id: string;
    node_id: string;
    ofc_cable_id: string;
    position_km: number | null;
    updated_at: string | null;
};

export type Junction_closuresInsert = {
    created_at?: string | null;
    id?: string;
    node_id: string;
    ofc_cable_id: string;
    position_km?: number | null;
    updated_at?: string | null;
};

export type Junction_closuresUpdate = {
    created_at?: string | null;
    id?: string;
    node_id?: string;
    ofc_cable_id?: string;
    position_km?: number | null;
    updated_at?: string | null;
};

export type Logical_fiber_pathsRow = {
    bandwidth_gbps: number | null;
    commissioned_date: string | null;
    created_at: string | null;
    destination_port: string | null;
    destination_system_id: string | null;
    id: string;
    operational_status_id: string | null;
    path_name: string | null;
    path_role: string;
    path_type_id: string | null;
    remark: string | null;
    service_type: string | null;
    source_port: string | null;
    source_system_id: string | null;
    total_distance_km: number | null;
    total_loss_db: number | null;
    updated_at: string | null;
    wavelength_nm: number | null;
    working_path_id: string | null;
};

export type Logical_fiber_pathsInsert = {
    bandwidth_gbps?: number | null;
    commissioned_date?: string | null;
    created_at?: string | null;
    destination_port?: string | null;
    destination_system_id?: string | null;
    id?: string;
    operational_status_id?: string | null;
    path_name?: string | null;
    path_role?: string;
    path_type_id?: string | null;
    remark?: string | null;
    service_type?: string | null;
    source_port?: string | null;
    source_system_id?: string | null;
    total_distance_km?: number | null;
    total_loss_db?: number | null;
    updated_at?: string | null;
    wavelength_nm?: number | null;
    working_path_id?: string | null;
};

export type Logical_fiber_pathsUpdate = {
    bandwidth_gbps?: number | null;
    commissioned_date?: string | null;
    created_at?: string | null;
    destination_port?: string | null;
    destination_system_id?: string | null;
    id?: string;
    operational_status_id?: string | null;
    path_name?: string | null;
    path_role?: string;
    path_type_id?: string | null;
    remark?: string | null;
    service_type?: string | null;
    source_port?: string | null;
    source_system_id?: string | null;
    total_distance_km?: number | null;
    total_loss_db?: number | null;
    updated_at?: string | null;
    wavelength_nm?: number | null;
    working_path_id?: string | null;
};

export type Logical_path_segmentsRow = {
    created_at: string | null;
    id: string;
    logical_path_id: string;
    ofc_cable_id: string | null;
    path_order: number;
    updated_at: string | null;
};

export type Logical_path_segmentsInsert = {
    created_at?: string | null;
    id?: string;
    logical_path_id: string;
    ofc_cable_id?: string | null;
    path_order: number;
    updated_at?: string | null;
};

export type Logical_path_segmentsUpdate = {
    created_at?: string | null;
    id?: string;
    logical_path_id?: string;
    ofc_cable_id?: string | null;
    path_order?: number;
    updated_at?: string | null;
};

export type Lookup_typesRow = {
    category: string;
    code: string | null;
    created_at: string | null;
    description: string | null;
    id: string;
    is_system_default: boolean | null;
    name: string;
    sort_order: number | null;
    status: boolean | null;
    updated_at: string | null;
};

export type Lookup_typesInsert = {
    category: string;
    code?: string | null;
    created_at?: string | null;
    description?: string | null;
    id?: string;
    is_system_default?: boolean | null;
    name: string;
    sort_order?: number | null;
    status?: boolean | null;
    updated_at?: string | null;
};

export type Lookup_typesUpdate = {
    category?: string;
    code?: string | null;
    created_at?: string | null;
    description?: string | null;
    id?: string;
    is_system_default?: boolean | null;
    name?: string;
    sort_order?: number | null;
    status?: boolean | null;
    updated_at?: string | null;
};

export type Maintenance_areasRow = {
    address: string | null;
    area_type_id: string | null;
    code: string | null;
    contact_number: string | null;
    contact_person: string | null;
    created_at: string | null;
    email: string | null;
    id: string;
    latitude: number | null;
    longitude: number | null;
    name: string;
    parent_id: string | null;
    status: boolean | null;
    updated_at: string | null;
};

export type Maintenance_areasInsert = {
    address?: string | null;
    area_type_id?: string | null;
    code?: string | null;
    contact_number?: string | null;
    contact_person?: string | null;
    created_at?: string | null;
    email?: string | null;
    id?: string;
    latitude?: number | null;
    longitude?: number | null;
    name: string;
    parent_id?: string | null;
    status?: boolean | null;
    updated_at?: string | null;
};

export type Maintenance_areasUpdate = {
    address?: string | null;
    area_type_id?: string | null;
    code?: string | null;
    contact_number?: string | null;
    contact_person?: string | null;
    created_at?: string | null;
    email?: string | null;
    id?: string;
    latitude?: number | null;
    longitude?: number | null;
    name?: string;
    parent_id?: string | null;
    status?: boolean | null;
    updated_at?: string | null;
};

export type Management_portsRow = {
    commissioned_on: string | null;
    created_at: string | null;
    id: string;
    name: string | null;
    node_id: string | null;
    port_no: string;
    remark: string | null;
    status: boolean | null;
    system_id: string | null;
    updated_at: string | null;
};

export type Management_portsInsert = {
    commissioned_on?: string | null;
    created_at?: string | null;
    id?: string;
    name?: string | null;
    node_id?: string | null;
    port_no: string;
    remark?: string | null;
    status?: boolean | null;
    system_id?: string | null;
    updated_at?: string | null;
};

export type Management_portsUpdate = {
    commissioned_on?: string | null;
    created_at?: string | null;
    id?: string;
    name?: string | null;
    node_id?: string | null;
    port_no?: string;
    remark?: string | null;
    status?: boolean | null;
    system_id?: string | null;
    updated_at?: string | null;
};

export type NodesRow = {
    created_at: string | null;
    id: string;
    latitude: number | null;
    longitude: number | null;
    maintenance_terminal_id: string | null;
    name: string;
    node_type_id: string | null;
    remark: string | null;
    status: boolean | null;
    updated_at: string | null;
};

export type NodesInsert = {
    created_at?: string | null;
    id?: string;
    latitude?: number | null;
    longitude?: number | null;
    maintenance_terminal_id?: string | null;
    name: string;
    node_type_id?: string | null;
    remark?: string | null;
    status?: boolean | null;
    updated_at?: string | null;
};

export type NodesUpdate = {
    created_at?: string | null;
    id?: string;
    latitude?: number | null;
    longitude?: number | null;
    maintenance_terminal_id?: string | null;
    name?: string;
    node_type_id?: string | null;
    remark?: string | null;
    status?: boolean | null;
    updated_at?: string | null;
};

export type Ofc_cablesRow = {
    asset_no: string | null;
    capacity: number;
    commissioned_on: string | null;
    created_at: string | null;
    current_rkm: number | null;
    en_id: string;
    id: string;
    maintenance_terminal_id: string | null;
    ofc_owner_id: string;
    ofc_type_id: string;
    remark: string | null;
    route_name: string;
    sn_id: string;
    status: boolean | null;
    transnet_id: string | null;
    transnet_rkm: number | null;
    updated_at: string | null;
};

export type Ofc_cablesInsert = {
    asset_no?: string | null;
    capacity: number;
    commissioned_on?: string | null;
    created_at?: string | null;
    current_rkm?: number | null;
    en_id: string;
    id?: string;
    maintenance_terminal_id?: string | null;
    ofc_owner_id: string;
    ofc_type_id: string;
    remark?: string | null;
    route_name: string;
    sn_id: string;
    status?: boolean | null;
    transnet_id?: string | null;
    transnet_rkm?: number | null;
    updated_at?: string | null;
};

export type Ofc_cablesUpdate = {
    asset_no?: string | null;
    capacity?: number;
    commissioned_on?: string | null;
    created_at?: string | null;
    current_rkm?: number | null;
    en_id?: string;
    id?: string;
    maintenance_terminal_id?: string | null;
    ofc_owner_id?: string;
    ofc_type_id?: string;
    remark?: string | null;
    route_name?: string;
    sn_id?: string;
    status?: boolean | null;
    transnet_id?: string | null;
    transnet_rkm?: number | null;
    updated_at?: string | null;
};

export type Ofc_connectionsRow = {
    connection_category: string;
    connection_type: string;
    created_at: string | null;
    destination_port: string | null;
    en_dom: string | null;
    en_power_dbm: number | null;
    fiber_no_en: number;
    fiber_no_sn: number;
    fiber_role: string | null;
    id: string;
    logical_path_id: string | null;
    ofc_id: string;
    otdr_distance_en_km: number | null;
    otdr_distance_sn_km: number | null;
    path_segment_order: number | null;
    remark: string | null;
    route_loss_db: number | null;
    sn_dom: string | null;
    sn_power_dbm: number | null;
    source_port: string | null;
    status: boolean | null;
    system_id: string | null;
    updated_at: string | null;
    updated_en_id: string | null;
    updated_fiber_no_en: number | null;
    updated_fiber_no_sn: number | null;
    updated_sn_id: string | null;
};

export type Ofc_connectionsInsert = {
    connection_category?: string;
    connection_type?: string;
    created_at?: string | null;
    destination_port?: string | null;
    en_dom?: string | null;
    en_power_dbm?: number | null;
    fiber_no_en: number;
    fiber_no_sn: number;
    fiber_role?: string | null;
    id?: string;
    logical_path_id?: string | null;
    ofc_id: string;
    otdr_distance_en_km?: number | null;
    otdr_distance_sn_km?: number | null;
    path_segment_order?: number | null;
    remark?: string | null;
    route_loss_db?: number | null;
    sn_dom?: string | null;
    sn_power_dbm?: number | null;
    source_port?: string | null;
    status?: boolean | null;
    system_id?: string | null;
    updated_at?: string | null;
    updated_en_id?: string | null;
    updated_fiber_no_en?: number | null;
    updated_fiber_no_sn?: number | null;
    updated_sn_id?: string | null;
};

export type Ofc_connectionsUpdate = {
    connection_category?: string;
    connection_type?: string;
    created_at?: string | null;
    destination_port?: string | null;
    en_dom?: string | null;
    en_power_dbm?: number | null;
    fiber_no_en?: number;
    fiber_no_sn?: number;
    fiber_role?: string | null;
    id?: string;
    logical_path_id?: string | null;
    ofc_id?: string;
    otdr_distance_en_km?: number | null;
    otdr_distance_sn_km?: number | null;
    path_segment_order?: number | null;
    remark?: string | null;
    route_loss_db?: number | null;
    sn_dom?: string | null;
    sn_power_dbm?: number | null;
    source_port?: string | null;
    status?: boolean | null;
    system_id?: string | null;
    updated_at?: string | null;
    updated_en_id?: string | null;
    updated_fiber_no_en?: number | null;
    updated_fiber_no_sn?: number | null;
    updated_sn_id?: string | null;
};

export type Ring_based_systemsRow = {
    maintenance_area_id: string | null;
    ring_id: string | null;
    system_id: string;
};

export type Ring_based_systemsInsert = {
    maintenance_area_id?: string | null;
    ring_id?: string | null;
    system_id: string;
};

export type Ring_based_systemsUpdate = {
    maintenance_area_id?: string | null;
    ring_id?: string | null;
    system_id?: string;
};

export type RingsRow = {
    created_at: string | null;
    description: string | null;
    id: string;
    maintenance_terminal_id: string | null;
    name: string;
    ring_type_id: string | null;
    status: boolean | null;
    total_nodes: number | null;
    updated_at: string | null;
};

export type RingsInsert = {
    created_at?: string | null;
    description?: string | null;
    id?: string;
    maintenance_terminal_id?: string | null;
    name: string;
    ring_type_id?: string | null;
    status?: boolean | null;
    total_nodes?: number | null;
    updated_at?: string | null;
};

export type RingsUpdate = {
    created_at?: string | null;
    description?: string | null;
    id?: string;
    maintenance_terminal_id?: string | null;
    name?: string;
    ring_type_id?: string | null;
    status?: boolean | null;
    total_nodes?: number | null;
    updated_at?: string | null;
};

export type Sdh_connectionsRow = {
    a_customer: string | null;
    a_slot: string | null;
    b_customer: string | null;
    b_slot: string | null;
    carrier: string | null;
    stm_no: string | null;
    system_connection_id: string;
};

export type Sdh_connectionsInsert = {
    a_customer?: string | null;
    a_slot?: string | null;
    b_customer?: string | null;
    b_slot?: string | null;
    carrier?: string | null;
    stm_no?: string | null;
    system_connection_id: string;
};

export type Sdh_connectionsUpdate = {
    a_customer?: string | null;
    a_slot?: string | null;
    b_customer?: string | null;
    b_slot?: string | null;
    carrier?: string | null;
    stm_no?: string | null;
    system_connection_id?: string;
};

export type Sdh_node_associationsRow = {
    id: string;
    node_id: string;
    node_ip: unknown | null;
    node_position: string | null;
    sdh_system_id: string;
};

export type Sdh_node_associationsInsert = {
    id?: string;
    node_id: string;
    node_ip?: unknown | null;
    node_position?: string | null;
    sdh_system_id: string;
};

export type Sdh_node_associationsUpdate = {
    id?: string;
    node_id?: string;
    node_ip?: unknown | null;
    node_position?: string | null;
    sdh_system_id?: string;
};

export type Sdh_systemsRow = {
    gne: string | null;
    system_id: string;
};

export type Sdh_systemsInsert = {
    gne?: string | null;
    system_id: string;
};

export type Sdh_systemsUpdate = {
    gne?: string | null;
    system_id?: string;
};

export type Sfp_based_connectionsRow = {
    bandwidth_allocated_mbps: number | null;
    customer_name: string | null;
    fiber_in: number | null;
    fiber_out: number | null;
    sfp_capacity: string | null;
    sfp_port: string | null;
    sfp_serial_no: string | null;
    sfp_type_id: string | null;
    system_connection_id: string;
};

export type Sfp_based_connectionsInsert = {
    bandwidth_allocated_mbps?: number | null;
    customer_name?: string | null;
    fiber_in?: number | null;
    fiber_out?: number | null;
    sfp_capacity?: string | null;
    sfp_port?: string | null;
    sfp_serial_no?: string | null;
    sfp_type_id?: string | null;
    system_connection_id: string;
};

export type Sfp_based_connectionsUpdate = {
    bandwidth_allocated_mbps?: number | null;
    customer_name?: string | null;
    fiber_in?: number | null;
    fiber_out?: number | null;
    sfp_capacity?: string | null;
    sfp_port?: string | null;
    sfp_serial_no?: string | null;
    sfp_type_id?: string | null;
    system_connection_id?: string;
};

export type System_connectionsRow = {
    bandwidth_mbps: number | null;
    commissioned_on: string | null;
    connected_system_id: string | null;
    created_at: string | null;
    en_id: string | null;
    en_interface: string | null;
    en_ip: unknown | null;
    id: string;
    media_type_id: string | null;
    remark: string | null;
    sn_id: string | null;
    sn_interface: string | null;
    sn_ip: unknown | null;
    status: boolean | null;
    system_id: string;
    updated_at: string | null;
    vlan: string | null;
};

export type System_connectionsInsert = {
    bandwidth_mbps?: number | null;
    commissioned_on?: string | null;
    connected_system_id?: string | null;
    created_at?: string | null;
    en_id?: string | null;
    en_interface?: string | null;
    en_ip?: unknown | null;
    id?: string;
    media_type_id?: string | null;
    remark?: string | null;
    sn_id?: string | null;
    sn_interface?: string | null;
    sn_ip?: unknown | null;
    status?: boolean | null;
    system_id: string;
    updated_at?: string | null;
    vlan?: string | null;
};

export type System_connectionsUpdate = {
    bandwidth_mbps?: number | null;
    commissioned_on?: string | null;
    connected_system_id?: string | null;
    created_at?: string | null;
    en_id?: string | null;
    en_interface?: string | null;
    en_ip?: unknown | null;
    id?: string;
    media_type_id?: string | null;
    remark?: string | null;
    sn_id?: string | null;
    sn_interface?: string | null;
    sn_ip?: unknown | null;
    status?: boolean | null;
    system_id?: string;
    updated_at?: string | null;
    vlan?: string | null;
};

export type SystemsRow = {
    commissioned_on: string | null;
    created_at: string | null;
    id: string;
    ip_address: unknown | null;
    maintenance_terminal_id: string | null;
    make: string | null;
    node_id: string;
    remark: string | null;
    s_no: string | null;
    status: boolean | null;
    system_name: string | null;
    system_type_id: string;
    updated_at: string | null;
};

export type SystemsInsert = {
    commissioned_on?: string | null;
    created_at?: string | null;
    id?: string;
    ip_address?: unknown | null;
    maintenance_terminal_id?: string | null;
    make?: string | null;
    node_id: string;
    remark?: string | null;
    s_no?: string | null;
    status?: boolean | null;
    system_name?: string | null;
    system_type_id: string;
    updated_at?: string | null;
};

export type SystemsUpdate = {
    commissioned_on?: string | null;
    created_at?: string | null;
    id?: string;
    ip_address?: unknown | null;
    maintenance_terminal_id?: string | null;
    make?: string | null;
    node_id?: string;
    remark?: string | null;
    s_no?: string | null;
    status?: boolean | null;
    system_name?: string | null;
    system_type_id?: string;
    updated_at?: string | null;
};

export type User_profilesRow = {
    address: Json | null;
    avatar_url: string | null;
    created_at: string | null;
    date_of_birth: string | null;
    designation: string | null;
    first_name: string;
    id: string;
    last_name: string;
    phone_number: string | null;
    preferences: Json | null;
    role: string | null;
    status: string | null;
    updated_at: string | null;
};

export type User_profilesInsert = {
    address?: Json | null;
    avatar_url?: string | null;
    created_at?: string | null;
    date_of_birth?: string | null;
    designation?: string | null;
    first_name: string;
    id: string;
    last_name: string;
    phone_number?: string | null;
    preferences?: Json | null;
    role?: string | null;
    status?: string | null;
    updated_at?: string | null;
};

export type User_profilesUpdate = {
    address?: Json | null;
    avatar_url?: string | null;
    created_at?: string | null;
    date_of_birth?: string | null;
    designation?: string | null;
    first_name?: string;
    id?: string;
    last_name?: string;
    phone_number?: string | null;
    preferences?: Json | null;
    role?: string | null;
    status?: string | null;
    updated_at?: string | null;
};

export type Vmux_connectionsRow = {
    c_code: string | null;
    channel: string | null;
    subscriber: string | null;
    system_connection_id: string;
    tk: string | null;
};

export type Vmux_connectionsInsert = {
    c_code?: string | null;
    channel?: string | null;
    subscriber?: string | null;
    system_connection_id: string;
    tk?: string | null;
};

export type Vmux_connectionsUpdate = {
    c_code?: string | null;
    channel?: string | null;
    subscriber?: string | null;
    system_connection_id?: string;
    tk?: string | null;
};

export type Vmux_systemsRow = {
    system_id: string;
    vm_id: string | null;
};

export type Vmux_systemsInsert = {
    system_id: string;
    vm_id?: string | null;
};

export type Vmux_systemsUpdate = {
    system_id?: string;
    vm_id?: string | null;
};

// ============= VIEWS =============

export type V_cable_segments_at_jcRow = {
    end_node_id: string | null;
    fiber_count: number | null;
    id: string | null;
    jc_node_id: string | null;
    original_cable_id: string | null;
    segment_order: number | null;
    start_node_id: string | null;
};

export type V_cable_utilizationRow = {
    available_fibers: number | null;
    cable_id: string | null;
    capacity: number | null;
    route_name: string | null;
    used_fibers: number | null;
    utilization_percent: number | null;
};

export type V_employee_designationsRow = {
    created_at: string | null;
    id: string | null;
    name: string | null;
    parent_id: string | null;
    status: boolean | null;
    updated_at: string | null;
};

export type V_employeesRow = {
    created_at: string | null;
    employee_addr: string | null;
    employee_contact: string | null;
    employee_designation_id: string | null;
    employee_designation_name: string | null;
    employee_dob: string | null;
    employee_doj: string | null;
    employee_email: string | null;
    employee_name: string | null;
    employee_pers_no: string | null;
    id: string | null;
    maintenance_terminal_id: string | null;
    remark: string | null;
    status: boolean | null;
    updated_at: string | null;
};

export type V_end_to_end_pathsRow = {
    destination_system_id: string | null;
    operational_status: string | null;
    path_id: string | null;
    path_name: string | null;
    route_names: string | null;
    segment_count: number | null;
    source_system_id: string | null;
    total_distance_km: number | null;
    total_loss_db: number | null;
};

export type V_junction_closures_completeRow = {
    id: string | null;
    latitude: number | null;
    longitude: number | null;
    name: string | null;
    node_id: string | null;
    ofc_cable_id: string | null;
    position_km: number | null;
};

export type V_lookup_typesRow = {
    category: string | null;
    code: string | null;
    created_at: string | null;
    description: string | null;
    id: string | null;
    is_system_default: boolean | null;
    name: string | null;
    sort_order: number | null;
    status: boolean | null;
    updated_at: string | null;
};

export type V_maintenance_areasRow = {
    address: string | null;
    area_type_id: string | null;
    code: string | null;
    contact_number: string | null;
    contact_person: string | null;
    created_at: string | null;
    email: string | null;
    id: string | null;
    latitude: number | null;
    longitude: number | null;
    maintenance_area_type_code: string | null;
    maintenance_area_type_name: string | null;
    name: string | null;
    parent_id: string | null;
    status: boolean | null;
    updated_at: string | null;
};

export type V_nodes_completeRow = {
    created_at: string | null;
    id: string | null;
    latitude: number | null;
    longitude: number | null;
    maintenance_area_name: string | null;
    maintenance_terminal_id: string | null;
    name: string | null;
    node_type_code: string | null;
    node_type_id: string | null;
    node_type_name: string | null;
    remark: string | null;
    status: boolean | null;
    updated_at: string | null;
};

export type V_ofc_cables_completeRow = {
    asset_no: string | null;
    capacity: number | null;
    commissioned_on: string | null;
    created_at: string | null;
    current_rkm: number | null;
    en_id: string | null;
    en_name: string | null;
    en_node_type_name: string | null;
    id: string | null;
    maintenance_area_code: string | null;
    maintenance_area_name: string | null;
    maintenance_terminal_id: string | null;
    ofc_owner_code: string | null;
    ofc_owner_id: string | null;
    ofc_owner_name: string | null;
    ofc_type_code: string | null;
    ofc_type_id: string | null;
    ofc_type_name: string | null;
    remark: string | null;
    route_name: string | null;
    sn_id: string | null;
    sn_name: string | null;
    sn_node_type_name: string | null;
    status: boolean | null;
    transnet_id: string | null;
    transnet_rkm: number | null;
    updated_at: string | null;
};

export type V_ofc_connections_completeRow = {
    connection_category: string | null;
    connection_type: string | null;
    created_at: string | null;
    destination_port: string | null;
    en_dom: string | null;
    en_id: string | null;
    en_name: string | null;
    en_power_dbm: number | null;
    fiber_no_en: number | null;
    fiber_no_sn: number | null;
    fiber_role: string | null;
    id: string | null;
    logical_path_id: string | null;
    maintenance_area_name: string | null;
    ofc_id: string | null;
    ofc_route_name: string | null;
    ofc_type_name: string | null;
    otdr_distance_en_km: number | null;
    otdr_distance_sn_km: number | null;
    path_segment_order: number | null;
    remark: string | null;
    route_loss_db: number | null;
    sn_dom: string | null;
    sn_id: string | null;
    sn_name: string | null;
    sn_power_dbm: number | null;
    source_port: string | null;
    status: boolean | null;
    system_id: string | null;
    system_name: string | null;
    updated_at: string | null;
    updated_en_id: string | null;
    updated_en_name: string | null;
    updated_fiber_no_en: number | null;
    updated_fiber_no_sn: number | null;
    updated_sn_id: string | null;
    updated_sn_name: string | null;
};

export type V_ring_nodesRow = {
    id: string | null;
    ip: string | null;
    lat: number | null;
    long: number | null;
    name: string | null;
    order_in_ring: number | null;
    remark: string | null;
    ring_id: string | null;
    ring_name: string | null;
    ring_status: boolean | null;
    system_status: boolean | null;
    type: string | null;
};

export type V_ringsRow = {
    created_at: string | null;
    description: string | null;
    id: string | null;
    maintenance_area_name: string | null;
    maintenance_terminal_id: string | null;
    name: string | null;
    ring_type_code: string | null;
    ring_type_id: string | null;
    ring_type_name: string | null;
    status: boolean | null;
    total_nodes: number | null;
    updated_at: string | null;
};

export type V_system_connections_completeRow = {
    bandwidth_allocated_mbps: number | null;
    bandwidth_mbps: number | null;
    commissioned_on: string | null;
    connected_system_name: string | null;
    connected_system_type_name: string | null;
    created_at: string | null;
    customer_name: string | null;
    en_interface: string | null;
    en_ip: unknown | null;
    en_name: string | null;
    en_node_name: string | null;
    fiber_in: number | null;
    fiber_out: number | null;
    id: string | null;
    media_type_name: string | null;
    remark: string | null;
    sdh_a_customer: string | null;
    sdh_a_slot: string | null;
    sdh_b_customer: string | null;
    sdh_b_slot: string | null;
    sdh_carrier: string | null;
    sdh_stm_no: string | null;
    sfp_capacity: string | null;
    sfp_port: string | null;
    sfp_serial_no: string | null;
    sfp_type_name: string | null;
    sn_interface: string | null;
    sn_ip: unknown | null;
    sn_name: string | null;
    sn_node_name: string | null;
    status: boolean | null;
    system_id: string | null;
    system_name: string | null;
    system_type_name: string | null;
    updated_at: string | null;
    vlan: string | null;
    vmux_c_code: string | null;
    vmux_channel: string | null;
    vmux_subscriber: string | null;
    vmux_tk: string | null;
};

export type V_system_ring_paths_detailedRow = {
    created_at: string | null;
    end_node_id: string | null;
    end_node_name: string | null;
    id: string | null;
    logical_path_id: string | null;
    ofc_cable_id: string | null;
    path_name: string | null;
    path_order: number | null;
    route_name: string | null;
    source_system_id: string | null;
    start_node_id: string | null;
    start_node_name: string | null;
};

export type V_systems_completeRow = {
    commissioned_on: string | null;
    created_at: string | null;
    id: string | null;
    ip_address: unknown | null;
    latitude: number | null;
    longitude: number | null;
    maintenance_terminal_id: string | null;
    make: string | null;
    node_id: string | null;
    node_name: string | null;
    node_type_name: string | null;
    remark: string | null;
    ring_id: string | null;
    ring_logical_area_name: string | null;
    s_no: string | null;
    sdh_gne: string | null;
    status: boolean | null;
    system_category: string | null;
    system_maintenance_terminal_name: string | null;
    system_name: string | null;
    system_type_code: string | null;
    system_type_id: string | null;
    system_type_name: string | null;
    updated_at: string | null;
    vmux_vm_id: string | null;
};

export type V_user_profiles_extendedRow = {
    account_age_days: number | null;
    address: Json | null;
    auth_updated_at: string | null;
    avatar_url: string | null;
    computed_status: string | null;
    created_at: string | null;
    date_of_birth: string | null;
    designation: string | null;
    email: string | null;
    email_confirmed_at: string | null;
    first_name: string | null;
    full_name: string | null;
    id: string | null;
    is_email_verified: boolean | null;
    is_phone_verified: boolean | null;
    is_super_admin: boolean | null;
    last_activity_period: string | null;
    last_name: string | null;
    last_sign_in_at: string | null;
    phone_confirmed_at: string | null;
    phone_number: string | null;
    preferences: Json | null;
    raw_app_meta_data: Json | null;
    raw_user_meta_data: Json | null;
    role: string | null;
    status: string | null;
    updated_at: string | null;
};

// ============= ENUMS =============

export type AuthAal_level = "aal1" | "aal2" | "aal3";

export type AuthCode_challenge_method = "s256" | "plain";

export type AuthFactor_status = "unverified" | "verified";

export type AuthFactor_type = "totp" | "webauthn" | "phone";

export type AuthOauth_registration_type = "dynamic" | "manual";

export type AuthOne_time_token_type = "confirmation_token" | "reauthentication_token" | "recovery_token" | "email_change_token_new" | "email_change_token_current" | "phone_change_token";

// ============= HELPERS =============

export const tableNames = [
  "audit_log_entries",
  "flow_state",
  "identities",
  "instances",
  "mfa_amr_claims",
  "mfa_challenges",
  "mfa_factors",
  "oauth_clients",
  "one_time_tokens",
  "refresh_tokens",
  "saml_providers",
  "saml_relay_states",
  "schema_migrations",
  "sessions",
  "sso_domains",
  "sso_providers",
  "users",
  "cable_segments",
  "employee_designations",
  "employees",
  "fiber_splices",
  "files",
  "folders",
  "junction_closures",
  "logical_fiber_paths",
  "logical_path_segments",
  "lookup_types",
  "maintenance_areas",
  "management_ports",
  "nodes",
  "ofc_cables",
  "ofc_connections",
  "ring_based_systems",
  "rings",
  "sdh_connections",
  "sdh_node_associations",
  "sdh_systems",
  "sfp_based_connections",
  "system_connections",
  "systems",
  "user_profiles",
  "vmux_connections",
  "vmux_systems"
] as const;

export const viewNames = [
  "v_cable_segments_at_jc",
  "v_cable_utilization",
  "v_employee_designations",
  "v_employees",
  "v_end_to_end_paths",
  "v_junction_closures_complete",
  "v_lookup_types",
  "v_maintenance_areas",
  "v_nodes_complete",
  "v_ofc_cables_complete",
  "v_ofc_connections_complete",
  "v_ring_nodes",
  "v_rings",
  "v_system_connections_complete",
  "v_system_ring_paths_detailed",
  "v_systems_complete",
  "v_user_profiles_extended"
] as const;


```

<!-- path: types/user-roles.ts -->
```typescript
// types/user-roles.ts

export enum UserRole {
    ADMIN = "admin",
    CPANADMIN = "cpan_admin",
    MAANADMIN = "maan_admin",
    SDHADMIN = "sdh_admin",
    VMUXADMIN = "vmux_admin",
    MNGADMIN = "mng_admin",
    VIEWER = "viewer",
    AUTHENTICATED = "authenticated",
    ANON = "anon",
}
```

<!-- path: lib/queryClient.ts -->
```typescript

// lib/queryClient.ts
import { QueryClient } from '@tanstack/react-query'

export const queryClient = new QueryClient({
  defaultOptions: {
    queries: {
      staleTime: 5 * 60 * 1000, // 5 minutes
      gcTime: 10 * 60 * 1000, // 10 minutes (formerly cacheTime)
      retry: (failureCount, error: Error) => {
        // Don't retry on 4xx errors
        if ('status' in error && typeof error.status === 'number' && error.status >= 400 && error.status < 500) {
          return false
        }
        return failureCount < 3
      },
      refetchOnWindowFocus: false,
    },
    mutations: {
      retry: 1,
    },
  },
})
```

<!-- path: lib/utils.ts -->
```typescript
import { clsx, type ClassValue } from "clsx"
import { twMerge } from "tailwind-merge"

export function cn(...inputs: ClassValue[]) {
  return twMerge(clsx(inputs))
}

```

<!-- path: app/terms/page.tsx -->
```typescript
// app/terms/page.tsx
import Terms from '@/components/auth/terms';

const TermsPage = () => {
 return (
 <Terms />
 );
};

export default TermsPage;
```

<!-- path: app/(auth)/login/page.tsx -->
```typescript
'use client';

import { useForm } from 'react-hook-form';
import { zodResolver } from '@hookform/resolvers/zod';
import Link from 'next/link';
import { useRouter, useSearchParams } from 'next/navigation';
import { useAuth } from '@/hooks/useAuth';
import OAuthProviders from '@/components/auth/OAuthProviders';
import { useEffect } from 'react';
import { toast } from 'sonner';
import { authUsersRowSchema } from '@/schemas/zod-schemas';
import { z } from 'zod';

// CORRECTED: Use the auto-generated schema as the single source of truth.
// We only pick the fields that are relevant to the login form.
export const loginSchema = authUsersRowSchema.pick({
  email: true,
  encrypted_password: true,
});

type LoginForm = z.infer<typeof loginSchema>;

export default function LoginPage() {
  const { authState, signIn } = useAuth();
  const router = useRouter();
  const searchParams = useSearchParams();
  const redirectTo = searchParams.get('redirectTo') || '/dashboard';
  const errorParam = searchParams.get('error');

  const {
    register,
    handleSubmit,
    formState: { errors, isSubmitting },
  } = useForm<LoginForm>({
    resolver: zodResolver(loginSchema),
    defaultValues: {
      email: '',
      encrypted_password: '',
    },
  });

  // Redirect if already authenticated
  useEffect(() => {
    if (authState === 'authenticated') {
      router.push('/dashboard');
    }
  }, [authState, router]);

  useEffect(() => {
    if (errorParam === 'oauth_failed') {
      toast.error('OAuth authentication failed. Please try again.');
    }
  }, [errorParam]);

  const onSubmit = async (data: LoginForm) => {
    // The nullish coalescing operator `??` provides a fallback and satisfies TypeScript
    const { success } = await signIn(data.email ?? '', data.encrypted_password ?? '');
    if (success) {
      router.push(redirectTo);
    }
  };

  return (
    <div className="min-h-screen flex items-center justify-center bg-gray-50 dark:bg-gray-900 py-12 px-4 sm:px-6 lg:px-8">
      <div className="max-w-md w-full space-y-8">
        <div>
          <h2 className="mt-6 text-center text-3xl font-extrabold text-gray-900 dark:text-white font-family-heading">
            Sign in to your account
          </h2>
          <p className="mt-2 text-center text-sm text-gray-600 dark:text-gray-400">
            Or{' '}
            <Link
              href="/signup"
              className="font-medium text-blue-600 hover:text-blue-500 dark:text-blue-400 dark:hover:text-blue-300"
            >
              create a new account
            </Link>
          </p>
        </div>

        <div className="bg-white dark:bg-gray-800 py-8 px-6 shadow-lg rounded-lg">
          <OAuthProviders
            variant="login"
            providers={['google']}
            className="mb-6"
          />

          <form className="space-y-6" onSubmit={handleSubmit(onSubmit)}>
            <div>
              <label
                htmlFor="email"
                className="block text-sm font-medium text-gray-700 dark:text-gray-300"
              >
                Email address
              </label>
              <input
                id="email"
                type="email"
                autoComplete="email"
                {...register('email')}
                className="mt-1 block w-full px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-md shadow-sm focus:outline-none focus:ring-blue-500 focus:border-blue-500 dark:focus:ring-blue-400 dark:focus:border-blue-400 dark:bg-gray-700 dark:text-white"
                placeholder="Enter your email"
              />
              {errors.email && (
                <p className="text-red-500 text-sm">{errors.email.message}</p>
              )}
            </div>

            <div>
              <label
                htmlFor="password"
                className="block text-sm font-medium text-gray-700 dark:text-gray-300"
              >
                Password
              </label>
              <input
                id="password"
                type="password"
                autoComplete="current-password"
                {...register('encrypted_password')}
                className="mt-1 block w-full px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-md shadow-sm focus:outline-none focus:ring-blue-500 focus:border-blue-500 dark:focus:ring-blue-400 dark:focus:border-blue-400 dark:bg-gray-700 dark:text-white"
                placeholder="Enter your password"
              />
              {errors.encrypted_password && (
                <p className="text-red-500 text-sm">
                  {errors.encrypted_password.message}
                </p>
              )}
            </div>

            <div className="flex items-center justify-between">
              <div className="text-sm">
                <Link
                  href="/forgot-password"
                  className="font-medium text-blue-600 hover:text-blue-500 dark:text-blue-400 dark:hover:text-blue-300"
                >
                  Forgot your password?
                </Link>
              </div>
            </div>

            <div>
              <button
                type="submit"
                disabled={isSubmitting}
                className="group relative w-full flex justify-center py-2 px-4 border border-transparent text-sm font-medium rounded-md text-white bg-blue-600 hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-blue-500 disabled:opacity-50 disabled:cursor-not-allowed dark:bg-blue-500 dark:hover:bg-blue-600 dark:focus:ring-blue-400"
              >
                {isSubmitting ? (
                  <div className="animate-spin rounded-full h-5 w-5 border-b-2 border-white"></div>
                ) : (
                  'Sign in'
                )}
              </button>
            </div>
          </form>
        </div>
      </div>
    </div>
  );
}
```

<!-- path: app/(auth)/verify-email/page.tsx -->
```typescript
// app/(auth)/verify-email/page.tsx
import Link from 'next/link'

export default function VerifyEmailPage() {
  return (
    <div className="min-h-screen flex items-center justify-center bg-gray-50 dark:bg-gray-900 py-12 px-4 sm:px-6 lg:px-8">
      <div className="max-w-md w-full space-y-8 text-center">
        <div>
          <div className="mx-auto h-12 w-12 text-green-600 dark:text-green-500">
            <svg fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M3 8l7.89 7.89a2 2 0 002.82 0L21 8M5 19h14a2 2 0 002-2V7a2 2 0 00-2-2H5a2 2 0 00-2 2v10a2 2 0 002 2z" />
            </svg>
          </div>
          <h2 className="mt-6 text-3xl font-extrabold text-gray-900 dark:text-white">
            Check your email
          </h2>
          <p className="mt-2 text-sm text-gray-600 dark:text-gray-400">
            We&apos;ve sent a confirmation link to your email address. Please click the link to verify your account.
          </p>
        </div>

        <div className="mt-8 space-y-4">
          <p className="text-sm text-gray-500 dark:text-gray-400">
            Didn&apos;t receive the email? Check your spam folder or{' '}
            <Link href="/signup" className="font-medium text-indigo-600 hover:text-indigo-500 dark:text-indigo-400 dark:hover:text-indigo-300">
              try signing up again
            </Link>
          </p>

          <Link
            href="/login"
            className="inline-flex items-center px-4 py-2 border border-transparent text-sm font-medium rounded-md text-indigo-600 bg-indigo-100 hover:bg-indigo-200 dark:text-indigo-100 dark:bg-indigo-800 dark:hover:bg-indigo-700"
          >
            Back to Sign In
          </Link>
        </div>
      </div>
    </div>
  )
}
```

<!-- path: app/(auth)/reset-password/page.tsx -->
```typescript
// app/(auth)/reset-password/page.tsx
"use client";

import { useState } from "react";
import { useRouter } from "next/navigation";
import { motion } from "framer-motion";
import { toast } from "sonner";
import { LoadingSpinner } from "@/components/common/ui/LoadingSpinner";
import { useAuth } from "@/hooks/useAuth";

export default function ResetPasswordPage() {
  const [password, setPassword] = useState("");
  const [confirmPassword, setConfirmPassword] = useState("");
  const [isLoading, setIsLoading] = useState(false);
  const router = useRouter();
  // const searchParams = useSearchParams()
  const { resetPassword } = useAuth();

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();

    if (password !== confirmPassword) {
      toast.error("Passwords do not match");
      return;
    }

    if (password.length < 8) {
      toast.error("Password must be at least 8 characters long");
      return;
    }

    setIsLoading(true);
    try {
      const { success } = await resetPassword(password);
      if (success) {
        toast.success("Password updated successfully!");
        router.push("/login");
      }
    } catch (error) {
      toast.error("Something went wrong");
      setIsLoading(false);
    }
  };

  return (
    <div className='min-h-screen flex items-center justify-center bg-gray-50 dark:bg-gray-900 py-12 px-4 sm:px-6 lg:px-8'>
      <motion.div initial={{ opacity: 0, y: 20 }} animate={{ opacity: 1, y: 0 }} transition={{ duration: 0.5 }} className='max-w-md w-full space-y-8'>
        <div>
          <h2 className='mt-6 text-center text-3xl font-extrabold text-gray-900 dark:text-white'>Set new password</h2>
        </div>

        <form className='mt-8 space-y-6' onSubmit={handleSubmit}>
          <div>
            <label htmlFor='password' className='sr-only'>
              New Password
            </label>
            <input
              id='password'
              name='password'
              type='password'
              required
              value={password}
              onChange={(e) => setPassword(e.target.value)}
              className='appearance-none rounded-t-md relative block w-full px-3 py-2 border border-gray-300 dark:border-gray-600 placeholder-gray-500 dark:placeholder-gray-400 text-gray-900 dark:text-white bg-white dark:bg-gray-800 focus:outline-none focus:ring-blue-500 focus:border-blue-500 focus:z-10 sm:text-sm'
              placeholder='New password'
            />
          </div>
          <div>
            <label htmlFor='confirmPassword' className='sr-only'>
              Confirm Password
            </label>
            <input
              id='confirmPassword'
              name='confirmPassword'
              type='password'
              required
              value={confirmPassword}
              onChange={(e) => setConfirmPassword(e.target.value)}
              className='appearance-none rounded-b-md relative block w-full px-3 py-2 border border-gray-300 dark:border-gray-600 placeholder-gray-500 dark:placeholder-gray-400 text-gray-900 dark:text-white bg-white dark:bg-gray-800 focus:outline-none focus:ring-blue-500 focus:border-blue-500 focus:z-10 sm:text-sm'
              placeholder='Confirm new password'
            />
          </div>

          <div>
            <button
              type='submit'
              disabled={isLoading}
              className='group relative w-full flex justify-center py-2 px-4 border border-transparent text-sm font-medium rounded-md text-white bg-blue-600 hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-blue-500 disabled:opacity-50 disabled:cursor-not-allowed dark:bg-blue-700 dark:hover:bg-blue-800'>
              {isLoading ? <LoadingSpinner size='sm' /> : "Update Password"}
            </button>
          </div>
        </form>
      </motion.div>
    </div>
  );
}

```

<!-- path: app/(auth)/layout.tsx -->
```typescript
// app/(auth)/layout.tsx
"use client";

import { motion } from "framer-motion";
import { useAuth } from "@/hooks/useAuth";
import { redirect } from "next/navigation";

export default function AuthLayout({ children }: { children: React.ReactNode }) {
  const { authState } = useAuth();

  if (authState === "authenticated") {
    redirect("/dashboard");
  }

  return (
    <div className='min-h-screen bg-gradient-to-br from-blue-50 via-white to-purple-50 dark:from-gray-900 dark:via-gray-800 dark:to-gray-900'>
      <div className='flex min-h-screen'>
        {/* Left side - Branding */}
        <div className='relative hidden overflow-hidden lg:flex lg:flex-1'>
          <div className='absolute inset-0 bg-gradient-to-br from-blue-600 to-purple-700 opacity-90 dark:from-gray-800 dark:to-gray-900' />
          {/* <div className="absolute inset-0 bg-[url('/grid.svg')] opacity-5" /> */}
          <div className='relative z-10 flex flex-col justify-center px-12 text-white'>
            <motion.div initial={{ opacity: 0, y: 20 }} animate={{ opacity: 1, y: 0 }} transition={{ duration: 0.6 }}>
              <h1 className='mb-6 text-4xl font-bold'>Welcome to HARINAVI TRANSMISSION MAINTENANCE DATABASE</h1>
              <p className='mb-8 text-xl opacity-90 dark:opacity-80'>Secure authentication with role-based access control</p>
              <div className='space-y-4'>
                <div className='flex items-center space-x-3'>
                  <div className='h-2 w-2 rounded-full bg-white dark:bg-blue-400' />
                  <span>Multi-role user management</span>
                </div>
                <div className='flex items-center space-x-3'>
                  <div className='h-2 w-2 rounded-full bg-white dark:bg-blue-400' />
                  <span>Secure email verification</span>
                </div>
                <div className='flex items-center space-x-3'>
                  <div className='h-2 w-2 rounded-full bg-white dark:bg-blue-400' />
                  <span>Protected routes & permissions</span>
                </div>
                <div className='flex items-center space-x-3'>
                  <div className='h-2 w-2 rounded-full bg-white dark:bg-blue-400' />
                  <span>Dark mode support</span>
                </div>
              </div>
            </motion.div>
          </div>
        </div>

        {/* Right side - Auth forms */}
        <div className='flex flex-1 flex-col justify-center px-6 py-12 lg:px-8'>
          <motion.div initial={{ opacity: 0, x: 20 }} animate={{ opacity: 1, x: 0 }} transition={{ duration: 0.6, delay: 0.2 }} className='mx-auto w-full max-w-md'>
            {children}
          </motion.div>
        </div>
      </div>
    </div>
  );
}

```

<!-- path: app/(auth)/forgot-password/page.tsx -->
```typescript
// app/(auth)/forgot-password/page.tsx
'use client'

import { motion } from 'framer-motion'
import ForgotPasswordForm from '@/components/auth/ForgotPasswordForm'
import Link from 'next/link'

export default function ForgotPasswordPage() {
  return (
    <div className="min-h-screen flex items-center justify-center bg-gray-50 dark:bg-gray-900 py-12 px-4 sm:px-6 lg:px-8">
      <motion.div
        initial={{ opacity: 0, y: 20 }}
        animate={{ opacity: 1, y: 0 }}
        transition={{ duration: 0.5 }}
        className="max-w-md w-full space-y-8"
      >
        <div>
          <h2 className="mt-6 text-center text-3xl font-extrabold text-gray-900 dark:text-white">
            Reset your password
          </h2>
          <p className="mt-2 text-center text-sm text-gray-600 dark:text-gray-400">
            Remember your password?{' '}
            <Link
              href="/login"
              className="font-medium text-blue-600 hover:text-blue-500 dark:text-blue-400"
            >
              Sign in
            </Link>
          </p>
        </div>
        <ForgotPasswordForm />
      </motion.div>
    </div>
  )
}

```

<!-- path: app/(auth)/signup/page.tsx -->
```typescript
// app/(auth)/signup/page.tsx

'use client';

import Link from 'next/link';
import { redirect, useRouter } from 'next/navigation';
import { useAuth } from '@/hooks/useAuth';
import { useEffect } from 'react';
import { useForm } from 'react-hook-form';
import { zodResolver } from '@hookform/resolvers/zod';
import { z } from 'zod';
import { loginSchema } from '@/app/(auth)/login/page';
import { toast } from 'sonner';

// CORRECTED: Extend the schema from the login page, ensuring consistency.
const signupSchema = loginSchema
  .extend({
    firstName: z
      .string()
      .min(1, 'First name is required')
      .max(50, 'First name must not exceed 50 characters'),
    lastName: z
      .string()
      .min(1, 'Last name is required')
      .max(50, 'Last name must not exceed 50 characters'),
    confirmPassword: z.string().min(6, 'Confirm password is required'),
  })
  .refine((data) => data.encrypted_password === data.confirmPassword, {
    message: 'Passwords must match',
    path: ['confirmPassword'],
  });

type SignupForm = z.infer<typeof signupSchema>;

export default function SignUpPage() {
  const { signUp, authState } = useAuth();
  const router = useRouter();

  useEffect(() => {
    if (authState === 'authenticated') {
      redirect('/onboarding');
    }
  }, [authState]);

  const {
    register,
    handleSubmit,
    formState: { errors, isSubmitting },
  } = useForm<SignupForm>({
    resolver: zodResolver(signupSchema),
    defaultValues: {
      firstName: '',
      lastName: '',
      email: '',
      encrypted_password: '',
      confirmPassword: '',
    },
  });

  const onSubmit = async (data: SignupForm) => {
    const { success, error } = await signUp({
      email: data.email ?? '',
      password: data.encrypted_password ?? '',
      firstName: data.firstName,
      lastName: data.lastName,
    });
  
    if (success) {
      router.push('/verify-email');
    }
    
    if(error){
      toast.error(error.message);
    }
    
  };

  return (
    <div className="min-h-screen flex items-center justify-center bg-gray-50 dark:bg-gray-900 py-12 px-4 sm:px-6 lg:px-8">
      <div className="max-w-md w-full space-y-8">
        <div>
          <h2 className="mt-6 text-center text-3xl font-extrabold text-gray-900 dark:text-white">
            Create your account
          </h2>
          <p className="mt-2 text-center text-sm text-gray-600 dark:text-gray-400">
            Or{' '}
            <Link
              href="/login"
              className="font-medium text-blue-600 hover:text-blue-500 dark:text-blue-400 dark:hover:text-blue-300"
            >
              sign in to your existing account
            </Link>
          </p>
        </div>

        <div className="bg-white dark:bg-gray-800 py-8 px-6 shadow-lg rounded-lg">
          <form className="space-y-6" onSubmit={handleSubmit(onSubmit)}>
            <div className="grid grid-cols-2 gap-4">
              <div>
                <label
                  htmlFor="firstName"
                  className="block text-sm font-medium text-gray-700 dark:text-gray-300"
                >
                  First name *
                </label>
                <input
                  id="firstName"
                  type="text"
                  autoComplete="given-name"
                  {...register('firstName')}
                  className="mt-1 block w-full px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-md shadow-sm focus:outline-none focus:ring-blue-500 focus:border-blue-500 dark:bg-gray-700 dark:text-white"
                  placeholder="First name"
                />
                {errors.firstName && (
                  <p className="text-red-500 text-sm">
                    {errors.firstName.message}
                  </p>
                )}
              </div>

              <div>
                <label
                  htmlFor="lastName"
                  className="block text-sm font-medium text-gray-700 dark:text-gray-300"
                >
                  Last name *
                </label>
                <input
                  id="lastName"
                  type="text"
                  autoComplete="family-name"
                  {...register('lastName')}
                  className="mt-1 block w-full px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-md shadow-sm focus:outline-none focus:ring-blue-500 focus:border-blue-500 dark:bg-gray-700 dark:text-white"
                  placeholder="Last name"
                />
                {errors.lastName && (
                  <p className="text-red-500 text-sm">
                    {errors.lastName.message}
                  </p>
                )}
              </div>
            </div>

            <div>
              <label
                htmlFor="email"
                className="block text-sm font-medium text-gray-700 dark:text-gray-300"
              >
                Email address *
              </label>
              <input
                id="email"
                type="email"
                autoComplete="email"
                {...register('email')}
                className="mt-1 block w-full px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-md shadow-sm focus:outline-none focus:ring-blue-500 focus:border-blue-500 dark:bg-gray-700 dark:text-white"
                placeholder="Enter your email"
              />
              {errors.email && (
                <p className="text-red-500 text-sm">{errors.email.message}</p>
              )}
            </div>

            <div>
              <label
                htmlFor="password"
                className="block text-sm font-medium text-gray-700 dark:text-gray-300"
              >
                Password *
              </label>
              <input
                id="password"
                type="password"
                autoComplete="new-password"
                {...register('encrypted_password')}
                className="mt-1 block w-full px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-md shadow-sm focus:outline-none focus:ring-blue-500 focus:border-blue-500 dark:bg-gray-700 dark:text-white"
                placeholder="Create a password"
              />
              {errors.encrypted_password && (
                <p className="text-red-500 text-sm">
                  {errors.encrypted_password.message}
                </p>
              )}
            </div>

            <div>
              <label
                htmlFor="confirmPassword"
                className="block text-sm font-medium text-gray-700 dark:text-gray-300"
              >
                Confirm password *
              </label>
              <input
                id="confirmPassword"
                type="password"
                autoComplete="new-password"
                {...register('confirmPassword')}
                className="mt-1 block w-full px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-md shadow-sm focus:outline-none focus:ring-blue-500 focus:border-blue-500 dark:bg-gray-700 dark:text-white"
                placeholder="Confirm your password"
              />
              {errors.confirmPassword && (
                <p className="text-red-500 text-sm">
                  {errors.confirmPassword.message}
                </p>
              )}
            </div>

            <div>
              <button
                type="submit"
                disabled={isSubmitting || authState === 'loading'}
                className="group relative w-full flex justify-center py-2 px-4 border border-transparent text-sm font-medium rounded-md text-white bg-blue-600 hover:bg-blue-700 focus:outline-none disabled:opacity-50"
              >
                {isSubmitting || authState === 'loading' ? (
                  <div className="animate-spin rounded-full h-5 w-5 border-b-2 border-white"></div>
                ) : (
                  'Create account'
                )}
              </button>
            </div>
          </form>
        </div>
      </div>
    </div>
  );
}
```

<!-- path: app/privacy/page.tsx -->
```typescript

// app/privacy/page.tsx
import Privacy from "@/components/auth/privacy";

const PrivacyPage = () => {
  return <Privacy />;
};

export default PrivacyPage;

```

<!-- path: app/api/ors-distance/route.ts -->
```typescript
// path: app/api/ors-distance/route.ts
import { NextRequest, NextResponse } from "next/server";

export async function POST(req: NextRequest) {
  const { a, b } = await req.json();
  const ORS_API_KEY = process.env.ORS_API_KEY;

  if (!ORS_API_KEY) {
    return NextResponse.json({ error: "Missing ORS API key on the server" }, { status: 500 });
  }

  try {
    const res = await fetch("https://api.openrouteservice.org/v2/directions/driving-car", {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        Authorization: ORS_API_KEY,
      },
      body: JSON.stringify({
        coordinates: [
          [a.long, a.lat],
          [b.long, b.lat],
        ],
      }),
    });
    
    if (!res.ok) {
      const errorData = await res.json();
      console.error("ORS API Error:", errorData);
      return NextResponse.json({ error: "Failed to fetch distance from ORS API" }, { status: res.status });
    }

    const data = await res.json();
    const meters = data?.routes?.[0]?.summary?.distance;
    return NextResponse.json({ distance_km: meters ? (meters / 1000).toFixed(1) : null });
  } catch (error) {
    console.error("ORS internal API error:", error);
    return NextResponse.json({ error: "Failed to fetch distance" }, { status: 500 });
  }
}
```

<!-- path: app/api/admin/users/route.ts -->
```typescript
// app/api/admin/users/route.ts
import { NextResponse } from 'next/server';
import { Pool } from 'pg';
import bcrypt from 'bcrypt';
import { createAdmin } from '@/utils/supabase/admin';
import { createClient } from '@/utils/supabase/server';

const pgHost = process.env.PGHOST;
const pgUser = process.env.PGUSER;
const pgPassword = process.env.PGPASSWORD;
const pgDatabase = process.env.PGDATABASE;
const pgPort = process.env.PGPORT;

const pool = new Pool({
  connectionString: `postgresql://${pgUser}:${pgPassword}@${pgHost}:${pgPort}/${pgDatabase}`,
});

// This function handles creating users MANUALLY
export async function POST(req: Request) {
  const client = await pool.connect();
  try {
    const userData = await req.json();
    const hashed = await bcrypt.hash(userData.password, 10);

    // ** Remove the manual transaction and the second INSERT.**
    // We will now rely on the database trigger to create the user profile.
    
    const { rows: authUserRows } = await client.query(
      `
      INSERT INTO auth.users (id, instance_id, email, encrypted_password, email_confirmed_at, raw_app_meta_data, raw_user_meta_data)
      VALUES ($1, '00000000-0000-0000-0000-000000000000', $2, $3, $4, $5, $6)
      RETURNING id, email
      `,
      [
        userData.id,
        userData.email,
        hashed,
        userData.email_confirm ? new Date().toISOString() : null,
        JSON.stringify({
          provider: 'email',
          providers: ['email'],
          role: userData.role,
        }),
        JSON.stringify({
          first_name: userData.first_name,
          last_name: userData.last_name,
        }),
      ]
    );

    const createdAuthUser = authUserRows[0];
    if (!createdAuthUser) {
      throw new Error("Failed to create user in auth.users");
    }

    // The database trigger 'on_auth_user_created' will now automatically handle
    // creating the corresponding record in 'public.user_profiles'.

    return NextResponse.json({ user: createdAuthUser });

  } catch (err: unknown) {
    console.error('Error inserting user:', err);
    const errorMessage = err instanceof Error ? err.message : 'An unknown error occurred during user creation.';
    if (typeof errorMessage === 'string' && errorMessage.includes('duplicate key value violates unique constraint "users_email_key"')) {
        const { email } = await req.json();
        return NextResponse.json({ error: `A user with the email "${email}" already exists.` }, { status: 409 });
    }
    return NextResponse.json({ error: errorMessage }, { status: 500 });
  } finally {
    client.release();
  }
}


// DELETE function remains the same
export async function DELETE(req: Request) {
  try {
    const supabase = await createClient();
    const { data: { user } } = await supabase.auth.getUser();

    if (!user) {
      return NextResponse.json({ error: 'Forbidden: Authentication required.' }, { status: 401 });
    }

    const { data: isSuperAdmin, error: rpcError } = await supabase.rpc('is_super_admin');

    if (rpcError) {
      console.error('RPC error checking admin status:', rpcError);
      return NextResponse.json({ error: 'Could not verify user permissions.' }, { status: 500 });
    }

    if (!isSuperAdmin) {
      return NextResponse.json({ error: 'Forbidden: You do not have permission to perform this action.' }, { status: 403 });
    }
    
    const { userIds } = await req.json();

    if (!userIds || !Array.isArray(userIds) || userIds.length === 0) {
      return NextResponse.json({ error: 'User IDs are required' }, { status: 400 });
    }

    const supabaseAdmin = createAdmin();
    const deletionErrors: { id: string; error: string }[] = [];

    for (const id of userIds) {
      const { error } = await supabaseAdmin.auth.admin.deleteUser(id);
      if (error) {
        console.error(`Failed to delete user ${id}:`, error.message);
        deletionErrors.push({ id, error: error.message });
      }
    }

    if (deletionErrors.length > 0) {
      return NextResponse.json({
        message: `Completed with ${deletionErrors.length} errors.`,
        errors: deletionErrors,
      }, { status: 500 });
    }
    
    return NextResponse.json({ message: 'Users deleted successfully' });

  } catch (err: unknown) {
    console.error('Error processing delete request:', err);
    return NextResponse.json(
      { error: err instanceof Error ? err.message : 'An unknown error occurred' },
      { status: 500 }
    );
  }
}
```

<!-- path: app/api/route/[id]/route.ts -->
```typescript
import { NextResponse } from 'next/server';
import { createClient } from '@/utils/supabase/server';
import z from 'zod';

// It is NOT a database model, but an API contract.
const evolutionCommitPayloadSchema = z.object({
    plannedJointBoxes: z.array(z.object({
      name: z.string(),
      latitude: z.number(),
      longitude: z.number(),
      attributes: z.object({
        position_on_route: z.number().min(0).max(100),
      }),
    })),
    plannedSegments: z.array(z.object({
      segment_order: z.number(),
      start_node_id: z.string(),
      end_node_id: z.string(),
      fiber_count: z.number(),
      distance_km: z.number(),
    })),
    plannedSplices: z.array(z.object({
      fiber_count: z.number(),
      distance_km: z.number(),
    })),
  });
  
  // Infer the TypeScript type from the schema.
  export type EvolutionCommitPayload = z.infer<typeof evolutionCommitPayloadSchema>;

export async function GET(
  request: Request,
  context: { params: Promise<{ id: string }> }
) {
  const routeId = (await context.params).id;
  if (!routeId) {
    return NextResponse.json({ error: 'Route ID is required' }, { status: 400 });
  }

  const supabase = await createClient();

  try {
    // 1. Fetch main route info from the complete view
    const { data: routeData, error: routeError } = await supabase
      .from('v_ofc_cables_complete')
      .select('*')
      .eq('id', routeId)
      .single();

    if (routeError) throw new Error(`Route fetch error: ${routeError.message}`);
    if (!routeData) return NextResponse.json({ error: 'Route not found' }, { status: 404 });
    
    // 2. Fetch all existing JCs on this cable (now includes the nested node name)
    const { data: jcData, error: jcError } = await supabase
      .from('junction_closures')
      .select('*, node:node_id(name)')
      .eq('ofc_cable_id', routeId);

    if (jcError) throw new Error(`JC fetch error: ${jcError.message}`);

    const jointBoxes = (jcData || []).map(jc => ({
      ...jc,
      status: 'existing' as const,
      attributes: {
        position_on_route: (jc.position_km / (routeData.current_rkm || 1)) * 100,
        // The name is now correctly available under the 'node' relation
        name: jc.node?.name 
      }
    }));

    // 3. Fetch all current segments for this cable
    const { data: segmentData, error: segmentError } = await supabase
      .from('cable_segments')
      .select('*')
      .eq('original_cable_id', routeId)
      .order('segment_order');
      
    if (segmentError) throw new Error(`Segment fetch error: ${segmentError.message}`);

    // FIX: Construct the final payload correctly
    const payload = {
      route: {
        ...routeData,
        // Add the nested objects the client side logic expects for start/end sites
        start_site: { id: routeData.sn_id, name: routeData.sn_name },
        end_site: { id: routeData.en_id, name: routeData.en_name },
        evolution_status: segmentData && segmentData.length > 1 ? 'fully_segmented' : (jointBoxes.length > 0 ? 'with_jcs' : 'simple')
      },
      jointBoxes,
      segments: segmentData || [],
      splices: [] // Placeholder for splices
    };

    // console.log("routeData", routeData);
    // console.log("jcData", jcData);
    // console.log("jointBoxes", jointBoxes);
    // console.log("segmentData", segmentData);
    // console.log("payload", payload);


    return NextResponse.json(payload);

  } catch (err: unknown) {
    const error = err as Error;
    console.error(`Error fetching route details for ID ${routeId}:`, error);
    return NextResponse.json({ error: error.message }, { status: 500 });
  }
}


export async function POST(
    request: Request,
    context: { params: Promise<{ id: string }> }
  ) {
    const routeId = (await context.params).id;
    if (!routeId) {
      return NextResponse.json({ error: 'Route ID is required' }, { status: 400 });
    }
  
    try {
      const payload = await request.json();
  
      // Validate the incoming payload against our strict Zod schema
      const validationResult = evolutionCommitPayloadSchema.safeParse(payload);
      if (!validationResult.success) {
        return NextResponse.json({ error: 'Invalid payload structure.', details: z.treeifyError(validationResult.error) }, { status: 400 });
      }
  
      const supabase = await createClient();
  
      const { data, error } = await supabase.rpc('commit_route_evolution', {
        p_route_id: routeId,
        p_planned_equipment: validationResult.data.plannedJointBoxes,
      });
      
      if (error) throw error;
  
      return NextResponse.json({ message: 'Route evolution committed successfully', data });
  
    } catch (err: unknown) {
      const error = err as Error;
      console.error(`Error committing evolution for route ${routeId}:`, error);
      return NextResponse.json({ error: error.message }, { status: 500 });
    }
  }
```

<!-- path: app/customuppy.css -->
```css
/* Custom Uppy Styles - Add this to your globals.css or import as a separate file */

/* Dark theme customizations */
.uppy-dark .uppy-Dashboard {
  background-color: #1f2937;
  color: #f9fafb;
  border-color: #374151;
}

.uppy-dark .uppy-Dashboard-inner {
  background-color: #1f2937;
  border-color: #374151;
}

.uppy-dark .uppy-Dashboard-AddFiles {
  background-color: #374151;
  border-color: #4b5563;
}

.uppy-dark .uppy-Dashboard-AddFiles:hover {
  background-color: #4b5563;
}

.uppy-dark .uppy-DashboardTab-btn {
  color: #d1d5db;
  background-color: transparent;
}

.uppy-dark .uppy-DashboardTab-btn:hover {
  background-color: #374151;
  color: #f9fafb;
}

.uppy-dark .uppy-DashboardTab-btn:focus {
  background-color: #4b5563;
  color: #f9fafb;
}

.uppy-dark .uppy-DashboardTab-btn[aria-selected="true"] {
  background-color: #3b82f6;
  color: #ffffff;
}

.uppy-dark .uppy-Dashboard-dropFilesHereHint {
  color: #9ca3af;
}

.uppy-dark .uppy-Dashboard-browse {
  color: #60a5fa;
}

.uppy-dark .uppy-Dashboard-browse:hover {
  color: #93c5fd;
}

.uppy-dark .uppy-Dashboard-Item {
  background-color: #374151;
  border-color: #4b5563;
}

.uppy-dark .uppy-Dashboard-Item-preview {
  background-color: #4b5563;
}

.uppy-dark .uppy-Dashboard-Item-name {
  color: #f9fafb;
}

.uppy-dark .uppy-Dashboard-Item-status {
  color: #d1d5db;
}

.uppy-dark .uppy-Dashboard-ItemProgress {
  background-color: #4b5563;
}

.uppy-dark .uppy-Dashboard-ItemProgress-bar {
  background-color: #3b82f6;
}

/* Progress bar customization */
.uppy-ProgressBar {
  height: 8px;
  background-color: #e5e7eb;
  border-radius: 4px;
  overflow: hidden;
}

.uppy-dark .uppy-ProgressBar {
  background-color: #4b5563;
}

.uppy-ProgressBar-inner {
  background: linear-gradient(90deg, #3b82f6 0%, #1d4ed8 100%);
  transition: width 0.3s ease;
  height: 100%;
}

/* Custom drag-drop area */
.uppy-DragDrop-container {
  border: 2px dashed #d1d5db;
  border-radius: 8px;
  background-color: #f9fafb;
  transition: all 0.3s ease;
}

.uppy-dark .uppy-DragDrop-container {
  border-color: #4b5563;
  background-color: #374151;
  color: #f9fafb;
}

.uppy-DragDrop-container:hover,
.uppy-is-drag-over .uppy-DragDrop-container {
  border-color: #3b82f6;
  background-color: #eff6ff;
}

.uppy-dark .uppy-DragDrop-container:hover,
.uppy-dark.uppy-is-drag-over .uppy-DragDrop-container {
  border-color: #60a5fa;
  background-color: #1e3a8a;
}

/* Webcam styles */
.uppy-dark .uppy-Webcam-container {
  background-color: #1f2937;
}

.uppy-dark .uppy-Webcam-video {
  border-color: #374151;
}

.uppy-dark .uppy-Webcam-button {
  background-color: #3b82f6;
  color: #ffffff;
}

.uppy-dark .uppy-Webcam-button:hover {
  background-color: #2563eb;
}

/* Image editor styles */
.uppy-dark .uppy-ImageEditor-container {
  background-color: #1f2937;
}

.uppy-dark .uppy-ImageEditor-sidebar {
  background-color: #374151;
  border-color: #4b5563;
}

.uppy-dark .uppy-ImageEditor-button {
  background-color: #4b5563;
  color: #f9fafb;
  border-color: #6b7280;
}

.uppy-dark .uppy-ImageEditor-button:hover {
  background-color: #6b7280;
}

.uppy-dark .uppy-ImageEditor-button--active {
  background-color: #3b82f6;
  color: #ffffff;
}

/* Custom animations */
@keyframes uppy-fade-in {
  from {
    opacity: 0;
    transform: translateY(10px);
  }
  to {
    opacity: 1;
    transform: translateY(0);
  }
}

.uppy-Dashboard-Item {
  animation: uppy-fade-in 0.3s ease-out;
}

/* Responsive adjustments */
@media (max-width: 768px) {
  .uppy-Dashboard {
    border-radius: 0;
  }
  
  .uppy-Dashboard-inner {
    padding: 1rem;
  }
  
  .uppy-DragDrop-container {
    padding: 2rem 1rem;
  }
}

/* File type icons */
.uppy-Dashboard-Item-previewIcon {
  font-size: 2rem;
}

/* Success/Error states */
.uppy-Dashboard-Item--success .uppy-Dashboard-Item-progress {
  background-color: #10b981;
}

.uppy-Dashboard-Item--error .uppy-Dashboard-Item-progress {
  background-color: #ef4444;
}

.uppy-Dashboard-Item--error .uppy-Dashboard-Item-name {
  color: #ef4444;
}

/* Custom button styles */
.uppy-Dashboard-browse,
.uppy-Dashboard-AddFiles-title {
  font-weight: 600;
}

.uppy-Dashboard-AddFiles-info {
  font-size: 0.875rem;
  opacity: 0.8;
}

/* Hide powered by Uppy */
.uppy-Dashboard-poweredBy {
  display: none !important;
}

/* Add this to your customuppy.css file */
.uppy-dashboard-container {
  position: relative;
  width: 100%;
  overflow: hidden;
}

.uppy-dashboard-container .uppy-Dashboard {
  width: 100% !important;
  max-width: 100% !important;
}

.uppy-dashboard-container .uppy-Dashboard-inner {
  width: 100% !important;
  max-width: 100% !important;
  overflow-x: hidden;
}

/* For mobile devices */
@media (max-width: 768px) {
  .uppy-dashboard-container .uppy-Dashboard {
    height: 350px !important; /* Reduced height for mobile */
  }
  
  .uppy-dashboard-container .uppy-Dashboard-files {
    padding: 0 5px;
  }
  
  .uppy-dashboard-container .uppy-DashboardItem-name {
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
    max-width: 150px;
  }
}
```

<!-- path: app/page.tsx -->
```typescript
"use client";

import OfflineStatus from "@/components/pwa/offline-status";
import PWAInstallPrompt from "@/components/pwa/pwa-install-prompt";

import { useScroll, useTransform } from "framer-motion";
import { useEffect, useState } from "react";

import AnimatedBackground from "@/components/home/AnimatedBackground";
import HeroContent from "@/components/home/HeroContent";
import ParticlesOverlay from "@/components/home/ParticlesOverlay";
import ScrollIndicator from "@/components/home/ScrollIndicator";
import StatsHighlights from "@/components/home/StatsHighlights";
import { containerVariants, ctaVariants, floatingAnimation, highlightVariants, subtitleVariants, titleVariants } from "@/components/home/variants";
import OutdatedBrowserModal from "@/components/outdated/OutdatedBrowserModal";
import { useOutdatedBrowserCheck } from "@/hooks/useOutdatedBrowserCheck";

export default function Home() {
  const [showModal, setShowModal] = useState(false);
  const isOutdated = useOutdatedBrowserCheck();

  const { scrollY } = useScroll();
  const textY = useTransform(scrollY, [0, 500], [0, -50]);

  // Check if browser modal should be shown
  useEffect(() => {
    if (isOutdated && typeof window !== "undefined") {
      const dismissed = localStorage.getItem("legacyBrowserDismissed");
      if (!dismissed) {
        setShowModal(true);
      }
    }
  }, [isOutdated]);

  const handleCloseModal = () => {
    setShowModal(false);
    if (typeof window !== "undefined") {
      localStorage.setItem("legacyBrowserDismissed", "true");
    }
  };

  if (isOutdated === null) return null;

  return (
    <>
      <div className='relative min-h-screen w-full overflow-hidden'>
        <AnimatedBackground />
        <ParticlesOverlay />

        {showModal && <OutdatedBrowserModal handleCloseModal={handleCloseModal} />}

        <div className='overflow-hidden relative z-10 flex min-h-screen flex-col items-center justify-center bg-gradient-to-b from-black/60 via-black/40 to-black/60'>
          <HeroContent
            variants={{
              containerVariants,
              titleVariants,
              subtitleVariants,
              highlightVariants,
              ctaVariants,
            }}
            floatingAnimation={floatingAnimation}
            textY={textY}
          />
          <StatsHighlights />
        </div>

        <ScrollIndicator />
      </div>
      <PWAInstallPrompt />
      <OfflineStatus />
    </>
  );
}

```

<!-- path: app/auth/callback/route.ts -->
```typescript

// app/auth/callback/route.ts
import { createClient } from '@/utils/supabase/server';
import { NextResponse } from 'next/server';

export async function GET(request: Request) {
  const { searchParams, origin } = new URL(request.url);
  const code = searchParams.get('code');
  // The 'next' URL is passed from the client when the OAuth flow is initiated
  const next = searchParams.get('next') ?? '/dashboard'; 
  const error = searchParams.get('error');

  if (error) {
    console.error('OAuth Error:', error);
    return NextResponse.redirect(`${origin}/login?error=oauth_failed`);
  }

  if (!code) {
    console.error('OAuth Error: No code provided.');
    return NextResponse.redirect(`${origin}/login?error=oauth_failed`);
  }

  const supabase = await createClient();
  const { error: exchangeError } = await supabase.auth.exchangeCodeForSession(code);

  if (exchangeError) {
    console.error('Session exchange error:', exchangeError.message);
    return NextResponse.redirect(`${origin}/login?error=oauth_failed`);
  }

  // On success, redirect to the intended page. The Protected component will handle the rest.
  return NextResponse.redirect(`${origin}${next}`);
}
```

<!-- path: app/dashboard/lookup/page.tsx -->
```typescript
'use client';

import {
  PageHeader,
  useStandardHeaderActions,
} from '@/components/common/page-header';
import { ErrorDisplay } from '@/components/common/ui';
import { Card } from '@/components/common/ui/card';
import { useLookupTypes } from '@/components/lookup/lookup-hooks';
import { LookupModal } from '@/components/lookup/LookupModal';
import {
  ErrorState,
  LoadingState,
  NoCategoriesState,
  SelectCategoryPrompt,
} from '@/components/lookup/LookupTypesEmptyStates';
import { LookupTypesFilters } from '@/components/lookup/LookupTypesFilters';
import { LookupTypesTable } from '@/components/lookup/LookupTypesTable';
import { Filters } from '@/hooks/database';
import { useSorting } from '@/hooks/useSorting';
import { useMemo } from 'react';
import { FiList } from 'react-icons/fi';
import { toast } from 'sonner';

export default function LookupTypesPage() {
  const {
    state: {
      selectedCategory,
      isLookupModalOpen,
      searchTerm,
      editingLookup,
      categories,
      lookupTypes,
      isLoading,
      hasCategories,
      hasSelectedCategory,
      categoriesError,
      lookupError,
    },
    handlers: {
      setSearchTerm,
      handleCategoryChange,
      handleRefresh,
      handleAddNew,
      handleEdit,
      handleDelete,
      handleToggleStatus,
      handleModalClose,
      handleLookupCreated,
      handleLookupUpdated,
    },
  } = useLookupTypes();

  // Apply sorting to lookup types
  const {
    sortedData: sortedLookupTypes,
    handleSort,
    getSortDirection,
  } = useSorting({
    data: lookupTypes,
    defaultSortKey: 'name',
    defaultDirection: 'asc',
    options: {
      caseSensitive: false,
      numericSort: true,
    },
  });

  // Filter sorted data based on search term
  const filteredAndSortedLookupTypes = useMemo(() => {
    if (!searchTerm.trim()) return sortedLookupTypes;

    const lowerSearchTerm = searchTerm.toLowerCase();
    return sortedLookupTypes.filter(
      (lookup) =>
        lookup.name?.toLowerCase().includes(lowerSearchTerm) ||
        lookup.code?.toLowerCase().includes(lowerSearchTerm) ||
        lookup.description?.toLowerCase().includes(lowerSearchTerm)
    );
  }, [sortedLookupTypes, searchTerm]);

  // --- Define header content using the hook ---
  const serverFilters = useMemo(() => {
    const f: Filters = {
      // Filter to download only categories with name not equal to "DEFAULT"
      name: {
        operator: 'neq',
        value: 'DEFAULT',
      },
    };
    return f;
  }, []);
  const headerActions = useStandardHeaderActions({
    data: lookupTypes,
    onRefresh: async () => {
      await handleRefresh();
      toast.success('Refreshed successfully!');
    },
    onAddNew: handleAddNew,
    isLoading: isLoading,
    exportConfig: { tableName: 'lookup_types', filters: serverFilters },
  });

  // --- Define header stats ---
  const activeLookups = lookupTypes.filter((lookup) => lookup.status);
  const inactiveLookups = lookupTypes.filter((lookup) => !lookup.status);
  const headerStats = [
    { value: lookupTypes.length, label: 'Total Lookup Types' },
    { value: activeLookups.length, label: 'Active', color: 'success' as const },
    {
      value: inactiveLookups.length,
      label: 'Inactive',
      color: 'danger' as const,
    },
  ];

  // Error handling
  if (lookupError) {
    return (
      <ErrorDisplay
        error={lookupError.message}
        actions={[
          {
            label: 'Retry',
            onClick: handleRefresh,
            variant: 'primary',
          },
        ]}
      />
    );
  }

  return (
    <div className="space-y-6 p-6">
      <PageHeader
        title="Lookup Types"
        description="Manage lookup types"
        icon={<FiList />}
        stats={headerStats}
        actions={headerActions}
        isLoading={isLoading}
      />

      {!hasCategories && !isLoading && (
        <NoCategoriesState
          error={categoriesError as Error}
          isLoading={isLoading}
        />
      )}

      {hasCategories && (
        <LookupTypesFilters
          categories={categories}
          selectedCategory={selectedCategory}
          onCategoryChange={handleCategoryChange}
          searchTerm={searchTerm}
          onSearchTermChange={setSearchTerm}
          hasSelectedCategory={hasSelectedCategory}
        />
      )}

      {lookupError && hasSelectedCategory && (
        <ErrorState error={lookupError} onRetry={handleRefresh} />
      )}

      {isLoading && hasSelectedCategory && (
        <LoadingState selectedCategory={selectedCategory} />
      )}

      {hasSelectedCategory && !isLoading && !lookupError && (
        <Card className="overflow-hidden">
          <div className="border-b bg-gray-50 dark:bg-gray-800 dark:border-gray-700 p-4">
            <p className="text-sm text-gray-600 dark:text-gray-400">
              Showing {filteredAndSortedLookupTypes.length} of{' '}
              {lookupTypes.length} lookup types for category:{' '}
              <strong className="text-gray-900 dark:text-gray-100">{`"${selectedCategory}"`}</strong>
              {searchTerm && (
                <span className="ml-2">
                  (filtered by: <em>&quot;{searchTerm}&quot;</em>)
                </span>
              )}
            </p>
          </div>

          <LookupTypesTable
            lookups={filteredAndSortedLookupTypes.map((lookup) => ({
              ...lookup,
              sort_order: lookup.sort_order ?? null,
              created_at: lookup.created_at
                ? new Date(lookup.created_at).toISOString()
                : null,
              updated_at: lookup.updated_at
                ? new Date(lookup.updated_at).toISOString()
                : null,
              is_system_default: lookup.is_system_default ?? null,
              status: lookup.status ?? null,
            }))}
            onEdit={handleEdit}
            onDelete={handleDelete}
            onToggleStatus={handleToggleStatus}
            selectedCategory={selectedCategory}
            searchTerm={searchTerm}
            onSort={handleSort}
            getSortDirection={getSortDirection}
          />
        </Card>
      )}

      {!hasSelectedCategory && !isLoading && hasCategories && (
        <SelectCategoryPrompt />
      )}

      <LookupModal
        isOpen={isLookupModalOpen}
        onClose={handleModalClose}
        onLookupCreated={handleLookupCreated}
        onLookupUpdated={handleLookupUpdated}
        editingLookup={editingLookup}
        category={selectedCategory}
        categories={categories}
      />
    </div>
  );
}

```

<!-- path: app/dashboard/route-manager/page.tsx -->
```typescript
// app/dashboard/route-manager/page.tsx
"use client";

import { useState, useMemo, useCallback } from "react";
import { useRouteDetails } from "@/hooks/database/route-manager-hooks";
import { PageSpinner, ConfirmModal } from "@/components/common/ui";
import { Tabs, TabsContent, TabsList, TabsTrigger } from "@/components/common/ui/tabs";
import { JcFormModal } from "@/components/route-manager/JcFormModal";
import RouteVisualization from "@/components/route-manager/ui/RouteVisualization";
import { FiberSpliceManager } from "@/components/route-manager/FiberSpliceManager";
import { JointBox } from "@/schemas/custom-schemas";
import { useDeleteManager } from "@/hooks/useDeleteManager";
import RouteSelection from "@/components/route-manager/RouteSelection";

export default function RouteManagerPage() {
  const [selectedRouteId, setSelectedRouteId] = useState<string | null>(null);
  const [selectedJc, setSelectedJc] = useState<JointBox | null>(null);
  const [editingJc, setEditingJc] = useState<JointBox | null>(null);
  const [isJcFormModalOpen, setIsJcFormModalOpen] = useState(false);
  const [activeTab, setActiveTab] = useState("visualization");

  const { data: routeDetails, isLoading: isLoadingRouteDetails, refetch: refetchRouteDetails, error: routeDetailsError, isError: routeDetailsIsError } = useRouteDetails(selectedRouteId as string);

  const deleteManager = useDeleteManager({
    tableName: "junction_closures",
    onSuccess: () => {
      refetchRouteDetails();
      if (selectedJc && selectedJc.id === deleteManager.deleteConfig?.items[0]?.id) {
        setSelectedJc(null);
        setActiveTab("visualization");
      }
    },
  });

  const allJointBoxesOnRoute = useMemo(() => routeDetails?.jointBoxes || [], [routeDetails]);
  const currentSegments = useMemo(() => routeDetails?.segments || [], [routeDetails]);

  const handleRouteChange = useCallback((routeId: string | null) => {
    setSelectedRouteId(routeId);
    setSelectedJc(null);
    setActiveTab("visualization");
  }, []);

  const handleAddJunctionClosure = useCallback(() => {
    setEditingJc(null);
    setIsJcFormModalOpen(true);
  }, []);

  const handleOpenEditJcModal = useCallback((jc: JointBox) => {
    setEditingJc(jc);
    setIsJcFormModalOpen(true);
  }, []);

  const handleJcClick = useCallback((jc: JointBox) => {
    setSelectedJc(jc);
    setActiveTab("splicing");
  }, []);

  const handleRemoveJc = useCallback(
    (jcId: string) => {
      const jcToRemove = allJointBoxesOnRoute.find((jc) => jc.id === jcId);
      if (!jcToRemove) return;
      const name = jcToRemove.attributes?.name || jcToRemove.node?.name || `JC ${jcId.slice(-4)}`;
      deleteManager.deleteSingle({ id: jcId, name });
    },
    [allJointBoxesOnRoute, deleteManager]
  );

  return (
    <div className='p-6 space-y-6'>
      <RouteSelection selectedRouteId={selectedRouteId} onRouteChange={handleRouteChange} onAddJunctionClosure={handleAddJunctionClosure} isLoadingRouteDetails={isLoadingRouteDetails} />

      {isLoadingRouteDetails && <PageSpinner text='Loading route details...' />}
      {routeDetailsIsError && <div className='p-4 bg-red-50 text-red-700 border border-red-200 rounded-lg'>Error: {routeDetailsError.message}</div>}

      {routeDetails && (
        <Tabs value={activeTab} onValueChange={setActiveTab} className='w-full'>
          <TabsList>
            <TabsTrigger value='visualization'>Route Visualization</TabsTrigger>
            <TabsTrigger value='splicing' disabled={!selectedJc}>
              Splice Management
            </TabsTrigger>
          </TabsList>
          <TabsContent value='visualization'>
            <RouteVisualization routeDetails={{ ...routeDetails, jointBoxes: allJointBoxesOnRoute, segments: currentSegments }} onJcClick={handleJcClick} onEditJc={handleOpenEditJcModal} onDeleteJc={handleRemoveJc} />
          </TabsContent>
          <TabsContent value='splicing'>
            <FiberSpliceManager junctionClosureId={selectedJc?.id ?? null} />
          </TabsContent>
        </Tabs>
      )}

      {isJcFormModalOpen && (
        <JcFormModal
          isOpen={isJcFormModalOpen}
          onClose={() => {
            setEditingJc(null);
            setIsJcFormModalOpen(false);
          }}
          onSave={() => refetchRouteDetails()}
          routeId={selectedRouteId}
          editingJc={editingJc}
          rkm={routeDetails?.route.current_rkm ?? null}
        />
      )}

      <ConfirmModal
        isOpen={deleteManager.isConfirmModalOpen}
        onConfirm={deleteManager.handleConfirm}
        onCancel={deleteManager.handleCancel}
        title='Confirm Deletion'
        message={deleteManager.confirmationMessage}
        loading={deleteManager.isPending}
        type='danger'
      />
    </div>
  );
}

```

<!-- path: app/dashboard/rings/[id]/page.tsx -->
```typescript
// path: app/dashboard/rings/[id]/page.tsx
"use client";

import { useMemo, useCallback } from "react"; // <-- Import useCallback
import { useParams, useRouter } from "next/navigation";
import { FiArrowLeft, FiMap } from "react-icons/fi";
import { useRingNodes } from "@/hooks/database/ring-map-queries";
import ClientRingMap from "@/components/map/ClientRingMap";
import { PageSpinner, ErrorDisplay } from "@/components/common/ui";
import { PageHeader } from "@/components/common/page-header";
import { RingMapNode, NodeType } from "@/components/map/types/node";
import useORSRouteDistances from "@/hooks/useORSRouteDistances";

export default function RingMapPage() {
  const params = useParams();
  const router = useRouter();
  const ringId = params.id as string;

  const { data: nodes, isLoading, isError, error, refetch } = useRingNodes(ringId);

  const mappedNodes = useMemo((): RingMapNode[] => {
    if (!nodes) return [];
    return nodes
      .filter(node => node.lat != null && node.long != null)
      .map(node => ({
        id: node.id!,
        ring_id: node.ring_id,
        name: node.name!,
        lat: node.lat!,
        long: node.long!,
        order_in_ring: node.order_in_ring,
        type: node.type as NodeType | string | null,
        ring_status: node.ring_status,
        ip: node.ip,
        remark: node.remark,
      }));
  }, [nodes]);

  const { mainSegments, spurConnections, allPairs } = useMemo(() => {
    const ringStatusNodes = mappedNodes.filter(node => node.ring_status);
    
    const main = (ringStatusNodes.length > 0 ? ringStatusNodes : mappedNodes.filter(n => n.type === NodeType.MAAN))
      .sort((a, b) => (a.order_in_ring || 0) - (b.order_in_ring || 0));

    if (main.length === 0) {
      return { mainSegments: [], spurConnections: [], allPairs: [] };
    }

    const segments: Array<[RingMapNode, RingMapNode]> = [];
    if (main.length > 1) {
      main.forEach((node, index) => {
        const nextNode = main[(index + 1) % main.length];
        segments.push([node, nextNode]);
      });
    }

    const spurs: Array<[RingMapNode, RingMapNode]> = [];
    mappedNodes.filter(node => !node.ring_status).forEach(spurNode => {
      const parentNode = main.find(m => m.order_in_ring === spurNode.order_in_ring);
      if (parentNode) {
        spurs.push([parentNode, spurNode]);
      }
    });

    return { mainSegments: segments, spurConnections: spurs, allPairs: [...segments, ...spurs] };
  }, [mappedNodes]);

  const { data: distances = {} } = useORSRouteDistances(allPairs);
  
  const ringName = nodes?.[0]?.ring_name || `Ring ${ringId.slice(0, 8)}...`;
  
  // ** Wrap the onBack handler in useCallback for a stable reference.**
  const handleBack = useCallback(() => {
    router.push('/dashboard/rings');
  }, [router]);


  const renderContent = () => {
    if (isLoading) return <PageSpinner text="Loading Ring Map Data..." />;
    if (isError) return <ErrorDisplay error={error.message} actions={[{ label: 'Retry', onClick: () => refetch(), variant: 'primary' }]} />;
    if (mappedNodes.length === 0) return <div className="text-center py-12"><FiMap className="mx-auto h-12 w-12 text-gray-400" /> <h3 className="mt-2 text-lg font-medium text-gray-900 dark:text-white">No Nodes Found</h3></div>;

    return (
      <ClientRingMap
        nodes={mappedNodes}
        solidLines={mainSegments}
        dashedLines={spurConnections}
        distances={distances}
        onBack={handleBack} // Pass the stable handler
        showControls={true} 
      />
    );
  };

  return (
    <div className="p-4 md:p-6 space-y-6">
      <PageHeader
        title={ringName}
        description="Visualizing the ring topology and connected nodes."
        icon={<FiMap />}
        actions={[{ label: "Back to Rings List", onClick: handleBack, variant: "outline", leftIcon: <FiArrowLeft /> }]}
      />
      <div className="h-[70vh] bg-white dark:bg-gray-800 rounded-lg shadow-md border dark:border-gray-700 p-4">
        {renderContent()}
      </div>
    </div>
  );
}
```

<!-- path: app/dashboard/rings/page.tsx -->
```typescript
// path: app/dashboard/rings/page.tsx
'use client';

import { PageHeader, useStandardHeaderActions } from '@/components/common/page-header';
import { ConfirmModal } from '@/components/common/ui';
import { RingModal } from '@/components/rings/RingModal';
import { RingSystemsModal } from '@/components/rings/RingSystemsModal';
import { RingsFilters } from '@/components/rings/RingsFilters';
import { createStandardActions } from '@/components/table/action-helpers';
import { DataTable } from '@/components/table/DataTable';
import { desiredRingColumnOrder } from '@/config/column-orders';
import { RingsColumns } from '@/config/table-columns/RingsTableColumns';
import { usePagedData, useTableQuery } from '@/hooks/database';
import { DataQueryHookParams, DataQueryHookReturn, useCrudManager } from '@/hooks/useCrudManager';
import { V_ringsRowSchema, RingsRowSchema, RingsInsertSchema } from '@/schemas/zod-schemas'; // Import InsertSchema
import { createClient } from '@/utils/supabase/client';
import { useMemo, useCallback, useState } from 'react';
import { GiLinkedRings } from 'react-icons/gi';
import { toast } from 'sonner';
import { useRouter } from 'next/navigation';
import { FaNetworkWired } from 'react-icons/fa';

const useRingsData = (
  params: DataQueryHookParams
): DataQueryHookReturn<V_ringsRowSchema> => {
  const { currentPage, pageLimit, filters, searchQuery } = params;
  const supabase = createClient();
  const { data, isLoading, error, refetch } = usePagedData<V_ringsRowSchema>(
    supabase, 'v_rings', {
      filters: { ...filters, ...(searchQuery ? { name: searchQuery } : {}) },
      limit: pageLimit, offset: (currentPage - 1) * pageLimit,
    }
  );
  return {
    data: data?.data || [], totalCount: data?.total_count || 0,
    activeCount: data?.active_count || 0, inactiveCount: data?.inactive_count || 0,
    isLoading, error, refetch,
  };
};

const RingsPage = () => {
  const router = useRouter();
  const supabase = createClient();
  
  const [isSystemsModalOpen, setIsSystemsModalOpen] = useState(false);
  const [selectedRingForSystems, setSelectedRingForSystems] = useState<V_ringsRowSchema | null>(null);

  const {
    data: rings, totalCount, activeCount, inactiveCount, isLoading, isMutating, refetch,
    pagination, search, editModal, deleteModal, actions: crudActions,
  } = useCrudManager<'rings', V_ringsRowSchema>({
    tableName: 'rings', dataQueryHook: useRingsData,
  });

  const { data: ringTypes = [] } = useTableQuery(supabase, 'lookup_types', {
    filters: { category: 'RING_TYPES', name: { operator: 'neq', value: 'DEFAULT' } },
    orderBy: [{ column: 'name' }]
  });
  const { data: maintenanceAreas = [] } = useTableQuery(supabase, 'maintenance_areas', {
    filters: { status: true }, orderBy: [{ column: 'name' }]
  });

  const columns = RingsColumns(rings);
  const notUndefined = <T,>(x: T | undefined): x is T => x !== undefined;
  const orderedColumns = [
    ...desiredRingColumnOrder.map((k) => columns.find((c) => c.key === k)).filter(notUndefined),
    ...columns.filter((c) => !desiredRingColumnOrder.includes(c.key)),
  ];

  const handleView = useCallback((record: V_ringsRowSchema) => {
    if (record.id) {
      router.push(`/dashboard/rings/${record.id}`);
    } else {
      toast.error("Cannot view ring: Missing ID.");
    }
  }, [router]);

  const handleManageSystems = useCallback((record: V_ringsRowSchema) => {
    setSelectedRingForSystems(record);
    setIsSystemsModalOpen(true);
  }, []);

  const tableActions = useMemo(() => {
    const standardActions = createStandardActions<V_ringsRowSchema>({
      onEdit: editModal.openEdit,
      onView: handleView,
      onDelete: crudActions.handleDelete,
    });
    standardActions.unshift({
      key: 'manage-systems',
      label: 'Manage Systems',
      icon: <FaNetworkWired className="w-4 h-4" />,
      onClick: handleManageSystems,
      variant: 'secondary',
    });
    return standardActions;
  }, [editModal.openEdit, handleView, crudActions.handleDelete, handleManageSystems]);

  const headerActions = useStandardHeaderActions({
    data: rings as RingsRowSchema[],
    onRefresh: async () => { await refetch(); toast.success('Refreshed successfully!'); },
    onAddNew: editModal.openAdd, isLoading: isLoading, exportConfig: { tableName: 'rings' },
  });

  const headerStats = [
    { value: totalCount, label: 'Total Rings' },
    { value: activeCount, label: 'Active', color: 'success' as const },
    { value: inactiveCount, label: 'Inactive', color: 'danger' as const },
  ];

  return (
    <div className="mx-auto space-y-4 p-6">
      <PageHeader
        title="Ring Management"
        description="Manage network rings and their related information."
        icon={<GiLinkedRings />}
        stats={headerStats}
        actions={headerActions}
        isLoading={isLoading}
      />
      <DataTable
        tableName="v_rings"
        data={rings} columns={orderedColumns} loading={isLoading} actions={tableActions}
        pagination={{
          current: pagination.currentPage, pageSize: pagination.pageLimit, total: totalCount, showSizeChanger: true,
          onChange: (page, pageSize) => { pagination.setCurrentPage(page); pagination.setPageLimit(pageSize); },
        }}
        customToolbar={<RingsFilters searchQuery={search.searchQuery} onSearchChange={search.setSearchQuery} />}
      />
      
      {/* ** Pass the correct props to the now "dumb" component.** */}
      <RingModal
        isOpen={editModal.isOpen}
        onClose={editModal.close}
        editingRing={editModal.record as RingsRowSchema | null}
        onSubmit={crudActions.handleSave as (data: RingsInsertSchema) => void}
        isLoading={isMutating}
        ringTypes={ringTypes.map(rt => ({ id: rt.id, name: rt.name, code: rt.code }))}
        maintenanceAreas={maintenanceAreas.map(ma => ({ id: ma.id, name: ma.name, code: ma.code }))}
      />

      <RingSystemsModal
        isOpen={isSystemsModalOpen}
        onClose={() => setIsSystemsModalOpen(false)}
        ring={selectedRingForSystems}
      />

      <ConfirmModal
        isOpen={deleteModal.isOpen} onConfirm={deleteModal.onConfirm} onCancel={deleteModal.onCancel}
        title="Confirm Deletion" message={deleteModal.message} confirmText="Delete"
        cancelText="Cancel" type="danger" showIcon loading={deleteModal.loading}
      />
    </div>
  );
};

export default RingsPage;

```

<!-- path: app/dashboard/page.tsx -->
```typescript
// app/dashboard/page.tsx
"use client";

import { useState, useEffect } from "react";
import { useRouter } from "next/navigation";
import { useAuthStore } from "@/stores/authStore";
import { useGetMyUserDetails } from "@/hooks/useAdminUsers";
import { useTableUpdate } from "@/hooks/database";
import { createClient } from "@/utils/supabase/client";
import { OnboardingPromptModal } from "@/components/auth/OnboardingPromptModal";
import ScalableFiberNetworkDashboard from "@/app/bsnl/page";
import { toast } from "sonner";

export default function DashboardPage() {
  const router = useRouter();
  const user = useAuthStore((state) => state.user);
  const { data: profile, isLoading: isProfileLoading, refetch } = useGetMyUserDetails();
  const { mutate: updateProfile } = useTableUpdate(createClient(), 'user_profiles');

  const [isPromptOpen, setIsPromptOpen] = useState(false);

  useEffect(() => {
    if (!isProfileLoading && profile) {
      // ** Check the 'needsOnboarding' flag directly from the user's preferences.**
      // This is the reliable source of truth.
      const needsOnboarding = (profile.preferences as any)?.needsOnboarding === true;
      const hasDismissedPrompt = (profile.preferences as any)?.showOnboardingPrompt === false;

      if (needsOnboarding && !hasDismissedPrompt) {
        setIsPromptOpen(true);
      }
    }
  }, [profile, isProfileLoading]);

  const handleGoToProfile = () => {
    setIsPromptOpen(false);
    router.push('/onboarding');
  };

  const handleDismissTemporarily = () => {
    setIsPromptOpen(false);
  };

  const handleDismissPermanently = () => {
    if (user?.id && profile) {
      const currentPreferences = (profile.preferences as object) || {};
      const newPreferences = { ...currentPreferences, showOnboardingPrompt: false };
      
      updateProfile({ id: user.id, data: { preferences: newPreferences } }, {
        onSuccess: () => {
          toast.success("Preference saved. We won't ask again.");
          // Manually update the local profile state to prevent the prompt from reappearing before a full refetch
          refetch(); 
        },
        onError: (error) => {
          toast.error(`Failed to save preference: ${error.message}`);
        }
      });
    }
    setIsPromptOpen(false);
  };

  return (
    <>
      <ScalableFiberNetworkDashboard />
      <OnboardingPromptModal
        isOpen={isPromptOpen}
        onClose={handleDismissTemporarily}
        onGoToProfile={handleGoToProfile}
        onDismissPermanently={handleDismissPermanently}
        userName={(profile?.first_name && profile.first_name !== 'Placeholder') ? profile.first_name : 'there'}
      />
    </>
  );
}
```

<!-- path: app/dashboard/diagrams/page.tsx -->
```typescript
"use client";

// app/diagrams/page.tsx

import dynamic from "next/dynamic";

// Disable SSR for the StorageManager component
const FileUploader = dynamic(
  () => import("@/components/diagrams/FileUploader"),
  { ssr: false },
);

import { useEffect, useState } from "react";
import { createClient } from "@/utils/supabase/client";
import { AuthChangeEvent, AuthSession, User } from "@supabase/supabase-js";

export default function Home() {
  const [user, setUser] = useState<User | null>(null);
  const supabase = createClient();

  useEffect(() => {
    let listener: { unsubscribe: () => void };

    async function initSupabase() {
      const { data: { user } = {} } = await supabase.auth.getUser();
      setUser(user ?? null);

      const { data } = supabase.auth.onAuthStateChange(
        (_event: AuthChangeEvent, session: AuthSession | null) => {
          setUser(session?.user ?? null);
        },
      );
      listener = data.subscription;
    }

    initSupabase();

    return () => {
      if (listener?.unsubscribe) {
        listener.unsubscribe();
      }
    };
  }, [supabase]);

  return (
    <div className="p-4">
      <h1 className="mb-4 text-2xl font-bold">
        Upload OFC Diagrams
      </h1>
      {!user ? <p>Please log in to upload files.</p> : <FileUploader />}
    </div>
  );
}

```

<!-- path: app/dashboard/logical-paths/page.tsx -->
```typescript
// path: app/dashboard/logical-paths/page.tsx
'use client';

import { useMemo, useCallback, useState } from 'react';
import { useRouter } from 'next/navigation';
import { toast } from 'sonner';
import { FiGitBranch, FiTrash2, FiEye } from 'react-icons/fi';

import { PageHeader, useStandardHeaderActions } from '@/components/common/page-header';
import { ConfirmModal, ErrorDisplay } from '@/components/common/ui';
import { DataTable } from '@/components/table/DataTable';
import { createStandardActions } from '@/components/table/action-helpers';
import { SearchAndFilters } from '@/components/common/filters/SearchAndFilters';

import { Row, usePagedData } from '@/hooks/database';
import { useDeprovisionPath } from '@/hooks/database/path-mutations';
import { DataQueryHookReturn } from '@/hooks/useCrudManager';
import type { TableAction } from '@/components/table/datatable-types';

import { LogicalPathsTableColumns } from '@/config/table-columns/LogicalPathsTableColumns';
import { V_end_to_end_pathsRowSchema } from '@/schemas/zod-schemas';
import { createClient } from '@/utils/supabase/client';

// Define the shape for our UI, aliasing path_id to id for compatibility with generic components
type LogicalPathView = Row<'v_end_to_end_paths'> & { id: string | null };

// Data fetching hook remains the same, but we'll use its return value directly
const useLogicalPathsData = (
  params: { currentPage: number; pageLimit: number; searchQuery: string }
): DataQueryHookReturn<LogicalPathView> => {
  const { currentPage, pageLimit, searchQuery } = params;
  const supabase = createClient();

  const searchFilters = useMemo(() => {
    if (!searchQuery) return {};
    return { or: { path_name: searchQuery, route_names: searchQuery } };
  }, [searchQuery]);

  const { data, isLoading, isFetching, error, refetch } = usePagedData<V_end_to_end_pathsRowSchema>(
    supabase,
    'v_end_to_end_paths',
    {
      filters: searchFilters,
      limit: pageLimit,
      offset: (currentPage - 1) * pageLimit,
      orderBy: 'path_name',
    }
  );

  const mappedData = useMemo(() => {
    return (data?.data || []).map(path => ({
      ...path,
      id: path.path_id,
    }));
  }, [data]);

  return {
    data: mappedData,
    totalCount: data?.total_count || 0,
    activeCount: data?.active_count || 0,
    inactiveCount: data?.inactive_count || 0,
    isLoading, isFetching, error, refetch,
  };
};

export default function LogicalPathsPage() {
  const router = useRouter();
  
  // --- MANUAL STATE MANAGEMENT (Replaces useCrudManager) ---
  const [currentPage, setCurrentPage] = useState(1);
  const [pageLimit, setPageLimit] = useState(10);
  const [searchQuery, setSearchQuery] = useState('');
  const [showFilters, setShowFilters] = useState(false); // Kept for consistency, though unused
  const [isDeleteModalOpen, setDeleteModalOpen] = useState(false);
  const [itemToDelete, setItemToDelete] = useState<{ id: string; name: string } | null>(null);

  const {
    data: logicalPaths, totalCount, activeCount, inactiveCount, isLoading, isFetching, error, refetch
  } = useLogicalPathsData({ currentPage, pageLimit, searchQuery });
  
  const deprovisionMutation = useDeprovisionPath();

  const handleClearFilters = () => setSearchQuery('');
  const hasActiveFilters = !!searchQuery;

  // --- Deletion Logic ---
  const handleDeletePath = useCallback((record: Row<'v_end_to_end_paths'>) => {
    if (!record.path_id) {
      toast.error("Cannot de-provision: Path ID is missing.");
      return;
    }
    setItemToDelete({
      id: record.path_id,
      name: record.path_name || `Path ${record.path_id.slice(0, 8)}`
    });
    setDeleteModalOpen(true);
  }, []);

  const handleConfirmDelete = () => {
    if (itemToDelete) {
      deprovisionMutation.mutate({ pathId: itemToDelete.id }, {
        onSuccess: () => {
          toast.success(`Successfully de-provisioned "${itemToDelete.name}".`);
          setItemToDelete(null);
          setDeleteModalOpen(false);
          refetch();
        },
        onError: (err) => {
          toast.error(`De-provision failed: ${err.message}`);
          setItemToDelete(null);
          setDeleteModalOpen(false);
        }
      });
    }
  };

  const tableActions = useMemo<TableAction<'v_end_to_end_paths'>[]>(() => [
    {
      key: 'view',
      label: 'View Details',
      icon: <FiEye />, 
      onClick: (record) => {
        if (record.source_system_id) {
          router.push(`/dashboard/systems/${record.source_system_id}`);
        } else {
          toast.info('This path does not have a source system assigned.');
        }
      },
      variant: 'secondary',
    },
    {
      key: 'deprovision',
      label: 'De-provision Path',
      icon: <FiTrash2 />,
      onClick: handleDeletePath,
      variant: 'danger',
    },
  ], [handleDeletePath, router]);

  const headerActions = useStandardHeaderActions<'v_end_to_end_paths'>({
    data: logicalPaths,
    onRefresh: async () => { await refetch(); toast.success('Logical paths refreshed!'); },
    isLoading: isLoading,
    exportConfig: { tableName: 'v_end_to_end_paths' }
  });

  const headerStats = [
    { value: totalCount, label: 'Total Paths' },
    { value: activeCount, label: 'Active' },
    { value: inactiveCount, label: 'Inactive' },
  ];
  
  if (error) {
    return <ErrorDisplay error={error.message} actions={[{ label: 'Retry', onClick: refetch, variant: 'primary' }]} />;
  }

  return (
    <div className="p-6 space-y-6">
      <PageHeader
        title="Logical Fiber Paths"
        description="View and manage all provisioned end-to-end service paths."
        icon={<FiGitBranch />}
        stats={headerStats}
        actions={headerActions}
        isLoading={isLoading}
      />

      <DataTable<'v_end_to_end_paths'>
        // Provide the view name for column config, but the specific data type for operation
        tableName="v_end_to_end_paths"
        data={logicalPaths}
        columns={LogicalPathsTableColumns(logicalPaths)}
        loading={isLoading}
        isFetching={isFetching || deprovisionMutation.isPending}
        actions={tableActions}
        searchable={false}
        pagination={{
          current: currentPage,
          pageSize: pageLimit,
          total: totalCount,
          showSizeChanger: true,
          onChange: (page, limit) => {
            setCurrentPage(page);
            setPageLimit(limit);
          },
        }}
        customToolbar={
          <SearchAndFilters
            searchTerm={searchQuery}
            onSearchChange={setSearchQuery}
            showFilters={showFilters}
            onToggleFilters={() => setShowFilters(p => !p)}
            onClearFilters={handleClearFilters}
            hasActiveFilters={hasActiveFilters}
            activeFilterCount={0}
            searchPlaceholder="Search by path or route name..."
          >
            placeholder
          </SearchAndFilters>
        }
      />
      
      <ConfirmModal
        isOpen={isDeleteModalOpen}
        onConfirm={handleConfirmDelete}
        onCancel={() => setDeleteModalOpen(false)}
        title="Confirm De-provisioning"
        message={`Are you sure you want to de-provision "${itemToDelete?.name}"? This will release all associated fibers.`}
        loading={deprovisionMutation.isPending}
        type="danger"
      />
    </div>
  );
}
```

<!-- path: app/dashboard/categories/page.tsx -->
```typescript
'use client';

import { CategoriesTable } from '@/components/categories/CategoriesTable';
import { CategoryModal } from '@/components/categories/CategoryModal';
import { CategorySearch } from '@/components/categories/CategorySearch';
import { EmptyState } from '@/components/categories/EmptyState';
import { LoadingState } from '@/components/categories/LoadingState';
import { formatCategoryName } from '@/components/categories/utils';
import {
  PageHeader,
  useStandardHeaderActions,
} from '@/components/common/page-header';
import { ErrorDisplay } from '@/components/common/ui';
import { ConfirmModal } from '@/components/common/ui/Modal';
import { Filters, useDeduplicated, useTableQuery } from '@/hooks/database';
import { useDelete } from '@/hooks/useDelete';
import { useDeleteManager } from '@/hooks/useDeleteManager';
import { Lookup_typesRowSchema } from '@/schemas/zod-schemas';
import { createClient } from '@/utils/supabase/client';
import { useCallback, useEffect, useMemo, useState } from 'react';
import { FiLayers } from 'react-icons/fi';
import { toast } from 'sonner';

type GroupedLookupsByCategory = Record<string, Lookup_typesRowSchema[]>;
export interface CategoryInfo {
  name: string;
  lookupCount: number;
  hasSystemDefaults: boolean;
}

export default function CategoriesPage() {
  const [searchTerm, setSearchTerm] = useState('');
  const [isModalOpen, setIsModalOpen] = useState(false);
  const [editingCategory, setEditingCategory] = useState<string | null>(null);
  const [categoryLookupCounts, setCategoryLookupCounts] = useState<
    Record<string, CategoryInfo>
  >({});
  const [selectedCategoryId, setSelectedCategoryId] = useState<string | null>(
    null
  );

  const supabase = createClient();

  const {
    data: categoriesDeduplicated = [],
    isLoading: dedupLoading,
    error: dedupError,
    refetch: refetchCategories,
  } = useDeduplicated(supabase, 'lookup_types', {
    columns: ['category'],
    orderBy: [{ column: 'created_at', ascending: true }],
  });

  const {
    data: groupedLookupsByCategory,
    isLoading: groupedLookupsByCategoryLoading,
    error: groupedLookupsByCategoryError,
    refetch: refetchGroupedLookupsByCategory,
  } = useTableQuery(supabase, 'lookup_types', {
    select: (allLookups): GroupedLookupsByCategory => {
      if (!allLookups) return {};
      return allLookups.reduce((accumulator, currentLookup) => {
        const category = currentLookup.category;
        if (!accumulator[category]) {
          accumulator[category] = [];
        }
        accumulator[category].push(currentLookup);
        return accumulator;
      }, {} as GroupedLookupsByCategory);
    },
  });

  const deleteManager = useDelete({
    tableName: 'lookup_types',
    onSuccess: () => {
      if (selectedCategoryId === deleteManager.itemToDelete?.id) {
        setSelectedCategoryId(null);
      }
      refetchCategories();
    },
  });

  const isLoading =
    dedupLoading || groupedLookupsByCategoryLoading || deleteManager.isPending;

  const refreshCategoryInfo = useCallback(() => {
    const counts: Record<string, CategoryInfo> = {};
    for (const category of categoriesDeduplicated) {
      const categoryLookups =
        groupedLookupsByCategory?.[category.category] || [];
      counts[category.category] = {
        name: category.category,
        lookupCount: categoryLookups.length,
        hasSystemDefaults: categoryLookups.some(
          (lookup) => lookup.is_system_default
        ),
      };
    }
    setCategoryLookupCounts(counts);
  }, [categoriesDeduplicated, groupedLookupsByCategory]);

  useEffect(() => {
    if (!isLoading) {
      refreshCategoryInfo();
    }
  // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [isLoading]);

  async function handleRefresh() {
    try {
      await Promise.all([
        refetchCategories(),
        refetchGroupedLookupsByCategory(),
      ]);
      if (!isModalOpen) {
        toast.success('Data refreshed successfully');
      }
    } catch (error) {
      console.error('Error refreshing data:', error);
    }
  }

  const handleCategoryCreated = async () => {
    setIsModalOpen(false);
    setEditingCategory(null);
    handleRefresh();
  };

  const handleEdit = (categoryName: string) => {
    setEditingCategory(categoryName);
    setIsModalOpen(true);
    // handleRefresh();
  };

  const bulkDeleteManager = useDeleteManager({
    tableName: 'lookup_types',
    onSuccess: () => {
      if (selectedCategoryId === deleteManager.itemToDelete?.id) {
        setSelectedCategoryId(null);
      }
      refetchCategories();
    },
  });
  const handleDeleteCategory = (categoryToDelete: string) => {
    bulkDeleteManager.deleteBulk({
      column: 'category',
      value: categoryToDelete,
      displayName: categoryToDelete,
    });
  };

  const openCreateModal = () => {
    setEditingCategory(null);
    setIsModalOpen(true);
  };

  const handleModalClose = () => {
    setIsModalOpen(false);
    setEditingCategory(null);
  };

  const filteredCategories = (
    categoriesDeduplicated as Lookup_typesRowSchema[]
  )?.filter(
    (category) =>
      (category.category &&
        category.category.toLowerCase().includes(searchTerm.toLowerCase())) ||
      formatCategoryName(category as Lookup_typesRowSchema)
        .toLowerCase()
        .includes(searchTerm.toLowerCase())
  );

  // --- Define header content using the hook ---
  const serverFilters = useMemo(() => {
    const f: Filters = {
      // Filter to download only categories with name not equal to "DEFAULT"
      name: {
        operator: 'eq',
        value: 'DEFAULT',
      },
    };
    return f;
  }, []);
  const headerActions = useStandardHeaderActions({
    data: categoriesDeduplicated,
    onRefresh: async () => {
      await refetchCategories();
      toast.success('Refreshed successfully!');
    },
    onAddNew: openCreateModal,
    isLoading: isLoading,
    exportConfig: {
      tableName: 'lookup_types',
      fileName: 'Categories',
      filters: serverFilters,
    },
  });

  const activeCategories = categoriesDeduplicated.filter(
    (category) => category.status
  );
  const inactiveCategories = categoriesDeduplicated.filter(
    (category) => !category.status
  );

  const headerStats = [
    { value: categoriesDeduplicated.length, label: 'Total Categories' },
    {
      value: activeCategories.length,
      label: 'Active',
      color: 'success' as const,
    },
    {
      value: inactiveCategories.length,
      label: 'Inactive',
      color: 'danger' as const,
    },
  ];
  const error = dedupError || groupedLookupsByCategoryError;

  if (error) {
    return (
      <ErrorDisplay
        error={error.message}
        actions={[
          {
            label: 'Retry',
            onClick: refetchCategories,
            variant: 'primary',
          },
        ]}
      />
    );
  }

  return (
    <div className="space-y-6 p-6 dark:bg-gray-900 dark:text-gray-100">
      <PageHeader
        title="Categories"
        description="Manage categories and their related information."
        icon={<FiLayers />}
        stats={headerStats}
        actions={headerActions}
        isLoading={isLoading}
      />

      <CategorySearch searchTerm={searchTerm} onSearchChange={setSearchTerm} />

      {isLoading && <LoadingState />}

      {!isLoading && !dedupError && !groupedLookupsByCategoryError && (
        <CategoriesTable
          categories={filteredCategories}
          categoryLookupCounts={categoryLookupCounts}
          totalCategories={categoriesDeduplicated.length}
          onEdit={handleEdit}
          onDelete={handleDeleteCategory}
          isDeleting={deleteManager.isPending}
          searchTerm={searchTerm}
        />
      )}

      {categoriesDeduplicated.length === 0 && !isLoading && !dedupError && (
        <EmptyState onCreate={openCreateModal} />
      )}

      <ConfirmModal
        isOpen={bulkDeleteManager.isConfirmModalOpen}
        onConfirm={bulkDeleteManager.handleConfirm}
        onCancel={bulkDeleteManager.handleCancel}
        title="Confirm Deletion"
        message={bulkDeleteManager.confirmationMessage}
        confirmText="Delete"
        cancelText="Cancel"
        type="danger"
        showIcon
        closeOnBackdrop
        closeOnEscape
        loading={bulkDeleteManager.isPending}
        size="md"
      />

      <CategoryModal
        isOpen={isModalOpen}
        onClose={handleModalClose}
        onCategoryCreated={handleCategoryCreated}
        editingCategory={editingCategory || ''}
        categories={categoriesDeduplicated}
        lookupsByCategory={groupedLookupsByCategory}
      />
    </div>
  );
}

```

<!-- path: app/dashboard/maintenance-areas/page.tsx -->
```typescript
// app/dashboard/maintenance-areas/page.tsx
'use client';

import { EntityManagementComponent } from '@/components/common/entity-management/EntityManagementComponent';
import {
  PageHeader,
  useStandardHeaderActions,
} from '@/components/common/page-header';
import { ErrorDisplay } from '@/components/common/ui';
import { ConfirmModal } from '@/components/common/ui/Modal';
import { AreaFormModal } from '@/components/maintenance-areas/AreaFormModal';
import { useMaintenanceAreasMutations } from '@/components/maintenance-areas/useMaintenanceAreasMutations';
import { areaConfig, MaintenanceAreaWithRelations } from '@/config/areas';
import {
  Filters,
  useTableQuery,
  useTableWithRelations,
} from '@/hooks/database';
import { useDelete } from '@/hooks/useDelete';
import { Maintenance_areasInsertSchema } from '@/schemas/zod-schemas';
import { createClient } from '@/utils/supabase/client';
import { useMemo, useState } from 'react';
import { FiMapPin } from 'react-icons/fi';
import { toast } from 'sonner';

export default function MaintenanceAreasPage() {
  const supabase = createClient();

  const [filters, setFilters] = useState<{ status?: string; areaType?: string; }>({});
  const [selectedAreaId, setSelectedAreaId] = useState<string | null>(null);
  const [isFormOpen, setFormOpen] = useState(false);
  const [editingArea, setEditingArea] =
    useState<MaintenanceAreaWithRelations | null>(null);

  const serverFilters = useMemo(() => {
    const f: Filters = {};
    if (filters.status) f.status = filters.status === 'true';
    if (filters.areaType) f.area_type_id = filters.areaType;
    return f;
  }, [filters]);

  // **THE FIX (for "No parent" display): The `.select()` method has been removed.**
  // useTableWithRelations now correctly returns the full nested objects for relations.
  const areasQuery = useTableWithRelations<
    'maintenance_areas',
    MaintenanceAreaWithRelations[]
  >(
    supabase,
    'maintenance_areas',
    [
      'area_type:area_type_id(id, name)',
      'parent_area:parent_id(id, name, code)',
      'child_areas:maintenance_areas!parent_id(id, name, code, status)'
    ],
    {
      filters: serverFilters,
      orderBy: [{ column: 'name', ascending: true }],
    }
  );

  const { refetch, error, data } = areasQuery;

  const { data: areaTypes = [] } = useTableQuery(supabase, 'lookup_types', {
    filters: { category: { operator: 'eq', value: 'MAINTENANCE_AREA_TYPES' } },
    orderBy: [{ column: 'name', ascending: true }],
  });

  const {
    createAreaMutation,
    updateAreaMutation,
    toggleStatusMutation,
    handleFormSubmit,
  } = useMaintenanceAreasMutations(supabase, () => {
    areasQuery.refetch();
    setFormOpen(false);
    setEditingArea(null);
  });

  const deleteManager = useDelete({
    tableName: 'maintenance_areas',
    onSuccess: () => {
      if (selectedAreaId === deleteManager.itemToDelete?.id) {
        setSelectedAreaId(null);
      }
      areasQuery.refetch();
    },
  });

  const allAreas = useMemo(
    () => (areasQuery.data as MaintenanceAreaWithRelations[]) || [],
    [areasQuery.data]
  );
  
  const handleOpenCreateForm = () => {
    setEditingArea(null);
    setFormOpen(true);
  };

  const handleOpenEditForm = (area: MaintenanceAreaWithRelations) => {
    setEditingArea(area);
    setFormOpen(true);
  };
  
  const headerActions = useStandardHeaderActions({
    data: allAreas,
    onRefresh: async () => { await refetch(); toast.success('Refreshed successfully!'); },
    onAddNew: handleOpenCreateForm,
    isLoading: areasQuery.isLoading,
    exportConfig: { tableName: 'maintenance_areas' },
  });

  const headerStats = [
    { value: allAreas.length, label: 'Total Areas' },
    { value: allAreas.filter((r) => r.status).length, label: 'Active', color: 'success' as const },
    { value: allAreas.filter((r) => !r.status).length, label: 'Inactive', color: 'danger' as const },
  ];

  if (error) {
    return (
      <ErrorDisplay
        error={error.message}
        actions={[
          {
            label: 'Retry',
            onClick: refetch,
            variant: 'primary',
          },
        ]}
      />
    );
  }

  const isLoading =
    areasQuery.isLoading ||
    createAreaMutation.isPending ||
    updateAreaMutation.isPending ||
    toggleStatusMutation.isPending;

  return (
    <div className="p-4 md:p-6 dark:bg-gray-900 min-h-screen">
      <PageHeader
        title="Maintenance Areas"
        description="Manage maintenance areas, zones, and terminals."
        icon={<FiMapPin />}
        stats={headerStats}
        actions={headerActions}
        isLoading={isLoading}
        className="mb-4"
      />
      <EntityManagementComponent<MaintenanceAreaWithRelations>
        config={areaConfig}
        entitiesQuery={areasQuery}
        toggleStatusMutation={{ mutate: toggleStatusMutation.mutate, isPending: toggleStatusMutation.isPending }}
        onEdit={handleOpenEditForm}
        onDelete={deleteManager.deleteSingle}
        onCreateNew={handleOpenCreateForm}
        selectedEntityId={selectedAreaId}
        onSelect={setSelectedAreaId}
      />

      {isFormOpen && (
        <AreaFormModal
          isOpen={isFormOpen}
          onClose={() => setFormOpen(false)}
          onSubmit={(data: Maintenance_areasInsertSchema) =>
            handleFormSubmit(data, editingArea)
          }
          area={editingArea}
          allAreas={allAreas}
          areaTypes={areaTypes}
          isLoading={
            createAreaMutation.isPending || updateAreaMutation.isPending
          }
        />
      )}

      <ConfirmModal
        isOpen={deleteManager.isConfirmModalOpen}
        onConfirm={deleteManager.handleConfirm}
        onCancel={deleteManager.handleCancel}
        title="Confirm Deletion"
        message={deleteManager.confirmationMessage}
        confirmText="Delete"
        cancelText="Cancel"
        type="danger"
        showIcon
        loading={deleteManager.isPending}
      />
    </div>
  );
}
```

<!-- path: app/dashboard/employees/page.tsx -->
```typescript
// app/dashboard/employees/page.tsx
'use client';

import React, { useCallback, useMemo, useState } from 'react';
import { PageHeader, useStandardHeaderActions } from '@/components/common/page-header';
import { ConfirmModal, ErrorDisplay } from '@/components/common/ui';
import EmployeeForm from '@/components/employee/EmployeeForm';
import EmployeeFilters from '@/components/employee/EmployeeFilters';
import { getEmployeeTableColumns } from '@/components/employee/EmployeeTableColumns';
import { DataTable } from '@/components/table/DataTable';
import { BulkActions } from '@/components/common/BulkActions';
import { Filters, usePagedData, useTableQuery } from '@/hooks/database';
import { DataQueryHookParams, DataQueryHookReturn, useCrudManager } from '@/hooks/useCrudManager';
import {
  V_employeesRowSchema,
  EmployeesInsertSchema,
  EmployeesRowSchema,
  Employee_designationsRowSchema,
  Maintenance_areasRowSchema,
} from '@/schemas/zod-schemas';
import { createClient } from '@/utils/supabase/client';
import { FiUsers } from 'react-icons/fi';
import { createStandardActions } from '@/components/table/action-helpers';
import { TableAction } from '@/components/table/datatable-types';
import { EmployeeDetailsModal } from '@/config/employee-details-config';
import { toast } from 'sonner';

const useEmployeesData = (
  params: DataQueryHookParams
): DataQueryHookReturn<V_employeesRowSchema> => {
  const { currentPage, pageLimit, filters, searchQuery } = params;
  const supabase = createClient();

  const searchFilters = useMemo(() => {
    const newFilters: Filters = { ...filters };
    if (searchQuery) {
      newFilters.or = {
        employee_name: searchQuery,
        employee_pers_no: searchQuery,
      };
    }
    return newFilters;
  }, [filters, searchQuery]);

  const { data, isLoading, isFetching, error, refetch } = usePagedData<V_employeesRowSchema>(
    supabase,
    'v_employees',
    {
      filters: searchFilters,
      limit: pageLimit,
      offset: (currentPage - 1) * pageLimit,
      orderBy: 'employee_name',
    }
  );

  return {
    data: data?.data || [],
    totalCount: data?.total_count || 0,
    activeCount: data?.active_count || 0,
    inactiveCount: data?.inactive_count || 0,
    isLoading,
    isFetching,
    error,
    refetch,
  };
};

const EmployeesPage = () => {
  const supabase = createClient();
  const [showFilters, setShowFilters] = useState(false);
  
  const {
    data: employees,
    totalCount, activeCount, inactiveCount, isLoading, isMutating, isFetching, error, refetch,
    pagination, search, filters, editModal, viewModal, bulkActions, deleteModal, actions: crudActions,
  } = useCrudManager<'employees', V_employeesRowSchema>({
    tableName: 'employees',
    dataQueryHook: useEmployeesData,
  });

  // ** Restore the dedicated queries to fetch the full data structures.**
  const { data: designations = [] } = useTableQuery<"employee_designations", Employee_designationsRowSchema[]>(supabase, 'employee_designations', { orderBy: [{ column: 'name' }] });
  const { data: maintenanceAreas = [] } = useTableQuery<"maintenance_areas", Maintenance_areasRowSchema[]>(supabase, 'maintenance_areas', { filters: { status: true }, orderBy: [{ column: 'name' }] });

  const columns = useMemo(() => getEmployeeTableColumns({
    designationMap: Object.fromEntries(designations.map(d => [d.id, d.name])),
    areaMap: Object.fromEntries(maintenanceAreas.map(a => [a.id, a.name])),
  }), [designations, maintenanceAreas]);

  const tableActions = useMemo(
    () => createStandardActions<V_employeesRowSchema>({
      onView: viewModal.open,
      onEdit: editModal.openEdit,
      onToggleStatus: crudActions.handleToggleStatus,
      onDelete: crudActions.handleDelete,
    }) as TableAction<'v_employees'>[],
    [viewModal.open, editModal.openEdit, crudActions.handleToggleStatus, crudActions.handleDelete]
  );
  
  const headerActions = useStandardHeaderActions<'employees'>({
    data: employees as EmployeesRowSchema[],
    onRefresh: async () => { await refetch(); toast.success('Refreshed successfully!'); },
    onAddNew: editModal.openAdd,
    isLoading: isLoading,
    exportConfig: { tableName: 'employees' },
  });

  const headerStats = [
    { value: totalCount, label: 'Total Employees' },
    { value: activeCount, label: 'Active', color: 'success' as const },
    { value: inactiveCount, label: 'Inactive', color: 'danger' as const },
  ];

  const handleSaveEmployee = useCallback((data: EmployeesInsertSchema) => {
    crudActions.handleSave(data);
  }, [crudActions]);

  if (error) {
    return <ErrorDisplay error={error.message} actions={[{ label: 'Retry', onClick: refetch, variant: 'primary' }]} />;
  }

  return (
    <div className="mx-auto space-y-4 p-6">
      <PageHeader
        title="Employee Management"
        description="View, add, and manage all employee records."
        icon={<FiUsers />}
        stats={headerStats}
        actions={headerActions}
        isLoading={isLoading}
      />
      
      <BulkActions
        selectedCount={bulkActions.selectedCount}
        isOperationLoading={isMutating}
        onBulkDelete={bulkActions.handleBulkDelete}
        onBulkUpdateStatus={bulkActions.handleBulkUpdateStatus}
        onClearSelection={bulkActions.handleClearSelection}
        entityName="employee"
        showStatusUpdate={true}
      />

      <DataTable
        tableName="v_employees"
        data={employees}
        columns={columns}
        loading={isLoading}
        isFetching={isFetching || isMutating}
        actions={tableActions}
        selectable
        onRowSelect={(selectedRows) => {
            const validRows = selectedRows.filter(
                (row): row is V_employeesRowSchema & { id: string } => row.id != null
            );
            bulkActions.handleRowSelect(validRows);
        }}
        pagination={{
          current: pagination.currentPage,
          pageSize: pagination.pageLimit,
          total: totalCount,
          showSizeChanger: true,
          onChange: (page, pageSize) => {
            pagination.setCurrentPage(page);
            pagination.setPageLimit(pageSize);
          },
        }}
        customToolbar={
          <EmployeeFilters
            searchQuery={search.searchQuery}
            filters={filters.filters}
            onSearchChange={search.setSearchQuery}
            setFilters={filters.setFilters} 
            designations={designations}
            maintenanceAreas={maintenanceAreas}
            showFilters={showFilters}
            onFilterToggle={() => setShowFilters(!showFilters)}
          />
        }
      />
      
      <EmployeeForm
        isOpen={editModal.isOpen}
        onClose={editModal.close}
        employee={editModal.record}
        onSubmit={handleSaveEmployee}
        onCancel={editModal.close}
        isLoading={isMutating}
        designations={designations}
        maintenanceAreas={maintenanceAreas}
      />
      <EmployeeDetailsModal
        employee={viewModal.record}
        onClose={viewModal.close}
        isOpen={viewModal.isOpen}
      />
      <ConfirmModal
        isOpen={deleteModal.isOpen}
        onConfirm={deleteModal.onConfirm}
        onCancel={deleteModal.onCancel}
        title="Confirm Deletion"
        message={deleteModal.message}
        loading={deleteModal.loading}
        type="danger"
      />
    </div>
  );
};

export default EmployeesPage;
```

<!-- path: app/dashboard/designations/page.tsx -->
```typescript
'use client';

import { EntityManagementComponent } from '@/components/common/entity-management/EntityManagementComponent';
import { ErrorDisplay, ConfirmModal } from '@/components/common/ui';
import { PageHeader } from '@/components/common/page-header/PageHeader';
import { useStandardHeaderActions } from '@/components/common/page-header/hooks/useStandardHeaderActions';
import { DesignationFormModal } from '@/components/designations/DesignationFormModal';
import { designationConfig, DesignationWithRelations } from '@/config/designations';
import {
  Filters,
  useTableInsert,
  useTableUpdate,
  useTableWithRelations,
  useToggleStatus,
} from '@/hooks/database';
import { useDelete } from '@/hooks/useDelete';
import {
  Employee_designationsInsertSchema,
  Employee_designationsUpdateSchema,
} from '@/schemas/zod-schemas';
import { createClient } from '@/utils/supabase/client';
import { useMemo, useState } from 'react';
import { ImUserTie } from 'react-icons/im';
import { toast } from 'sonner';

export default function DesignationManagerPage() {
  const supabase = createClient();

  const [filters, setFilters] = useState<{ status?: string }>({});
  const [selectedDesignationId, setSelectedDesignationId] = useState<string | null>(null);
  const [isFormOpen, setFormOpen] = useState(false);
  const [editingDesignation, setEditingDesignation] = useState<DesignationWithRelations | null>(null);
  
  const serverFilters = useMemo(() => {
    const f: Filters = {};
    if (filters.status) f.status = filters.status === 'true';
    return f;
  }, [filters]);

  const designationsQuery = useTableWithRelations<'employee_designations', DesignationWithRelations[]>(
    supabase,
    'employee_designations',
    ['parent_designation:parent_id(id, name)'],
    {
      filters: serverFilters,
      orderBy: [{ column: 'name', ascending: true }],
    }
  );

  const { refetch, error, data } = designationsQuery;
  const totalCount = data?.length || 0;

  const onMutationSuccess = () => {
    designationsQuery.refetch();
    setFormOpen(false);
    setEditingDesignation(null);
  };

  // ** Pass the 'supabase' client as the first argument to the hooks.**
  const createDesignationMutation = useTableInsert(supabase, 'employee_designations', { onSuccess: onMutationSuccess });
  const updateDesignationMutation = useTableUpdate(supabase, 'employee_designations', { onSuccess: onMutationSuccess });
  const toggleStatusMutation = useToggleStatus(supabase, 'employee_designations', { onSuccess: onMutationSuccess }) as unknown as {
    mutate: (variables: { id: string; status: boolean; nameField?: string }) => void;
    isPending: boolean;
  };
  
  const toggleStatus = (variables: { id: string; status: boolean; nameField?: string }) => {
    return toggleStatusMutation.mutate({ ...variables, nameField: 'status' });
  };
  
  const { isPending } = toggleStatusMutation;

  const deleteManager = useDelete({
    tableName: 'employee_designations',
    onSuccess: () => {
      if (selectedDesignationId === deleteManager.itemToDelete?.id) {
        setSelectedDesignationId(null);
      }
      designationsQuery.refetch();
    },
  });

  const allDesignations = useMemo(
    () => (designationsQuery.data as DesignationWithRelations[]) || [],
    [designationsQuery.data]
  );

  const handleOpenCreateForm = () => {
    setEditingDesignation(null);
    setFormOpen(true);
  };

  const handleOpenEditForm = (designation: DesignationWithRelations) => {
    setEditingDesignation(designation);
    setFormOpen(true);
  };

  const handleFormSubmit = (data: Employee_designationsInsertSchema) => {
    if (editingDesignation) {
      updateDesignationMutation.mutate({
        id: editingDesignation.id || '',
        data: data as Employee_designationsUpdateSchema,
      });
    } else {
      createDesignationMutation.mutate(data);
    }
  };

  const headerActions = useStandardHeaderActions({
    data: designationsQuery.data?.map((d) => ({
      id: d.id, name: d.name, created_at: d.created_at ?? null,
      updated_at: d.updated_at ?? null, parent_id: d.parent_id ?? null, status: d.status ?? null,
    })),
    onRefresh: async () => { await refetch(); toast.success('Refreshed successfully!'); },
    onAddNew: handleOpenCreateForm,
    isLoading: designationsQuery.isLoading,
    exportConfig: { tableName: 'employee_designations' },
  });

  const headerStats = [
    { value: totalCount, label: 'Total Designations' },
    { value: allDesignations.filter((r) => r.status).length, label: 'Active', color: 'success' as const },
    { value: allDesignations.filter((r) => !r.status).length, label: 'Inactive', color: 'danger' as const },
  ];

  if (error) {
    return <ErrorDisplay error={error.message} actions={[{ label: 'Retry', onClick: refetch, variant: 'primary' }]} />;
  }

  const isLoading = designationsQuery.isLoading || createDesignationMutation.isPending || updateDesignationMutation.isPending || toggleStatusMutation.isPending;

  return (
    <div className="min-h-screen bg-gray-50 dark:bg-gray-900 overflow-x-hidden">
      <PageHeader
        title="Designation Management"
        description="Manage designations and their related information."
        icon={<ImUserTie />}
        stats={headerStats}
        actions={headerActions}
        isLoading={isLoading}
        className="mb-4"
      />
      <EntityManagementComponent<DesignationWithRelations>
        config={designationConfig}
        entitiesQuery={designationsQuery}
        toggleStatusMutation={{ mutate: toggleStatus, isPending }}
        onEdit={handleOpenEditForm}
        onDelete={deleteManager.deleteSingle}
        onCreateNew={handleOpenCreateForm}
        selectedEntityId={selectedDesignationId}
        onSelect={setSelectedDesignationId}
      />

      {isFormOpen && (
        <DesignationFormModal
          isOpen={isFormOpen}
          onClose={() => setFormOpen(false)}
          onSubmit={handleFormSubmit}
          designation={editingDesignation}
          allDesignations={allDesignations.map((d) => ({
            id: d.id ?? '', name: d.name, created_at: d.created_at ?? null, updated_at: d.updated_at ?? null,
            parent_id: d.parent_id ?? null, status: d.status ?? null,
          }))}
          isLoading={createDesignationMutation.isPending || updateDesignationMutation.isPending}
        />
      )}
      <ConfirmModal
        isOpen={deleteManager.isConfirmModalOpen}
        onConfirm={deleteManager.handleConfirm}
        onCancel={deleteManager.handleCancel}
        title="Confirm Deletion"
        message={deleteManager.confirmationMessage}
        confirmText="Delete"
        cancelText="Cancel"
        type="danger"
        showIcon
        loading={deleteManager.isPending}
      />
    </div>
  );
}
```

<!-- path: app/dashboard/doc/page.tsx -->
```typescript
"use client";

import { useState } from "react";
import { Separator } from "@/components/common/ui/separator";
import WorkflowAccordion from "@/components/doc/WorkflowAccordion";
import HeaderSection from "@/components/doc/HeaderSection";
import BackgroundElements from "@/components/doc/BackgroundElements";
import { workflowSections } from "@/components/doc/data/workflowData";

export default function Workflows() {
  const [open, setOpen] = useState<string | undefined>("auth");

  return (
    <div className="min-h-screen w-full bg-gradient-to-br from-gray-950 via-gray-900 to-gray-950 text-gray-100 p-4 md:p-8">
      <BackgroundElements />
      
      <div className="max-w-7xl mx-auto space-y-8 relative z-10">
        <HeaderSection />
        
        <Separator className="bg-gradient-to-r from-transparent via-gray-700 to-transparent h-px" />

        <WorkflowAccordion 
          sections={workflowSections}
          open={open}
          onValueChange={setOpen}
        />
      </div>
    </div>
  );
}
```

<!-- path: app/dashboard/layout.tsx -->
```typescript
"use client";

import useIsMobile from "@/hooks/useIsMobile";
import { UserRole } from "@/types/user-roles";
import { useState } from "react";
import { Protected } from "@/components/auth/Protected";
import DashboardContent from "@/components/dashboard/DashboardContent";
import { QueryProvider } from "@/providers/QueryProvider";
import { RouteBasedUploadConfigProvider } from "@/hooks/UseRouteBasedUploadConfigOptions";
import 'leaflet/dist/leaflet.css';

interface DashboardLayoutProps {
  children: React.ReactNode;
  showFileUpload?: boolean;
  showColumnManagement?: boolean;
  allowedRoles?: UserRole[];
}

export default function DashboardLayout({
  children,
  showFileUpload = true,
  showColumnManagement = true,
  allowedRoles = [
    UserRole.VIEWER,
    UserRole.ADMIN,
    UserRole.CPANADMIN,
    UserRole.MAANADMIN,
    UserRole.SDHADMIN,
    UserRole.VMUXADMIN,
    UserRole.MNGADMIN,
  ],
}: DashboardLayoutProps) {
  const [isCollapsed, setIsCollapsed] = useState(true);
  const isMobile = useIsMobile();

  // Determine table name based on current route

  return (
    <QueryProvider>
      <Protected allowedRoles={allowedRoles}>
        <RouteBasedUploadConfigProvider
          options={{
            autoSetConfig: true,
            customConfig: {
              // Global defaults that apply to all pages
              isUploadEnabled: true,
            },
          }}
        >
          <div className="min-h-screen bg-gray-50 dark:bg-gray-900 overflow-x-hidden">
            {/* File Upload Provider - conditionally render */}
            {showFileUpload ? (
              <DashboardContent
                isCollapsed={isCollapsed}
                setIsCollapsed={setIsCollapsed}
                isMobile={isMobile}
                showColumnManagement={showColumnManagement}
              >
                {children}
              </DashboardContent>
            ) : (
              <DashboardContent
                isCollapsed={isCollapsed}
                setIsCollapsed={setIsCollapsed}
                isMobile={isMobile}
                showColumnManagement={showColumnManagement}
              >
                {children}
              </DashboardContent>
            )}
          </div>
        </RouteBasedUploadConfigProvider>
      </Protected>
    </QueryProvider>
  );
}

```

<!-- path: app/dashboard/ofc/[id]/page.tsx -->
```typescript
// path: app/dashboard/ofc/[id]/page.tsx
"use client";

import { useMemo, useState, useEffect } from "react";
import { useParams, useRouter } from "next/navigation";
import { createClient } from "@/utils/supabase/client";
import { PageSpinner, ConfirmModal } from "@/components/common/ui";
import { DataTable } from "@/components/table";
import { Row, usePagedData, useTableQuery } from "@/hooks/database";
import { OfcDetailsTableColumns } from "@/config/table-columns/OfcDetailsTableColumns";
import useOrderedColumns from "@/hooks/useOrderedColumns";
import { TABLE_COLUMN_KEYS } from "@/config/table-column-keys";
import { DataQueryHookParams, DataQueryHookReturn, useCrudManager } from "@/hooks/useCrudManager";
import { createStandardActions } from "@/components/table/action-helpers";
import { useIsSuperAdmin } from "@/hooks/useAdminUsers";
import { OfcConnectionsFormModal } from "@/components/ofc-details/OfcConnectionsFormModal";
import { FiberTraceModal } from "@/components/ofc-details/FiberTraceModal";
import { GitCommit, GitBranch } from "lucide-react"; // Changed icon for better context
import { useOfcRoutesForSelection, useRouteDetails } from "@/hooks/database/route-manager-hooks";
import CableNotFound from "@/components/ofc-details/CableNotFound";
import OfcDetailsHeader from "@/components/ofc-details/OfcDetailsHeader";
import { useCreateOfcConnection } from "@/hooks/useCreateOfcConnection";
import { toast } from "sonner";
import { Ofc_connectionsInsertSchema, Ofc_connectionsRowSchema, V_ofc_cables_completeRowSchema, V_ofc_connections_completeRowSchema } from "@/schemas/zod-schemas";
import { PageHeader, useStandardHeaderActions } from "@/components/common/page-header"; // Import PageHeader components

export const dynamic = "force-dynamic";

// Data fetching hook remains the same
const useOfcConnectionsData = (params: DataQueryHookParams): DataQueryHookReturn<V_ofc_connections_completeRowSchema> => {
  const { currentPage, pageLimit, searchQuery } = params;
  const supabase = createClient();
  const { id } = useParams();
  const cableId = id as string;

  const { data, isLoading, error, refetch } = usePagedData<V_ofc_connections_completeRowSchema>(supabase, "v_ofc_connections_complete", {
    filters: { ofc_id: cableId, ...(searchQuery ? { or: `system_name.ilike.%${searchQuery}%,connection_type.ilike.%${searchQuery}%` } : {}) },
    limit: pageLimit,
    offset: (currentPage - 1) * pageLimit,
    orderBy: "fiber_no_sn",
    orderDir: "asc",
  });

  return {
    data: data?.data || [],
    totalCount: data?.total_count || 0,
    activeCount: data?.active_count || 0,
    inactiveCount: data?.inactive_count || 0,
    isLoading,
    error,
    refetch,
  };
};

export default function OfcCableDetailsPage() {
  const {
    data: cableConnectionsData,
    totalCount,
    activeCount,
    inactiveCount,
    isLoading,
    refetch,
    pagination,
    editModal,
    deleteModal,
    actions: crudActions,
  } = useCrudManager<"ofc_connections", V_ofc_connections_completeRowSchema>({
    tableName: "ofc_connections",
    dataQueryHook: useOfcConnectionsData,
  });
  

  const { id: cableId } = useParams();
  const router = useRouter();
  const supabase = createClient();

  const { data: routeDetails, isLoading: isLoadingRouteDetails } = useRouteDetails(cableId as string);
  const { data: allCablesData } = useOfcRoutesForSelection();

  const [tracingFiber, setTracingFiber] = useState<{ startSegmentId: string; fiberNo: number; record?: V_ofc_connections_completeRowSchema } | null>(null);

  const { data: cableSegments } = useTableQuery(createClient(), "cable_segments", {
    filters: { original_cable_id: cableId as string },
    orderBy: [{ column: "segment_order", ascending: true }],
  });

  const { ensureConnectionsExist } = useCreateOfcConnection({
    supabase,
    cableId: cableId as string,
    rawConnections: cableConnectionsData as Ofc_connectionsInsertSchema[],
    refetchOfcConnections: refetch,
    isLoadingOfcConnections: isLoading,
  });

  useEffect(() => {
    if (!isLoading && routeDetails?.route) {
      ensureConnectionsExist();
    }
  }, [isLoading, routeDetails, ensureConnectionsExist]);

  const columns = OfcDetailsTableColumns(cableConnectionsData);
  const orderedColumns = useOrderedColumns(columns, [...TABLE_COLUMN_KEYS.v_ofc_connections_complete]);

  const { data: isSuperAdmin } = useIsSuperAdmin();

  const tableActions = useMemo(
    () => [
      {
        key: "trace",
        label: "Trace Fiber Path",
        icon: <GitCommit className='h-4 w-4' />,
        onClick: (record: V_ofc_connections_completeRowSchema) => {
          const firstSegment = cableSegments?.find((s) => s.segment_order === 1);
          if (firstSegment && record.fiber_no_sn) {
            setTracingFiber({ startSegmentId: firstSegment.id, fiberNo: record.fiber_no_sn, record });
          } else {
            toast.error("Cannot trace fiber: No cable segments found for this route or fiber number is missing.");
          }
        },
        variant: "secondary" as const,
      },
      ...createStandardActions({
        onEdit: editModal.openEdit,
        onDelete: crudActions.handleDelete,
        onToggleStatus: crudActions.handleToggleStatus,
        canDelete: () => isSuperAdmin === true,
      }),
    ],
    [editModal.openEdit, crudActions.handleDelete, crudActions.handleToggleStatus, isSuperAdmin, cableSegments]
  );

  const headerActions = useStandardHeaderActions({
    data: cableConnectionsData as Ofc_connectionsRowSchema[],
    onRefresh: async () => { await refetch(); toast.success('Connections refreshed!'); },
    onAddNew: editModal.openAdd,
    isLoading: isLoading,
    exportConfig: {
      tableName: 'ofc_connections',
      fileName: `${routeDetails?.route.route_name}_connections`,
      filters: { ofc_id: { operator: 'eq', value: cableId as string } }
    },
  });

  const headerStats = [
    { value: totalCount, label: 'Total Connections' },
    { value: activeCount, label: 'Active', color: 'success' as const },
    { value: inactiveCount, label: 'Inactive', color: 'danger' as const },
  ];

  if (isLoading || isLoadingRouteDetails) {
    return <PageSpinner />;
  }

  if (!routeDetails?.route) {
    return <CableNotFound id={cableId as string} handleBackToOfcList={() => router.push("/dashboard/ofc")} isBackClicked={false} />;
  }

  return (
    <div className='mx-auto space-y-6 p-4 md:p-6'>
      {/* --- REPLACED: Old header is replaced with PageHeader --- */}
      <PageHeader
        title="OFC Cable Details"
        description={`Managing connections for route: ${routeDetails.route.route_name}`}
        icon={<GitBranch />}
        stats={headerStats}
        actions={headerActions}
        isLoading={isLoading}
      />
      {/* --- END REPLACEMENT --- */}

      <OfcDetailsHeader cable={routeDetails.route as V_ofc_cables_completeRowSchema} />

      <div className='rounded-lg border border-gray-200 dark:border-gray-700 p-4'>
        <DataTable<"v_ofc_connections_complete">
          tableName='v_ofc_connections_complete'
          data={cableConnectionsData as Row<"v_ofc_connections_complete">[]}
          columns={orderedColumns}
          loading={isLoading}
          actions={tableActions}
          selectable={true}
          searchable={true}
          pagination={{
            current: pagination.currentPage,
            pageSize: pagination.pageLimit,
            total: totalCount,
            showSizeChanger: true,
            onChange: (page, limit) => {
              pagination.setCurrentPage(page);
              pagination.setPageLimit(limit);
            },
          }}
        />
      </div>
      <OfcConnectionsFormModal isOpen={editModal.isOpen} onClose={editModal.close} editingOfcConnections={editModal.record as Ofc_connectionsRowSchema | null} onCreated={crudActions.handleSave} onUpdated={crudActions.handleSave} />
      <ConfirmModal isOpen={deleteModal.isOpen} onConfirm={deleteModal.onConfirm} onCancel={deleteModal.onCancel} title='Confirm Deletion' message={deleteModal.message} type='danger' loading={deleteModal.loading} />
      <FiberTraceModal refetch={refetch} isOpen={!!tracingFiber} onClose={() => setTracingFiber(null)} startSegmentId={tracingFiber?.startSegmentId || null} fiberNo={tracingFiber?.fiberNo || null} allCables={allCablesData} record={tracingFiber?.record} />
    </div>
  );
}
```

<!-- path: app/dashboard/ofc/page.tsx -->
```typescript
'use client';

import {
  Filters,
  usePagedData,
  useTableInsert,
  useTableUpdate,
} from '@/hooks/database';
import { useIsSuperAdmin } from '@/hooks/useAdminUsers';
import { createClient } from '@/utils/supabase/client';
import { useRouter } from 'next/navigation';
import { useCallback, useMemo, useState } from 'react';

import { BulkActions } from '@/components/common/BulkActions';
import { ConfirmModal, ErrorDisplay } from '@/components/common/ui';
import OfcForm from '@/components/ofc/OfcForm/OfcForm';
import { DataTable } from '@/components/table/DataTable';
import { TablesInsert } from '@/types/supabase-types';
import { SelectFilter } from '@/components/common/filters/FilterInputs';
import { SearchAndFilters } from '@/components/common/filters/SearchAndFilters';
import {
  PageHeader,
  useStandardHeaderActions,
} from '@/components/common/page-header';
import { createStandardActions } from '@/components/table/action-helpers';
import { TABLE_COLUMN_KEYS } from '@/config/table-column-keys';
import { OfcTableColumns } from '@/config/table-columns/OfcTableColumns';
import {
  DataQueryHookParams,
  DataQueryHookReturn,
  useCrudManager,
} from '@/hooks/useCrudManager';
import useOrderedColumns from '@/hooks/useOrderedColumns';
import { V_ofc_cables_completeRowSchema } from '@/schemas/zod-schemas';
import { AiFillMerge } from 'react-icons/ai';
import { toast } from 'sonner';

export type OfcCablesWithRelations = V_ofc_cables_completeRowSchema & {
  ofc_type: {
    id: string;
    name: string;
  } | null;
  maintenance_area: {
    id: string;
    name: string;
  } | null;
};

// 1. ADAPTER HOOK: Makes `useOfcData` compatible with `useCrudManager`
const useOfcData = (
  params: DataQueryHookParams
): DataQueryHookReturn<V_ofc_cables_completeRowSchema> => {
  const { currentPage, pageLimit, filters, searchQuery } = params;
  const supabase = createClient();

  // Build the server filters object that the RPC function expects.
  // const serverFilters = useMemo(() => {
  //   const richFilters: Filters = { ...filters };
  //   if (searchQuery) {
  //     richFilters.or = {
  //       route_name: searchQuery,
  //       asset_no: searchQuery,
  //       transnet_id: searchQuery,
  //     };
  //   }
  //   return richFilters; // Return Filters type instead of converting to Json
  // }, [filters, searchQuery]);

  const { data, isLoading, isFetching, error, refetch } = usePagedData<V_ofc_cables_completeRowSchema>(
    supabase,
    'v_ofc_cables_complete',
    {
      filters: filters,
      limit: pageLimit,
      offset: (currentPage - 1) * pageLimit,
      orderBy: 'route_name', // Changed from default 'name' to 'route_name' which exists in the view
    }
  );


  return {
    data: data?.data || [],
    totalCount: data?.total_count || 0,
    activeCount: data?.active_count || 0,
    inactiveCount: data?.inactive_count || 0,
    isLoading,
    isFetching,
    error,
    refetch,
  };
};

const OfcPage = () => {
  // 2. USE THE CRUD MANAGER with the adapter hook and both generic types
  const {
    data: ofcData,
    totalCount,
    activeCount,
    inactiveCount,
    isLoading,
    isMutating,
    isFetching,
    error,
    refetch,
    pagination,
    search,
    filters: crudFilters,
    editModal,
    // viewModal,
    bulkActions,
    deleteModal,
    actions: crudActions,
  } = useCrudManager<'ofc_cables', V_ofc_cables_completeRowSchema>({
    tableName: 'ofc_cables',
    dataQueryHook: useOfcData, 
    // Provide an array of column names to search across
    searchColumn: ['route_name', 'asset_no', 'transnet_id'],
  });

  // 3. Extract ring types from the rings data
  const ofcTypes = useMemo(() => {
    const uniqueOfcTypes = new Map();
    ofcData.forEach((ofc) => {
      if (ofc.ofc_type_code) {
        uniqueOfcTypes.set(ofc.ofc_type_id, {
          id: ofc.ofc_type_id,
          name: ofc.ofc_type_code,
        });
      }
    });
    return Array.from(uniqueOfcTypes.values());
  }, [ofcData]);

  const maintenanceAreas = useMemo(() => {
    const uniqueMaintenanceAreas = new Map();
    ofcData.forEach((ofc) => {
      if (ofc.maintenance_area_code) {
        uniqueMaintenanceAreas.set(ofc.maintenance_terminal_id, {
          id: ofc.maintenance_terminal_id,
          name: ofc.maintenance_area_code,
        });
      }
    });
    return Array.from(uniqueMaintenanceAreas.values());
  }, [ofcData]);

  const ofcOwners = useMemo(() => {
    const uniqueOwners = new Map();
    ofcData.forEach((ofc) => {
      if (ofc.ofc_owner_code) {
        uniqueOwners.set(ofc.ofc_owner_id, {
          id: ofc.ofc_owner_id,
          ofc_owner_code: ofc.ofc_owner_code,
        });
      }
    });
    return Array.from(uniqueOwners.values());
  }, [ofcData]);

  const supabase = createClient();
  const router = useRouter();
  const [showFilters, setShowFilters] = useState(false);

  const activeFilterCount = Object.values(crudFilters.filters).filter(
    Boolean
  ).length;
  const hasActiveFilters = activeFilterCount > 0 || !!search.searchQuery;

  const handleClearFilters = () => {
    crudFilters.setFilters({});
    search.setSearchQuery('');
  };

  const { data: isSuperAdmin } = useIsSuperAdmin();

  // Memoize the record to prevent unnecessary re-renders
  const memoizedOfcCable = useMemo(
    () => editModal.record as OfcCablesWithRelations,
    [editModal.record]
  );

  // --- MUTATIONS ---
  const { mutate: insertOfcCable, isPending: isInserting } = useTableInsert(
    supabase,
    'ofc_cables',
    {
      onSuccess: () => {
        refetch();
        closeModal();
        toast.success('OFC Cable created.');
      },
    }
  );
  const { mutate: updateOfcCable, isPending: isUpdating } = useTableUpdate(
    supabase,
    'ofc_cables',
    {
      onSuccess: () => {
        refetch();
        closeModal();
        toast.success('OFC Cable updated.');
      },
    }
  );

  // --- HANDLERS ---
  const closeModal = useCallback(() => {
    editModal.close();
  }, [editModal]);

  const handleSave = useCallback((data: TablesInsert<'ofc_cables'>) => {
    if (editModal.record) {
      updateOfcCable({ id: editModal.record.id!, data });
    } else {
      insertOfcCable(data);
    }
  }, [editModal.record, insertOfcCable, updateOfcCable]); 

  // --- MEMOIZED VALUES ---
  const columns = OfcTableColumns(ofcData);

  const orderedColumns = useOrderedColumns(
    columns,
    [...TABLE_COLUMN_KEYS.ofc_cables] // Spread operator creates a new mutable array
  );

  const tableActions = useMemo(
    () =>
      createStandardActions({
        onEdit: editModal.openEdit,
        onView: (record) => router.push(`/dashboard/ofc/${record.id}`),
        onDelete: crudActions.handleDelete,
        onToggleStatus: crudActions.handleToggleStatus,
        canDelete: () => isSuperAdmin === true,
      }),
    [crudActions, editModal.openEdit, router, isSuperAdmin]
  );

  const headerStats = [
    { value: totalCount, label: 'Total OFC Cables' },
    {
      value: activeCount,
      label: 'Active',
      color: 'success' as const,
    },
    {
      value: inactiveCount,
      label: 'Inactive',
      color: 'danger' as const,
    },
  ];

  const loading = isLoading || isInserting || isUpdating;

  const headerActions = useStandardHeaderActions({
    onRefresh: async () => {
      await refetch();
      toast.success('Refreshed successfully!');
    },
    onAddNew: editModal.openAdd,
    isLoading: loading,
    exportConfig: {
      tableName: 'ofc_cables',
      filterOptions: [
        {
          label: 'BSNL',
          filters: {
            ofc_owner_id: {
              operator: 'eq',
              value: 'ad3477d5-de78-4b9f-9302-a4b5db326e9f',
            },
          },
        },
        {
          label: 'BBNL',
          filters: {
            ofc_owner_id: {
              operator: 'eq',
              value: 'e40c2549-11ec-485d-a67a-8261fcaec68a',
            },
          },
        },
      ],
    },
  });

  if (error) {
    return (
      <ErrorDisplay
        error={error.message}
        actions={[
          {
            label: 'Retry',
            onClick: refetch,
            variant: 'primary',
          },
        ]}
      />
    );
  }

  return (
    <div className="mx-auto space-y-6 p-4 md:p-6">
      <PageHeader
        title="OFC Cable Management"
        description="Manage OFC cables and their related information."
        icon={<AiFillMerge />}
        stats={headerStats}
        actions={headerActions}
        isLoading={loading}
      />
      <BulkActions
        selectedCount={bulkActions.selectedCount}
        isOperationLoading={isMutating}
        onBulkDelete={() => bulkActions.handleBulkDelete()}
        onBulkUpdateStatus={bulkActions.handleBulkUpdateStatus}
        onClearSelection={bulkActions.handleClearSelection}
        entityName="ofc cable"
        showStatusUpdate={true}
        canDelete={() => isSuperAdmin === true && bulkActions.selectedCount > 0}
      />

      <DataTable
        tableName="v_ofc_cables_complete"
        data={ofcData}
        columns={orderedColumns}
        loading={loading}
        isFetching={isFetching}
        actions={tableActions}
        selectable
        onRowSelect={(selectedRows: V_ofc_cables_completeRowSchema[]): void => {
          // Update selection with new row IDs
          bulkActions.handleRowSelect(selectedRows as never);
        }}
        searchable={false}
        filterable={false}
        pagination={{
          current: pagination.currentPage,
          pageSize: pagination.pageLimit,
          total: totalCount,
          showSizeChanger: true,
          onChange: (page, limit) => {
            pagination.setCurrentPage(page);
            pagination.setPageLimit(limit);
          },
        }}
        customToolbar={
          <SearchAndFilters
            searchTerm={search.searchQuery}
            onSearchChange={search.setSearchQuery}
            showFilters={showFilters}
            onToggleFilters={() => setShowFilters((p) => !p)}
            onClearFilters={handleClearFilters}
            hasActiveFilters={hasActiveFilters}
            activeFilterCount={activeFilterCount}
            searchPlaceholder="Search by Asset No or Route Name or Transnet ID..."
          >
            {/* THIS IS THE CLEANER, TYPE-SAFE WAY */}
            <SelectFilter
              label="OFC Type"
              filterKey="ofc_type_id"
              filters={crudFilters.filters}
              setFilters={crudFilters.setFilters}
              options={ofcTypes.map((t) => ({ value: t.id, label: t.name }))}
            />
            <SelectFilter
              label="Status"
              filterKey="status"
              filters={crudFilters.filters}
              setFilters={crudFilters.setFilters}
              options={[
                { value: 'true', label: 'Active' },
                { value: 'false', label: 'Inactive' },
              ]}
            />
            <SelectFilter
              label="ofc_owner"
              filterKey="ofc_owner_id"
              filters={crudFilters.filters}
              setFilters={crudFilters.setFilters}
              options={ofcOwners.map((t) => ({
                value: t.id,
                label: t.ofc_owner_code,
              }))}
            />
            <SelectFilter
              label="Maintenance Terminal"
              filterKey="maintenance_terminal_id"
              filters={crudFilters.filters}
              setFilters={crudFilters.setFilters}
              options={maintenanceAreas.map((t) => ({
                value: t.id,
                label: t.name,
              }))}
            />
          </SearchAndFilters>
        }
      />

      <OfcForm
        isOpen={editModal.isOpen}
        onClose={editModal.close}
        ofcCable={memoizedOfcCable}
        onSubmit={handleSave}
        pageLoading={isMutating}
      />

      <ConfirmModal
        isOpen={deleteModal.isOpen}
        onConfirm={deleteModal.onConfirm}
        onCancel={deleteModal.onCancel}
        title="Confirm Deletion"
        message={deleteModal.message}
        type="danger"
        loading={deleteModal.loading}
        confirmText="Delete"
        cancelText="Cancel"
        showIcon={true}
      />
    </div>
  );
};

export default OfcPage;

```

<!-- path: app/dashboard/systems/[id]/page.tsx -->
```typescript
// path: app/dashboard/systems/[id]/page.tsx
"use client";

import { useParams } from "next/navigation";
import { createClient } from "@/utils/supabase/client";
import { useTableRecord } from "@/hooks/database";
import { PageSpinner, ErrorDisplay } from "@/components/common/ui";
import { SystemRingPath } from "@/components/systems/SystemRingPath";
import { NodesRowSchema, SystemsRowSchema } from "@/schemas/zod-schemas";

// Define the expected shape of our data, including the nested 'node' object
type SystemWithNode = SystemsRowSchema & {
  node: NodesRowSchema | null;
};

export default function SystemDetailsPage() {
  const params = useParams();
  const id = params.id as string;
  const supabase = createClient();

  const { data: system, isLoading, isError, error, refetch } = useTableRecord<'systems', SystemWithNode>(
    supabase,
    "systems",
    id,
    { columns: "*, node:node_id(*)" }
  );

  if (isLoading) return <PageSpinner text="Loading system details..." />;
  if (isError) return <ErrorDisplay error={error?.message} actions={[{ label: 'Retry', onClick: () => refetch(), variant: 'primary' }]} />;
  if (!system) return <div className="p-6">System not found. It may have been deleted.</div>;

  return (
    <div className="space-y-8 p-4 md:p-6">
      <header>
        <h1 className="text-3xl font-bold text-gray-900 dark:text-white">{system.system_name || "Unnamed System"}</h1>
        <p className="text-gray-500 dark:text-gray-400 mt-1">
          Location: {system.node?.name || "N/A"}
        </p>
      </header>

      <main>
        <SystemRingPath system={system} />
      </main>
    </div>
  );
}
```

<!-- path: app/dashboard/systems/page.tsx -->
```typescript
// path: app/dashboard/systems/page.tsx

'use client';

import { useRouter } from 'next/navigation';
import { useCallback, useMemo, useState } from 'react';
import { FiDatabase } from 'react-icons/fi';
import { toast } from 'sonner';

import { SelectFilter } from '@/components/common/filters/FilterInputs';
import { SearchAndFilters } from '@/components/common/filters/SearchAndFilters';
import { PageHeader, useStandardHeaderActions } from '@/components/common/page-header';
import { ErrorDisplay } from '@/components/common/ui';
import { ConfirmModal } from '@/components/common/ui/Modal/confirmModal';
import { createStandardActions } from '@/components/table/action-helpers';
import { DataTable } from '@/components/table/DataTable';
import type { TableAction } from '@/components/table/datatable-types';
import { SystemsTableColumns } from '@/config/table-columns/SystemsTableColumns';
import { Filters, Row, usePagedData, useTableQuery } from '@/hooks/database';
import { DataQueryHookParams, DataQueryHookReturn, useCrudManager } from '@/hooks/useCrudManager';
import { V_systems_completeRowSchema } from '@/schemas/zod-schemas';
import { createClient } from '@/utils/supabase/client';
import { SystemModal } from '@/components/systems/SystemModal';

const useSystemsData = (
  params: DataQueryHookParams
): DataQueryHookReturn<V_systems_completeRowSchema> => {
  const { currentPage, pageLimit, filters, searchQuery } = params;
  const supabase = createClient();

  // This hook now correctly receives and uses the complex `Filters` type
  const searchFilters = useMemo(() => {
    const newFilters: Filters = { ...filters };
    if (searchQuery) {
      newFilters.or = {
        system_name: searchQuery,
        system_type_name: searchQuery,
      };
    }
    return newFilters;
  }, [filters, searchQuery]);

  // Pass the complex `Filters` object directly to usePagedData
  const { data, isLoading, error, refetch } = usePagedData<V_systems_completeRowSchema>(supabase,
    'v_systems_complete',
     {
      filters: searchFilters,
      limit: pageLimit,
      offset: (currentPage - 1) * pageLimit,
    }
  );

  return {
    data: data?.data || [],
    totalCount: data?.total_count || 0,
    activeCount: data?.active_count || 0,
    inactiveCount: data?.inactive_count || 0,
    isLoading,
    error,
    refetch,
  };
};

export default function SystemsPage() {
  const router = useRouter();
  const [showFilters, setShowFilters] = useState(false);

  const {
    data: systems, totalCount, activeCount, inactiveCount, isLoading, error, refetch,
    pagination, search, filters, editModal, deleteModal, actions: crudActions,
  } = useCrudManager<'systems', V_systems_completeRowSchema>({
    tableName: 'systems',
    dataQueryHook: useSystemsData,
    searchColumn: 'system_name',
  });

  const { data: systemTypes = [] } = useTableQuery(createClient(), 'lookup_types', { filters: { category: 'SYSTEM_TYPES' } });

  const handleView = useCallback((system: Row<'v_systems_complete'>) => {
    router.push(`/dashboard/systems/${system.id}`);
  }, [router]);

  const tableActions = useMemo(
    () => createStandardActions<V_systems_completeRowSchema>({
        onEdit: editModal.openEdit,
        onView: handleView,
        onDelete: crudActions.handleDelete,
        onToggleStatus: crudActions.handleToggleStatus,
      }),
    [editModal.openEdit, handleView, crudActions]
  );

  const headerActions = useStandardHeaderActions({
    data: systems as V_systems_completeRowSchema[],
    onRefresh: () => { refetch(); toast.success('Systems refreshed.'); },
    onAddNew: editModal.openAdd,
    isLoading: isLoading,
    exportConfig: { tableName: 'v_systems_complete', fileName: 'systems' },
  });

  if (error) return <ErrorDisplay error={error.message} actions={[{ label: 'Retry', onClick: refetch, variant: 'primary' }]} />;

  return (
    <div className="p-6 space-y-6">
      <PageHeader
        title="System Management"
        description="Manage all network systems, including CPAN, MAAN, SDH, and VMUX."
        icon={<FiDatabase />}
        stats={[
          { value: totalCount, label: 'Total Systems' },
          { value: activeCount, label: 'Active', color: 'success' },
          { value: inactiveCount, label: 'Inactive', color: 'danger' },
        ]}
        actions={headerActions}
        isLoading={isLoading}
      />
      <DataTable
        tableName="v_systems_complete"
        data={systems}
        columns={SystemsTableColumns(systems)}
        loading={isLoading}
        actions={tableActions as TableAction<'v_systems_complete'>[]}
        pagination={{
          current: pagination.currentPage,
          pageSize: pagination.pageLimit,
          total: totalCount,
          showSizeChanger: true,
          onChange: (page, limit) => { pagination.setCurrentPage(page); pagination.setPageLimit(limit); },
        }}
        customToolbar={
          <SearchAndFilters
            searchTerm={search.searchQuery}
            onSearchChange={search.setSearchQuery}
            showFilters={showFilters}
            onToggleFilters={() => setShowFilters(p => !p)}
            onClearFilters={() => { search.setSearchQuery(''); filters.setFilters({}); }}
            hasActiveFilters={Object.values(filters.filters).some(Boolean) || !!search.searchQuery}
            activeFilterCount={Object.values(filters.filters).filter(Boolean).length}
            searchPlaceholder="Search by system name or type..."
          >
            <SelectFilter
              label="System Type"
              filterKey="system_type_name"
              filters={filters.filters}
              setFilters={filters.setFilters}
              options={systemTypes.map(t => ({ value: t.name, label: t.name }))}
            />
            <SelectFilter
              label="Status"
              filterKey="status"
              filters={filters.filters}
              setFilters={filters.setFilters}
              options={[{ value: 'true', label: 'Active' }, { value: 'false', label: 'Inactive' }]}
            />
          </SearchAndFilters>
        }
      />

      <SystemModal
        isOpen={editModal.isOpen}
        onClose={editModal.close}
        rowData={editModal.record}
        refetch={refetch}
      />

      <ConfirmModal
        isOpen={deleteModal.isOpen}
        onConfirm={deleteModal.onConfirm}
        onCancel={deleteModal.onCancel}
        title="Confirm Deletion"
        message={deleteModal.message}
        loading={deleteModal.loading}
        type="danger"
      />
    </div>
  );
}
```

<!-- path: app/dashboard/nodes/page.tsx -->
```typescript
'use client';

import {
  PageHeader,
  useStandardHeaderActions,
} from '@/components/common/page-header';
import { ConfirmModal, ErrorDisplay } from '@/components/common/ui';
import { NodeFormModal } from '@/components/nodes/NodeFormModal';
import { NodesFilters } from '@/components/nodes/NodesFilters';
import { createStandardActions } from '@/components/table/action-helpers';
import { DataTable } from '@/components/table/DataTable';
import { NodeDetailsModal } from '@/config/node-details-config';
import { NodesTableColumns } from '@/config/table-columns/NodesTableColumns';
import { convertRichFiltersToSimpleJson, usePagedData, Filters } from '@/hooks/database';
import {
  DataQueryHookParams,
  DataQueryHookReturn,
  useCrudManager,
} from '@/hooks/useCrudManager';
import useOrderedColumns from '@/hooks/useOrderedColumns';
import { NodesRowSchema, V_nodes_completeRowSchema } from '@/schemas/zod-schemas';
import { createClient } from '@/utils/supabase/client';
import { useMemo } from 'react';
import { FiCpu } from 'react-icons/fi';
import { toast } from 'sonner';

export type NodeRowsWithRelations = NodesRowSchema & {
  maintenance_terminal?: {
    id: string;
    name: string;
  } | null;
  node_type?: {
    id: string;
    name: string;
  } | null;
};

const useNodesData = (
  params: DataQueryHookParams
): DataQueryHookReturn<V_nodes_completeRowSchema> => {
  const { currentPage, pageLimit, filters, searchQuery } = params;
  const supabase = createClient();
  const rpcFilters = useMemo(() => {
      const convertedFilters = convertRichFiltersToSimpleJson(filters);
      return {
        ...(convertedFilters as Record<string, string | number | boolean | string[] | null>),
        ...(searchQuery ? { name: searchQuery } : {}),
      };
    }, [filters, searchQuery]);

  const { data, isLoading, error, refetch } = usePagedData<V_nodes_completeRowSchema>(
    supabase,
    'v_nodes_complete',
    {
      filters: rpcFilters,
      limit: pageLimit,
      offset: (currentPage - 1) * pageLimit,
    }
  );

  return {
    data: data?.data || [],
    totalCount: data?.total_count || 0,
    activeCount: data?.active_count || 0,
    inactiveCount: data?.inactive_count || 0,
    isLoading,
    error,
    refetch,
  };
};

const NodesPage = () => {
  const {
    data: nodes,
    totalCount,
    activeCount,
    inactiveCount,
    isLoading,
    isMutating,
    error,
    refetch,
    pagination,
    search,
    filters,
    editModal,
    viewModal,
    deleteModal,
    actions: crudActions,
  } = useCrudManager<'nodes', V_nodes_completeRowSchema>({
    tableName: 'nodes',
    dataQueryHook: useNodesData,
  });

  const nodeTypes = useMemo(() => {
    const uniqueNodeTypes = new Map();
    nodes.forEach((node) => {
      if (node.node_type_id) {
        uniqueNodeTypes.set(node.node_type_id, {
          id: node.node_type_id,
          name: node.node_type_name,
        });
      }
    });
    return Array.from(uniqueNodeTypes.values());
  }, [nodes]);

  const columns = NodesTableColumns(nodes);
  const orderedColumns = useOrderedColumns(columns, [
    'name', 'latitude', 'longitude', 'node_type_name', 'maintenance_area_name', 'status', 'remark',
  ]);

  const tableActions = useMemo(
    () => createStandardActions<V_nodes_completeRowSchema>({
        onEdit: editModal.openEdit,
        onView: viewModal.open,
        onDelete: crudActions.handleDelete,
      }),
    [editModal.openEdit, viewModal.open, crudActions.handleDelete]
  );

  const headerActions = useStandardHeaderActions({
    data: nodes as NodesRowSchema[],
    onAddNew: () => { editModal.openAdd(); },
    onRefresh: () => { refetch(); toast.success('Refreshed successfully!'); },
    isLoading: isLoading,
    exportConfig: { tableName: 'nodes' },
  });

  const headerStats = [
    { value: totalCount, label: 'Total Nodes' },
    { value: activeCount, label: 'Active', color: 'success' as const },
    { value: inactiveCount, label: 'Inactive', color: 'danger' as const },
  ];

  if (error) {
    return <ErrorDisplay error={error.message} actions={[{ label: 'Retry', onClick: refetch, variant: 'primary' }]} />;
  }

  return (
    <div className="mx-auto space-y-4 p-6">
      <PageHeader
        title="Node Management"
        description="Manage network nodes and their related information."
        icon={<FiCpu />}
        stats={headerStats}
        actions={headerActions}
        isLoading={isLoading}
      />

      <NodeDetailsModal
        isOpen={viewModal.isOpen}
        node={viewModal.record as V_nodes_completeRowSchema}
        onClose={viewModal.close}
      />

      <DataTable
        tableName="v_nodes_complete"
        data={nodes}
        columns={orderedColumns}
        loading={isLoading}
        actions={tableActions}
        selectable={true}
        showColumnsToggle={true}
        pagination={{
          current: pagination.currentPage,
          pageSize: pagination.pageLimit,
          total: totalCount,
          showSizeChanger: true,
          onChange: (page, pageSize) => {
            pagination.setCurrentPage(page);
            pagination.setPageLimit(pageSize);
          },
        }}
        customToolbar={
          <NodesFilters
            searchQuery={search.searchQuery}
            onSearchChange={search.setSearchQuery}
            nodeTypes={nodeTypes}
            selectedNodeType={
              filters.filters.node_type_id as string | undefined
            }
            onNodeTypeChange={(value) =>
              filters.setFilters((prev) => ({ ...prev, node_type_id: value } as Filters))
            }
          />
        }
      />

      {editModal.isOpen && (
        <NodeFormModal
          isOpen={editModal.isOpen}
          onClose={editModal.close}
          editingNode={editModal.record as NodeRowsWithRelations | null}
          // ** Pass the correct props to the now "dumb" component.**
          onSubmit={crudActions.handleSave}
          isLoading={isMutating}
        />
      )}

      <ConfirmModal
        isOpen={deleteModal.isOpen}
        onConfirm={deleteModal.onConfirm}
        onCancel={deleteModal.onCancel}
        title="Confirm Deletion"
        message={deleteModal.message}
        loading={deleteModal.loading}
        type="danger"
      />
    </div>
  );
};

export default NodesPage;
```

<!-- path: app/dashboard/users/page.tsx -->
```typescript
'use client';

import {
  PageHeader,
  useStandardHeaderActions,
} from '@/components/common/page-header';
import { BulkActions } from '@/components/users/BulkActions';
import { UserCreateModal } from '@/components/users/UserCreateModal';
import { ConfirmModal, ErrorDisplay } from '@/components/common/ui';
import { DataTable } from '@/components/table/DataTable';
import { UserFilters } from '@/components/users/UserFilters';
import UserProfileEditModal from '@/components/users/UserProfileEditModal';
import { UserProfileColumns } from '@/config/table-columns/UsersTableColumns';
import { UserDetailsModal } from '@/config/user-details-config';
import { Row } from '@/hooks/database';
import {
  useAdminGetAllUsersExtended,
  useAdminUserOperations,
  useIsSuperAdmin,
  UserCreateInput,
} from '@/hooks/useAdminUsers';
import {
  DataQueryHookParams,
  DataQueryHookReturn,
  useCrudManager,
} from '@/hooks/useCrudManager';
import { useCallback, useMemo, useState } from 'react';
import { FiUsers } from 'react-icons/fi';
import { toast } from 'sonner';
import { User_profilesUpdateSchema, V_user_profiles_extendedRowSchema } from '@/schemas/zod-schemas';
import { createStandardActions } from '@/components/table/action-helpers';
import { TableAction } from '@/components/table/datatable-types';
import { Json } from '@/types/supabase-types';

// This hook adapts the specific RPC hook to the generic interface required by useCrudManager.
// 1. ADAPTER HOOK: Makes `useAdminGetAllUsersExtended` compatible with `useCrudManager`
const useUsersData = (
  params: DataQueryHookParams
): DataQueryHookReturn<V_user_profiles_extendedRowSchema> => {
  const { currentPage, pageLimit, searchQuery, filters } = params;

  const { data, isLoading, error, refetch } = useAdminGetAllUsersExtended({
    search_query: searchQuery || undefined,
    filter_role: (filters.role as string) || undefined,
    filter_status: (filters.status as string) || undefined,
    page_offset: (currentPage - 1) * pageLimit,
    page_limit: pageLimit,
  });


  return {
    data: (data?.data || []) as V_user_profiles_extendedRowSchema[],
    totalCount: data?.counts?.total || 0,
    activeCount: data?.counts?.active || 0,
    inactiveCount: data?.counts?.inactive || 0,
    isLoading,
    error: (error as Error) || null,
    refetch: () => {
      void refetch();
    },
  };
};
const AdminUsersPage = () => {
  // --- STATE MANAGEMENT (Mimicking useCrudManager) ---
  const [showFilters, setShowFilters] = useState(false);
  const { data: isSuperAdmin } = useIsSuperAdmin();
  const {
    createUser,
    deleteUsers: bulkDelete,
    updateUserRoles: bulkUpdateRole,
    updateUserStatus: bulkUpdateStatus,
    isLoading: isOperationLoading,
  } = useAdminUserOperations();

  // 2. USE THE CRUD MANAGER with the adapter hook and both generic types
  const {
    data: users,
    totalCount,
    isLoading,
    isMutating,
    error,
    refetch,
    pagination,
    search,
    filters,
    editModal,
    viewModal,
    bulkActions,
    deleteModal,
    actions: crudActions,
  } = useCrudManager<'user_profiles', V_user_profiles_extendedRowSchema>({
    tableName: 'user_profiles',
    dataQueryHook: useUsersData,
  });

  const columns = UserProfileColumns(users as V_user_profiles_extendedRowSchema[]);
  const { selectedRowIds, handleClearSelection } = bulkActions;

  const tableActions = useMemo(
    () =>
      createStandardActions<V_user_profiles_extendedRowSchema>({
        onEdit: editModal.openEdit,
        onView: viewModal.open,
        onDelete: crudActions.handleDelete,
        canDelete: (record) => !record.is_super_admin,
      }) as TableAction<"v_user_profiles_extended">[],
    [editModal.openEdit, viewModal.open, crudActions.handleDelete]
  );

  const [isCreateModalOpen, setIsCreateModalOpen] = useState(false);

  const handleCreateUser = async (userData: UserCreateInput) => {
    await createUser.mutateAsync({
      ...userData,
    });
  };

  const handleBulkDelete = useCallback(async () => {
    if (selectedRowIds.length === 0) return;
    if (
      !window.confirm(
        `Are you sure you want to delete ${selectedRowIds.length} selected user(s)?`
      )
    )
      return;

    await bulkDelete.mutateAsync({ user_ids: selectedRowIds });
    handleClearSelection();
  }, [selectedRowIds, bulkDelete, handleClearSelection]);

  const handleBulkUpdateRole = useCallback(
    async (newRole: string) => {
      if (selectedRowIds.length === 0) return;
      await bulkUpdateRole.mutateAsync({
        user_ids: selectedRowIds,
        new_role: newRole,
      });
      handleClearSelection();
    },
    [selectedRowIds, bulkUpdateRole, handleClearSelection]
  );

  const handleBulkUpdateStatus = useCallback(
    async (newStatus: string) => {
      if (selectedRowIds.length === 0) return;
      await bulkUpdateStatus.mutateAsync({
        user_ids: selectedRowIds,
        new_status: newStatus,
      });
      handleClearSelection();
    },
    [selectedRowIds, bulkUpdateStatus, handleClearSelection]
  );

  // --- Define header content using the hook ---
  const headerActions = useStandardHeaderActions<'user_profiles'>({
    data: users as Row<'user_profiles'>[],
    onRefresh: async () => {
      await refetch();
      toast.success('Refreshed successfully!');
    },
    onAddNew: () => setIsCreateModalOpen(true),
    isLoading: isLoading,
    exportConfig: { tableName: 'user_profiles' },
  });

  const headerStats = [
    { value: totalCount, label: 'Total Users' },
    {
      value: users.filter((r) => r.status).length,
      label: 'Active',
      color: 'success' as const,
    },
    {
      value: users.filter((r) => !r.status).length,
      label: 'Inactive',
      color: 'danger' as const,
    },
  ];

  if (error) {
    return (
      <ErrorDisplay
        error={error.message}
        actions={[
          {
            label: 'Retry',
            onClick: refetch,
            variant: 'primary',
          },
        ]}
      />
    );
  }

  return (
    <div className="p-3 sm:p-4 md:p-6 lg:p-8 space-y-4 sm:space-y-6">
      <PageHeader
        title="User Management"
        description="Manage network users and their related information."
        icon={<FiUsers />}
        stats={headerStats}
        actions={headerActions} // <-- Pass the generated actions
        isLoading={isLoading}
      />
      <BulkActions
        selectedCount={bulkActions.selectedCount}
        isSuperAdmin={!!isSuperAdmin}
        isOperationLoading={isMutating}
        onBulkDelete={handleBulkDelete}
        onBulkUpdateRole={handleBulkUpdateRole}
        onBulkUpdateStatus={handleBulkUpdateStatus}
        onClearSelection={bulkActions.handleClearSelection}
      />
      <DataTable
        tableName="v_user_profiles_extended"
        data={users.map(user => ({
          ...user,
          first_name: user.first_name || '',
          last_name: user.last_name || '',
          id: user.id || '',
          address: user.address as Json | null
        }))}
        columns={columns}
        loading={isLoading || isOperationLoading}
        actions={tableActions}
        selectable
        onRowSelect={(rows) => {
          // Filter out any rows where id is null
          const validRows = rows.filter(
            (row): row is V_user_profiles_extendedRowSchema & { id: string } => row.id !== null
          );
          bulkActions.handleRowSelect(validRows);
        }}
        searchable={false}
        filterable={false}
        pagination={{
          current: pagination.currentPage,
          pageSize: pagination.pageLimit,
          total: totalCount,
          showSizeChanger: true,
          onChange: (page, pageSize) => {
            pagination.setCurrentPage(page);
            pagination.setPageLimit(pageSize);
          },
        }}
        customToolbar={
          <UserFilters
            searchQuery={search.searchQuery}
            onSearchChange={search.setSearchQuery}
            roleFilter={(filters.filters.role as string) || ''}
            onRoleFilterChange={(value) =>
              filters.setFilters((prev) => ({ ...prev, role: value }))
            }
            statusFilter={(filters.filters.status as string) || ''}
            onStatusFilterChange={(value) =>
              filters.setFilters((prev) => ({ ...prev, status: value }))
            }
            emailVerificationFilter={''} // This filter is not implemented in the hook yet
            onEmailVerificationFilterChange={() => {}}
            showFilters={showFilters}
            onToggleFilters={() => setShowFilters(!showFilters)}
            onClearFilters={() => {
              search.setSearchQuery('');
              filters.setFilters((prev) => ({ ...prev, role: '', status: '' }));
            }}
          />
        }
      />
      <UserProfileEditModal
        isOpen={editModal.isOpen}
        user={editModal.record as User_profilesUpdateSchema}
        onClose={editModal.close}
        onSave={() => {
          refetch();
        }}
      />

      <UserDetailsModal
        isOpen={viewModal.isOpen}
        user={viewModal.record as V_user_profiles_extendedRowSchema}
        onClose={viewModal.close}
      />
      <ConfirmModal
        isOpen={deleteModal.isOpen}
        onConfirm={deleteModal.onConfirm}
        onCancel={deleteModal.onCancel}
        title="Confirm Deletion"
        message={deleteModal.message}
        loading={deleteModal.loading}
        type="danger"
      />

      <UserCreateModal
        isOpen={isCreateModalOpen}
        onClose={() => setIsCreateModalOpen(false)}
        onCreate={handleCreateUser}
        isLoading={createUser.isPending}
      />
    </div>
  );
};

export default AdminUsersPage;

```

<!-- path: app/layout.tsx -->
```typescript
import type { Metadata, Viewport } from "next";
import localFont from "next/font/local";
import "./globals.css";
import "react-datepicker/dist/react-datepicker.css";
import PolyfillLoader from "@/components/polyfills/PolyfillLoader";
import { ToastProvider } from "@/providers/ToastProvider";
import ThemeProvider from "@/providers/ThemeProvider";

const defaultUrl = process.env.VERCEL_URL ? `https://${process.env.VERCEL_URL}` : "http://localhost:3000";

// Load the main body font (Inter)
const fontSans = localFont({
  src: "../public/fonts/Inter.woff2",
  display: "swap",
  variable: "--font-sans", // We'll use this for Tailwind's 'sans' class
  preload: true,
  fallback: ["system-ui", "arial"],
});

// Load the secondary heading font (Montserrat)
const fontHeading = localFont({
  src: "../public/fonts/Montserrat.woff2",
  display: "swap",
  variable: "--font-heading", // We'll use this for a custom 'heading' class
  preload: true,
  fallback: ["system-ui", "times new roman"],
});

export const viewport: Viewport = {
  width: "device-width",
  initialScale: 1,
  maximumScale: 1,
  userScalable: false,
  themeColor: [
    { media: "(prefers-color-scheme: light)", color: "cyan" },
    { media: "(prefers-color-scheme: dark)", color: "black" },
  ],
};

export const metadata: Metadata = {
  metadataBase: new URL(defaultUrl),
  applicationName: "Harinavi Transmission Maintenance",
  title: {
    default: "Harinavi Transmission Maintenance",
    template: "%s - PWA App",
  },
  description: "We provide reliable telecom transmission maintenance services.",
  manifest: "/manifest.json",
  appleWebApp: {
    capable: true,
    statusBarStyle: "default",
    title: "Harinavi Transmission Maintenance",
  },
  formatDetection: {
    telephone: false,
  },
  icons: {
    shortcut: "/favicon.ico",
    apple: [{ url: "/icon-192x192.png", sizes: "192x192" }],
    icon: "/favicon.ico",
  },
};

export default function RootLayout({
  children,
}: Readonly<{
  children: React.ReactNode;
}>) {
  return (
    <html lang='en' suppressHydrationWarning>
      <body className={`${fontSans.variable} ${fontHeading.variable} antialiased`}>
        {/* ** Inline script to prevent theme flashing** */}
        <script
          dangerouslySetInnerHTML={{
            __html: `
              (function() {
                try {
                  let theme = 'system'; // Default to system
                  const storedValue = localStorage.getItem('theme-storage');

                  if (storedValue) {
                    // Try to parse as JSON (new format)
                    try {
                      const parsed = JSON.parse(storedValue);
                      if (parsed && parsed.state && typeof parsed.state.theme === 'string') {
                        theme = parsed.state.theme;
                      }
                    } catch (e) {
                      // If parsing fails, it might be the old raw string format
                      if (typeof storedValue === 'string' && ['light', 'dark', 'system'].includes(storedValue)) {
                        theme = storedValue;
                      }
                    }
                  }
                  
                  const isDark = theme === 'dark' || (theme === 'system' && window.matchMedia('(prefers-color-scheme: dark)').matches);
                  if (isDark) {
                    document.documentElement.classList.add('dark');
                  }
                } catch (e) {
                  console.error('Failed to apply initial theme', e);
                }
              })();
            `,
          }}
        />
        <ThemeProvider>
          <ToastProvider>{children}</ToastProvider>
        </ThemeProvider>
        <PolyfillLoader />
      </body>
    </html>
  );
}

```

<!-- path: app/onboarding/page.tsx -->
```typescript
"use client";
import Link from "next/link";
import OnboardingFormEnhanced from "./onboarding-form-enhanced";
import { useAuth } from "@/hooks/useAuth";

export default function OnboardingPage() {
  const { logout } = useAuth();
  

  return (
    <div className="min-h-screen bg-gray-50 dark:bg-gray-900 flex flex-col">
      {/* Header */}
      <div className="px-6 py-4 border-b border-gray-200 dark:border-gray-700 flex justify-between items-center bg-white dark:bg-gray-800">
        <h1 className="text-2xl font-bold text-gray-900 dark:text-white">Update Your Profile</h1>
        <div className="flex items-center gap-4">
          <Link
            href="/dashboard"
            className="text-blue-600 dark:text-blue-400 hover:underline text-sm font-medium"
          >
            Go to Dashboard
          </Link>
          <form onSubmit={logout}>
            <button
              type="submit"
              className="bg-red-600 hover:bg-red-700 dark:hover:bg-red-800 text-white px-4 py-2 rounded-md text-sm font-medium"
            >
              Sign Out
            </button>
          </form>
        </div>
      </div>

      {/* Centered Form */}
      <div className="flex flex-1 items-center justify-center p-4">
        <div className="w-full bg-white dark:bg-gray-800 shadow-lg rounded-lg p-6 border border-gray-200 dark:border-gray-700">
          <OnboardingFormEnhanced />
        </div>
      </div>
    </div>
  );
}
```

<!-- path: app/onboarding/layout.tsx -->
```typescript
// app/onboarding/layout.tsx
"use client"

import { Protected } from "@/components/auth/Protected";
import { QueryProvider } from "@/providers/QueryProvider";


export default function AccountLayout({ children }: { children: React.ReactNode }) {
    
  return (
    <QueryProvider><Protected>{children}</Protected></QueryProvider>
  );
}

```

<!-- path: app/onboarding/onboarding-form-enhanced.tsx -->
```typescript
// path: app/onboarding/onboarding-form-enhanced.tsx

"use client";

import { useEffect } from "react";
import { useAuthStore } from "@/stores/authStore";
import Image from "next/image";
import { createClient } from "@/utils/supabase/client";
import { useTableUpdate } from "@/hooks/database";
import { toast } from "sonner";
import { useForm } from "react-hook-form";
import { zodResolver } from "@hookform/resolvers/zod";
import { User_profilesUpdateSchema, user_profilesUpdateSchema } from "@/schemas/zod-schemas";

import { useGetMyUserDetails } from "@/hooks/useAdminUsers";
import { z } from "zod";
import { Input, Label } from "@/components/common/ui";

// NEW: Define specific shapes for nested JSONB fields for robust form validation.
const addressSchema = z
  .object({
    street: z.string().optional().nullable(),
    city: z.string().optional().nullable(),
    state: z.string().optional().nullable(),
    zip_code: z.string().optional().nullable(),
    country: z.string().optional().nullable(),
  })
  .nullable();

const preferencesSchema = z
  .object({
    language: z.string().optional().nullable(),
    theme: z.string().optional().nullable(),
    // ADDED: Include our new flags in the schema
    needsOnboarding: z.boolean().optional().nullable(),
    showOnboardingPrompt: z.boolean().optional().nullable(),
  })
  .nullable();

// NEW: Extend the base schema to include our specific nested shapes.
const onboardingFormSchema = user_profilesUpdateSchema
  .pick({
    first_name: true,
    last_name: true,
    avatar_url: true,
    date_of_birth: true,
    designation: true,
    phone_number: true,
  })
  .extend({
    address: addressSchema,
    preferences: preferencesSchema,
  });

type OnboardingFormData = z.infer<typeof onboardingFormSchema>;

// Helper to safely cast unknown to a record or return an empty object
const toObject = (data: unknown): Record<string, unknown> => {
  if (data && typeof data === "object") {
    return data as Record<string, unknown>;
  }
  return {};
};

export default function OnboardingFormEnhanced() {
  const user = useAuthStore((state) => state.user);
  const supabase = createClient();

  const { data: profile, isLoading: isProfileLoading, error: profileError, refetch } = useGetMyUserDetails();

  const {
    register,
    handleSubmit,
    reset,
    formState: { errors, isDirty, dirtyFields },
    watch,
  } = useForm<OnboardingFormData>({
    resolver: zodResolver(onboardingFormSchema),
  });

  const { mutate: updateProfile, isPending: isUpdatePending } = useTableUpdate(supabase, "user_profiles", {
    onSuccess: (data) => {
      toast.success("Profile updated successfully!");
      refetch();
      reset(data[0] as OnboardingFormData);
    },
    onError: (error) => {
      toast.error(`Update failed: ${error.message}`);
    },
  });

  const isLoading = isProfileLoading || isUpdatePending;
  const avatarUrl = watch("avatar_url");

  useEffect(() => {
    if (profile) {
      reset({
        first_name: profile.first_name === 'Placeholder' ? '' : profile.first_name || "",
        last_name: profile.last_name === 'User' ? '' : profile.last_name || "",
        avatar_url: profile.avatar_url,
        date_of_birth: profile.date_of_birth,
        designation: profile.designation,
        phone_number: profile.phone_number,
        address: toObject(profile.address),
        preferences: toObject(profile.preferences),
      });
    } else if (!isProfileLoading) {
      reset({
        first_name: "",
        last_name: "",
        avatar_url: null,
        date_of_birth: null,
        designation: null,
        phone_number: null,
        address: {},
        preferences: {},
      });
    }
  }, [profile, isProfileLoading, reset]);

  const onSubmit = (data: OnboardingFormData) => {
    if (!isDirty || !user?.id) {
      toast.info("No changes to save.");
      return;
    }

    const updates: Partial<User_profilesUpdateSchema> = {};
    for (const key in dirtyFields) {
      const fieldName = key as keyof OnboardingFormData;
      // Skip preferences, we will handle it separately
      if (fieldName !== 'preferences') {
        updates[fieldName] = data[fieldName];
      }
    }

    // ** Intelligently merge preferences**
    const newPreferences = {
      ...toObject(profile?.preferences), // Start with existing preferences
      ...toObject(data.preferences),      // Overwrite with any form changes
      needsOnboarding: false,            // Explicitly set onboarding to false
    };
    updates.preferences = newPreferences;

    if (Object.keys(updates).length > 0) {
      updateProfile({ id: user.id, data: updates });
    }
  };

  if (isProfileLoading) {
    return (
      <div className='animate-pulse space-y-4'>
        <div className='h-4 bg-gray-200 dark:bg-gray-700 rounded w-1/4'></div>
        <div className='space-y-3'>
          <div className='h-10 bg-gray-200 dark:bg-gray-700 rounded'></div>
          <div className='h-10 bg-gray-200 dark:bg-gray-700 rounded'></div>
          <div className='h-10 bg-gray-200 dark:bg-gray-700 rounded'></div>
        </div>
      </div>
    );
  }

  if (profileError) {
    return (
      <div className='p-4 rounded-md bg-red-100 dark:bg-red-900/30 text-red-700 dark:text-red-300'>
        <h3 className='font-medium'>Error loading profile</h3>
        <p className='text-sm mt-1'>{profileError.message}</p>
        <button onClick={() => window.location.reload()} className='mt-3 text-sm underline hover:no-underline text-red-600 dark:text-red-400'>
          Try again
        </button>
      </div>
    );
  }

  return (
    <form onSubmit={handleSubmit(onSubmit)} className='space-y-6 w-full max-w-3xl mx-auto'>
      <div className='flex items-center gap-4'>
        <Image src={avatarUrl || "/default-avatar.png"} alt='Profile' width={64} height={64} className='w-16 h-16 rounded-full object-cover bg-gray-200' />
        <div className='flex-1'>
          <Label htmlFor='avatar_url'>Avatar URL</Label>
          <Input id='avatar_url' {...register("avatar_url")} placeholder='https://example.com/avatar.jpg' className='mt-1' />
          {errors.avatar_url && <p className='text-red-500 text-xs mt-1'>{errors.avatar_url.message}</p>}
        </div>
      </div>

      <div className='grid grid-cols-1 gap-6 sm:grid-cols-2'>
        <div>
          <Label htmlFor='email'>Email</Label>
          <Input id='email' type='email' value={user?.email || ""} disabled className='mt-1 bg-gray-50 dark:bg-gray-700 text-gray-500' />
        </div>
        <div>
          <Label htmlFor='phone_number'>Phone Number</Label>
          <Input id='phone_number' type='tel' {...register("phone_number")} placeholder='+1 (555) 123-4567' className='mt-1' />
          {errors.phone_number && <p className='text-red-500 text-xs mt-1'>{errors.phone_number.message}</p>}
        </div>
        <div>
          <Label htmlFor='first_name'>
            First Name <span className='text-red-500'>*</span>
          </Label>
          <Input id='first_name' type='text' {...register("first_name")} className='mt-1' />
          {errors.first_name && <p className='text-red-500 text-xs mt-1'>{errors.first_name.message}</p>}
        </div>
        <div>
          <Label htmlFor='last_name'>
            Last Name <span className='text-red-500'>*</span>
          </Label>
          <Input id='last_name' type='text' {...register("last_name")} className='mt-1' />
          {errors.last_name && <p className='text-red-500 text-xs mt-1'>{errors.last_name.message}</p>}
        </div>
      </div>

      <div className='space-y-4 border-t border-gray-200 dark:border-gray-700 pt-6'>
        <h3 className='text-md font-medium text-gray-700 dark:text-gray-300'>Address Information</h3>
        <div className='grid grid-cols-1 gap-4 sm:grid-cols-2'>
          <div className='sm:col-span-2'>
            <Label htmlFor='address_street'>Street Address</Label>
            <Input id='address_street' {...register("address.street")} placeholder='123 Main St' className='mt-1' />
          </div>
          <div>
            <Label htmlFor='address_city'>City</Label>
            <Input id='address_city' {...register("address.city")} placeholder='New York' className='mt-1' />
          </div>
          <div>
            <Label htmlFor='address_state'>State/Province</Label>
            <Input id='address_state' {...register("address.state")} placeholder='NY' className='mt-1' />
          </div>
          <div>
            <Label htmlFor='address_zip_code'>Zip Code</Label>
            <Input id='address_zip_code' {...register("address.zip_code")} placeholder='12345' className='mt-1' />
          </div>
          <div>
            <Label htmlFor='address_country'>Country</Label>
            <Input id='address_country' {...register("address.country")} placeholder='USA' className='mt-1' />
          </div>
        </div>
      </div>

      <div className='space-y-4 border-t border-gray-200 dark:border-gray-700 pt-6'>
        <h3 className='text-md font-medium text-gray-700 dark:text-gray-300'>Preferences</h3>
        <div className='grid grid-cols-1 gap-4 sm:grid-cols-2'>
          <div>
            <Label htmlFor='preferences_language'>Language</Label>
            <Input id='preferences_language' {...register("preferences.language")} placeholder='English' className='mt-1' />
          </div>
          <div>
            <Label htmlFor='preferences_theme'>Theme</Label>
            <Input id='preferences_theme' {...register("preferences.theme")} placeholder='Light' className='mt-1' />
          </div>
        </div>
      </div>

      <div className='flex justify-end items-center pt-4 border-t border-gray-200 dark:border-gray-700'>
        <div className='flex space-x-3'>
          <button
            type='button'
            onClick={() => reset()}
            disabled={!isDirty || isLoading}
            className='px-4 py-2 text-sm font-medium text-gray-700 dark:text-gray-300 bg-white dark:bg-gray-700 border border-gray-300 dark:border-gray-600 rounded-md hover:bg-gray-50 dark:hover:bg-gray-600 disabled:opacity-50'>
            Reset
          </button>
          <button type='submit' disabled={!isDirty || isLoading} className='px-4 py-2 text-sm font-medium text-white bg-indigo-600 border border-transparent rounded-md hover:bg-indigo-700 disabled:opacity-50 flex items-center'>
            {isLoading && (
              <svg className='animate-spin -ml-1 mr-2 h-4 w-4 text-white' fill='none' viewBox='0 0 24 24'>
                <circle className='opacity-25' cx='12' cy='12' r='10' stroke='currentColor' strokeWidth='4' />
                <path className='opacity-75' fill='currentColor' d='M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z' />
              </svg>
            )}
            {isLoading ? "Updating..." : "Update Profile"}
          </button>
        </div>
      </div>
    </form>
  );
}

```

<!-- path: app/manifest.ts -->
```typescript
import type { MetadataRoute } from "next";
 
export default function manifest(): MetadataRoute.Manifest {
  return {
    name: "Harinavi Transmission Maintenance",
    short_name: "Harinavi Database App",
    description:
      "Complete records management system for Harinavi Transmission maintenance",
    start_url: "/",
    display: "standalone",
    background_color: "#ffffff",
    theme_color: "#000000",
    orientation: "portrait-primary",
    icons: [
      {
        src: "/icon-192x192.png",
        sizes: "192x192",
        type: "image/png",
        purpose: "maskable",
      },
      {
        src: "/icon-256x256.png",
        sizes: "256x256",
        type: "image/png",
      },
      {
        src: "/icon-384x384.png",
        sizes: "384x384",
        type: "image/png",
      },
      {
        src: "/icon-512x512.png",
        sizes: "512x512",
        type: "image/png",
        purpose: "maskable",
      },
    ],
    categories: ["productivity", "business"],
    screenshots: [
      {
        src: "/screenshot-wide.png",
        sizes: "1280x720",
        type: "image/png",
        form_factor: "wide",
      },
      {
        src: "/screenshot-narrow.png",
        sizes: "750x1334",
        type: "image/png",
        form_factor: "narrow",
      },
    ],
  };
}
```

<!-- path: app/bsnl/page.tsx -->
```typescript
// path: app/bsnl/page.tsx
"use client"

import React, { useState, useCallback, useMemo } from 'react';
import 'leaflet/dist/leaflet.css';
import { Network, Settings, RefreshCw, Loader2 } from 'lucide-react';
import { BsnlCable, BsnlSystem, AllocationSaveData } from '@/components/bsnl/types';
import { AdvancedSearchBar } from '@/components/bsnl/AdvancedSearchBar';
import { OptimizedNetworkMap } from '@/components/bsnl/OptimizedNetworkMap';
import { PaginatedTable } from '@/components/bsnl/PaginatedTable';
import AdvancedAllocationModal from '@/components/bsnl/NewAllocationModal';
import { useBsnlDashboardData } from '@/components/bsnl/useBsnlDashboardData';
import { PageSpinner, ErrorDisplay } from '@/components/common/ui';
import { toast } from 'sonner';
import { DashboardStatsGrid } from '@/components/bsnl/DashboardStatsGrid';
import { BsnlSearchFilters, bsnlSearchFiltersSchema } from '@/schemas/custom-schemas';

type BsnlDashboardTab = 'overview' | 'systems' | 'allocations';

export default function ScalableFiberNetworkDashboard() {
  const [activeTab, setActiveTab] = useState<BsnlDashboardTab>('systems');
  const [isAllocationModalOpen, setIsAllocationModalOpen] = useState(false);
  
  const [filters, setFilters] = useState<BsnlSearchFilters>(
    bsnlSearchFiltersSchema.parse({
      query: '',
      status: [],
      type: [],
      region: [],
      nodeType: [],
      priority: []
    })
  );

  const { data, isLoading, isError, error, refetchAll, isFetching } = useBsnlDashboardData(filters);

  const [selectedSystem, setSelectedSystem] = useState<BsnlSystem | null>(null);
  const [selectedCable, setSelectedCable] = useState<BsnlCable | null>(null);

  const handleSaveAllocation = (allocationData: AllocationSaveData) => {
    // console.log("Allocation Saved:", allocationData);
    toast.info("Allocation feature is a work in progress.");
  };

  const clearFilters = useCallback(() => {
    setFilters({ query: '', status: [], type: [], region: [], nodeType: [], priority: [] });
  }, []);
  
  const handleRefresh = async () => {
    toast.info("Refreshing network data...");
    await refetchAll();
    toast.success("Dashboard data refreshed.");
  };

  const { typeOptions, regionOptions, nodeTypeOptions } = useMemo(() => {
    const allSystemTypes = [...new Set(data.systems.map(s => s.system_type_name).filter(Boolean))];
    const allCableTypes = [...new Set(data.ofcCables.map(c => c.ofc_type_name).filter(Boolean))];
    const uniqueTypes = [...new Set([...allSystemTypes, ...allCableTypes])].sort();
    const allRegions = [...new Set(data.nodes.map(n => n.maintenance_area_name).filter(Boolean))].sort();
    const allNodeTypes = [...new Set(data.nodes.map(n => n.node_type_name).filter(Boolean))].sort();
    
    return { 
      typeOptions: uniqueTypes as string[], 
      regionOptions: allRegions as string[],
      nodeTypeOptions: allNodeTypes as string[],
    };
  }, [data]);

  const systemColumns = [
    { key: 'name', label: 'System Name', render: (system: BsnlSystem) => (<div><div className="font-medium text-gray-900 dark:text-white">{system.system_name}</div><div className="text-sm text-gray-500 dark:text-gray-400">{system.system_type_name}</div></div>) },
    { key: 'status', label: 'Status', render: (system: BsnlSystem) => (<span className={`px-2 py-1 text-xs rounded-full ${system.status ? 'bg-green-100 text-green-800 dark:bg-green-900/30 dark:text-green-300' : 'bg-red-100 text-red-800 dark:bg-red-900/30 dark:text-red-300'}`}>{system.status ? 'Active' : 'Inactive'}</span>) },
    { key: 'node', label: 'Node', render: (system: BsnlSystem) => system.node_name },
    { key: 'ip', label: 'IP Address', render: (system: BsnlSystem) => <code className="text-xs">{system.ip_address as string}</code> },
    { key: 'region', label: 'Region', render: (system: BsnlSystem) => system.system_maintenance_terminal_name }
  ];

  const cableColumns = [
    { key: 'name', label: 'Route Name', render: (cable: BsnlCable) => (<div><div className="font-medium text-gray-900 dark:text-white">{cable.route_name}</div><div className="text-sm text-gray-500 dark:text-gray-400">{cable.asset_no}</div></div>) },
    { key: 'status', label: 'Status', render: (cable: BsnlCable) => (<span className={`px-2 py-1 text-xs rounded-full ${cable.status ? 'bg-green-100 text-green-800 dark:bg-green-900/30 dark:text-green-300' : 'bg-red-100 text-red-800 dark:bg-red-900/30 dark:text-red-300'}`}>{cable.status ? 'Active' : 'Inactive'}</span>) },
    { key: 'capacity', label: 'Capacity', render: (cable: BsnlCable) => `${cable.capacity}F / ${cable.current_rkm?.toFixed(1)}km` },
    { key: 'endpoints', label: 'Endpoints', render: (cable: BsnlCable) => <div className="text-sm">{cable.sn_name} → {cable.en_name}</div> },
    { key: 'owner', label: 'Owner', render: (cable: BsnlCable) => cable.ofc_owner_name }
  ];
  
  // Only show full page spinner on initial load (no data yet)
  const isInitialLoad = isLoading && data.nodes.length === 0 && data.systems.length === 0;
  
  if (isInitialLoad) return <PageSpinner text="Loading Network Dashboard Data..." />;
  if (isError) return <ErrorDisplay error={error?.message || "An unknown error occurred."} />;

  return (
    <div className="min-h-screen bg-gray-50 dark:bg-gray-900">
      <header className="bg-white dark:bg-gray-800 shadow-sm border-b border-gray-200 dark:border-gray-700">
        <div className="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8">
          <div className="flex justify-between items-center h-16">
            <div className="flex items-center">
              <Network className="h-8 w-8 text-blue-600 mr-3" />
              <div>
                <h1 className="text-2xl font-bold text-gray-900 dark:text-white">BSNL Fiber Network Dashboard</h1>
                <p className="text-sm text-gray-500 dark:text-gray-400">
                  {data.systems.length.toLocaleString()} Systems | {data.ofcCables.length.toLocaleString()} Cables
                  {isFetching && <span className="ml-2 inline-flex items-center"><Loader2 className="h-3 w-3 animate-spin" /></span>}
                </p>
              </div>
            </div>
            <div className="flex items-center space-x-2">
              <button 
                onClick={handleRefresh} 
                disabled={isFetching}
                className="p-2 text-gray-500 dark:text-gray-400 hover:text-gray-700 dark:hover:text-white disabled:opacity-50 disabled:cursor-not-allowed"
              >
                <RefreshCw className={`h-5 w-5 ${isFetching ? 'animate-spin' : ''}`} />
              </button>
              <button className="p-2 text-gray-500 dark:text-gray-400 hover:text-gray-700 dark:hover:text-white">
                <Settings className="h-5 w-5" />
              </button>
            </div>
          </div>
        </div>
      </header>

      <div className="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-6">
        <AdvancedSearchBar 
          filters={filters} 
          onFiltersChange={setFilters} 
          onClear={clearFilters}
          typeOptions={typeOptions}
          regionOptions={regionOptions}
          nodeTypeOptions={nodeTypeOptions}
        />
        
        <div className="mb-6 border-b border-gray-200 dark:border-gray-700">
          <nav className="flex space-x-8 -mb-px">
            {(['overview', 'systems', 'allocations'] as BsnlDashboardTab[]).map((tab) => (
              <button 
                key={tab} 
                onClick={() => setActiveTab(tab)} 
                className={`py-4 px-1 border-b-2 font-medium text-sm capitalize ${activeTab === tab ? 'border-blue-500 text-blue-600 dark:text-blue-400' : 'border-transparent text-gray-500 hover:text-gray-700 dark:hover:text-gray-300 hover:border-gray-300 dark:hover:border-gray-600'}`}
              >
                {tab}
              </button>
            ))}
          </nav>
        </div>
        
        {/* Overlay loading indicator for subsequent fetches */}
        <div className="relative">
          {isFetching && !isInitialLoad && (
            <div className="absolute inset-0 bg-white/50 dark:bg-gray-900/50 backdrop-blur-sm z-10 flex items-center justify-center rounded-lg">
              <div className="flex items-center space-x-2 bg-white dark:bg-gray-800 px-4 py-2 rounded-lg shadow-lg border border-gray-200 dark:border-gray-700">
                <Loader2 className="h-4 w-4 animate-spin text-blue-600" />
                <span className="text-sm font-medium text-gray-700 dark:text-gray-300">Updating results...</span>
              </div>
            </div>
          )}
          
          {activeTab === 'overview' && (
            <div className="space-y-6">
              <DashboardStatsGrid />
              <div className="h-[60vh] bg-white dark:bg-gray-800 rounded-lg shadow p-4">
                <OptimizedNetworkMap 
                  nodes={data.nodes} 
                  cables={data.ofcCables} 
                  selectedSystem={selectedSystem} 
                  visibleLayers={{ nodes: true, cables: true, systems: true }} 
                />
              </div>
            </div>
          )}

          {activeTab === 'systems' && (
            <div className="bg-white dark:bg-gray-800 rounded-lg shadow-md border dark:border-gray-700">
              <PaginatedTable 
                data={data.systems} 
                columns={systemColumns} 
                onItemClick={setSelectedSystem} 
                pageSize={50} 
              />
            </div>
          )}

          {activeTab === 'allocations' && (
            <div className="bg-white dark:bg-gray-800 rounded-lg shadow-md border dark:border-gray-700">
              <PaginatedTable 
                data={data.ofcCables} 
                columns={cableColumns} 
                onItemClick={setSelectedCable} 
                pageSize={25} 
              />
            </div>
          )}
        </div>
      </div>

      <AdvancedAllocationModal
        isOpen={isAllocationModalOpen}
        onClose={() => setIsAllocationModalOpen(false)}
        onSave={handleSaveAllocation}
        systems={data.systems}
        nodes={data.nodes}
        cables={data.ofcCables}
      />
    </div>
  );
}
```

<!-- path: app/globals.css -->
```css
@import "tailwindcss";

@custom-variant dark (&:where([class=dark], [class=dark] *));

:root {
  --background: #ffffff;
  --foreground: #171717;
}

@theme inline {
  --color-background: var(--background);
  --color-foreground: var(--foreground);
  --font-sans: var(--font-geist-sans);
  --font-mono: var(--font-geist-mono);
}


/* Smooth transitions for interactive elements */
button,
a {
  transition: opacity 0.15s ease-in-out, transform 0.15s ease-in-out;
}

/* Loading state transitions */
[data-loading='true'] {
  opacity: 0.8;
  transform: translateY(1px);
}

.dark {
  --background: #0a0a0a;
  --foreground: #ededed;
  input[type="date"]::-webkit-calendar-picker-indicator {
    filter: invert(1);
  }
}

body {
  background: var(--background);
  color: var(--foreground);
  font-family: var(--font-sans);
  overflow-x: hidden;
}

/* Ensure react-datepicker popper appears above modals/overlays */
.react-datepicker-popper {
  z-index: 9999 !important;
}
```

<!-- path: middleware.ts -->
```typescript
import { type NextRequest } from "next/server";
import { updateSession } from "@/utils/supabase/middleware";

export async function middleware(request: NextRequest) {
  // update user's auth session
  return await updateSession(request);
}

export const config = {
  matcher: [
    /*
     * Match all request paths except the landing page `/`, `/login`, `/signup` and for the ones starting with:
     * - _next/static (static files)
     * - _next/image (image optimization files)
     * - favicon.ico (favicon file)
     * Feel free to modify this pattern to include more paths.
     */
    "/((?!_next/static|_next/image|favicon\\.ico|.*\\.(?:svg|png|jpg|jpeg|gif|webp)$|^$|^login$|^signup$).*)",
  ],
};

```

<!-- path: package.json -->
```json
{
  "name": "hnvtx",
  "version": "0.1.0",
  "private": true,
  "scripts": {
    "dev": "next dev --turbopack",
    "cleandev": "rm -rf .next node_modules && npm install && next dev --turbopack",
    "build": "next build",
    "start": "next start",
    "lint": "eslint .",
    "lint:fix": "eslint --fix",
    "gitpush": "git add . && git commit -m \"$(date +'%Y-%m-%d %H:%M:%S')\" && git push",
    "find-unused": "node scripts/find-unused-files.js",
    "supabase": "supabase",
    "gen:types": "supabase gen types typescript --project-id mnnttnrgafkymejqpjhw --schema public,auth > types/supabase-types.ts",
    "gen:flattened": "tsx scripts/generate-flattened-types.ts",
    "gen:zod": "tsx scripts/generate-zod-schemas.ts",
    "gen:all": "npm run gen:types && npm run gen:flattened && npm run gen:zod",
    "debug:script": "dotenv -e .env node scripts/debug-connection.js",
    "push:migrations": "dotenv -e .env node scripts/push-sql.js data/migrations/",
    "push:seeds": "dotenv -e .env node scripts/push-sql.js data/seeds/",
    "push:setup": "dotenv -e .env node scripts/push-sql.js data/migrations/00_setup/",
    "push:users": "dotenv -e .env node scripts/push-sql.js data/migrations/01_user_management/",
    "push:core": "dotenv -e .env node scripts/push-sql.js data/migrations/02_core_infrastructure/",
    "push:ofc": "dotenv -e .env node scripts/push-sql.js data/migrations/04_advanced_ofc/",
    "push:systems": "dotenv -e .env node scripts/push-sql.js data/migrations/03_network_systems/",
    "push:audit": "dotenv -e .env node scripts/push-sql.js data/migrations/05_auditing/",
    "push:util": "dotenv -e .env node scripts/push-sql.js data/migrations/06_utilities/",
    "push:final": "dotenv -e .env node scripts/push-sql.js data/migrations/99_finalization/",
    "push:sql": "dotenv -e .env node scripts/push-sql.js"
  },
  "dependencies": {
    "@dnd-kit/core": "^6.3.1",
    "@dnd-kit/sortable": "^10.0.0",
    "@dnd-kit/utilities": "^3.2.2",
    "@hookform/resolvers": "^5.2.1",
    "@radix-ui/react-accordion": "^1.2.12",
    "@radix-ui/react-scroll-area": "^1.2.10",
    "@radix-ui/react-select": "^2.2.6",
    "@radix-ui/react-separator": "^1.1.7",
    "@radix-ui/react-tabs": "^1.1.13",
    "@supabase/ssr": "^0.6.1",
    "@supabase/supabase-js": "^2.56.0",
    "@tanstack/react-query": "^5.85.5",
    "@tanstack/react-query-devtools": "^5.85.1",
    "@types/bcrypt": "^6.0.0",
    "@types/pg": "^8.15.5",
    "@uppy/core": "^5.0.1",
    "@uppy/dashboard": "^5.0.1",
    "@uppy/drag-drop": "^5.0.1",
    "@uppy/react": "^5.0.2",
    "@uppy/webcam": "^5.0.0",
    "@uppy/xhr-upload": "^5.0.0",
    "bcrypt": "^6.0.0",
    "class-variance-authority": "^0.7.1",
    "clsx": "^2.1.1",
    "core-js": "^3.45.0",
    "exceljs": "^4.4.0",
    "framer-motion": "^12.23.12",
    "intersection-observer": "^0.12.2",
    "lodash.isequal": "^4.5.0",
    "lucide-react": "^0.541.0",
    "next": "^15.4.4",
    "papaparse": "^5.5.3",
    "pg": "^8.16.3",
    "react": "^19.1.0",
    "react-datepicker": "^8.7.0",
    "react-dom": "^19.1.0",
    "react-hook-form": "^7.62.0",
    "react-icons": "^5.5.0",
    "react-leaflet": "^5.0.0",
    "react-select": "^5.10.2",
    "regenerator-runtime": "^0.14.1",
    "sonner": "^2.0.7",
    "tailwind-merge": "^3.3.1",
    "url-polyfill": "^1.1.13",
    "use-debounce": "^10.0.5",
    "web-push": "^3.6.7",
    "whatwg-fetch": "^3.6.20",
    "xlsx": "^0.18.5",
    "zod": "^4.1.5",
    "zustand": "^5.0.7"
  },
  "devDependencies": {
    "@eslint/eslintrc": "^3.3.1",
    "@tailwindcss/postcss": "^4.1.11",
    "@tanstack/eslint-plugin-query": "^5.83.1",
    "@types/estree": "^1.0.8",
    "@types/json-schema": "^7.0.15",
    "@types/leaflet": "^1.9.20",
    "@types/lodash": "^4.17.20",
    "@types/lodash.isequal": "^4.5.8",
    "@types/node": "^20.19.17",
    "@types/papaparse": "^5.3.16",
    "@types/prismjs": "^1.26.5",
    "@types/react": "^19.1.10",
    "@types/react-dom": "^19.1.7",
    "@types/uuid": "^10.0.0",
    "@types/web-push": "^3.6.4",
    "dotenv-cli": "^10.0.0",
    "eslint": "^9.33.0",
    "eslint-config-next": "^15.4.4",
    "eslint-formatter-compact": "^8.40.0",
    "prism-react-renderer": "^2.4.1",
    "supabase": "^2.45.5",
    "tailwindcss": "^4.1.11",
    "tsx": "^4.20.5",
    "tw-animate-css": "^1.3.7",
    "typescript": "^5.9.2"
  }
}

```

<!-- path: config/employee-details-config.tsx -->
```typescript
// ==== EMPLOYEE DETAILS MODAL CONFIGURATION ====

import { 
  DetailsModal, 
  defaultFormatters, 
  type HeaderConfig, 
  type SectionConfig 
} from '@/components/common/ui/Modal/DetailsModal';
import { 
  FiUser, 
  FiPhone, 
  FiMail, 
  FiBriefcase, 
  FiCalendar, 
  FiClock, 
  FiMapPin, 
  FiInfo 
} from "react-icons/fi";
import { StatusBadge } from "@/components/common/ui/badges/StatusBadge";
import { V_employeesRowSchema, EmployeesRowSchema } from '@/schemas/zod-schemas';

type EmployeeDetails = V_employeesRowSchema | (EmployeesRowSchema & { employee_designation_name?: string | null });

// Helper function to get the first letter of the name for avatar
const getInitials = (name?: string | null) => {
  if (!name) return '?';
  return name.charAt(0).toUpperCase();
};

// Create header config function
const createHeaderConfig = (emp: EmployeeDetails): HeaderConfig<EmployeeDetails> => ({
  title: (data: EmployeeDetails) => data.employee_name || emp.employee_name || "Unnamed Employee",
  subtitle: (data: EmployeeDetails) => data.employee_pers_no || emp.employee_pers_no || "No Personnel No.",
  avatar: {
    urlKey: '', // employees don't have avatars
    fallbackText: (data: EmployeeDetails) => getInitials(data.employee_name || emp.employee_name)
  },
  badges: [
    {
      key: 'designation',
      component: (value: unknown, data: EmployeeDetails) => 
        data.employee_designation_name ? (
          <span className="px-3 py-1 text-xs font-semibold bg-blue-100 text-blue-800 rounded-full dark:bg-blue-900 dark:text-blue-200">
            {data.employee_designation_name}
          </span>
        ) : null
    },
    {
      key: 'status',
      component: (value: unknown, data: EmployeeDetails) => 
        <StatusBadge status={data.status ? "ACTIVE" : "INACTIVE"} />
    }
  ]
});

// Employee details modal configuration
export const employeeDetailsConfig = {
  header: createHeaderConfig({} as EmployeeDetails), // Will be overridden in the component
  
  sections: [
    {
      title: "Personal Information",
      icon: <FiUser size={20} />,
      fields: [
        { 
          key: 'employee_email', 
          label: 'Email', 
          icon: <FiMail size={18} />, 
          formatter: (email: string | null) => email || 'Not provided'
        },
        { 
          key: 'employee_contact', 
          label: 'Contact', 
          icon: <FiPhone size={18} />, 
          formatter: (contact: string | null) => contact || 'Not provided'
        },
        { 
          key: 'employee_dob', 
          label: 'Date of Birth', 
          icon: <FiCalendar size={18} />, 
          formatter: defaultFormatters.date 
        },
        { 
          key: 'employee_doj', 
          label: 'Date of Joining', 
          icon: <FiCalendar size={18} />, 
          formatter: defaultFormatters.date 
        },
        { 
          key: 'employee_addr', 
          label: 'Address', 
          icon: <FiMapPin size={18} />, 
          formatter: (addr: string | null) => addr || 'Not provided'
        }
      ]
    },
    {
      title: "Employment Details",
      icon: <FiBriefcase size={20} />,
      fields: [
        { 
          key: 'employee_designation_name', 
          label: 'Designation', 
          icon: <FiBriefcase size={18} />,
          formatter: (designation: string | null) => designation || 'Not assigned'
        },
        { 
          key: 'status', 
          label: 'Status', 
          icon: <FiInfo size={18} />,
          formatter: (status: boolean | null) => status ? 'Active' : 'Inactive'
        }
      ]
    },
    {
      title: "Timestamps",
      icon: <FiCalendar size={20} />,
      fields: [
        { 
          key: 'created_at', 
          label: 'Created At', 
          icon: <FiCalendar size={18} />, 
          formatter: defaultFormatters.dateTime 
        },
        { 
          key: 'updated_at', 
          label: 'Updated At', 
          icon: <FiClock size={18} />, 
          formatter: defaultFormatters.dateTime 
        }
      ]
    }
  ] as SectionConfig<EmployeeDetails>[]
};

export const EmployeeDetailsModal = ({ 
  employee, 
  onClose, 
  isOpen 
}: { 
  employee: EmployeeDetails | null; 
  onClose: () => void; 
  isOpen: boolean 
}) => {
  if (!employee) {
    return null;
  }
  
  return (
    <DetailsModal<EmployeeDetails>
      data={employee}
      onClose={onClose}
      isOpen={isOpen}
      config={{
        ...employeeDetailsConfig,
        header: createHeaderConfig(employee)
      }}
    />
  );
};
```

<!-- path: config/areas.ts -->
```typescript
// config/areas.ts
import { z } from 'zod';
import { EntityConfig } from "@/components/common/entity-management/types";
import { FiBriefcase } from "react-icons/fi";
import { maintenance_areasInsertSchema, maintenance_areasRowSchema, lookup_typesRowSchema } from "@/schemas/zod-schemas";

// --- TYPE DEFINITIONS (DERIVED FROM ZOD) ---
export type MaintenanceArea = z.infer<typeof maintenance_areasRowSchema>;
export type AreaType = z.infer<typeof lookup_typesRowSchema>;

export interface MaintenanceAreaWithRelations extends MaintenanceArea {
  area_type: AreaType | null;
  parent_area: MaintenanceAreaWithRelations | null;
  child_areas: MaintenanceAreaWithRelations[];
}

export interface AreaFormModalProps {
  isOpen: boolean;
  onClose: () => void;
  onSubmit: (data: z.infer<typeof maintenance_areasInsertSchema>) => void;
  area: MaintenanceAreaWithRelations | null;
  allAreas: MaintenanceArea[];
  areaTypes: AreaType[];
  isLoading: boolean;
}

// --- CONFIGURATION (Unchanged) ---
export const areaConfig: EntityConfig<MaintenanceAreaWithRelations> = {
  entityName: 'area', entityDisplayName: 'Area', entityPluralName: 'Areas',
  parentField: 'parent_area', icon: FiBriefcase, isHierarchical: true,
  searchFields: ['name'],
  detailFields: [
    { key: 'name', label: 'Name', type: 'text' },
    { key: 'status', label: 'Status', type: 'status' },
    { key: 'parent_area', label: 'Parent Area', type: 'parent' },
    { key: 'created_at', label: 'Created At', type: 'date' },
  ],
  filterOptions: [
    {
      key: 'status', label: 'Status', type: 'select',
      options: [
        { value: '', label: 'All Status' }, { value: 'true', label: 'Active' }, { value: 'false', label: 'Inactive' },
      ],
    },
  ],
};
```

<!-- path: config/column-orders.ts -->
```typescript
export const desiredCpanConnectionColumnOrder = [
    "customer_name",
    "bandwidth_allocated_mbps",
    "sfp_type_id",
    "sfp_capacity",
    "sfp_port",
    "sfp_serial_no",
    "fiber_in",
    "fiber_out",
    "system_connection_id",
  ];
  
  export const desiredCpanSystemColumnOrder = [
    "area",
    "ring_no",
    "system_id",
  ];
  
  export const desiredEmployeeDesignationColumnOrder = [
    "name",
    "parent_id",
    "status",
    "created_at",
    "updated_at",
    "id",
  ];
  
  export const desiredEmployeeColumnOrder = [
    "employee_name",
    "employee_pers_no",
    "employee_designation_id",
    "employee_contact",
    "employee_email",
    "employee_addr",
    "employee_dob",
    "employee_doj",
    "maintenance_terminal_id",
    "remark",
    "status",
    "created_at",
    "updated_at",
    "id",
  ];
  
  export const desiredFiberJointConnectionColumnOrder = [
    "joint_id",
    "input_ofc_id",
    "input_fiber_no",
    "output_ofc_id",
    "output_fiber_no",
    "splice_loss_db",
    "logical_path_id",
    "created_at",
    "updated_at",
    "id",
  ];
  
  export const desiredFiberJointColumnOrder = [
    "joint_name",
    "joint_category",
    "joint_type",
    "installed_date",
    "node_id",
    "maintenance_area_id",
    "location_description",
    "latitude",
    "longitude",
    "remark",
    "status",
    "created_at",
    "updated_at",
    "id",
  ];
  
  export const desiredLogicalFiberPathColumnOrder = [
    "path_name",
    "path_category",
    "path_type",
    "source_system_id",
    "destination_system_id",
    "source_port",
    "destination_port",
    "operational_status_category",
    "operational_status",
    "service_type",
    "bandwidth_gbps",
    "wavelength_nm",
    "total_distance_km",
    "total_loss_db",
    "commissioned_date",
    "remark",
    "created_at",
    "updated_at",
    "id",
  ];
  
  export const desiredLookupTypeColumnOrder = [
    "category",
    "name",
    "code",
    "description",
    "sort_order",
    "is_system_default",
    "status",
    "created_at",
    "updated_at",
    "id",
  ];
  
  export const desiredMaanConnectionColumnOrder = [
    "customer_name",
    "bandwidth_allocated_mbps",
    "sfp_type_id",
    "sfp_capacity",
    "sfp_port",
    "sfp_serial_no",
    "fiber_in",
    "fiber_out",
    "system_connection_id",
  ];
  
  export const desiredMaanSystemColumnOrder = [
    "area",
    "ring_no",
    "system_id",
  ];
  
  export const desiredMaintenanceAreaColumnOrder = [
    "name",
    "area_type_id",
    "code",
    "parent_id",
    "address",
    "contact_person",
    "contact_number",
    "email",
    "latitude",
    "longitude",
    "status",
    "created_at",
    "updated_at",
    "id",
  ];
  
  export const desiredManagementPortColumnOrder = [
    "port_no",
    "name",
    "system_id",
    "node_id",
    "commissioned_on",
    "remark",
    "status",
    "created_at",
    "updated_at",
    "id",
  ];
  
  export const desiredNodeColumnOrder = [
    "name",
    "node_type_id",
    "maintenance_terminal_id",
    "latitude",
    "longitude",
    "remark",
    "status",
    "created_at",
    "updated_at",
    "id",
  ];
  
  export const desiredOfcCableColumnOrder = [
    "route_name",
    "ofc_type_id",
    "capacity",
    "ofc_owner_id",
    "sn_id",
    "en_id",
    "transnet_id",
    "transnet_rkm",
    "current_rkm",
    "maintenance_terminal_id",
    "asset_no",
    "commissioned_on",
    "remark",
    "status",
    "created_at",
    "updated_at",
    "id",
  ];
  
  export const desiredOfcConnectionColumnOrder = [
    "ofc_id",
    "connection_category",
    "connection_type",
    "system_id",
    "fiber_no_sn",
    "fiber_no_en",
    "source_port",
    "destination_port",
    "sn_power_dbm",
    "en_power_dbm",
    "route_loss_db",
    "sn_dom",
    "en_dom",
    "otdr_distance_sn_km",
    "otdr_distance_en_km",
    "logical_path_id",
    "path_segment_order",
    "remark",
    "status",
    "created_at",
    "updated_at",
    "id",
  ];
  
  // "id", "created_at", "updated_at","active_count","inactive_count","maintenance_area_area_type_id","maintenance_area_code","maintenance_area_contact_number","maintenance_area_contact_person","maintenance_area_created_at","maintenance_area_email","maintenance_area_latitude","maintenance_area_longitude","maintenance_area_parent_id","maintenance_area_status","maintenance_area_updated_at","ring_type_category","ring_type_created_at","ring_type_id","ring_type_is_system_default","ring_type_name","ring_type_sort_order","ring_type_status","ring_type_updated_at","total_count","maintenance_terminal_id"
  export const desiredRingColumnOrder = [
    "name",
    "total_nodes",
    "maintenance_area_name",
    "ring_type_code",
    "description",
    "status",
    "created_at",
    "updated_at",
    "id",
  ];
  
  export const desiredSdhConnectionColumnOrder = [
    "stm_no",
    "carrier",
    "a_customer",
    "b_customer",
    "a_slot",
    "b_slot",
    "system_connection_id",
  ];
  
  export const desiredSdhNodeAssociationColumnOrder = [
    "sdh_system_id",
    "node_id",
    "node_position",
    "node_ip",
    "id",
  ];
  
  export const desiredSdhSystemColumnOrder = [
    "gne",
    "make",
    "system_id",
  ];
  
  export const desiredSystemConnectionColumnOrder = [
    "system_id",
    "connected_system_id",
    "media_type_id",
    "bandwidth_mbps",
    "sn_id",
    "sn_interface",
    "sn_ip",
    "en_id",
    "en_interface",
    "en_ip",
    "vlan",
    "commissioned_on",
    "remark",
    "status",
    "created_at",
    "updated_at",
    "id",
  ];
  
  export const desiredSystemColumnOrder = [
    "system_name",
    "system_type_id",
    "node_id",
    "s_no",
    "ip_address",
    "maintenance_terminal_id",
    "commissioned_on",
    "remark",
    "status",
    "created_at",
    "updated_at",
    "id",
  ];
  
  export const desiredUserActivityLogColumnOrder = [
    "user_id",
    "user_role",
    "action_type",
    "table_name",
    "record_id",
    "details",
    "old_data",
    "new_data",
    "created_at",
    "id",
  ];
  
  export const desiredUserProfileColumnOrder = [
    "first_name",
    "last_name",
    "designation",
    "phone_number",
    "email", // Assuming email will be derived from user_profiles_extended or similar
    "role",
    "status",
    "date_of_birth",
    "address",
    "avatar_url",
    "preferences",
    "created_at",
    "updated_at",
    "id",
  ];
  
  export const desiredVmuxConnectionColumnOrder = [
    "c_code",
    "subscriber",
    "channel",
    "tk",
    "system_connection_id",
  ];
  
  export const desiredVmuxSystemColumnOrder = [
    "vm_id",
    "system_id",
  ];
```

<!-- path: config/designations.ts -->
```typescript
// config/designations.ts
import { z } from 'zod';
import { EntityConfig } from "@/components/common/entity-management/types";
import { FiBriefcase } from "react-icons/fi";
import { employee_designationsRowSchema } from "@/schemas/zod-schemas";

// --- TYPE DEFINITIONS (DERIVED FROM ZOD) ---
export type Designation = z.infer<typeof employee_designationsRowSchema>;

export interface DesignationWithRelations extends Designation {
  parent_designation: DesignationWithRelations | null;
  child_designations: DesignationWithRelations[];
}

// --- CONFIGURATION (Unchanged) ---
export const designationConfig: EntityConfig<DesignationWithRelations> = {
  entityName: 'designation', entityDisplayName: 'Designation', entityPluralName: 'Designations',
  parentField: 'parent_designation', icon: FiBriefcase, isHierarchical: true,
  searchFields: ['name'],
  detailFields: [
    { key: 'name', label: 'Name', type: 'text' },
    { key: 'status', label: 'Status', type: 'status' },
    { key: 'parent_designation', label: 'Parent Designation', type: 'parent' },
    { key: 'created_at', label: 'Created At', type: 'date' },
  ],
  filterOptions: [
    {
      key: 'status', label: 'Status', type: 'select',
      options: [
        { value: '', label: 'All Status' }, { value: 'true', label: 'Active' }, { value: 'false', label: 'Inactive' },
      ],
    },
  ],
};
```

<!-- path: config/ofc-details-config.tsx -->
```typescript
// ==== OFC DETAILS MODAL CONFIGURATION ====
import { 
    DetailsModal, 
    defaultFormatters, 
    type HeaderConfig, 
    type SectionConfig 
  } from '@/components/common/ui/Modal/DetailsModal';
  import { 
    FiActivity,
    FiCalendar, 
    FiClock, 
    FiDatabase, 
    FiMapPin, 
    FiInfo,
    FiGitBranch,
    FiTool
  } from "react-icons/fi";
  import { StatusBadge } from "@/components/common/ui/badges/StatusBadge";
import { V_ofc_cables_completeRowSchema } from '@/schemas/zod-schemas';
  
  // OFC details modal configuration
  export const ofcDetailsConfig = {
    header: {
      title: (ofc: V_ofc_cables_completeRowSchema) => ofc.route_name || "Unnamed OFC Route",
      subtitle: (ofc: V_ofc_cables_completeRowSchema) => ofc.ofc_owner_name || "Unknown Owner",
      avatar: {
        urlKey: '', // OFC doesn’t have avatars
        fallbackText: (ofc: V_ofc_cables_completeRowSchema) => (ofc.ofc_owner_name?.charAt(0)?.toUpperCase() || "O")
      },
      badges: [
        {
          key: 'ofc_type_name',
          component: (type: string) => type ? (
            <span className="px-3 py-1 text-xs font-semibold bg-purple-100 text-purple-800 rounded-full dark:bg-purple-900 dark:text-purple-200">
              {type}
            </span>
          ) : null
        },
        {
          key: 'status',
          component: (status: boolean) => (
            <StatusBadge status={status ? "ACTIVE" : "INACTIVE"} />
          )
        }
      ]
    } as HeaderConfig<V_ofc_cables_completeRowSchema>,
  
    sections: [
      {
        title: "Route Information",
        icon: <FiGitBranch size={20} />,
        fields: [
          { key: 'route_name', label: 'Route Name', icon: <FiInfo size={18} /> },
          { key: 'asset_no', label: 'Asset No.', icon: <FiDatabase size={18} /> },
          { key: 'sn_id', label: 'SN ID', icon: <FiDatabase size={18} /> },
          { key: 'en_id', label: 'EN ID', icon: <FiDatabase size={18} /> },
          { key: 'transnet_id', label: 'Transnet ID', icon: <FiDatabase size={18} /> }
        ]
      },
      {
        title: "Capacity & Type",
        icon: <FiTool size={20} />,
        fields: [
          { key: 'capacity', label: 'Capacity (Fibers)', icon: <FiActivity size={18} /> },
          { key: 'ofc_type_name', label: 'OFC Type', icon: <FiTool size={18} /> },
          { key: 'ofc_type_code', label: 'OFC Type Code', icon: <FiTool size={18} /> }
        ]
      },
      {
        title: "Ownership & Maintenance",
        icon: <FiMapPin size={20} />,
        fields: [
          { key: 'ofc_owner_name', label: 'Owner', icon: <FiInfo size={18} /> },
          { key: 'ofc_owner_code', label: 'Owner Code', icon: <FiDatabase size={18} /> },
          { key: 'maintenance_area_name', label: 'Maintenance Area', icon: <FiMapPin size={18} /> },
          { key: 'maintenance_area_code', label: 'Area Code', icon: <FiDatabase size={18} /> },
          { key: 'maintenance_terminal_id', label: 'Maintenance Terminal ID', icon: <FiDatabase size={18} /> }
        ]
      },
      {
        title: "Length Information",
        icon: <FiActivity size={20} />,
        fields: [
          { key: 'current_rkm', label: 'Current RKM', icon: <FiActivity size={18} /> },
          { key: 'transnet_rkm', label: 'Transnet RKM', icon: <FiActivity size={18} /> }
        ]
      },
      {
        title: "Commissioning & Timestamps",
        icon: <FiCalendar size={20} />,
        fields: [
          { key: 'commissioned_on', label: 'Commissioned On', icon: <FiCalendar size={18} />, formatter: defaultFormatters.date },
          { key: 'created_at', label: 'Created At', icon: <FiCalendar size={18} />, formatter: defaultFormatters.dateTime },
          { key: 'updated_at', label: 'Updated At', icon: <FiClock size={18} />, formatter: defaultFormatters.dateTime }
        ]
      },
      {
        title: "Counts",
        icon: <FiDatabase size={20} />,
        fields: [
          { key: 'total_count', label: 'Total', icon: <FiDatabase size={18} /> },
          { key: 'active_count', label: 'Active', icon: <FiDatabase size={18} /> },
          { key: 'inactive_count', label: 'Inactive', icon: <FiDatabase size={18} /> }
        ]
      }
    ] as SectionConfig<V_ofc_cables_completeRowSchema>[]
  };
  
  export const OfcDetailsModal = ({ ofc, onClose, isOpen }: { ofc: V_ofc_cables_completeRowSchema, onClose: () => void, isOpen: boolean }) => {
    return (
      <DetailsModal
        data={ofc}
        onClose={onClose}
        isOpen={isOpen}
        config={ofcDetailsConfig}
      />
    );
  };
  
```

<!-- path: config/helper-types.ts -->
```typescript
// config/helpers.ts

import { Database, Tables } from "@/types/supabase-types";
import { TABLES, VIEWS } from "@/config/table-column-keys";
import { PublicTableName, PublicTableOrViewName, ViewName } from "@/hooks/database";

// Database schema types

export type TableNames = keyof typeof TABLES;
export type ViewNames = keyof typeof VIEWS;


export type CurrentTableName = keyof typeof TABLES;

// This Mapped Type now correctly includes both Tables and Views.
export type AllColumnKeys = {
  [K in PublicTableName]: (keyof Tables<K> & string)[];
} & {
  // Add a mapped type for Views. This merges the view keys into the type.
  [K in ViewName]: (keyof Database["public"]["Views"][K]["Row"] & string)[];
};



export type ExcelFormat =
  | "text"
  | "number"
  | "date"
  | "currency"
  | "percentage";
export type ColumnTransform = (value: unknown) => unknown;

export type ColumnMeta = {
  title?: string;
  excelHeader?: string;
  excelFormat?: ExcelFormat;
  transform?: ColumnTransform;
};

export type TableMetaMap = {
  [K in PublicTableName]?: Partial<Record<keyof Tables<K> & string, ColumnMeta>>;
};

export type UploadTableMeta<T extends PublicTableName> = {
  uploadType: "insert" | "upsert";
  conflictColumn?: keyof Tables<T> & string;
  isUploadEnabled?: boolean;
};

export type UploadMetaMap = {
  [K in PublicTableName]?: UploadTableMeta<K>;
};





```

<!-- path: config/node-details-config.tsx -->
```typescript
// ==== NODE DETAILS MODAL CONFIGURATION ====
import { 
  DetailsModal, 
  defaultFormatters, 
  type HeaderConfig, 
  type SectionConfig 
} from '@/components/common/ui/Modal/DetailsModal';
import { 
  FiCpu,
  FiCalendar, 
  FiClock, 
  FiMapPin, 
  FiDatabase, 
  FiServer,
  FiCode,
  FiInfo
} from "react-icons/fi";
import { StatusBadge } from "@/components/common/ui/badges/StatusBadge";
import { V_nodes_completeRowSchema } from '@/schemas/zod-schemas';

// Node details modal configuration
export const nodeDetailsConfig = {
  header: {
    title: (node: V_nodes_completeRowSchema) => node.name || "Unnamed Node",
    avatar: {
      urlKey: '', // nodes probably don’t have avatars
      fallbackText: (node: V_nodes_completeRowSchema) => (node.name?.charAt(0)?.toUpperCase() || "?")
    },
    badges: [
      {
        key: 'node_type_name',
        component: (type: string) => type ? (
          <span className="px-3 py-1 text-xs font-semibold bg-green-100 text-green-800 rounded-full dark:bg-green-900 dark:text-green-200">
            {type}
          </span>
        ) : null
      },
      {
        key: 'ring_status',
        component: (status: string) => status ? (
          <StatusBadge status={status} />
        ) : null
      }
    ]
  } as HeaderConfig<V_nodes_completeRowSchema>,

  sections: [
    {
      title: "Basic Information",
      icon: <FiCpu size={20} />,
      fields: [
        { key: 'name', label: 'Node Name', icon: <FiServer size={18} /> },
        { key: 'node_type_name', label: 'Node Type', icon: <FiCode size={18} /> },
        { key: 'remark', label: 'Remark', icon: <FiInfo size={18} /> },
      ]
    },
    {
      title: "Maintenance Area",
      icon: <FiMapPin size={20} />,
      fields: [
        { key: 'maintenance_area_code', label: 'Area Code', icon: <FiDatabase size={18} /> },
        { key: 'maintenance_area_name', label: 'Area Name', icon: <FiMapPin size={18} /> },
        { key: 'maintenance_area_type_name', label: 'Area Type', icon: <FiMapPin size={18} /> },
      ]
    },
    {
      title: "Geolocation",
      icon: <FiMapPin size={20} />,
      fields: [
        { key: 'latitude', label: 'Latitude', icon: <FiMapPin size={18} /> },
        { key: 'longitude', label: 'Longitude', icon: <FiMapPin size={18} /> },
      ]
    },
    {
      title: "Timestamps",
      icon: <FiCalendar size={20} />,
      fields: [
        { key: 'created_at', label: 'Created At', icon: <FiCalendar size={18} />, formatter: defaultFormatters.dateTime },
        { key: 'updated_at', label: 'Updated At', icon: <FiClock size={18} />, formatter: defaultFormatters.dateTime }
      ]
    }
  ] as SectionConfig<V_nodes_completeRowSchema>[]
};

export const NodeDetailsModal = ({ node, onClose, isOpen }: { node: V_nodes_completeRowSchema, onClose: () => void, isOpen: boolean }) => {
  return (
    <DetailsModal
      data={node}
      onClose={onClose}
      isOpen={isOpen}
      config={nodeDetailsConfig}
    />
  );
};

```

<!-- path: config/table-columns/NodesTableColumns.tsx -->
```typescript
import { useDynamicColumnConfig } from '@/hooks/useColumnConfig';
import TruncateTooltip from '@/components/common/TruncateTooltip';
import { StatusBadge } from '@/components/common/ui';
import { V_nodes_completeRowSchema } from '@/schemas/zod-schemas';

export const NodesTableColumns = (data: V_nodes_completeRowSchema[]) => {
  return useDynamicColumnConfig('v_nodes_complete', {
    data: data,
    omit: [
      'node_type_id',
      'node_type_code',
      'maintenance_area_code',
      'id',
      'maintenance_terminal_id',
      'created_at',
      'updated_at',
      'total_count',
      'active_count',
      'inactive_count',
    ],
    overrides: {
      name: {
        render: (value: unknown) => {
          return (
            <TruncateTooltip
              text={(value as string) ?? ''}
              className="font-semibold"
            />
          );
        },
      },
      maintenance_area_name: {
        title: 'Maintenance Area',
        render: (_value: unknown, record: V_nodes_completeRowSchema) => {
          const rel = record.maintenance_area_name;
          return (
            <TruncateTooltip text={rel ?? 'N/A'} className="font-semibold" />
          );
        },
      },
      status: {
        render: (value: unknown) => {
          return <StatusBadge status={value as string} />;
        },
      },
    },
  });
};

```

<!-- path: config/table-columns/OfcDetailsTableColumns.tsx -->
```typescript
import { Row } from '@/hooks/database';
import { useDynamicColumnConfig } from '@/hooks/useColumnConfig';
import { formatDate } from '@/utils/formatters';

export const OfcDetailsTableColumns = (
  data: Row<'v_ofc_connections_complete'>[]
) => {
  return useDynamicColumnConfig('v_ofc_connections_complete', {
    data: data,

    omit: [
      'id',
      'ofc_id',
      'created_at',
      'updated_at',
      'sn_id',
      'en_id',
      'connection_category',
      'destination_port',
      'en_name',
      'path_segment_order',
      'sn_name',
      'source_port',
      'system_id',
      'system_name',
      'ofc_type_name',
      'ofc_route_name',
      'fiber_no_sn',
      'fiber_no_en',
      'destination_port',
      'logical_path_id',
      'ofc_id',
      'path_segment_order',
      'source_port',
      'system_id',
      'updated_at',
      'otdr_distance_sn_km',
      'otdr_distance_en_km',
      'en_dom',
      'en_power_dbm',
      'sn_dom',
      'sn_power_dbm',
      'route_loss_db',
      'connection_type',
      'ofc_type_name',
      'ofc_route_name',
      'remark',
      'status',
      'maintenance_area_name',
      'active_count',
      'inactive_count',
      'total_count',
    ],
    overrides: {
      updated_fiber_no_sn: { 
        title: 'End A Fiber', 
        sortable: true, 
        searchable: true,
        excelFormat: 'number',
        // render: (value) => {
        //   if (value === null || value === undefined) return '';
        //   return String(value);
        // }
      },
      updated_fiber_no_en: { 
        title: 'End B Fiber', 
        sortable: true, 
        searchable: true,
        excelFormat: 'number',
        // render: (value) => {
        //   if (value === null || value === undefined) return '';
        //   return String(value);
        // }
      },
      otdr_distance_sn_km: {
        title: 'End A OTDR Distance (km)',
        sortable: true,
        searchable: true,
      },
      otdr_distance_en_km: {
        title: 'End B OTDR Distance (km)',
        sortable: true,
        searchable: true,
      },
      updated_sn_id: {
        title: 'End A',
        render(value, record, index) {
          return record.updated_sn_name || '';
        },
      },
      updated_en_id: {
        title: 'End B',
        render(value, record, index) {
          return record.updated_en_name || '';
        },
      },
      en_dom: { title: 'End B D.O.M.', sortable: true, width: '150px', searchable: true, render: (value) => formatDate(value as string, { format: 'dd-mm-yyyy' }) },
      en_power_dbm: {
        title: 'End B Power (dBm)',
        sortable: true,
        searchable: true,
      },
      sn_dom: { title: 'End A D.O.M.', sortable: true, width: '150px', searchable: true, render: (value) => formatDate(value as string, { format: 'dd-mm-yyyy' }) },
      sn_power_dbm: {
        title: 'End A Power (dBm)',
        sortable: true,
        searchable: true,
      },
      route_loss_db: {
        title: 'Route Loss (dB)',
        sortable: true,
        searchable: true,
      },
      connection_type: {
        title: 'Connection Type',
        sortable: true,
        searchable: true,
      },
      ofc_type_name: { title: 'Ofc Type', sortable: true, searchable: true },
      // destination_port: {
      //   title: 'Destination Port',
      //   sortable: true,
      //   searchable: true,
      // },
      // logical_path_id: {
      //   title: 'Logical Path ID',
      //   sortable: true,
      //   searchable: true,
      // },
      // ofc_id: { title: 'OFC ID', sortable: true, searchable: true },
      // path_segment_order: {
      //   title: 'Path Segment Order',
      //   sortable: true,
      //   searchable: true,
      // },
      remark: { title: 'Remark', sortable: true, searchable: true },
      // source_port: { title: 'Source Port', sortable: true, searchable: true },
      // system_id: { title: 'System ID', sortable: true, searchable: true },
      // updated_at: { title: 'Updated At', sortable: true, searchable: true },
      status: {
        title: 'Status',
        sortable: true,
        searchable: true,
        render: (value) => (
          <span
            className={`inline-flex items-center px-2.5 py-0.5 rounded-full text-xs font-medium ${
              value ? 'bg-green-100 text-green-800' : 'bg-red-100 text-red-800'
            }`}
          >
            {value ? 'Active' : 'Inactive'}
          </span>
        ),
      },
    },
  });
};

```

<!-- path: config/table-columns/UsersTableColumns.tsx -->
```typescript
import Image from 'next/image';
import {StatusBadge} from '@/components/common/ui/badges/StatusBadge';
import { useDynamicColumnConfig } from "@/hooks/useColumnConfig";
import { formatDate } from "@/utils/formatters";
import { RoleBadge } from '@/components/common/ui';
import { UserRole } from '@/types/user-roles';
import { renderKeyValueCell } from '@/utils/renderKeyValueCell';
import { V_user_profiles_extendedRowSchema } from '@/schemas/zod-schemas';
import TruncateTooltip from '@/components/common/TruncateTooltip';

export const UserProfileColumns = (data:V_user_profiles_extendedRowSchema[]) => {
  return useDynamicColumnConfig("v_user_profiles_extended", {
    data:data,
    omit: ["id", "created_at", "updated_at", "auth_updated_at", "email_confirmed_at", "raw_user_meta_data", "raw_app_meta_data", "phone_confirmed_at", "first_name", "last_name", "is_phone_verified", "computed_status"],
    overrides: {
      status: {
        render: (value) => {
          return <StatusBadge status={value as string} />;
        },
      },
      date_of_birth: {
        render: (value) => {
          return formatDate(value as string, { format: "dd-mm-yyyy" });
        },
      },
      avatar_url: {
        render: (value) => {
          return value ? (
            <><Image src={value as string} alt='Avatar' className='w-10 h-10 rounded-full' width={40} height={40} /> <TruncateTooltip text={value as string} className="font-semibold" /></>
          ) : (
            <><Image src='/default-avatar.png' alt='Avatar' className='w-10 h-10 rounded-full bg-gray-200 dark:bg-gray-700' width={40} height={40} /> <TruncateTooltip text={value as string} className="font-semibold" /></>
          );
        },
      },
      role: {
        render: (value) => {
          return <RoleBadge role={value as UserRole} />;
        },
      },
      address: {
        render: (value) => renderKeyValueCell(value),
      },
      preferences: {
        render: (value) => renderKeyValueCell(value),
      },
    },
  });
};
```

<!-- path: config/table-columns/RingsTableColumns.tsx -->
```typescript
import { StatusBadge } from "@/components/common/ui/badges/StatusBadge";
import { useDynamicColumnConfig } from "@/hooks/useColumnConfig";
import { TruncateTooltip } from "@/components/common/TruncateTooltip";
import { V_ringsRowSchema } from "@/schemas/zod-schemas";

export const RingsColumns = (data: V_ringsRowSchema[]) => {
  return useDynamicColumnConfig("v_rings", {
    data: data,
    omit: [
      "id",
      "created_at",
      "updated_at",
      "active_count",
      "inactive_count",
      "maintenance_area_area_type_id",
      "maintenance_area_code",
      "maintenance_area_contact_number",
      "maintenance_area_contact_person",
      "maintenance_area_created_at",
      "maintenance_area_email",
      "maintenance_area_latitude",
      "maintenance_area_longitude",
      "maintenance_area_parent_id",
      "maintenance_area_status",
      "maintenance_area_updated_at",
      "ring_type_category",
      "ring_type_created_at",
      "ring_type_id",
      "ring_type_is_system_default",
      "ring_type_name",
      "ring_type_sort_order",
      "ring_type_status",
      "ring_type_updated_at",
      "total_count",
      "maintenance_terminal_id",
    ],
    overrides: {
      name: {
        render: (value: unknown) => {
          return <TruncateTooltip text={(value as string) ?? ""} className='font-semibold' />;
        },
      },
      description: {
        title: "Description",
        render: (value: unknown) => {
          return <TruncateTooltip text={(value as string) ?? ""} className='font-semibold' />;
        },
      },
      total_nodes: {
        title: "Total Nodes",
        render: (value: unknown) => {
          return <span className='font-semibold'>{value as string}</span>;
        },
      },
      ring_type_code: {
        title: "Ring Type",
        render: (_value: unknown, record: V_ringsRowSchema) => {
          const rel = record.ring_type_code;
          return <TruncateTooltip text={rel ?? "N/A"} className='font-semibold' />;
        },
      },
      maintenance_area_name: {
        title: "Maintenance Area",
        render: (_value: unknown, record: V_ringsRowSchema) => {
          const rel = record.maintenance_area_name;
          return <TruncateTooltip text={rel ?? "N/A"} className='font-semibold' />;
        },
      },
      status: {
        render: (value: unknown) => {
          return <StatusBadge status={value as string} />;
        },
      },
    },
  });
};

```

<!-- path: config/table-columns/SystemsTableColumns.tsx -->
```typescript
import { Row } from '@/hooks/database';
import { useDynamicColumnConfig } from '@/hooks/useColumnConfig';
import { StatusBadge } from '@/components/common/ui';
import { FiMapPin } from 'react-icons/fi';
import { formatDate } from '@/utils/formatters';

export const SystemsTableColumns = (data: Row<'v_systems_complete'>[]) => {
  return useDynamicColumnConfig('v_systems_complete', {
    data: data,
    omit: [
 
    ],
    overrides: {
      system_name:{
            key: "system_name",
            title: "Name",
            dataIndex: "system_name",
            sortable: true,
            searchable: true,
            filterable: true,
            width: 200,
            render: (value: unknown, record: Row<'v_systems_complete'>) => {
              const stringValue = value as string; // Type assertion since we know it will be a string
              return (
                <div className='flex flex-col'>
                  <span className='font-medium text-gray-900 dark:text-white'>{stringValue}</span>
                  <span className='text-xs text-gray-500 dark:text-gray-400'>S/N: {record.s_no}</span>
                </div>
              );
            },
          },
          system_type_name:{
            key: "system_type_name",
            title: "Type",
            dataIndex: "system_type_name",
            sortable: true,
            searchable: true,
            filterable: true,
            width: 150,
          },
          node_name:{
            key: "node_name",
            title: "Node / Location",
            dataIndex: "node_name",
            sortable: true,
            searchable: true,
            filterable: true,
            width: 150,
            render: (value) => (
              <div className="flex items-center gap-1">
                <FiMapPin className="h-3 w-3 text-gray-400" />
                <span>{value as string || "N/A"}</span>
              </div>
            ),
          },
          ip_address:{
            key: "ip_address",
            title: "IP Address",
            dataIndex: "ip_address",
            sortable: true,
            searchable: true,
            filterable: true,
            width: 150,
            render: (value: unknown) => (
              <code className="rounded bg-gray-100 px-2 py-1 text-sm dark:bg-gray-700">
                {value as string || "N/A"}
              </code>
            ),
          },
          status:{
            key: "status",
            title: "Status",
            dataIndex: "status",
            sortable: true,
            searchable: true,
            filterable: true,
            width: 150,
            render: (value) => <StatusBadge status={value as boolean} />
          },
          commissioned_on:{
            key: "commissioned_on",
            title: "Commissioned On",
            dataIndex: "commissioned_on",
            sortable: true,
            searchable: true,
            filterable: true,
            width: 150,
            render: (value) => formatDate(value as string, { format: 'dd-mm-yyyy' }),
          }
    },
  });
};

```

<!-- path: config/table-columns/LogicalPathsTableColumns.tsx -->
```typescript
import { StatusBadge } from '@/components/common/ui/badges/StatusBadge';
import { useDynamicColumnConfig } from "@/hooks/useColumnConfig";
import { TruncateTooltip } from "@/components/common/TruncateTooltip";
import { V_end_to_end_pathsRowSchema } from '@/schemas/zod-schemas';
import { Row } from '@/hooks/database';

export const LogicalPathsTableColumns = (data: Row<'v_end_to_end_paths'>[]) => {
  return useDynamicColumnConfig("v_end_to_end_paths", {
    data: data,
    omit: ["path_id", "source_system_id", "destination_system_id", "total_loss_db"],
    overrides: {
      path_name: {
        title: "Path Name",
        render: (value) => <TruncateTooltip text={(value as string) ?? 'N/A'} className='font-semibold' />,
      },
      operational_status: {
        title: "Status",
        render: (value) => <StatusBadge status={(value as string) || "Unknown"} />,
      },
      segment_count: {
        title: "Segments",
        render: (value) => <span className="font-mono text-sm">{value as number ?? 0}</span>,
      },
      route_names: {
        title: "Route",
        render: (value) => <TruncateTooltip text={(value as string) ?? 'N/A'} />,
      },
      total_distance_km: {
        title: "Distance (km)",
        render: (value) => <span className="font-mono text-sm">{(value as number)?.toFixed(2) ?? '0.00'}</span>,
      },
    },
  });
};
```

<!-- path: config/table-columns/OfcTableColumns.tsx -->
```typescript
import { Row } from '@/hooks/database';
import { useDynamicColumnConfig } from '@/hooks/useColumnConfig';
import TruncateTooltip from '@/components/common/TruncateTooltip';
import { StatusBadge } from '@/components/common/ui';
import { formatDate } from '@/utils/formatters';

export const OfcTableColumns = (data: Row<'v_ofc_cables_complete'>[]) => {
  return useDynamicColumnConfig('v_ofc_cables_complete', {
    data: data,

    omit: [
      'active_count',
      'created_at',
      'en_id',
      'id',
      'inactive_count',
      'maintenance_area_name',
      'maintenance_terminal_id',
      'ofc_owner_id',
      'ofc_owner_name',
      'ofc_type_id',
      'ofc_type_name',
      'sn_id',
      'total_count',
      'updated_at',
      'status'
    ],
    overrides: {
      asset_no: {
        render: (value: unknown) => {
          return (
            <TruncateTooltip
              text={(value as string) ?? ''}
              className="font-semibold"
            />
          );
        },
      },
      route_name: {
        title: 'Route',
        render: (_value: unknown, record: Row<'v_ofc_cables_complete'>) => {
          const rel = record.route_name;
          return (
            <TruncateTooltip text={rel ?? 'N/A'} className="font-semibold" />
          );
        },
      },
      maintenance_area_name: {
        title: 'Maintenance Area',
        render: (_value: unknown, record: Row<'v_ofc_cables_complete'>) => {
          const rel = record.maintenance_area_name;
          return (
            <TruncateTooltip text={rel ?? 'N/A'} className="font-semibold" />
          );
        },
      },
      commissioned_on: {
        render: (value: unknown) => {
          return formatDate(value as string, { format: 'dd-mm-yyyy' });
        },
      },
      status: {
        render: (value: unknown) => {
          return <StatusBadge status={value as string} />;
        },
      },
    },
  });
};

```

<!-- path: config/helper-functions.ts -->
```typescript
// Helper: normalize various Excel/CSV date representations to 'YYYY-MM-DD' or null
export const toPgDate = (value: unknown): string | null => {
  if (value === null || value === undefined) return null;
  // Treat empty string as null to avoid Postgres date parse errors
  if (typeof value === "string") {
    const v = value.trim();
    if (v === "") return null;
    // If already in YYYY-MM-DD, return as-is
    if (/^\d{4}-\d{2}-\d{2}$/.test(v)) return v;

    // If the string is a numeric-like Excel serial, treat it as such
    if (/^\d+(?:\.\d+)?$/.test(v)) {
      const num = parseFloat(v);
      if (!isNaN(num)) {
        const ms = Math.round((num - 25569) * 86400 * 1000);
        const d = new Date(ms);
        if (!isNaN(d.getTime())) {
          const yyyy = d.getFullYear();
          const mm = String(d.getMonth() + 1).padStart(2, "0");
          const dd = String(d.getDate()).padStart(2, "0");
          return `${yyyy}-${mm}-${dd}`;
        }
      }
    }

    // Handle common D/M/Y or M/D/Y with optional time "DD/MM/YYYY HH:MM:SS" or "MM/DD/YYYY HH:MM:SS"
    const dmYTime =
      /^(\d{1,2})\/(\d{1,2})\/(\d{4})(?:[ T](\d{1,2}):(\d{2})(?::(\d{2}))?)?$/;
    const match = v.match(dmYTime);
    if (match) {
      const d1 = parseInt(match[1], 10);
      const d2 = parseInt(match[2], 10);
      const yyyy = parseInt(match[3], 10);
      // Disambiguate: if first part > 12 -> DD/MM/YYYY; if second part > 12 -> MM/DD/YYYY; otherwise assume DD/MM/YYYY (common in India)
      const isDMY = d1 > 12 || (d2 <= 12 && d1 <= 12);
      const dd = String(isDMY ? d1 : d2).padStart(2, "0");
      const mm = String(isDMY ? d2 : d1).padStart(2, "0");
      return `${yyyy}-${mm}-${dd}`;
    }

    // Fallback to Date parsing for other formats
    const d = new Date(v);
    if (!isNaN(d.getTime())) {
      const yyyy = d.getFullYear();
      const mm = String(d.getMonth() + 1).padStart(2, "0");
      const dd = String(d.getDate()).padStart(2, "0");
      return `${yyyy}-${mm}-${dd}`;
    }
    return null;
  }
  // Excel serial number dates
  if (typeof value === "number") {
    // Excel epoch (days since 1899-12-30). Multiply by ms per day.
    const ms = Math.round((value - 25569) * 86400 * 1000);
    const d = new Date(ms);
    if (!isNaN(d.getTime())) {
      const yyyy = d.getFullYear();
      const mm = String(d.getMonth() + 1).padStart(2, "0");
      const dd = String(d.getDate()).padStart(2, "0");
      return `${yyyy}-${mm}-${dd}`;
    }
    return null;
  }
  // Date object
  if (value instanceof Date && !isNaN(value.getTime())) {
    const yyyy = value.getFullYear();
    const mm = String(value.getMonth() + 1).padStart(2, "0");
    const dd = String(value.getDate()).padStart(2, "0");
    return `${yyyy}-${mm}-${dd}`;
  }
  return null;
};

export function toTitleCase(str: string): string {
  if (!str) return "";
  return str
    .replace(/_/g, " ")
    .replace(/([A-Z])/g, " $1")
    .replace(/\b\w/g, (char) => char.toUpperCase())
    .trim();
}

/**
 * Generates a smart code from a name based on practical rules.
 * - Multi-word: "Base Transceiver Station" -> "BTS"
 * - Single long word: "Exchange" -> "EXC"
 * - Single short word: "Node" -> "NODE"
 * - Handles hyphens: "Point-to-Point" -> "PTP"
 * @param name The input string.
 * @returns The generated uppercase code.
 */
export function generateCodeFromName(name: string | null | undefined): string {
  if (!name || typeof name !== 'string') return '';

  // Clean up and split by spaces, underscores, or hyphens
  const words = name
    .trim()
    .split(/[\s_-]+/)
    .filter(word => word.length > 0);

  if (words.length === 0) {
    return '';
  }

  // Case 1: Multiple words -> create an acronym
  if (words.length > 1) {
    return words
      .map(word => word.charAt(0))
      .join('')
      .toLowerCase();
  }

  // Case 2: A single word
  const singleWord = words[0];

  // If the word is short (like an existing acronym), use the whole word.
  if (singleWord.length <= 4) {
    return singleWord.toLowerCase();
  }

  // If it's a longer word, create a 3-letter abbreviation.
  return singleWord.substring(0, 3).toLowerCase();
}


export function inferExcelFormat(
  columnName: string
): "text" | "number" | "date" | "currency" | "percentage" | "json" {
  const name = columnName.toLowerCase();
  if (
    name.endsWith("_at") ||
    name.endsWith("_on") ||
    name.endsWith("dob") ||
    name.endsWith("doj") ||
    name.includes("date")
  )
    return "date";
  if (
    name.includes("amount") ||
    name.includes("price") ||
    name.includes("total") ||
    name.includes("rkm") ||
    name.includes("mbps")
  )
    return "number";
  if (name.includes("percent")) return "percentage";
  // common JSON-like columns
  if (
    name.includes("address") ||
    name.includes("preference") ||
    name.includes("metadata") ||
    name.includes("meta_data") ||
    name.includes("raw_user_meta_data") ||
    name.includes("raw_app_meta_data") ||
    name.endsWith("_json") ||
    name.includes("json")
  )
    return "json";
  return "text";
}

// Helper: normalize boolean-like values to true/false or null
export const toPgBoolean = (value: unknown): boolean | null => {
  if (value === null || value === undefined) return null;
  if (typeof value === "boolean") return value;
  if (typeof value === "number") {
    if (value === 1) return true;
    if (value === 0) return false;
  }
  if (typeof value === "string") {
    const v = value.trim().toLowerCase();
    if (v === "") return null;
    if (["true", "t", "1", "yes", "y"].includes(v)) return true;
    if (["false", "f", "0", "no", "n"].includes(v)) return false;
  }
  return null;
};

/**
 * Dynamically calculates the width of a column based on its content.
 * 
 * @param columnName - The name of the column
 * @param rows - The table data (array of objects from Supabase)
 * @param ctx - Optional CanvasRenderingContext2D for measuring text width
 * @returns A number representing the width in pixels (capped at 300px)
 */
export function inferDynamicColumnWidth(
  columnName: string,
  rows: Record<string, any>[],
  ctx?: CanvasRenderingContext2D
): number {
  const MIN_WIDTH = 120;
  const MAX_WIDTH = 400;
  const PADDING = 32; // left + right cell padding
  
  // fallback font if no canvas context provided
  if (!ctx) {
    const canvas = document.createElement("canvas");
    ctx = canvas.getContext("2d")!;
    ctx.font = "14px Inter, sans-serif"; // match your table CSS font
  }

  // measure header
  let maxWidth = ctx.measureText(columnName).width;

  // measure each row cell
  for (const row of rows) {
    const value = row[columnName];
    if (value == null) continue;
    const text = String(value);
    const width = ctx.measureText(text).width;
    if (width > maxWidth) {
      maxWidth = width;
    }
  }

  // add padding and clamp
  return Math.min(Math.max(Math.ceil(maxWidth) + PADDING, MIN_WIDTH), MAX_WIDTH);
}
```

<!-- path: config/user-details-config.tsx -->
```typescript
// ==== USER DETAILS MODAL CONFIGURATION ====
import { 
    DetailsModal, 
    defaultFormatters, 
    type HeaderConfig, 
    type SectionConfig 
  } from '@/components/common/ui/Modal/DetailsModal';
  import { 
    FiUser, 
    FiPhone, 
    FiCalendar, 
    FiUserCheck, 
    FiBriefcase, 
    FiMail, 
    FiShield, 
    FiClock, 
    FiSettings, 
    FiMapPin 
  } from "react-icons/fi";
  import { RoleBadge } from "@/components/common/ui/badges/RoleBadge";
  import { StatusBadge } from "@/components/common/ui/badges/StatusBadge";
import { V_user_profiles_extendedRowSchema } from '@/schemas/zod-schemas';
import { UserRole } from '@/types/user-roles';
  
  // User details modal configuration
  export const userDetailsConfig = {
    header: {
      title: (user: V_user_profiles_extendedRowSchema) => {
        const firstName = user.first_name?.trim() || "";
        const lastName = user.last_name?.trim() || "";
        const fullName = `${firstName} ${lastName}`.trim();
        return fullName || "No name provided";
      },
      subtitle: (user: V_user_profiles_extendedRowSchema) => user.email,
      avatar: {
        urlKey: 'avatar_url',
        fallbackText: (user: V_user_profiles_extendedRowSchema) => {
          const firstInitial = user.first_name?.charAt(0)?.toUpperCase() || "";
          const lastInitial = user.last_name?.charAt(0)?.toUpperCase() || "";
          return firstInitial + lastInitial || "?";
        }
      },
      badges: [
        {
          key: 'designation',
          component: (designation: string) => designation ? (
            <span className="px-3 py-1 text-xs font-semibold bg-blue-100 text-blue-800 rounded-full dark:bg-blue-900 dark:text-blue-200">
              {designation}
            </span>
          ) : null
        }
      ]
    } as HeaderConfig<V_user_profiles_extendedRowSchema>,
    sections: [
      {
        title: "Personal Information",
        icon: <FiUser size={20} />,
        fields: [
          {
            key: 'first_name',
            label: 'First Name',
            icon: <FiUser size={18} />
          },
          {
            key: 'last_name',
            label: 'Last Name',
            icon: <FiUser size={18} />
          },
          {
            key: 'email',
            label: 'Email Address',
            icon: <FiMail size={18} />,
            formatter: (email: string, data: V_user_profiles_extendedRowSchema) => defaultFormatters.email(email, data?.is_email_verified ?? undefined)
          },
          {
            key: 'phone_number',
            label: 'Phone Number',
            icon: <FiPhone size={18} />
          },
          {
            key: 'date_of_birth',
            label: 'Date of Birth',
            icon: <FiCalendar size={18} />,
            formatter: defaultFormatters.date
          },
          {
            key: 'designation',
            label: 'Designation',
            icon: <FiBriefcase size={18} />
          }
        ]
      },
      {
        title: "Account Information",
        icon: <FiUserCheck size={20} />,
        fields: [
          {
            key: 'role',
            label: 'Role',
            icon: <FiShield size={18} />,
            formatter: (role: UserRole) => <RoleBadge role={role} />
          },
          {
            key: 'status',
            label: 'Status',
            formatter: (status: string) => <StatusBadge status={status || ""} />
          },
          {
            key: 'created_at',
            label: 'Account Created',
            icon: <FiCalendar size={18} />,
            formatter: defaultFormatters.date
          },
          {
            key: 'last_sign_in_at',
            label: 'Last Sign In',
            icon: <FiClock size={18} />,
            formatter: defaultFormatters.dateTime
          },
          {
            key: 'updated_at',
            label: 'Last Updated',
            icon: <FiClock size={18} />,
            formatter: defaultFormatters.dateTime
          }
        ]
      },
      {
        title: "Address Information",
        icon: <FiMapPin size={20} />,
        condition: (user: V_user_profiles_extendedRowSchema) => user.address && defaultFormatters.address(user.address),
        renderCustom: (user: V_user_profiles_extendedRowSchema) => (
          <div className="p-6 bg-gradient-to-br from-gray-50 to-gray-100 dark:from-gray-800 dark:to-gray-850 rounded-2xl border border-gray-200 dark:border-gray-700">
            <p className="text-gray-900 dark:text-white font-medium text-lg leading-relaxed">
              {defaultFormatters.address(user.address)}
            </p>
          </div>
        )
      },
      {
        title: "User Preferences",
        icon: <FiSettings size={20} />,
        condition: (user: V_user_profiles_extendedRowSchema) => user.preferences && Object.keys(user.preferences).length > 0,
        renderCustom: (user: V_user_profiles_extendedRowSchema) => (
          <div className="p-6 bg-gradient-to-br from-gray-50 to-gray-100 dark:from-gray-800 dark:to-gray-850 rounded-2xl border border-gray-200 dark:border-gray-700 overflow-hidden">
            {defaultFormatters.json(user.preferences)}
          </div>
        )
      }
    ] as SectionConfig<V_user_profiles_extendedRowSchema>[]
  };

  export const UserDetailsModal = ({ user, onClose, isOpen }: { user: V_user_profiles_extendedRowSchema, onClose: () => void, isOpen: boolean }) => {
    return (
      <DetailsModal
        data={user}
        onClose={onClose}
        isOpen={isOpen}
        config={userDetailsConfig}
      />
    );
  };
```

<!-- path: config/constants.ts -->
```typescript
export const DEFAULTS = {
  DEBOUNCE_DELAY: 400,
  PAGE_SIZE: 10,
  PAGE_SIZE_OPTIONS: [10, 20, 50, 100, 500],
};

```

<!-- path: config/table-column-keys.ts -->
```typescript
import { toPgBoolean, toPgDate, toTitleCase } from '@/config/helper-functions';
import {
  ColumnMeta,
  ColumnTransform,
  TableMetaMap,
  TableNames,
  UploadMetaMap,
  UploadTableMeta,
} from '@/config/helper-types';
import { Tables } from '@/types/supabase-types';
import type { UploadConfig } from '@/stores/useUploadConfigStore';
import { PublicTableName, PublicTableOrViewName, Row } from '@/hooks/database';

export const UPLOAD_TABLE_META: UploadMetaMap = {
  employees: {
    uploadType: 'upsert',
    conflictColumn: 'employee_pers_no',
    isUploadEnabled: true,
  },
  user_profiles: {
    uploadType: 'upsert',
    conflictColumn: 'id',
    isUploadEnabled: true,
  },
  lookup_types: {
    uploadType: 'upsert',
    conflictColumn: 'id',
    isUploadEnabled: true,
  },
  rings: { uploadType: 'upsert', conflictColumn: 'id', isUploadEnabled: true },
  employee_designations: {
    uploadType: 'upsert',
    conflictColumn: 'id',
    isUploadEnabled: true,
  },
  maintenance_areas: {
    uploadType: 'upsert',
    conflictColumn: 'id',
    isUploadEnabled: true,
  },
  ofc_cables: {
    uploadType: 'upsert',
    conflictColumn: 'id',
    isUploadEnabled: true,
  },
  ofc_connections: {
    uploadType: 'upsert',
    conflictColumn: 'id',
    isUploadEnabled: true,
  },
  nodes: { uploadType: 'upsert', conflictColumn: 'id', isUploadEnabled: true },
  systems: {
    uploadType: 'upsert',
    conflictColumn: 'id',
    isUploadEnabled: true,
  },
};

// Per-table column metadata for UI/export and upload (only override where needed)
export const TABLE_COLUMN_META: TableMetaMap = {
  employees: {
    employee_dob: {
      title: 'Employee DOB',
      excelHeader: 'Employee DOB',
      transform: toPgDate,
      excelFormat: 'date',
    },
    employee_doj: {
      title: 'Employee DOJ',
      excelHeader: 'Employee DOJ',
      transform: toPgDate,
      excelFormat: 'date',
    },
    status: { title: 'Status', excelHeader: 'Status', transform: toPgBoolean },
  },
  lookup_types: {
    status: { transform: toPgBoolean },
    is_system_default: { transform: toPgBoolean },
  },
  rings: {
    status: { transform: toPgBoolean },
  },
  user_profiles: {
    date_of_birth: { transform: toPgDate, excelFormat: 'date' },
  },
  ofc_cables: {
    commissioned_on: { transform: toPgDate, excelFormat: 'date' },
    status: { transform: toPgBoolean },
  },
  ofc_connections: {
    en_dom: { transform: toPgDate, excelFormat: 'date' },
    sn_dom: { transform: toPgDate, excelFormat: 'date' },
    status: { transform: toPgBoolean },
  },
  nodes: {
    status: { transform: toPgBoolean },
  },
  systems: {
    commissioned_on: { transform: toPgDate, excelFormat: 'date' },
    status: { transform: toPgBoolean },
  },
};

// Build UI column configs (lightweight structure; consumer can enrich widths/formats)
export function buildColumnConfig<T extends PublicTableOrViewName>(tableName: T) {
  const keys = TABLE_COLUMN_KEYS[
    tableName as keyof typeof TABLE_COLUMN_KEYS
  ] as unknown as readonly (keyof Row<T> & string)[];
  const meta = (TABLE_COLUMN_META[tableName as PublicTableName] || {}) as Record<string, ColumnMeta>;
  return keys.map((key) => {
    const m = meta[key] || {};
    const title = m.title ?? toTitleCase(key);
    return {
      key,
      dataIndex: key,
      title,
      excelFormat: m.excelFormat,
    };
  });
}
// Build upload config from SSOT
export function buildUploadConfig<T extends PublicTableName>(tableName: T) {
  type RowType = Tables<T>;
  type ColumnKey = keyof RowType & string;

  const tableColumnKeys = TABLE_COLUMN_KEYS as Record<string, readonly string[]>;
  const keys = (tableColumnKeys[tableName] || []) as readonly ColumnKey[];
  const meta = (TABLE_COLUMN_META[tableName] || {}) as Partial<Record<ColumnKey, ColumnMeta>>;
  const tableMeta = UPLOAD_TABLE_META[tableName];
  const uploadType = tableMeta?.uploadType ?? 'upsert';
  const conflictColumn = tableMeta?.conflictColumn;
  const isUploadEnabled = tableMeta?.isUploadEnabled ?? true;

  const columnMapping = keys.map((key) => {
    const m = meta[key] || {};
    const excelHeader = m.excelHeader ?? toTitleCase(key);
    // Auto-infer transforms if not explicitly provided
    let transform = m.transform as ColumnTransform | undefined;
    if (!transform) {
      const k = String(key).toLowerCase();
      if (k.endsWith('_at') || k.endsWith('_on') || k.includes('date')) {
        transform = toPgDate;
      } else if (
        k.startsWith('is_') ||
        k.startsWith('has_') ||
        k.startsWith('can_') ||
        k.includes('enabled') ||
        k.includes('active') ||
        k === 'status'
      ) {
        transform = toPgBoolean;
      }
    }
    return {
      excelHeader,
      dbKey: key,
      transform,
    };
  });

  return {
    tableName,
    columnMapping,
    uploadType,
    conflictColumn,
    isUploadEnabled,
  } satisfies UploadConfig<T>;
}

/**
 * The single source of truth for the default columns to be displayed for each table.
 * This is the ONLY place you need to manually list column names.
 * TypeScript validates this entire object.
 */
export const TABLE_COLUMN_KEYS = {
  // We list all keys for each table here.
  user_profiles: [
    'id',
    'first_name',
    'last_name',
    'phone_number',
    'role',
    'designation',
    'status',
    'avatar_url',
    'date_of_birth',
    'address',
    'preferences',
    'created_at',
    'updated_at',
  ],
  lookup_types: [
    'id',
    'category',
    'name',
    'code',
    'description',
    'sort_order',
    'status',
    'is_system_default',
    'created_at',
    'updated_at',
  ],
  maintenance_areas: [
    'id',
    'code',
    'name',
    'address',
    'email',
    'contact_person',
    'contact_number',
    'latitude',
    'longitude',
    'area_type_id',
    'parent_id',
    'status',
    'created_at',
    'updated_at',
  ],
  employee_designations: ['id', 'name', 'parent_id', 'status', 'created_at', 'updated_at'],
  employees: [
    'id',
    'employee_pers_no',
    'employee_name',
    'employee_email',
    'employee_dob',
    'employee_doj',
    'employee_contact',
    'employee_addr',
    'employee_designation_id',
    'maintenance_terminal_id',
    'status',
    'remark',
    'created_at',
    'updated_at',
  ],
  rings: [
    'id',
    'name',
    'total_nodes',
    'description',
    'ring_type_id',
    'maintenance_terminal_id',
    'status',
    'created_at',
    'updated_at',
  ],
  nodes: [
    'id',
    'name',
    'node_type_id',
    'maintenance_terminal_id',
    'latitude',
    'longitude',
    'status',
    'remark',
    'created_at',
    'updated_at',
  ],
  ofc_cables: [
    'id',
    'route_name',
    'capacity',
    'ofc_type_id', // Correct: references lookup_types table
    'transnet_id',
    'transnet_rkm',
    'current_rkm',
    'ofc_owner_id', // Correct: references lookup_types table
    'asset_no',
    'maintenance_terminal_id', // Correct: references maintenance_areas table
    'commissioned_on',
    'remark',
    'sn_id', // Correct: references nodes table
    'en_id', // Correct: references nodes table
    'status',
    'created_at',
    'updated_at',
  ],
  systems: [
    'id',
    'system_name',
    's_no',
    'node_id',
    'system_type_id',
    'ip_address',
    'maintenance_terminal_id',
    'commissioned_on',
    'status',
    'remark',
    'created_at',
    'updated_at',
  ],
  ofc_connections: [
    'updated_sn_id',
    'fiber_no_sn',
    'updated_fiber_no_sn',
    'otdr_distance_sn_km',
    'sn_dom',
    'sn_power_dbm',
    'updated_en_id',
    'fiber_no_en',
    'updated_fiber_no_en',
    'otdr_distance_en_km',
    'en_dom',
    'en_power_dbm',
    'route_loss_db',
    'connection_type',
    'path_segment_order',
    'connection_category',
    'source_port',
    'destination_port',
    'status',
    'remark',
    'ofc_id',
    'logical_path_id',
    'system_id',
    'created_at',
    'updated_at',
    'id',
  ],
  // 'maan_connections' and 'cpan_connections' refer to 'sfp_based_connections'
  sfp_based_connections: [
    'system_connection_id',
    'bandwidth_allocated_mbps',
    'customer_name',
    'fiber_in',
    'fiber_out',
    'sfp_capacity',
    'sfp_port',
    'sfp_serial_no',
    'sfp_type_id',
  ],
  // 'maan_systems' and 'cpan_systems' are not directly present as tables in your types.
  // Assuming they might be specialized systems or a view not provided.
  // For now, I'll remove them or if they refer to `systems` with specific types, you need to clarify.
  // I will skip them for now.
  management_ports: [
    'id',
    'name',
    'port_no',
    'commissioned_on',
    'node_id',
    'system_id',
    'status',
    'remark',
    'created_at',
    'updated_at',
  ],
  sdh_connections: [
    'system_connection_id',
    'stm_no',
    'carrier',
    'a_customer',
    'a_slot',
    'b_customer',
    'b_slot',
  ],
  sdh_node_associations: ['id', 'sdh_system_id', 'node_id', 'node_position', 'node_ip'],
  sdh_systems: ['system_id', 'make', 'gne'],
  system_connections: [
    'id',
    'system_id',
    'sn_id',
    'en_id',
    'connected_system_id',
    'media_type_id',
    'sn_interface',
    'en_interface',
    'sn_ip',
    'en_ip',
    'vlan',
    'bandwidth_mbps',
    'commissioned_on',
    'status',
    'remark',
    'created_at',
    'updated_at',
  ],
  vmux_connections: ['system_connection_id', 'subscriber', 'channel', 'c_code', 'tk'],
  vmux_systems: ['system_id', 'vm_id'],
  fiber_joints: [
    'id',
    'joint_name',
    'joint_category',
    'joint_type',
    'node_id',
    'maintenance_area_id',
    'latitude',
    'longitude',
    'location_description',
    'installed_date',
    'status',
    'remark',
    'created_at',
    'updated_at',
  ],
  logical_fiber_paths: [
    'bandwidth_gbps',
    'commissioned_date',
    'created_at',
    'destination_port',
    'destination_system_id',
    'id',
    'operational_status_id',
    'path_name',
    'path_type_id',
    'remark',
    'service_type',
    'source_port',
    'source_system_id',
    'total_distance_km',
    'total_loss_db',
    'updated_at',
    'wavelength_nm',
  ],
  // 'fiber_joint_connections' is not directly present as a table in your types.
  // Assuming it might be a junction table or a view not provided.
  // I will skip it for now.
  user_activity_logs: [
    'id',
    'created_at',
    'user_id',
    'user_role',
    'action_type',
    'table_name',
    'record_id',
    'old_data',
    'new_data',
    'details',
  ],
  files: [
    'id',
    'file_name',
    'file_route',
    'file_size',
    'file_type',
    'file_url',
    'folder_id',
    'uploaded_at',
    'user_id',
  ],
  folders: ['id', 'name', 'user_id', 'created_at'],
  ring_based_systems: ['maintenance_area_id', 'ring_id', 'system_id'],
  logical_path_segments: [
    'created_at',
    'fiber_joint_id',
    'id',
    'logical_path_id',
    'ofc_cable_id',
    'path_order',
  ],

  // ===== Views =====
  v_cable_utilization: [
    'cable_id',
    'route_name',
    'capacity',
    'used_fibers',
    'available_fibers',
    'utilization_percent',
  ],
  v_end_to_end_paths: [
    'path_id',
    'path_name',
    'source_system_id',
    'destination_system_id',
    'operational_status',
    'segment_count',
    'route_names',
    'total_distance_km',
    'total_loss_db',
  ],
  v_ofc_cables_complete: [
    'id',
    'route_name',
    'sn_id',
    'en_id',
    'capacity',
    'ofc_type_id',
    'ofc_type_name',
    'ofc_type_code',
    'ofc_owner_id',
    'ofc_owner_name',
    'ofc_owner_code',
    'asset_no',
    'transnet_id',
    'transnet_rkm',
    'current_rkm',
    'maintenance_terminal_id',
    'maintenance_area_name',
    'maintenance_area_code',
    'commissioned_on',
    'status',
    'remark',
    'created_at',
    'updated_at',
    'total_count',
    'active_count',
    'inactive_count',
  ],
  v_nodes_complete: [
    'id',
    'name',
    'node_type_id',
    'node_type_name',
    'node_type_code',
    'maintenance_terminal_id',
    'maintenance_area_name',
    'maintenance_area_code',
    'maintenance_area_type_name',
    'latitude',
    'longitude',
    'status',
    'remark',
    'created_at',
    'updated_at',
    'total_count',
    'active_count',
    'inactive_count',
  ],
  v_ofc_connections_complete: [
    'updated_sn_id',
    'fiber_no_sn',
    'updated_fiber_no_sn',
    'otdr_distance_sn_km',
    'sn_power_dbm',
    'sn_dom',
    'updated_en_id',
    'fiber_no_en',
    'updated_fiber_no_en',
    'otdr_distance_en_km',
    'en_power_dbm',
    'en_dom',
    'route_loss_db',
    'connection_type',
    'maintenance_area_name',
    'remark',
    'status',
    'active_count',
    'inactive_count',
    'ofc_route_name',
    'ofc_type_name',
    'connection_category',
    'system_name',
    'system_id',
    'source_port',
    'destination_port',
    'path_segment_order',
    'logical_path_id',
    'sn_name',
    'en_name',
    'sn_id',
    'en_id',
    'total_count',
    'created_at',
    'updated_at',
    'ofc_id',
    'id',
  ],
  v_system_connections_complete: [
    'active_count',
    'bandwidth_allocated_mbps',
    'bandwidth_mbps',
    'commissioned_on',
    'connected_system_name',
    'connected_system_type_name',
    'created_at',
    'customer_name',
    'en_interface',
    'en_ip',
    'en_name',
    'en_node_name',
    'fiber_in',
    'fiber_out',
    'id',
    'inactive_count',
    'media_type_name',
    'remark',
    'sdh_a_customer',
    'sdh_a_slot',
    'sdh_b_customer',
    'sdh_b_slot',
    'sdh_carrier',
    'sdh_stm_no',
    'sfp_capacity',
    'sfp_port',
    'sfp_serial_no',
    'sfp_type_name',
    'sn_interface',
    'sn_ip',
    'sn_name',
    'sn_node_name',
    'status',
    'system_id',
    'system_name',
    'system_type_name',
    'total_count',
    'updated_at',
    'vlan',
    'vmux_c_code',
    'vmux_channel',
    'vmux_subscriber',
    'vmux_tk',
  ],
  v_systems_complete: [
    'active_count',
    'commissioned_on',
    'created_at',
    'id',
    'inactive_count',
    'ip_address',
    'latitude',
    'longitude',
    'maintenance_terminal_id',
    'node_id',
    'node_name',
    'remark',
    'ring_id',
    'ring_logical_area_name',
    's_no',
    'sdh_gne',
    'sdh_make',
    'status',
    'system_category',
    'system_maintenance_terminal_name',
    'system_name',
    'system_type_code',
    'system_type_id',
    'system_type_name',
    'total_count',
    'updated_at',
    'vmux_vm_id',
  ],
  v_user_profiles_extended: [
    'id',
    'email',
    'last_sign_in_at',
    'created_at',
    'updated_at',
    'auth_updated_at',
    'is_super_admin',
    'is_email_verified',
    'email_confirmed_at',
    'is_phone_verified',
    'phone_confirmed_at',
    'first_name',
    'last_name',
    'full_name',
    'avatar_url',
    'phone_number',
    'date_of_birth',
    'address',
    'preferences',
    'role',
    'designation',
    'status',
    'raw_user_meta_data',
    'raw_app_meta_data',
    'computed_status',
    'account_age_days',
    'last_activity_period',
  ],
  v_lookup_types: [
    'id',
    'category',
    'name',
    'code',
    'description',
    'sort_order',
    'status',
    'is_system_default',
    'created_at',
    'updated_at',
    'total_count',
    'active_count',
    'inactive_count',
  ],
  v_employee_designations: [
    'id',
    'name',
    'parent_id',
    'status',
    'created_at',
    'updated_at',
    'total_count',
    'active_count',
    'inactive_count',
  ],
  v_maintenance_areas: [
    'id',
    'code',
    'name',
    'address',
    'email',
    'contact_person',
    'contact_number',
    'latitude',
    'longitude',
    'area_type_id',
    'parent_id',
    'status',
    'created_at',
    'updated_at',
    'total_count',
    'active_count',
    'inactive_count',
    'maintenance_area_type_category',
    'maintenance_area_type_code',
    'maintenance_area_type_created_at',
    'maintenance_area_type_is_system_default',
    'maintenance_area_type_name',
    'maintenance_area_type_sort_order',
    'maintenance_area_type_status',
    'maintenance_area_type_updated_at',
  ],
  v_employees: [
    'id',
    'employee_pers_no',
    'employee_name',
    'employee_email',
    'employee_dob',
    'employee_doj',
    'employee_contact',
    'employee_addr',
    'employee_designation_id',
    'employee_designation_name',
    'maintenance_terminal_id',
    'remark',
    'status',
    'created_at',
    'updated_at',
    'total_count',
    'active_count',
    'inactive_count',
  ],
  v_rings: [
    // from rings r.*
    'id',
    'name',
    'description',
    'ring_type_id',
    'maintenance_terminal_id',
    'total_nodes',
    'status',
    'created_at',
    'updated_at',

    // from lookup_types lt_ring
    'ring_type_name',
    'ring_type_code',
    'ring_type_category',
    'ring_type_sort_order',
    'ring_type_is_system_default',
    'ring_type_status',
    'ring_type_created_at',
    'ring_type_updated_at',

    // from maintenance_areas ma
    'maintenance_area_name',
    'maintenance_area_code',
    'maintenance_area_email',
    'maintenance_area_contact_person',
    'maintenance_area_contact_number',
    'maintenance_area_latitude',
    'maintenance_area_longitude',
    'maintenance_area_area_type_id',
    'maintenance_area_parent_id',
    'maintenance_area_status',
    'maintenance_area_created_at',
    'maintenance_area_updated_at',

    // counts
    'total_count',
    'active_count',
    'inactive_count',
  ],
  v_system_ring_paths_detailed: [
    'created_at',
    'end_node_id',
    'end_node_name',
    'id',
    'logical_path_id',
    'ofc_cable_id',
    'path_name',
    'path_order',
    'route_name',
    'source_system_id',
    'start_node_id',
    'start_node_name',
  ],
} as const satisfies Record<string, readonly string[]>;

// Separate tables and views for better type safety
export const TABLES = {
  user_profiles: 'user_profiles',
  employees: 'employees',
  lookup_types: 'lookup_types',
  rings: 'rings',
  employee_designations: 'employee_designations',
  maintenance_areas: 'maintenance_areas',
  ofc_cables: 'ofc_cables',
  ofc_connections: 'ofc_connections',
  nodes: 'nodes',
  systems: 'systems',
  // 'cpan_connections' is SFP based connections
  sfp_based_connections: 'sfp_based_connections',
  // 'cpan_systems' is not in types, removed
  // 'fiber_joint_connections' is not in types, removed
  // fiber_joints: 'fiber_joints',
  logical_fiber_paths: 'logical_fiber_paths',
  logical_path_segments: 'logical_path_segments',
  // 'maan_connections' is SFP based connections
  management_ports: 'management_ports',
  sdh_connections: 'sdh_connections',
  sdh_node_associations: 'sdh_node_associations',
  sdh_systems: 'sdh_systems',
  system_connections: 'system_connections',
  // user_activity_logs: 'user_activity_logs',
  vmux_connections: 'vmux_connections',
  vmux_systems: 'vmux_systems',
  files: 'files',
  folders: 'folders',
  ring_based_systems: 'ring_based_systems',
} as const satisfies Partial<Record<PublicTableName, PublicTableName>>;

// Define views separately
export const VIEWS = {
  v_cable_utilization: 'v_cable_utilization',
  v_end_to_end_paths: 'v_end_to_end_paths',
  v_nodes_complete: 'v_nodes_complete',
  v_ofc_cables_complete: 'v_ofc_cables_complete',
  v_ofc_connections_complete: 'v_ofc_connections_complete',
  v_system_connections_complete: 'v_system_connections_complete',
  v_systems_complete: 'v_systems_complete',
  v_user_profiles_extended: 'v_user_profiles_extended',
  v_lookup_types: 'v_lookup_types',
  v_employee_designations: 'v_employee_designations',
  v_maintenance_areas: 'v_maintenance_areas',
  v_employees: 'v_employees',
  v_rings: 'v_rings',
  v_system_ring_paths_detailed: 'v_system_ring_paths_detailed',
} as const;

// For backward compatibility, export TABLE_NAMES as a union of tables and views
export const TABLE_NAMES = {
  ...TABLES,
  ...VIEWS,
} as const;

```

