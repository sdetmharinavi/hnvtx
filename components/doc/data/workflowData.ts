// path: components/doc/data/workflowData.ts
import { WorkflowSection } from "../types/workflowTypes";

export const workflowSections: WorkflowSection[] = [
  {
    value: "auth",
    icon: "ShieldCheck",
    title: "Authentication & Authorization",
    subtitle: "User registration, login & RBAC",
    gradient: "from-violet-500 to-purple-600",
    iconColor: "text-violet-400",
    bgGlow: "bg-violet-500/10",
    color: "violet",
    purpose: "To manage user registration, login, session handling, and role-based access control (RBAC).",
    workflows: [
      {
        title: "Workflow A: New User Registration & Onboarding Prompt",
        userSteps: [
          "User fills out the form on `/signup` and submits.",
          "User receives a verification email and clicks the link.",
          "User will log in and redirected to the `/dashboard` page.",
          "A welcome popup appears, prompting them to complete their profile.",
          "User can choose to 'Update Profile', 'Maybe Later', or 'Don't show again'.",
        ],
        uiSteps: ["On submit, user is redirected to `/verify-email`.", "After email verification, the `/auth/callback` route sends the user to `/dashboard`.", "On the dashboard, the `OnboardingPromptModal` appears if the profile is incomplete."],
        techSteps: [
          "The `signUp` function in the `useAuth` hook calls `supabase.auth.signUp`, passing user metadata.",
          'A database trigger `on_auth_user_created` fires upon a new entry in `auth.users`.',
          'The trigger function (`create_public_profile_for_new_user`) inserts a record into `public.user_profiles` and adds `{"needsOnboarding": true}` to the `preferences` JSONB column.',
          "The `app/dashboard/page.tsx` component uses `useGetMyUserDetails` to fetch the complete user profile.",
          "A `useEffect` checks if `profile.preferences.needsOnboarding` is `true` and `profile.preferences.showOnboardingPrompt` is not `false`.",
          "Clicking 'Don't show again' uses the `useTableUpdate` hook to set `showOnboardingPrompt: false` in the `preferences` column.",
        ],
      },
      {
        title: "Workflow B: User Login & Session Management",
        userSteps: ["User enters credentials on `/login` and clicks 'Sign in'."],
        uiSteps: ["Loading state shown.", "On success, user is redirected to `/dashboard`.", "On failure, an error toast is displayed."],
        techSteps: [
          "`signIn` function in `useAuth` calls `supabase.auth.signInWithPassword`.",
          "If successful, Supabase returns a session with a JWT, which is stored securely in browser cookies.",
          "The `middleware.ts` running on the server refreshes the user's auth token on subsequent requests to protected pages.",
          "The `useAuthStore` (Zustand) is updated by an `onAuthStateChange` listener in the `useAuth` hook, making the user session globally available on the client-side.",
        ],
      },
      {
        title: "Workflow C: Role Synchronization & RLS",
        userSteps: ["An admin changes a user's role in the User Management page."],
        uiSteps: ["The user's permissions are updated for their next session."],
        techSteps: [
          "An admin action updates the `role` column in the `public.user_profiles` table.",
          "A database trigger (`sync_user_role_trigger`) fires on this update.",
          "The trigger function updates the `role` text column in the corresponding `auth.users` table.",
          "On the user's next session refresh, their JWT is minted with the new role claim. This claim is used by PostgreSQL's Row Level Security (RLS) policies to grant or deny access to data.",
        ],
      },
      {
        title: "Workflow D: Existing User Profile Update",
        userSteps: ["User navigates to the `/onboarding` page to edit their profile.", "User changes details and clicks 'Update Profile'."],
        uiSteps: ["The form is pre-populated with existing data.", "A toast confirms the update.", "The user remains on the page to make further changes."],
        techSteps: [
          "The `OnboardingFormEnhanced` component fetches the user's profile using `useGetMyUserDetails`.",
          "On submit, it calls the `useTableUpdate` mutation, which updates the `user_profiles` record and sets `needsOnboarding` to `false` within the `preferences` column.",
          "This action is offline-capable. If the user is offline, the change is saved to the local `user_profiles` table in IndexedDB and the operation is queued in `mutation_queue`.",
        ],
      },
    ],
  },
  {
    value: "offline_first",
    icon: "Server",
    title: "Offline-First Architecture",
    subtitle: "Data Sync, Offline Queries & Mutation Queuing",
    gradient: "from-gray-500 to-slate-600",
    iconColor: "text-gray-400",
    bgGlow: "bg-gray-500/10",
    color: "yellow",
    purpose: "To provide a seamless and resilient user experience, allowing the application to function reliably even with intermittent or no network connectivity through a multi-layered caching and synchronization strategy.",
    workflows: [
      {
        title: "Workflow A: Initial Data Synchronization",
        userSteps: ["User logs in and lands on the main dashboard."],
        uiSteps: ["A toast notification appears: 'Starting data sync...'", "Once complete, the toast updates to 'Local data is up to date.'"],
        techSteps: [
          "The `DashboardContent` component calls the `useDataSync` hook, which triggers a `useQuery` to manage the sync process.",
          "It iterates through `entitiesToSync`, a list of table and view names.",
          "For each entity, the `syncEntity` function is called. It uses a dual strategy:",
          "- For **Views** (e.g., `v_rings`), it calls the `get_paged_data` RPC to bypass RLS issues and get complete, joined data.",
          "- For **Tables** (e.g., `user_profiles`), it uses a standard `supabase.from(...).select('*')`.",
          "The fetched data is written to the corresponding table in IndexedDB using Dexie's efficient `bulkPut` method.",
          "The local `sync_status` table is updated to track the progress of each entity.",
        ],
      },
      {
        title: "Workflow B: Offline Data Read (Example: Nodes Page)",
        userSteps: ["User goes offline.", "User navigates to the `/dashboard/nodes` page."],
        uiSteps: ["The page loads instantly with all the data.", "A toast appears: 'You are offline. Displaying locally cached data.'", "Searching and filtering the table is instantaneous."],
        techSteps: [
          "The `NodesPage` calls `useCrudManager`, which uses the `useNodesData` hook.",
          "`useNodesData` calls our custom `useOfflineQuery` hook.",
          "The `useOnlineStatus` hook inside `useOfflineQuery` returns `false`.",
          "`useOfflineQuery` immediately executes its `offlineQueryFn`, which fetches all records from the local Dexie table: `localDb.v_nodes_complete.toArray()`.",
          "All filtering (search) and pagination is then performed on this complete client-side dataset within a `useMemo` block.",
        ],
      },
      {
        title: "Workflow C: Offline Mutation & Queue Processing",
        userSteps: ["User is offline.", "User edits a Node's name via the `NodeFormModal` and clicks 'Update'."],
        uiSteps: ["The change appears instantly in the data table.", "A toast appears: 'Offline. Your change has been saved...'", "The header displays a 'Pending' sync indicator."],
        techSteps: [
          "The `useCrudManager`'s `handleSave` function detects `isOnline` is `false`.",
          "It performs an 'optimistic update' by writing the change directly to the local Dexie table: `getTable('nodes').update(...)`.",
          "It then calls `addMutationToQueue`, creating a new record in the `mutation_queue` table with the table name, action type, and payload.",
          "Later, the user comes back online. The `useOnlineStatus` hook updates.",
          "A `useEffect` inside the `useMutationQueue` hook (running in `DashboardContent`) detects the online status and pending tasks.",
          "The `processQueue` function retrieves the pending task, sends it to the real Supabase API, and on success, deletes the task from the local queue.",
          "Finally, it calls `queryClient.invalidateQueries()` to trigger a fresh data sync.",
        ],
      },
    ],
  },
  {
    value: "base_structure",
    icon: "Server",
    title: "Base Structure Setup",
    subtitle: "Categories, Lookups, Areas & Designations",
    gradient: "from-gray-500 to-slate-600",
    iconColor: "text-gray-400",
    bgGlow: "bg-gray-500/10",
    color: "yellow",
    purpose: "To configure the foundational data that categorizes and organizes all other entities in the system. This setup is typically performed by an administrator before regular data entry begins.",
    workflows: [
      {
        title: "Workflow A: Managing Categories & Lookups with System Flags",
        userSteps: [
          "Admin goes to `/dashboard/categories` and creates a new category (e.g., 'SYSTEM_TYPES').",
          "Admin navigates to `/dashboard/lookup`, selects the 'System Types' category, and clicks 'Add New'.",
          "In the `LookupModal`, admin fills in the details for a new system type.",
          "If the category is 'SYSTEM_TYPES', additional checkboxes appear: 'Is Ring-Based System' and 'Is SDH System'.",
          "Admin checks 'Is Ring-Based System' for types like 'CPAN' or 'MAAN'.",
          "Admin saves the new lookup type.",
        ],
        uiSteps: [
          "The Categories page allows creating and renaming high-level categories.",
          "On the Lookups page, a category must be selected to view or add types.",
          "The `LookupModal` conditionally displays checkboxes for `is_ring_based` and `is_sdh` only when the `category` is 'SYSTEM_TYPES'.",
        ],
        techSteps: [
          "A **Category** is a distinct value in the `category` column of the `lookup_types` table.",
          "When creating a new System via the `SystemModal`, the form fetches the selected `system_type_id`'s full record from `lookup_types`.",
          "The `upsert_system_with_details` database function receives all system parameters.",
          "Inside the function, it checks the boolean flags on the system type record (e.g., `IF v_system_type_record.is_ring_based = true THEN...`).",
          "Based on these flags, the function executes conditional `INSERT` or `UPDATE` statements on the appropriate subtype tables (e.g., `ring_based_systems`, `sdh_systems`).",
          "This flag-based approach makes the system extensible, as new system behaviors can be added just by adding a new boolean flag and a corresponding `IF` block in the function.",
        ],
      },
      {
        title: "Workflow B: Managing Maintenance Areas",
        userSteps: [
          "Admin navigates to `/dashboard/maintenance-areas`.",
          "Clicks 'Add New' and fills out the `AreaFormModal` to create a top-level area (e.g., a Zone).",
          "Admin then creates another area (e.g., a Terminal), but this time selects the newly created Zone as its 'Parent Area', establishing a hierarchy.",
        ],
        uiSteps: [
          "The `EntityManagementComponent` displays the areas in a hierarchical tree view or a simple list view.",
          "The form modal for an area dynamically filters the 'Parent Area' dropdown to prevent a user from making an area its own child (circular dependency).",
        ],
        techSteps: [
          "The page uses the `EntityManagementComponent` with `areaConfig`, which defines the parent-child relationship via the `parent_id` foreign key field.",
          "Data is fetched using `useTableWithRelations` to include nested `parent_area` and `child_areas` data in a single query.",
          "The `AreaFormModal` uses `useTableInsert` or `useTableUpdate` to modify records in the `maintenance_areas` table.",
        ],
      },
    ],
  },
  {
    value: 'designations_crud',
    icon: "ImUserTie",
    title: 'Designation Management',
    subtitle: 'Organizing employee roles in a hierarchy',
    gradient: 'from-cyan-500 to-sky-600',
    iconColor: 'text-cyan-400',
    bgGlow: 'bg-cyan-500/10',
    color: 'cyan',
    purpose: 'To establish a hierarchical structure for employee roles, enabling clear reporting lines and organizational charts. This feature is crucial for building an accurate representation of the company structure.',
    workflows: [
      {
        title: 'Workflow: Managing a Designation Hierarchy',
        userSteps: [
          "Admin navigates to `/dashboard/designations`.",
          "Clicks 'Add New Designation' to create a top-level role (e.g., 'General Manager') without selecting a parent.",
          "Clicks 'Add New' again to create a child role (e.g., 'Deputy Manager') and selects 'General Manager' from the 'Parent Designation' dropdown.",
          "User toggles between 'Tree' and 'List' view to visualize the structure.",
          "Admin clicks the 'Delete' icon on a role.",
        ],
        uiSteps: [
          'The `EntityManagementComponent` is the main layout, displaying designations in either a nested tree structure or a flat list.',
          'The `DesignationFormModal` appears for creating or editing. It intelligently filters the `Parent Designation` dropdown to prevent a designation from being its own child or grandchild (a circular dependency).',
          'A `ConfirmModal` appears before any deletion to ensure the action is intentional.',
        ],
        techSteps: [
          'The page is powered by the generic `EntityManagementComponent`, configured with `designationConfig`. This config object specifies `isHierarchical: true` and sets `parent_id` as the relational key.',
          'Data is fetched using the `useTableWithRelations` hook, which performs a self-join on the `employee_designations` table to get the `parent_designation` object for each record.',
          'The `useEntityManagement` hook processes the flat list into a nested tree structure for the UI by matching `id` and `parent_id` fields.',
          'When creating or editing, the `DesignationFormModal` uses the `useTableInsert` or `useTableUpdate` mutation to save data directly to the `employee_designations` table.',
          'The `useDelete` hook (via `useDeleteManager`) handles deletion by calling `supabase.from("employee_designations").delete()`. Postgres handles the `ON DELETE SET NULL` constraint for any children of the deleted designation.',
        ],
      },
    ],
  },
  {
    value: "employees_crud",
    icon: "BsPeople",
    title: "Employee Management",
    subtitle: "Managing employee records and roles",
    gradient: "from-sky-500 to-blue-600",
    iconColor: "text-sky-400",
    bgGlow: "bg-sky-500/10",
    color: "cyan",
    purpose: "To maintain a central database of all employees, their designations, contact information, and assigned maintenance areas.",
    workflows: [
      {
        title: "Workflow: Managing Employee Records",
        userSteps: ["Admin navigates to `/dashboard/employees`.", "Clicks 'Add New' to open the `EmployeeForm`.", "Fills in employee details, selecting a pre-configured Designation and Maintenance Area.", "Saves the new employee record."],
        uiSteps: ["The `DataTable` on the page lists all employees.", "The form modal provides dropdowns for selecting related data like designations.", "On success, a toast appears, and the employee list is refreshed."],
        techSteps: [
          "The page uses `useCrudManager` configured for the `employees` table.",
          "The `EmployeeForm` uses `useTableInsert` or `useTableUpdate` to save data to the `employees` table.",
          "The `employee_designation_id` and `maintenance_terminal_id` fields are foreign keys linking to their respective tables.",
          "The main data table queries the `v_employees` view to efficiently join and display the names of the designation and maintenance area.",
        ],
      },
    ],
  },
  {
    value: "diagrams_crud",
    icon: "FaDiagramNext",
    title: "Diagrams & File Management",
    subtitle: "Uploading and organizing network diagrams",
    gradient: "from-rose-500 to-pink-600",
    iconColor: "text-rose-400",
    bgGlow: "bg-rose-500/10",
    color: "orange",
    purpose: "To provide a centralized repository for uploading, storing, and accessing network diagrams, schematics, and other related documents.",
    workflows: [
      {
        title: "Workflow: Uploading a Diagram",
        userSteps: ["User navigates to the `/dashboard/diagrams` page.", "Creates a new folder or selects an existing one.", "Drags a file into the upload area or clicks 'Select Files'.", "Clicks the 'Upload' button."],
        uiSteps: ["The `FileUploader` component provides the main interface.", "A list of selected files appears before uploading.", "A success toast confirms the upload, and the file appears in the `FileTable` under the selected folder."],
        techSteps: [
          "The `useFolders` hook fetches and manages folder state from the `folders` table.",
          "The `useUppyUploader` hook handles the client-side file processing, including image optimizations via `smartCompress`.",
          "Uppy uploads the file to a serverless API route at `/api/upload`.",
          "The API route uploads the file to Supabase Storage.",
          "On `upload-success`, the `useUppyUploader` hook calls the `useUploadFile` mutation, which inserts a new record into the `files` table, linking the file metadata to the `folder_id` and `user_id`.",
        ],
      },
    ],
  },
  {
    value: "users_crud",
    icon: "Users",
    title: "User CRUD Operations",
    subtitle: "Creating, updating, and deleting users",
    gradient: "from-blue-500 to-cyan-600",
    iconColor: "text-blue-400",
    bgGlow: "bg-blue-500/10",
    color: "blue",
    purpose: "To provide administrators with the tools to manage user accounts, assign roles, and control access.",
    workflows: [
      {
        title: 'Workflow A: Viewing & Filtering Users',
        userSteps: [
          'Admin navigates to the `/dashboard/users` page.',
          'Admin uses the search bar and filter dropdowns to find specific users.',
        ],
        uiSteps: [
          'The `DataTable` displays a paginated list of users from the `v_user_profiles_extended` view.',
          'The `UserFilters` component updates the view as the admin types or selects filters.',
        ],
        techSteps: [
          'The `AdminUsersPage` uses a `useCrudManager` hook with a `useUsersData` adapter.',
          'The `useUsersData` adapter calls the `admin_get_all_users_extended` Supabase RPC.',
          'The RPC function performs a server-side search and filter on the `v_user_profiles_extended` view and returns the paginated results.',
        ],
      },
      {
        title: 'Workflow B: Creating a New User (Admin)',
        userSteps: [
          "Admin clicks 'Add New'.",
          "Fills in the user's details (name, email, password, role) in the `UserCreateModal`.",
          "Clicks 'Create User'.",
        ],
        uiSteps: [
          'The modal appears for data entry.',
          'On success, a toast notification is shown, the modal closes, and the user list refreshes.',
        ],
        techSteps: [
          'The `handleCreateUser` function calls the `createUser` mutation from `useAdminUserOperations` hook.',
          'This mutation sends a `POST` request to the `/api/admin/users` serverless function.',
          "THE FIX: The API route now only inserts into `auth.users`, passing the role and metadata.",
          'The `on_auth_user_created` database trigger is the single source of truth for profile creation. It reads the metadata and role from the new `auth.users` record and automatically inserts a corresponding row into `public.user_profiles`.',
          'The frontend invalidates the user list query to show the new user.',
        ],
      },
      {
        title: 'Workflow C: Editing a User',
        userSteps: [
          "Admin clicks the 'Edit' icon on a user row.",
          "Modifies user details (e.g., name, role, status) in the `UserProfileEditModal`.",
          "Clicks 'Save Changes'.",
        ],
        uiSteps: [
          'The modal opens, pre-filled with the selected userâ€™s data.',
          'On success, a toast is shown, and the UI updates with the new information.',
        ],
        techSteps: [
          'The `onEdit` handler from `useCrudManager` opens the modal with the user record.',
          'Submitting the form calls the `updateProfile` mutation from the `useAdminUpdateUserProfile` hook.',
          'This mutation calls the `admin_update_user_profile` RPC, which updates the `user_profiles` table.',
          'If the role is changed, the `sync_user_role_trigger` database trigger syncs the new role to the `auth.users` table.',
          'The user list query is invalidated and refetched.',
        ],
      },
      {
        title: 'Workflow D: Deleting a User',
        userSteps: [
          "Admin selects one or more users using the checkboxes.",
          "Clicks the 'Delete' button in the `BulkActions` toolbar.",
          "Confirms the deletion in the `ConfirmModal`.",
        ],
        uiSteps: [
          'A confirmation modal appears to prevent accidental deletion.',
          'On success, a toast is shown, and the user(s) are removed from the table.',
        ],
        techSteps: [
          'The `handleBulkDelete` function calls the `bulkDelete` mutation from `useAdminUserOperations`.',
          'This mutation sends a `DELETE` request to the `/api/admin/users` endpoint with the selected user IDs.',
          'The API route first verifies the requester is a super admin, then uses a privileged Supabase client to call `supabase.auth.admin.deleteUser()` for each ID.',
          'The `ON DELETE CASCADE` constraint on the `user_profiles` table automatically removes the corresponding profile.',
          'The user list query is invalidated to refresh the UI.',
        ],
      },
    ],
  },
  {
    value: "nodes_crud",
    icon: "Cpu",
    title: "Node CRUD Operations",
    subtitle: "Managing physical network locations",
    gradient: "from-emerald-500 to-teal-600",
    iconColor: "text-emerald-400",
    bgGlow: "bg-emerald-500/10",
    color: "teal",
    purpose: "To create, view, update, and delete network nodes, which represent physical sites like exchanges, BTS towers, or junction points.",
    workflows: [
      {
        title: "Workflow: Managing Node Records",
        userSteps: ["User navigates to the `/dashboard/nodes` page, clicks 'Add New' or 'Edit'.", "Fills out details in the `NodeFormModal`.", "Saves the record."],
        uiSteps: ["The `DataTable` displays a list of nodes from the `v_nodes_complete` view.", "A modal opens for data entry.", "A toast confirms success and the table refreshes."],
        techSteps: [
          "The `NodesPage` uses the `useCrudManager` hook for state and action management.",
          "The `NodeFormModal` is a 'dumb' component. It receives the `crudActions.handleSave` function as its `onSubmit` prop.",
          "The `handleSave` function, provided by `useCrudManager`, triggers either `useTableInsert` or `useTableUpdate` on the `nodes` table.",
          "TanStack Query invalidates the `v_nodes_complete` view query, causing the UI to refetch and display changes.",
        ],
      },
    ],
  },
  {
    value: "systems_crud",
    icon: "FiDatabase",
    title: "System CRUD Operations",
    subtitle: "Managing network equipment and devices",
    gradient: "from-lime-500 to-green-600",
    iconColor: "text-lime-400",
    bgGlow: "bg-lime-500/10",
    color: "teal",
    purpose: "To create, view, update, and delete network systems (e.g., CPAN, MAAN, SDH). This workflow leverages a powerful database function to handle different system subtypes from a single form.",
    workflows: [
      {
        title: "Workflow: Creating or Editing a System",
        userSteps: [
          "Admin navigates to `/dashboard/systems` and clicks 'Add New' or 'Edit'.",
          "The `SystemModal` opens. Admin fills out the form, which may have one or two steps depending on the system type selected.",
          "Admin clicks 'Create System' or 'Update System'.",
        ],
        uiSteps: [
          "The `SystemModal` is a multi-step form where Step 2 is conditional based on the 'System Type' selected.",
          "A success toast appears, the modal closes, and the systems list refreshes.",
        ],
        techSteps: [
          "THE FIX: The `SystemsPage` now holds the mutation logic. It passes its `handleSave` function to the `SystemModal`'s `onSubmit` prop.",
          "The `handleSave` function constructs a single payload object from the form data.",
          "It calls the `upsert_system_with_details` PostgreSQL RPC function via the `useRpcMutation` hook.",
          "The database function handles the complex logic of inserting/updating records in the generic `systems` table and the correct specific subtype table (`ring_based_systems`, `sdh_systems`, etc.) within a single transaction.",
          "On success, the frontend's `v_systems_complete` query is invalidated and refetched.",
        ],
      },
    ],
  },
  {
    value: "rings_crud",
    icon: "BellRing",
    title: "Ring CRUD Operations",
    subtitle: "Defining and managing logical network rings",
    gradient: "from-orange-500 to-amber-600",
    iconColor: "text-orange-400",
    bgGlow: "bg-orange-500/10",
    color: "orange",
    purpose: "To manage logical network rings, which group various systems together to form a resilient communication path.",
    workflows: [
      {
        title: "Workflow: Creating or Editing a Ring",
        userSteps: ["User navigates to `/dashboard/rings`, clicks 'Add New' or 'Edit'.", "Fills out the `RingModal`.", "Saves the record."],
        uiSteps: ["The `DataTable` lists all rings.", "A modal opens for data entry.", "A success toast appears and the table refreshes."],
        techSteps: [
          "THE FIX: The `RingsPage` now follows the standard pattern, using `useCrudManager`.",
          "The `RingModal` is a 'dumb' component that receives `crudActions.handleSave` as its `onSubmit` prop.",
          "The `handleSave` function triggers either `useTableInsert` or `useTableUpdate` on the `rings` table.",
          "The query for the `v_rings` view is invalidated, refreshing the UI.",
        ],
      },
      {
        title: "Workflow B: Associating Systems with a Ring",
        userSteps: ["User clicks the 'Manage Systems' icon on a ring row.", "In the `RingSystemsModal`, user moves systems from the 'Available' list to the 'Associated' list.", "User clicks 'Save Changes'."],
        uiSteps: ["A dual-listbox modal appears, showing systems in the same maintenance area.", "On success, a toast is shown, the modal closes, and the 'Total Nodes' count in the table updates."],
        techSteps: [
          "The `handleManageSystems` handler opens the `RingSystemsModal`.",
          "The modal fetches associated systems and available systems from the `v_systems_complete` view.",
          "Saving triggers the `updateMutation`, which calls the `update_ring_system_associations` RPC function.",
          "This RPC function deletes old associations and inserts the new list of system IDs into the `ring_based_systems` junction table.",
          "The `v_rings` view query is invalidated, causing the 'Total Nodes' count to update.",
        ],
      },
    ],
  },
  {
    value: "routes",
    icon: "Route",
    title: "OFC & Route Management",
    subtitle: "Cable segmentation & fiber splicing",
    gradient: "from-teal-500 to-emerald-600",
    iconColor: "text-teal-400",
    bgGlow: "bg-teal-500/10",
    color: "teal",
    purpose: "An advanced tool to manage the physical segmentation and fiber splicing of an optical fiber cable (OFC) route.",
    workflows: [
      {
        title: 'Workflow: Managing OFC Cable Records',
        userSteps: [
          'Admin navigates to `/dashboard/ofc`.',
          "Clicks 'Add New' or 'Edit' to open the `OfcForm`.",
          "Saves the record.",
        ],
        uiSteps: [
          'The `DataTable` lists all OFC cables.',
          'A success toast confirms the action and the table refreshes.',
        ],
        techSteps: [
          "THE FIX: The `OfcPage` now uses the `useCrudManager` hook for all state and actions, ensuring consistency with other pages.",
          "The `OfcForm` receives `crudActions.handleSave` as its `onSubmit` prop.",
          'An `AFTER INSERT` trigger on `ofc_cables` (`create_initial_connections_for_cable`) automatically populates the `ofc_connections` table.',
          'Deleting a cable automatically cascades and deletes all associated `ofc_connections` records via database constraints.',
        ],
      },
      {
        title: 'Workflow B: Adding a Junction Closure & Segmentation',
        userSteps: [
          "User selects a route from the dropdown in the Route Manager.",
          "User clicks 'Add Junction Closure', fills in the details, and saves.",
        ],
        uiSteps: [
          'The `RouteVisualization` updates to show the new JC on the cable path.',
          'The `Cable Segments` list below is recalculated and re-rendered.',
        ],
        techSteps: [
          'The form calls the `add_junction_closure` Supabase RPC function.',
          'An `AFTER INSERT` trigger on the `junction_closures` table (`manage_cable_segments`) automatically fires the `recalculate_segments_for_cable` function.',
          'This function deletes all old segments and rebuilds the complete set of new segments in the `cable_segments` table based on the new JC positions.',
          'The frontend simply refetches the route details to get the updated visualization.',
        ],
      },
      {
        title: "Workflow C: Fiber Path Tracing & Logical Sync",
        userSteps: [
            "User navigates to an OFC Cable's detail page (`/dashboard/ofc/[id]`).",
            "User clicks the 'Trace' icon on a fiber row.",
            "The `FiberTraceModal` opens, showing the fiber's path through segments and splices.",
            "User clicks the 'Sync Path to DB' button.",
        ],
        uiSteps: [
            "The `FiberTraceVisualizer` renders the path, orienting each segment to show a continuous flow.",
            "A toast confirms the sync, the modal closes, and the table refreshes to show updated logical start/end nodes.",
        ],
        techSteps: [
            "The `useFiberTrace` hook calls the `trace_fiber_path` RPC to build the end-to-end path.",
            "Clicking 'Sync' calls the `useSyncPathFromTrace` mutation, which executes the `apply_logical_path_update` RPC.",
            "This RPC updates the `updated_sn_id`, `updated_en_id`, `updated_fiber_no_sn`, and `updated_fiber_no_en` columns for the specific `ofc_connections` record, effectively caching the logical path.",
        ],
      },
    ],
  },
  {
    value: "provisioning",
    icon: "GitBranch",
    title: "Logical Path & Fiber Provisioning",
    subtitle: "End-to-end service provisioning",
    gradient: "from-cyan-500 to-blue-600",
    iconColor: "text-cyan-400",
    bgGlow: "bg-cyan-500/10",
    color: "cyan",
    purpose: "To define an end-to-end logical path over physical cable segments and provision working/protection fibers for a service.",
    workflows: [
      {
        title: "Workflow: Building and Provisioning a Path",
        userSteps: ["User navigates to a System's detail page.", "Clicks 'Initialize Path' to create a logical path record.", "In 'Build Mode', user clicks nodes on the map to add cable segments.", "User selects a 'Working Fiber' and 'Protection Fiber' from the dropdowns and saves."],
        uiSteps: ["The `SystemRingPath` component displays a map and a list of segments.", "Dropdowns only show continuously available fibers.", "UI updates to show the path as 'Provisioned'."],
        techSteps: [
          "Initializing inserts into `logical_fiber_paths`.",
          "Clicking a node calls `find_cable_between_nodes` RPC to find the `ofc_cables` record.",
          "A new record is inserted into `logical_path_segments`.",
          "The `useAvailableFibers` hook calls the `get_continuous_available_fibers` RPC to populate dropdowns.",
          "Saving calls the `provision_logical_path` RPC, which updates the `logical_path_id` on all relevant `ofc_connections` records.",
        ],
      },
      {
        title: "Workflow B: Deprovisioning a Logical Path",
        userSteps: ["On the `/dashboard/system-paths` page, user clicks 'Deprovision'.", "Confirms the action in the modal."],
        uiSteps: ["The path status changes from 'Provisioned' to 'Unprovisioned'.", "A success toast appears."],
        techSteps: [
          "THE FIX: The `useDeprovisionPath` hook now calls the safe `deprovision_logical_path` RPC function.",
          "This function accepts only a `path_id`.",
          "It finds the associated working and protection paths and sets the `logical_path_id` and `fiber_role` to `NULL` for all related records in the `ofc_connections` table.",
          "Finally, it deletes the records from the `logical_fiber_paths` table.",
        ],
      },
    ],
  },
]