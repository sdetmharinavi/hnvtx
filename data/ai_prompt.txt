First delete everything from your memory, if you have any from this chat section as we will start fresh as below:

üìã Project Overview
Project Type: Next.js App Router-based Web Application
Tech Stack:

Framework: Next.js (App Router) ^15.4.4
Styling: Tailwind CSS ^4.1.11
Animations: Framer Motion ^12.23.12
Database: Supabase ^2.45.5
State Management: Zustand ^5.0.7 (local stores)
Data Fetching: @tanstack/react-query ^5.85.5
Scale: Medium-sized application


üì¶ Codebase Context
I will provide my complete project structure including file paths and full file contents. Please analyze this codebase comprehensively and maintain this context throughout our entire conversation.
Key Areas to Understand:

Architecture patterns and design decisions
Data flow and state management patterns
External integrations and dependencies
Current features and functionality
File organization and module structure
Component relationships and prop flows


üîç Analysis Framework
Please evaluate the codebase across these prioritized dimensions:
Priority 1: Correctness & Stability ‚ö†Ô∏è

Identify bugs, logic errors, and crash scenarios
Check for unhandled edge cases and error conditions
Validate data handling, type safety, and null/undefined checks
Review async operations, promises, and race conditions
Assess error boundaries and recovery mechanisms
Check form validation and user input handling

Priority 2: Performance & Reliability ‚ö°

Identify performance bottlenecks and optimization opportunities
Review resource usage (memory, network requests, re-renders)
Check for memory leaks and inefficient algorithms
Evaluate bundle size and code splitting
Assess caching strategies (React Query, Supabase, etc.)
Review loading states and data fetching patterns

Priority 3: Code Quality & Maintainability üõ†Ô∏è

Review code organization, naming conventions, and structure
Identify code duplication and refactoring opportunities
Assess component reusability and composition
Check for proper TypeScript usage and type definitions
Evaluate dependency management and security vulnerabilities
Review hooks usage and custom hooks patterns

Priority 4: User Experience & Features ‚ú®

Identify UX pain points and improvement opportunities
Suggest realistic feature enhancements
Review accessibility (ARIA, keyboard navigation, screen readers)
Assess responsive design and mobile experience
Evaluate loading states, error messages, and user feedback
Check routing and navigation patterns


üìù Response Format
For each issue or recommendation, provide:
**Category:** [Correctness | Performance | Maintainability | UX]
**Severity:** [Critical | High | Medium | Low]
**Location:** [Specific file path(s) and relevant code sections]
**Description:** Clear explanation of the issue/opportunity
**Impact:** How this affects users, developers, or system performance
**Recommendation:** Specific, actionable solution with code examples
**Implementation:** Step-by-step guidance, gotchas, and considerations

üöÄ Development Approach & Workflow
Iterative Improvement Process:

Step-by-Step Implementation: We'll tackle improvements systematically, starting from the project foundation
Complete Code Delivery: Always provide FULL, COMPLETE code for any component, hook, utility, or file‚Äînever partial or truncated code. Also provide full codes of all the affected files due to the changes. After giving full codes, give summary of what changes has been made and which files will be affected.
Testing & Verification: After each implementation, I'll test and confirm functionality
Documentation Updates: Once verified, we'll update the workflow documentation in components/doc/data/workflowData.ts
Progressive Enhancement: Build upon verified changes, maintaining context of all previous discussions

Documentation Strategy:

Maintain comprehensive User Workflows (how users interact with features)
Maintain detailed Technical Workflows (implementation details and architecture)
Add new workflows for newly implemented features
Keep documentation synchronized with codebase changes


üß† Memory & Context Requirements
CRITICAL: Throughout our entire conversation, please:
‚úÖ Remember ALL previous discussions, decisions, and code changes
‚úÖ Maintain full context of the project structure and architecture
‚úÖ Reference earlier conversations when relevant to current questions
‚úÖ Provide complete, production-ready code‚Äînever partial snippets
‚úÖ Give precise, actionable solutions based on accumulated knowledge
‚úÖ Avoid repeating suggestions we've already implemented
‚úÖ Consider dependencies and relationships between previously discussed components
‚úÖ Build upon established patterns from our earlier discussions
‚úÖ Always remember that for view tables, rpc will be used otherwise there will be permission issues

üí¨ Ongoing Collaboration
After the initial analysis, I may:

Request detailed implementation guidance for specific fixes
Ask for complete code for components, hooks, utilities, or pages
Seek clarification on architectural decisions or trade-offs
Request prioritization of improvements based on impact vs. effort
Ask for best practices and pattern recommendations
Request refactoring strategies for specific modules
Seek debugging assistance for specific issues

Important: When providing code solutions:

Always use rpc for view table to avoid permission issues.
Always provide the COMPLETE file content, not just changed sections
Include all imports, exports, and dependencies
Ensure code is production-ready with proper error handling
Add inline comments for complex logic
Follow the existing code style and patterns
strictly follow @typescript-eslint/no-explicit-any.
Never try to edit auto generated files like types/supabase-types.ts, types/flattened-types.ts, schemas/zod-schemas.ts.
Always mention which part of the code has been edited and why.


üìÇ Project Structure & Codebase
Below is my complete project structure and codebase:
[Paste your project structure and file contents here]

As it is clear that our project has Robust Offline Caching: Uses Dexie.js (IndexedDB) for all major data entities.
Manual Sync Policy: Pages load instantly; network is only used when the user clicks "Refresh" or explicitly saves data.
Offline Write Queuing: Create/Update/Delete actions (for Inventory, Diary, Employees, etc.) are queued and synced automatically when back online.
Safety Guards: Complex operations like Route Splicing are blocked offline to prevent data corruption.
UI Feedback: Clear indicators for offline status, syncing state, and queued changes.

Let's begin! First of all we need to fix the issue that breadcrumb not showing in mobile devices and other UX/UI issues.