// hooks/database/excel-queries/useOfcConnectionsExcelUpload.ts
import { useMutation, useQueryClient } from '@tanstack/react-query';
import { SupabaseClient } from '@supabase/supabase-js';
import { toast } from 'sonner';

import { Database } from '@/types/supabase-types';
import {
  EnhancedUploadResult,
  UploadColumnMapping,
  UseExcelUploadOptions,
  ValidationError,
  ProcessingLog,
  TableInsert,
} from '@/hooks/database/queries-type-helpers';
import { parseExcelFile } from '@/utils/excel-parser';
import { logRowProcessing } from './excel-helpers';

export interface OfcConnectionsUploadOptions {
  file: File;
  columns: UploadColumnMapping<'v_ofc_connections_complete'>[];
  cableId?: string; // Optional: If provided, we scope mapping to this cable
}

type ConnectionPayload = TableInsert<'ofc_connections'>;

// Manual mapping for headers generated by OfcDetailsTableColumns.tsx
const MANUAL_HEADER_MAP: Record<string, string> = {
  'end a node': 'updated_sn_name',
  'end b node': 'updated_en_name',
  'f-a': 'updated_fiber_no_sn',
  'f-b': 'updated_fiber_no_en',
  'rkm (end a)': 'otdr_distance_sn_km',
  'rkm (end b)': 'otdr_distance_en_km',
  'pwr a (dbm)': 'sn_power_dbm',
  'pwr b (dbm)': 'en_power_dbm',
  'loss (db)': 'route_loss_db',
  'dom a': 'sn_dom',
  'dom b': 'en_dom',
  remarks: 'remark',
};

const parseExcelInt = (val: unknown): number | null => {
  if (val === null || val === undefined || val === '') return null;
  if (typeof val === 'number') return Math.round(val);
  if (typeof val === 'string') {
    const trimmed = val.trim();
    if (trimmed === '') return null;
    const num = Number(trimmed);
    if (!isNaN(num)) return Math.round(num);
  }
  return null;
};

const parseExcelFloat = (val: unknown): number | null => {
  if (val === null || val === undefined || val === '') return null;
  const num = Number(val);
  return isNaN(num) ? null : num;
};

const parseExcelDate = (val: unknown): string | null => {
  if (!val) return null;
  if (val instanceof Date) return val.toISOString();
  if (typeof val === 'string') {
    const d = new Date(val);
    if (!isNaN(d.getTime())) return d.toISOString();
  }
  return null; // Invalid date
};

export function useOfcConnectionsExcelUpload(
  supabase: SupabaseClient<Database>,
  options?: UseExcelUploadOptions<'v_ofc_connections_complete'>
) {
  const { showToasts = true, ...mutationOptions } = options || {};
  const queryClient = useQueryClient();

  return useMutation<EnhancedUploadResult, Error, OfcConnectionsUploadOptions>({
    ...mutationOptions,
    mutationFn: async (uploadOptions): Promise<EnhancedUploadResult> => {
      const { file, columns, cableId } = uploadOptions;
      const uploadResult: EnhancedUploadResult = {
        successCount: 0,
        errorCount: 0,
        totalRows: 0,
        errors: [],
        processingLogs: [],
        validationErrors: [],
        skippedRows: 0,
      };
      const processingLogs: ProcessingLog[] = [];
      const allValidationErrors: ValidationError[] = [];

      // 1. Parse File
      if (showToasts) toast.info('Parsing Excel file...');
      const jsonData = await parseExcelFile(file);

      if (jsonData.length < 2) {
        if (showToasts) toast.warning('No data found in file.');
        return uploadResult;
      }

      const excelHeaders: string[] = (jsonData[0] as string[]).map((h) => String(h || '').trim());
      const headerMap: Record<string, number> = {};
      excelHeaders.forEach((header, index) => {
        headerMap[header.toLowerCase()] = index;
      });

      const dataRows = jsonData.slice(1);

      // --- 2. PREPARATION: Resolve Dependencies ---

      // A. Extract Names from Excel to fetch IDs
      const uniqueNodeNames = new Set<string>();
      const uniqueCableNames = new Set<string>();

      const getVal = (row: unknown[], key: string) => {
        // Check config map first
        const configMap = columns.find(c => c.dbKey === key);
        if (configMap) {
           const idx = headerMap[configMap.excelHeader.toLowerCase()];
           if (idx !== undefined) return row[idx];
        }
        
        // Check Manual Map
        const manualHeader = Object.keys(MANUAL_HEADER_MAP).find(k => MANUAL_HEADER_MAP[k] === key);
        if (manualHeader) {
           const idx = headerMap[manualHeader.toLowerCase()]; // Ensure lowercase lookup
           if (idx !== undefined) return row[idx];
        }
        
        // Fallback: check direct header match
        const directIdx = headerMap[key.replace(/_/g, ' ').toLowerCase()];
        if(directIdx !== undefined) return row[directIdx];

        return undefined;
      };

      dataRows.forEach((row) => {
        const snName = getVal(row as unknown[], 'updated_sn_name');
        const enName = getVal(row as unknown[], 'updated_en_name');
        if (typeof snName === 'string' && snName.trim()) uniqueNodeNames.add(snName.trim().toLowerCase());
        if (typeof enName === 'string' && enName.trim()) uniqueNodeNames.add(enName.trim().toLowerCase());
        
        // If cableId is NOT provided, we must find it via route name
        if (!cableId) {
             const routeName = getVal(row as unknown[], 'ofc_route_name');
             if (typeof routeName === 'string' && routeName.trim()) uniqueCableNames.add(routeName.trim().toLowerCase());
        }
      });

      // B. Fetch matching Nodes
      const nodeNameMap = new Map<string, string>(); // Name -> UUID
      if (uniqueNodeNames.size > 0) {
        // Optimzation: Fetch all nodes if specific filter is tricky, or try to use 'in'
        // For robustness given potential case sensitivity issues in 'in' clause, 
        // we'll fetch ID/Name pairs and map locally.
        const { data: allNodes } = await supabase.from('nodes').select('id, name');
        if (allNodes) {
          allNodes.forEach(n => {
            if (n.name) nodeNameMap.set(n.name.trim().toLowerCase(), n.id);
          });
        }
      }

      // C. Fetch Cables if needed (Global Upload)
      const cableNameMap = new Map<string, string>();
      if (!cableId) {
         // Fetch all cables to ensure we match names correctly
         const { data: cables } = await supabase.from('ofc_cables').select('id, route_name');
         if (cables) {
            cables.forEach(c => {
                 if (c.route_name) cableNameMap.set(c.route_name.trim().toLowerCase(), c.id);
            });
         }
      }

      // D. Fetch Existing Fibers for ID Resolution
      // This is crucial if the Excel file DOES NOT have the `id` column but has Cable+FiberNo
      const fiberNumberToUuidMap = new Map<string, string>(); // Key: "cableId_fiberNo" -> UUID
      
      let cableIdsToFetch: string[] = [];
      if (cableId) {
          cableIdsToFetch = [cableId];
      } else {
          // If global, we fetch based on the names we found in the file
          cableIdsToFetch = Array.from(cableNameMap.values());
      }
      
      // Fetch only if we have cables to look up
      if (cableIdsToFetch.length > 0) {
          // Fetch in chunks if too many cables, but for now assuming limit < 50000
          const { data: existingFibers } = await supabase
          .from('ofc_connections')
          .select('id, ofc_id, fiber_no_sn')
          .in('ofc_id', cableIdsToFetch);
          
          if (existingFibers) {
              existingFibers.forEach(f => {
                  fiberNumberToUuidMap.set(`${f.ofc_id}_${f.fiber_no_sn}`, f.id);
              });
          }
      }

      // --- 3. PROCESSING ROWS ---
      const recordsToUpsert: ConnectionPayload[] = [];

      for (let i = 0; i < dataRows.length; i++) {
        const row = dataRows[i] as unknown[];
        const excelRowNumber = i + 2;

        // Skip empty rows
        if (row.every((cell) => cell === null || cell === undefined || String(cell).trim() === '')) {
          uploadResult.skippedRows++;
          continue;
        }

        const originalData: Record<string, unknown> = {};
        excelHeaders.forEach((h, idx) => { originalData[h] = row[idx]; });
        const rowErrors: ValidationError[] = [];

        // Helper wrapper to use closures above
        const extract = (dbKey: string) => getVal(row, dbKey);

        // --- Core Data Resolution ---
        
        // 1. Resolve Cable ID
        let targetCableId = cableId;
        if (!targetCableId) {
            const routeName = extract('ofc_route_name');
            if (typeof routeName === 'string') {
                targetCableId = cableNameMap.get(routeName.trim().toLowerCase());
            }
        }

        // 2. Resolve Fiber Number
        const fiberSnRaw = parseExcelInt(extract('fiber_no_sn'));
        
        // 3. Resolve Record ID
        let recordId: string | undefined = (extract('id') as string);
        
        // If ID missing, try to resolve via composite key (Cable + Fiber)
        if (!recordId && targetCableId && fiberSnRaw) {
            recordId = fiberNumberToUuidMap.get(`${targetCableId}_${fiberSnRaw}`);
        }

        // --- Validation ---
        if (!targetCableId) {
            rowErrors.push({ rowIndex: excelRowNumber, column: 'ofc_route_name', value: '', error: 'Cable Route not identified. Ensure name matches exactly.' });
        }
        if (!fiberSnRaw) {
             rowErrors.push({ rowIndex: excelRowNumber, column: 'fiber_no_sn', value: '', error: 'Fiber Number is required.' });
        }
        
        // --- Node Name Resolution ---
        const snNameRaw = extract('updated_sn_name');
        const enNameRaw = extract('updated_en_name');

        let updatedSnId = null;
        let updatedEnId = null;

        if (typeof snNameRaw === 'string' && snNameRaw.trim()) {
            const match = nodeNameMap.get(snNameRaw.trim().toLowerCase());
            if (match) updatedSnId = match;
            // Note: If node not found, it remains null (topology reset to physical)
        }
        if (typeof enNameRaw === 'string' && enNameRaw.trim()) {
             const match = nodeNameMap.get(enNameRaw.trim().toLowerCase());
             if (match) updatedEnId = match;
        }

        if (rowErrors.length > 0) {
            uploadResult.errorCount++;
            uploadResult.errors.push({
                rowIndex: excelRowNumber,
                data: originalData,
                error: rowErrors.map(e => e.error).join(', ')
            });
            allValidationErrors.push(...rowErrors);
            continue;
        }

        // --- Build Valid Payload ---
        // We use non-null assertions (!) for targetCableId and fiberSnRaw because we validated them above
        const payload: ConnectionPayload = {
            // Required Structural Fields for TableInsert Type
            ofc_id: targetCableId!, 
            fiber_no_sn: fiberSnRaw!,
            fiber_no_en: fiberSnRaw!, // Defaulting to same as SN, consistent with DB trigger logic

            // ID (Optional for Insert, Required for Update)
            // If ID exists, Supabase updates. If not, it tries to insert (and might fail uniqueness on cable+fiber if not handled)
            // But since we resolved ID from DB, we likely have it if the record exists.
            id: recordId, 
            
            // Updatable Fields
            updated_sn_id: updatedSnId, 
            updated_en_id: updatedEnId, 
            updated_fiber_no_sn: parseExcelInt(extract('updated_fiber_no_sn')) ?? fiberSnRaw!,
            updated_fiber_no_en: parseExcelInt(extract('updated_fiber_no_en')) ?? fiberSnRaw!,
            
            otdr_distance_sn_km: parseExcelFloat(extract('otdr_distance_sn_km')),
            otdr_distance_en_km: parseExcelFloat(extract('otdr_distance_en_km')),
            
            sn_power_dbm: parseExcelFloat(extract('sn_power_dbm')),
            en_power_dbm: parseExcelFloat(extract('en_power_dbm')),
            
            route_loss_db: parseExcelFloat(extract('route_loss_db')),
            
            sn_dom: parseExcelDate(extract('sn_dom')),
            en_dom: parseExcelDate(extract('en_dom')),
            
            remark: (extract('remark') as string) || null,
            
            updated_at: new Date().toISOString()
        };

        recordsToUpsert.push(payload);
        
        processingLogs.push(
             logRowProcessing(i, excelRowNumber, originalData, payload, [], false)
        );
      }

      uploadResult.totalRows = recordsToUpsert.length + uploadResult.errorCount;
      uploadResult.processingLogs = processingLogs;
      uploadResult.validationErrors = allValidationErrors;

      // --- 4. EXECUTE UPSERT ---
      if (recordsToUpsert.length > 0) {
          const BATCH = 500;
          for (let i = 0; i < recordsToUpsert.length; i += BATCH) {
              const batch = recordsToUpsert.slice(i, i + BATCH);
              
              // eslint-disable-next-line @typescript-eslint/no-explicit-any
              const { error } = await supabase.from('ofc_connections').upsert(batch as any);
              
              if (error) {
                  uploadResult.errorCount += batch.length;
                  uploadResult.errors.push({ rowIndex: -1, data: 'Batch Error', error: error.message });
              } else {
                  uploadResult.successCount += batch.length;
              }
          }
      }

      if (showToasts) {
        if (uploadResult.errorCount > 0) {
             toast.warning(`Upload complete: ${uploadResult.successCount} processed, ${uploadResult.errorCount} failed.`);
        } else {
             toast.success(`Successfully updated ${uploadResult.successCount} connections.`);
        }
      }

      return uploadResult;
    },
    onSuccess: (result, variables) => {
      // Invalidate relevant queries
      if (result.successCount > 0) {
        if (variables.cableId) {
            queryClient.invalidateQueries({ queryKey: ['ofc_connections-data', variables.cableId] });
            queryClient.invalidateQueries({ queryKey: ['v_cable_utilization'] });
        } else {
            // Global invalidation
            queryClient.invalidateQueries({ queryKey: ['ofc_connections-data'] });
            queryClient.invalidateQueries({ queryKey: ['all-ofc-connections'] });
        }
      }
      if (mutationOptions.onSuccess) mutationOptions.onSuccess(result, variables);
    },
    onError: (error, variables) => {
       if (showToasts) toast.error(`Upload failed: ${error.message}`);
       if (mutationOptions.onError) mutationOptions.onError(error, variables);
    }
  });
}